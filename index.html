<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Query Analyzer</title>
    <!-- Include jQuery UI CSS -->
    <link
      rel="stylesheet"
      href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css"
    />
    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Include Chart.js datetime adapter -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Include Chart.js zoom plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <!-- Include Hammer.js for touch/gesture support -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
      }
      #input-section {
        margin-bottom: 20px;
      }
      textarea {
        width: 100%;
        height: 50px;
        margin-bottom: 10px;
      }
      #tabs {
        flex: 1;
        overflow: auto;
      }
      #every-query,
      #analysis {
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      #flow-diagram-section,
      #charts-placeholder {
        flex: 0 0 250px; /* Fixed height for charts and flow diagram */
        overflow: auto;
        margin-bottom: 20px;
        border: 1px solid #ccc;
        padding: 10px;
        background-color: #fff;
      }
      #flow-diagram {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }
      .step-bubble {
        border: 1px solid #000;
        border-radius: 10px;
        padding: 10px;
        /*min-width: 110px;*/
        text-align: center;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
        cursor: pointer;
      }

      .step-bubble p {
        margin: 5px 0;
        line-height: 1; /* Default is around 1.4–1.6, so this tightens the text */
      }

      .green {
        background-color: #d4edda;
      }
      .yellow {
        background-color: #fff3cd;
      }
      .orange {
        background-color: #ffe5d0;
      }
      .red {
        background-color: #f8d7da;
      }
      .connector {
        width: 20px;
        height: 2px;
        background-color: #000;
      }
      #table-section,
      #analysis-table-section {
        flex: 1;
        overflow-y: auto;
      }
      #table-container,
      #analysis-table-container {
        overflow-x: auto;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        background-color: #fff;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
      }
      th {
        background-color: #f2f2f2;
        cursor: pointer;
        user-select: none;
      }
      th:hover {
        background-color: #e8e8e8;
      }
      .sort-arrow {
        margin-left: 5px;
        font-size: 12px;
        color: #666;
      }
      tr:hover {
        background-color: #f1f1f1;
        cursor: pointer;
      }
      .primary-scan-yes {
        font-weight: bold;
        color: red;
      }
      .fatal-state {
        font-weight: bold;
        color: red;
      }
      .modal {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      }
      .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-height: 80vh;
        overflow-y: auto;
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
      }
      .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
      }
      .close:hover,
      .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
      }
      #plan-modal-body ul {
        list-style-type: none;
        padding-left: 20px;
      }
      #plan-modal-body li {
        margin-bottom: 5px;
      }
      #operator-modal-body dl {
        margin: 0;
      }
      #operator-modal-body dt {
        font-weight: bold;
      }
      #operator-modal-body dd {
        margin-left: 20px;
      }
      #operator-modal-body, #plan-modal-body {
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
      }
      #operator-modal-body *, #plan-modal-body * {
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
      }
      .copy-button {
        background-color: #4CAF50;
        color: white;
        padding: 5px 10px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        margin: 5px;
        font-size: 12px;
      }
      .copy-button:hover {
        background-color: #45a049;
      }
    </style>
    <!-- Include Panzoom, jQuery, and jQuery UI -->
    <script src="https://cdn.jsdelivr.net/npm/panzoom@9.4.2/dist/panzoom.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
  </head>
  <body>
    <!-- Input Section (outside tabs) -->
    <div id="input-section">
      <textarea
        id="json-input"
        placeholder="Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests;"
      ></textarea>
      <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
        <button onclick="parseJSON()">Parse JSON</button>
        <label for="start-date">From:</label>
        <input type="datetime-local" id="start-date" title="Start date/time for filtering">
        <label for="end-date">To:</label>
        <input type="datetime-local" id="end-date" title="End date/time for filtering">
        <div style="display: flex; gap: 5px; align-items: center;">
          <button onclick="setTimeRange('original')" style="padding: 4px 8px; font-size: 0.8em;">Original</button>
          <button onclick="setTimeRange('1day')" style="padding: 4px 8px; font-size: 0.8em;">1 Day</button>
          <button onclick="setTimeRange('1hour')" style="padding: 4px 8px; font-size: 0.8em;">1 Hour</button>
        </div>
        <span id="filter-info" style="color: #666; font-size: 0.9em;"></span>
      </div>
    </div>

    <!-- Tabs Container -->
    <div id="tabs">
      <!-- Tab Headers -->
      <ul>
        <li><a href="#dashboard">Dashboard</a></li>
        <li><a href="#timeline">Timeline</a></li>
        <li><a href="#analysis">Query Groups</a></li>
        <li><a href="#every-query">Every Query</a></li>
      </ul>
      
      <!-- Dashboard Tab Content -->
      <div id="dashboard">

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; grid-template-rows: 300px;">
        <!-- Elapsed Time Distribution Bar Chart -->
          <div style="background: white; padding: 15px; border: 1px solid #ccc; border-radius: 5px; height: 300px; overflow: hidden;">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center; height: 30px;">Query Duration Distribution</h3>
            <div style="height: 250px; position: relative;">
              <canvas id="elapsed-time-chart"></canvas>
            </div>
          </div>
          <!-- Primary Scan Used Pie Chart -->
          <div style="background: white; padding: 15px; border: 1px solid #ccc; border-radius: 5px; height: 300px; overflow: hidden;">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center; height: 30px;">Primary Scan Used</h3>
            <div style="height: 250px; position: relative;">
              <canvas id="primary-scan-chart"></canvas>
            </div>
          </div>
          
        </div>

        <!-- Query Pattern Analysis Row -->
        <div style="display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 20px; grid-template-rows: 400px;">
          <!-- Query Pattern Features Bar Chart -->
          <div style="background: white; padding: 15px; border: 1px solid #ccc; border-radius: 5px; height: 400px; overflow: hidden;">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center; height: 30px;">Query Pattern Features</h3>
            <div style="height: 350px; position: relative;">
              <canvas id="query-pattern-chart"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Data Tables Row -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
          <!-- User Query Count Table -->
          <div style="background: white; padding: 15px; border: 1px solid #ccc; border-radius: 5px;">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center;">Users by Query Count</h3>
            <div style="height: 250px; overflow-y: auto; border: 1px solid #eee;">
              <table id="user-count-table" style="width: 100%; border-collapse: collapse;">
                <thead style="position: sticky; top: 0; background: #f5f5f5;">
                  <tr>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid #ddd; width: 80px;">Count</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid #ddd;">User</th>
                  </tr>
                </thead>
                <tbody id="user-count-body">
                </tbody>
              </table>
            </div>
          </div>
          
          <!-- Index Usage Count Table -->
          <div style="background: white; padding: 15px; border: 1px solid #ccc; border-radius: 5px;">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center;">Index Usage Count</h3>
            <div style="height: 250px; overflow-y: auto; border: 1px solid #eee;">
              <table id="index-count-table" style="width: 100%; border-collapse: collapse;">
                <thead style="position: sticky; top: 0; background: #f5f5f5;">
                  <tr>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid #ddd; width: 80px;">Count</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid #ddd;">Index Name</th>
                  </tr>
                </thead>
                <tbody id="index-count-body">
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; grid-template-rows: 300px;">

          <!-- Statement Type Pie Chart -->
          <div style="background: white; padding: 15px; border: 1px solid #ccc; border-radius: 5px; height: 300px; overflow: hidden;">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center; height: 30px;">Statement Type</h3>
            <div style="height: 250px; position: relative;">
              <canvas id="statement-type-chart"></canvas>
            </div>
          </div>
          
            <!-- Query State Pie Chart -->
          <div style="background: white; padding: 15px; border: 1px solid #ccc; border-radius: 5px; height: 300px; overflow: hidden;">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center; height: 30px;">Query State</h3>
            <div style="height: 250px; position: relative;">
              <canvas id="state-chart"></canvas>
            </div>
          </div>

        </div>
        

      </div>
      
      <!-- Timeline Tab Content -->
      <div id="timeline">
        <div style="margin-bottom: 10px">
          <button id="reset-zoom-btn" onclick="resetTimelineZoom()">
            Reset Zoom
          </button>
          <span style="margin-left: 20px">
            <label
              ><input
                type="radio"
                name="yScale"
                value="linear"
                checked
                onchange="changeYAxisScale()"
              />
              Linear</label
            >
            <label style="margin-left: 10px"
              ><input
                type="radio"
                name="yScale"
                value="logarithmic"
                onchange="changeYAxisScale()"
              />
              Logarithmic</label
            >
          </span>
          <span style="margin-left: 30px">
            <label
              ><input
                type="radio"
                name="timeGrouping"
                value="optimizer"
                checked
                onchange="changeTimeGrouping()"
              />
              <span id="optimizer-label">By Optimizer</span></label
            >
            <label style="margin-left: 10px"
              ><input
                type="radio"
                name="timeGrouping"
                value="minute"
                onchange="changeTimeGrouping()"
              />
              By Minute</label
            >
            <label style="margin-left: 10px"
              ><input
                type="radio"
                name="timeGrouping"
                value="second"
                onchange="changeTimeGrouping()"
              />
              By Second</label
            >
          </span>
          <span style="margin-left: 20px; color: #666; font-size: 12px">
            Drag to pan • Scroll to zoom • Drag box to zoom area
          </span>
          <button id="use-time-range-btn" onclick="useCurrentTimeRange()" style="margin-left: 20px; padding: 4px 8px; font-size: 0.8em;">
            Use Time Range
          </button>
        </div>
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
          <div style="flex: 1; height: 400px; position: relative;">
            <canvas id="duration-buckets-chart"></canvas>
          </div>
          <div style="flex: 1; height: 400px; position: relative;">
            <canvas id="query-types-chart"></canvas>
          </div>
        </div>
        
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
          <div style="flex: 1; height: 400px; position: relative;">
            <canvas id="operations-chart"></canvas>
          </div>
          <div style="flex: 1; height: 400px; position: relative;">
            <canvas id="filter-chart"></canvas>
          </div>
        </div>
        
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
          <div style="flex: 1; height: 400px; position: relative;">
            <canvas id="timeline-chart"></canvas>
          </div>
          <div style="flex: 1; height: 400px; position: relative;">
            <canvas id="memory-chart"></canvas>
          </div>
        </div>
      </div>

      <!-- Analysis Tab Content -->
      <div id="analysis">
        <!--
        <div id="charts-placeholder">
          *Future charts and visualizations will be displayed here.
          <canvas id="analysis-chart" width="10" height="10"></canvas>
        </div>
      -->
        <div id="analysis-table-section">
          <div id="analysis-table-container">
            <table id="analysis-table">
              <thead id="analysis-table-header"></thead>
              <tbody id="analysis-table-body"></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Every Query Tab Content -->
      <div id="every-query">
        <div id="flow-diagram-section">
          <div id="flow-diagram"></div>
        </div>
        <div id="table-section">
          <div id="table-container">
            <table id="query-table">
              <thead id="table-header"></thead>
              <tbody id="table-body"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <!-- Modals (outside tabs) -->
    <div id="plan-modal" class="modal">
      <div class="modal-content">
        <span class="close">×</span>
        <div id="plan-modal-body"></div>
      </div>
    </div>
    <div id="operator-modal" class="modal">
      <div class="modal-content">
        <span class="close">×</span>
        <div id="operator-modal-body"></div>
      </div>
    </div>

    <script>
      // Register the zoom plugin
      try {
        if (window.ChartZoom) {
          Chart.register(window.ChartZoom);
        } else if (window.chartjsPluginZoom) {
          Chart.register(window.chartjsPluginZoom);
        } else if (window.zoomPlugin) {
          Chart.register(window.zoomPlugin);
        }
      } catch (error) {
        // Silent fallback
      }
      
      // Global variables for time range tracking
      let originalTimeRange = { min: null, max: null };
      let currentTimeRange = { min: null, max: null };

      // Parse time strings to milliseconds
        function parseTime(timeStr) {
        if (!timeStr) {
            return 0;
        }

        // Handle empty or invalid strings
        timeStr = timeStr.trim();
        if (!timeStr) {
            return 0;
        }

        // Try different regex patterns for different time formats
        
        // Pattern 1: Handle ms, ns, µs, us formats like "681.413039ms", "250ns", "146.266µs"
        const simplePattern = /^(\d+\.?\d*)(ms|ns|µs|us)$/;
        let simpleMatch = timeStr.match(simplePattern);
        
        if (simpleMatch) {
            const value = parseFloat(simpleMatch[1]);
            const unit = simpleMatch[2];
            
            let totalMs = 0;
            if (unit === "ms") {
                totalMs = value;
            } else if (unit === "ns") {
                totalMs = value / 1000000; // nanoseconds to milliseconds
            } else if (unit === "µs" || unit === "us") {
                totalMs = value / 1000; // microseconds to milliseconds  
            }
            
            return totalMs;
        }
        
        // Pattern 2: Handle complex formats like "1h4m17.8098098s" or "4m17.8098098s" or "1h"
        const complexPattern = /(?:(\d+)h)?(?:(\d+)m)?(?:(\d+\.?\d*)s)?/;
        const complexMatch = timeStr.match(complexPattern);
        
        if (!complexMatch || (complexMatch[1] === undefined && complexMatch[2] === undefined && complexMatch[3] === undefined)) {
            return 0;
        }

        let totalMs = 0;
        const hours = parseInt(complexMatch[1] || 0); // Hours (optional)
        const minutes = parseInt(complexMatch[2] || 0); // Minutes (optional)
        const seconds = parseFloat(complexMatch[3] || 0); // Seconds (optional, including decimals)

        // Convert to milliseconds
        totalMs += hours * 60 * 60 * 1000; // Hours to milliseconds
        totalMs += minutes * 60 * 1000; // Minutes to milliseconds
        totalMs += seconds * 1000; // Seconds to milliseconds

        return totalMs;
        }

        // Format time in standardized mm:ss.sss format
        function formatTime(milliseconds) {
          if (!milliseconds || isNaN(milliseconds) || milliseconds <= 0) {
            return "00:00.000";
          }
          
          const totalSeconds = Math.floor(milliseconds / 1000);
          const ms = Math.floor(milliseconds % 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          
          // Format with leading zeros
          const formattedMinutes = minutes.toString().padStart(2, '0');
          const formattedSeconds = seconds.toString().padStart(2, '0');
          const formattedMs = ms.toString().padStart(3, '0');
          
          return `${formattedMinutes}:${formattedSeconds}.${formattedMs}`;
        }

      // Normalize statement by replacing literals and numbers with "?"
      function normalizeStatement(statement) {
        if (!statement) return "";
        let normalized = statement
          .replace(/"(?:[^"\\]|\\.)*"/g, "?")
          .replace(/'(?:[^'\\]|\\.)*'/g, "?")
          .replace(/\b\d+\.?\d*\b/g, "?");
        return normalized;
      }

      // Get color class based on percentage
      function getColorClass(percentage) {
        if (percentage === "N/A" || isNaN(percentage)) return "green";
        if (percentage < 25) return "green";
        if (percentage < 50) return "yellow";
        if (percentage < 75) return "orange";
        return "red";
      }

      // Recursively extract operators from the plan
      function getOperators(operator, operators = []) {
        if (operator) {
          if (operator["#operator"]) {
            operators.push(operator);
          }
          if (operator["~child"]) {
            getOperators(operator["~child"], operators);
          } else if (operator["~children"]) {
            operator["~children"].forEach((child) =>
              getOperators(child, operators)
            );
          }
        }
        return operators;
      }

        // Calculate the maximum of all kernTimes
        function calculateTotalKernTime(plan) {
        const operators = getOperators(plan);
        let maxKernTime = 0;
        operators.forEach((operator, index) => {
            const stats = operator["#stats"] || {};
            const kernTime = parseTime(stats.kernTime);
            if (!isNaN(kernTime)) {
            maxKernTime = Math.max(maxKernTime, kernTime);
            }
        });
        return maxKernTime;
        }

        // Calculate the total memory usage from all operators in the plan
        function calculateTotalMemoryUsage(plan) {
          const operators = getOperators(plan);
          let totalMemory = 0;

          operators.forEach((operator, index) => {
            const stats = operator["#stats"] || {};
            const usedMemory = stats.usedMemory || 0;
            if (!isNaN(usedMemory)) {
              totalMemory += usedMemory;
            }
          });
          return totalMemory;
        }

        // Calculate the sum of all execution times for percentage calculation
        function calculateTotalExecTime(plan) {
        const operators = getOperators(plan);
        let totalExecTime = 0;
        operators.forEach((operator, index) => {
            const stats = operator["#stats"] || {};
            const execTime = parseTime(stats.execTime);
            if (!isNaN(execTime)) {
            totalExecTime += execTime;
            }
        });
        return totalExecTime;
        }

      // Build operator stats for modal
      function buildOperatorStats(operator) {
        const operatorType = operator["#operator"] || "Unknown";
        let html = `<h3>Operator: ${operatorType}</h3>`;
        
        // Add copy button
        html += `<button class="copy-button" onclick="copyOperatorStats(this)">Copy Stats</button>`;
        
        // Show index name for specific operators
        if ((operatorType === "PrimaryScan3" || operatorType === "IndexFtsSearch" || operatorType === "IndexScan3") && operator.index) {
          html += `<p><strong>Index Used: ${operator.index}</strong></p>`;
        }
        
        if (operator["#stats"]) {
          html += "<dl>";
          for (const [key, value] of Object.entries(operator["#stats"])) {
            let formattedValue = value;
            // Format time fields
            if (key === "execTime" || key === "kernTime" || key === "servTime") {
              const timeMs = parseTime(value);
              formattedValue = timeMs > 0 ? formatTime(timeMs) : value;
            }
            html += `<dt>${key}</dt><dd>${formattedValue}</dd>`;
          }
          html += "</dl>";
        } else {
          html += "<p>No stats available.</p>";
        }
        return html;
      }

      // Function to copy operator stats to clipboard
      function copyOperatorStats(button) {
        const modalBody = document.getElementById("operator-modal-body");
        const text = modalBody.innerText || modalBody.textContent;
        
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(() => {
            button.textContent = "Copied!";
            setTimeout(() => {
              button.textContent = "Copy Stats";
            }, 2000);
          }).catch(err => {
            console.error('Failed to copy: ', err);
            fallbackCopyTextToClipboard(text, button);
          });
        } else {
          fallbackCopyTextToClipboard(text, button);
        }
      }

      // Fallback copy function for older browsers
      function fallbackCopyTextToClipboard(text, button) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.top = "-1000px";
        textArea.style.left = "-1000px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
          const successful = document.execCommand('copy');
          if (successful) {
            button.textContent = "Copied!";
            setTimeout(() => {
              button.textContent = "Copy Stats";
            }, 2000);
          }
        } catch (err) {
          console.error('Fallback: Oops, unable to copy', err);
        }
        
        document.body.removeChild(textArea);
      }

      // Generate flow diagram
      function generateFlowDiagram(request) {
        const flowDiagram = document.getElementById("flow-diagram");
        flowDiagram.innerHTML = "";
        if (!request || !request.plan) {
          flowDiagram.textContent = "No execution plan available.";
          return;
        }

        const totalKernTime = calculateTotalKernTime(request.plan);
        const totalExecTime = calculateTotalExecTime(request.plan);
        const operators = getOperators(request.plan);

        if (operators.length === 0) {
          flowDiagram.textContent = "No operators found in the execution plan.";
          return;
        }

        operators.forEach((operator, index) => {
          const operatorName = operator["#operator"] || "Unknown Operator";
          const stats = operator["#stats"] || {};
          const kernTime = stats.kernTime || "N/A";
          const execTime = stats.execTime || "N/A";
          const servTime = stats.servTime || "N/A";
          const itemsIn =
            stats["#itemsIn"] !== undefined ? stats["#itemsIn"] : "-";
          const itemsOut =
            stats["#itemsOut"] !== undefined ? stats["#itemsOut"] : "-";
          
          const kernTimeMs = parseTime(kernTime);
          const execTimeMs = parseTime(execTime);
          const servTimeMs = parseTime(servTime);
          
          const percentage =
            totalExecTime > 0 && !isNaN(execTimeMs)
              ? ((execTimeMs / totalExecTime) * 100).toFixed(2)
              : "N/A";

          const bubble = document.createElement("div");
          bubble.className = "step-bubble";
          const colorClass = getColorClass(parseFloat(percentage));
          bubble.classList.add(colorClass);
          
          // Build the HTML content
          let bubbleContent = `
                    <h4>${operatorName}</h4>
                    <p>${formatTime(execTimeMs)} (${percentage}%)</p>`;
          
          // Only show in/out line if both values are present and not "-"
          if (itemsIn !== "-" && itemsOut !== "-") {
            bubbleContent += `<p>${itemsIn} in / ${itemsOut} out</p>`;
          }
          
          bubble.innerHTML = bubbleContent;
          bubble.addEventListener("click", () => {
            const statsHtml = buildOperatorStats(operator);
            document.getElementById("operator-modal-body").innerHTML =
              statsHtml;
            document.getElementById("operator-modal").style.display = "block";
          });
          flowDiagram.appendChild(bubble);

          if (index < operators.length - 1) {
            const connector = document.createElement("div");
            connector.className = "connector";
            flowDiagram.appendChild(connector);
          }
        });

        if (request.plan) {
          const viewPlanButton = document.createElement("button");
          viewPlanButton.textContent = "View Detailed Execution Plan";
          viewPlanButton.style.marginTop = "10px";
          viewPlanButton.addEventListener("click", () => {
            const planTreeHtml = "<ul>" + buildPlanTree(request.plan) + "</ul>";
            document.getElementById("plan-modal-body").innerHTML = planTreeHtml;
            document.getElementById("plan-modal").style.display = "block";
          });
          flowDiagram.appendChild(viewPlanButton);
        }

        panzoom(flowDiagram, { smoothScroll: false });
      }

      // Build plan tree for modal
      function buildPlanTree(operator) {
        if (!operator) return "";
        let html = `<li>${operator["#operator"] || "Unknown Operator"}`;
        if (operator["#stats"]) {
          const stats = operator["#stats"];
          html += ` - itemsIn: ${
            stats["#itemsIn"] !== undefined ? stats["#itemsIn"] : "N/A"
          }, itemsOut: ${
            stats["#itemsOut"] !== undefined ? stats["#itemsOut"] : "N/A"
          }, execTime: ${stats.execTime || "N/A"}, kernTime: ${
            stats.kernTime || "N/A"
          }`;
        }
        if (operator["~child"]) {
          html += "<ul>" + buildPlanTree(operator["~child"]) + "</ul>";
        } else if (operator["~children"]) {
          html += "<ul>";
          operator["~children"].forEach((child) => {
            html += buildPlanTree(child);
          });
          html += "</ul>";
        }
        html += "</li>";
        return html;
      }

      // Sorting functionality
      let currentSortColumn = null;
      let currentSortDirection = 'asc';
      let currentTableType = 'every-query'; // 'every-query' or 'analysis'
      let everyQueryData = [];
      let analysisData = [];

      // Enhanced time parsing for sorting (handles various units and mm:ss.sss format)
      function parseTimeForSorting(timeStr) {
        if (!timeStr || timeStr === "N/A" || timeStr === "-") return 0;
        
        // Check if it's in mm:ss.sss format
        const mmssMatch = timeStr.match(/^(\d+):(\d{2})\.(\d{3})$/);
        if (mmssMatch) {
          const minutes = parseInt(mmssMatch[1]);
          const seconds = parseInt(mmssMatch[2]);
          const milliseconds = parseInt(mmssMatch[3]);
          return minutes * 60000 + seconds * 1000 + milliseconds;
        }
        
        // Handle legacy formats
        const match = timeStr
          .replace(/(\d+\.?\d*)(\D+)/, "$1 $2")
          .match(/(\d+\.?\d*)\s*(\D+)/);
        if (!match) return 0;
        const value = parseFloat(match[1]);
        const unit = match[2].toLowerCase().trim();
        // Convert everything to milliseconds for consistent sorting
        if (unit === "h" || unit === "hour" || unit === "hours") return value * 3600000;
        if (unit === "m" || unit === "min" || unit === "minute" || unit === "minutes") return value * 60000;
        if (unit === "s" || unit === "sec" || unit === "second" || unit === "seconds") return value * 1000;
        if (unit === "ms" || unit === "millisecond" || unit === "milliseconds") return value;
        if (unit === "us" || unit === "µs" || unit === "microsecond" || unit === "microseconds") return value / 1000;
        if (unit === "ns" || unit === "nanosecond" || unit === "nanoseconds") return value / 1000000;
        return value;
      }

      // Get sortable value for a column
      function getSortableValue(item, column) {
        let value = item[column];
        
        // Handle special columns for Every Query table
        if (column === "#") {
          // "#" column is calculated dynamically, use a default sort order
          return parseInt(item.rowIndex) || 0;
        }
        if (column === "requestTime") {
          return new Date(value).getTime() || 0;
        }
        if (["elapsedTime", "kernTime", "cpuTime", "serviceTime"].includes(column)) {
          return parseTimeForSorting(value);
        }
        if (column === "KernTime %") {
          const numStr = String(value).replace('%', '');
          return parseFloat(numStr) || 0;
        }
        if (["resultCount", "resultSize", "Items from Index Scan", "Doc Fetch Count"].includes(column)) {
          return parseInt(value) || 0;
        }
        if (column === "Primary Scan Used") {
          return value === "Yes" ? 1 : 0;
        }
        
        // Handle Analysis table columns
        if ([
          "min_duration_in_seconds", 
          "max_duration_in_seconds", 
          "avg_duration_in_seconds", 
          "median_duration_in_seconds"
        ].includes(column)) {
          return parseTimeForSorting(value);
        }
        if ([
          "total_count", 
          "avg_fetch", 
          "avg_primaryScan", 
          "avg_indexScan"
        ].includes(column)) {
          return parseFloat(value) || 0;
        }
        
        // Default: string comparison
        return String(value || "").toLowerCase();
      }

      // Sort data
      function sortData(data, column, direction) {
        return [...data].sort((a, b) => {
          const aVal = getSortableValue(a, column);
          const bVal = getSortableValue(b, column);
          
          let comparison = 0;
          if (aVal < bVal) comparison = -1;
          else if (aVal > bVal) comparison = 1;
          
          return direction === 'asc' ? comparison : -comparison;
        });
      }

      // Update sort arrows in headers
      function updateSortArrows(tableHeaderId, column, direction) {
        const headers = document.querySelectorAll(`#${tableHeaderId} th`);
        headers.forEach(th => {
          const existingArrow = th.querySelector('.sort-arrow');
          if (existingArrow) existingArrow.remove();
          
          if (th.textContent.trim() === column) {
            const arrow = document.createElement('span');
            arrow.className = 'sort-arrow';
            arrow.textContent = direction === 'asc' ? '▲' : '▼';
            th.appendChild(arrow);
          }
        });
      }

      // Handle column sort click
      function handleColumnSort(column, tableType) {
        if (currentSortColumn === column && currentTableType === tableType) {
          currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          currentSortColumn = column;
          currentSortDirection = 'asc';
          currentTableType = tableType;
        }
        
        if (tableType === 'every-query') {
          const sortedData = sortData(everyQueryData, column, currentSortDirection);
          populateEveryQueryTable(sortedData);
          updateSortArrows('table-header', column, currentSortDirection);
        } else if (tableType === 'analysis') {
          const sortedData = sortData(analysisData, column, currentSortDirection);
          populateAnalysisTable(sortedData);
          updateSortArrows('analysis-table-header', column, currentSortDirection);
        }
      }

      // Generate main table
      function generateTable(requests) {
        const tableHeader = document.getElementById("table-header");
        const tableBody = document.getElementById("table-body");
        tableHeader.innerHTML = "";
        tableBody.innerHTML = "";

        const columns = [
          "#",
          "requestTime",
          "statementType",
          "elapsedTime",
          "kernTime",
          "KernTime %",
          "cpuTime",
          "memory (MB)",
          "serviceTime",
          "resultCount",
          "resultSize",
          "Index(es) Used",
          "Items from Index Scan",
          "Doc Fetch Count",
          "Primary Scan Used",
          "state",
          "statement",
          "users",
        ];

        const headerRow = document.createElement("tr");
        columns.forEach((col) => {
          const th = document.createElement("th");
          th.textContent = col;
          th.style.textAlign = "center";
          th.addEventListener('click', () => handleColumnSort(col, 'every-query'));
          headerRow.appendChild(th);
        });
        tableHeader.appendChild(headerRow);

        // Prepare data with pre-calculated values
        const tableData = requests.map((request, index) => {
          // Use pre-calculated values from processRequestData
          const totalKernTimeMs = request.kernTimeMs || 0;
          const totalMemoryBytes = request.memoryBytes || 0;
          const elapsedTimeMs = request.elapsedTimeMs || 0;
          
          // Create row data object
          const rowData = {
            rowIndex: index + 1,
            request: request, // Keep original request for click handler
          };
          
          // Add all column values (skip "#" as it's calculated dynamically)
          ["requestTime", "statementType", "elapsedTime", "kernTime", "KernTime %", 
           "cpuTime", "memory (MB)", "serviceTime", "resultCount", "resultSize", "Index(es) Used", 
           "Items from Index Scan", "Doc Fetch Count", "Primary Scan Used", "state", 
           "statement", "users"].forEach(col => {
            let value;
            if (col === "Primary Scan Used") {
              value = request.usesPrimary ? "Yes" : "No";
            } else if (col === "Index(es) Used") {
              const indexes = [];
              if (request.usesPrimary) {
                indexes.push("Primary");
              }
              if (request.indexInfo && request.indexInfo.stats.indexScan > 0) {
                indexes.push("Secondary");
              }
              value = indexes.length > 0 ? indexes.join(", ") : "None";
            } else if (col === "Items from Index Scan") {
              if (request.indexInfo) {
                const stats = request.indexInfo.stats;
                if (stats.primaryScan > 0) {
                  value = stats.primaryScan;
                } else if (stats.indexScan > 0) {
                  value = stats.indexScan;
                } else {
                  value = "N/A";
                }
              } else {
                value = "N/A";
              }
            } else if (col === "Doc Fetch Count") {
              value = request.indexInfo ? request.indexInfo.stats.fetch || "N/A" : "N/A";
            } else if (col === "kernTime") {
              value = totalKernTimeMs > 0 ? formatTime(totalKernTimeMs) : "N/A";
            } else if (col === "KernTime %") {
              value =
                elapsedTimeMs > 0 && totalKernTimeMs > 0
                  ? ((totalKernTimeMs / elapsedTimeMs) * 100).toFixed(2) + "%"
                  : "N/A";
            } else if (col === "memory (MB)") {
              value = totalMemoryBytes > 0 ? (totalMemoryBytes / 1024 / 1024).toFixed(2) : "0.00";
            } else if (col === "elapsedTime") {
              value = formatTime(elapsedTimeMs);
            } else if (col === "cpuTime") {
              value = formatTime(parseTime(request[col]));
            } else if (col === "serviceTime") {
              value = formatTime(parseTime(request[col]));
            } else {
              value = request[col] || "N/A";
            }
            rowData[col] = value;
          });
          
          return rowData;
        });

        // Sort by elapsedTime by default
        const sortedData = sortData(tableData, 'elapsedTime', 'desc');
        everyQueryData = sortedData;
        currentSortColumn = 'elapsedTime';
        currentSortDirection = 'desc';
        currentTableType = 'every-query';
        
        populateEveryQueryTable(sortedData);
        updateSortArrows('table-header', 'elapsedTime', 'desc');
      }

      // Populate Every Query table body
      function populateEveryQueryTable(data) {
        
        const tableBody = document.getElementById("table-body");
        tableBody.innerHTML = "";
        
        // Clear statement store for new data
        statementStore = {};
        
        const columns = [
          "#", "requestTime", "statementType", "elapsedTime", "kernTime", "KernTime %", 
          "cpuTime", "memory (MB)", "serviceTime", "resultCount", "resultSize", "Index(es) Used", 
          "Items from Index Scan", "Doc Fetch Count", "Primary Scan Used", "state", 
          "statement", "users"
        ];

        data.forEach((rowData, index) => {
          const row = document.createElement("tr");

          columns.forEach((col) => {
            const td = document.createElement("td");
            // Recalculate row number based on current sort order
            const value = col === "#" ? index + 1 : rowData[col];
            
            if (col === "statement") {
              // Handle statement column with truncation and controls
              const statement = value || "";
              const statementId = `statement-${index}`;
              
              // Store the statement safely
              statementStore[statementId] = statement;
              
              if (statement.length > 500) {
                // Create truncated version
                const truncated = statement.substring(0, 500);
                
                td.innerHTML = `
                  <div id="${statementId}-truncated">
                    <span>${truncated}...</span>
                    <br>
                    <button onclick="toggleStatement('${statementId}', true)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">show more</button>
                    <button onclick="copyStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                  <div id="${statementId}-full" style="display: none;">
                    <span>${statement}</span>
                    <br>
                    <button onclick="toggleStatement('${statementId}', false)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">hide</button>
                    <button onclick="copyStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
              } else {
                // Short statement - just show it with copy button
                td.innerHTML = `
                  <div>
                    <span>${statement}</span>
                    <br>
                    <button onclick="copyStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
              }
            } else {
              td.textContent = value;
            }
            
            if (col === "Primary Scan Used" && value === "Yes") {
              td.classList.add("primary-scan-yes");
            }
            
            if (col === "state" && value === "fatal") {
              td.classList.add("fatal-state");
            }
            row.appendChild(td);
          });

          row.addEventListener("click", () => {
            document
              .querySelectorAll("tr")
              .forEach((r) => (r.style.backgroundColor = ""));
            row.style.backgroundColor = "#e0e0e0";
            generateFlowDiagram(rowData.request);
          });
          tableBody.appendChild(row);
        });
      }

      // Toggle statement display between truncated and full view
      function toggleStatement(statementId, showFull) {
        const truncatedDiv = document.getElementById(statementId + '-truncated');
        const fullDiv = document.getElementById(statementId + '-full');
        
        if (showFull) {
          truncatedDiv.style.display = 'none';
          fullDiv.style.display = 'block';
        } else {
          truncatedDiv.style.display = 'block';
          fullDiv.style.display = 'none';
        }
      }

      // Copy statement to clipboard
      function copyStatement(statementId) {
        const statement = statementStore[statementId];
        if (!statement) {
          console.error('Statement not found in store:', statementId);
          alert('Statement not found');
          return;
        }
        
        navigator.clipboard.writeText(statement).then(() => {
          // Show brief feedback
          const button = event.target;
          const originalText = button.textContent;
          button.textContent = 'copied!';
          button.style.backgroundColor = '#4CAF50';
          setTimeout(() => {
            button.textContent = originalText;
            button.style.backgroundColor = '';
          }, 1000);
        }).catch(err => {
          console.error('Failed to copy statement:', err);
          alert('Failed to copy to clipboard');
        });
      }

      // Toggle analysis statement display between truncated and full view
      function toggleAnalysisStatement(statementId, showFull) {
        const truncatedDiv = document.getElementById(statementId + '-truncated');
        const fullDiv = document.getElementById(statementId + '-full');
        
        if (showFull) {
          truncatedDiv.style.display = 'none';
          fullDiv.style.display = 'block';
        } else {
          truncatedDiv.style.display = 'block';
          fullDiv.style.display = 'none';
        }
      }

      // Copy analysis statement to clipboard
      function copyAnalysisStatement(statementId) {
        const statement = analysisStatementStore[statementId];
        if (!statement) {
          console.error('Statement not found in store:', statementId);
          alert('Statement not found');
          return;
        }
        
        navigator.clipboard.writeText(statement).then(() => {
          // Show brief feedback
          const button = event.target;
          const originalText = button.textContent;
          button.textContent = 'copied!';
          button.style.backgroundColor = '#4CAF50';
          setTimeout(() => {
            button.textContent = originalText;
            button.style.backgroundColor = '';
          }, 1000);
        }).catch(err => {
          console.error('Failed to copy statement:', err);
          alert('Failed to copy to clipboard');
        });
      }

      // Calculate statistics for a group of requests based on SQL++ query logic
      function calculateGroupStats(normalized_statement, groupedRequests) {
        const users_agg = groupedRequests.map((r) => r.users).filter((u) => u);
        const durations = groupedRequests
          .map((r) => {
            const ms = parseTime(r.serviceTime);
            return isNaN(ms) ? NaN : ms / 1000; // Convert ms to seconds
          })
          .filter((d) => !isNaN(d));
        const total_count = durations.length;
        if (total_count === 0) return null;

        const min_duration = Math.min(...durations);
        const max_duration = Math.max(...durations);
        const avg_duration =
          durations.reduce((sum, d) => sum + d, 0) / total_count;
        const sorted_durations = [...durations].sort((a, b) => a - b);
        const midFloor = Math.floor(total_count / 2);
        const midCeil = Math.ceil(total_count / 2) - 1;
        const median_duration =
          (sorted_durations[midFloor] + sorted_durations[midCeil]) / 2;

        const fetchValues = groupedRequests.map(
          (r) => r.phaseCounts?.fetch || 0
        );
        const primaryScanValues = groupedRequests.map(
          (r) => r.phaseCounts?.primaryScan || 0
        );
        const indexScanValues = groupedRequests.map(
          (r) => r.phaseCounts?.indexScan || 0
        );
        const avg_fetch =
          fetchValues.reduce((sum, v) => sum + v, 0) / total_count;
        const avg_primaryScan =
          primaryScanValues.reduce((sum, v) => sum + v, 0) / total_count;
        const avg_indexScan =
          indexScanValues.reduce((sum, v) => sum + v, 0) / total_count;

        // Compute user_query_counts as an object: { user: count }
        const uniqueUsers = [...new Set(users_agg)];
        const user_query_counts = {};
        uniqueUsers.forEach((user) => {
          user_query_counts[user] = users_agg.filter((v) => v === user).length;
        });

        return {
          normalized_statement,
          user_query_counts,
          total_count,
          min_duration_in_seconds: min_duration,
          max_duration_in_seconds: max_duration,
          avg_duration_in_seconds: avg_duration,
          median_duration_in_seconds: median_duration,
          avg_fetch,
          avg_primaryScan,
          avg_indexScan,
        };
      }

      // Generate analysis table based on SQL++ query logic
      function generateAnalysisTable(requests) {
        const analysisTableHeader = document.getElementById(
          "analysis-table-header"
        );
        const analysisTableBody = document.getElementById(
          "analysis-table-body"
        );
        analysisTableHeader.innerHTML = "";
        analysisTableBody.innerHTML = "";

        // Group requests by normalized_statement
        const groups = {};
        requests.forEach((request) => {
          const stmt = request.preparedText || request.statement;
          if (!stmt) return;
          const upperStmt = stmt.toUpperCase();
          // Apply SQL++ WHERE clause filters
          if (
            upperStmt.startsWith("INFER ") ||
            upperStmt.startsWith("ADVISE ") ||
            upperStmt.startsWith("CREATE ") ||
            upperStmt.startsWith("CREATE INDEX") ||
            upperStmt.startsWith("ALTER INDEX") ||
            upperStmt.includes(" SYSTEM:")
          ) {
            return;
          }
          const normalized = normalizeStatement(stmt);
          if (!groups[normalized]) {
            groups[normalized] = [];
          }
          groups[normalized].push(request);
        });

        // Calculate stats for each group
        const groupData = Object.keys(groups)
          .map((key) => calculateGroupStats(key, groups[key]))
          .filter((data) => data !== null);
        groupData.sort((a, b) => b.total_count - a.total_count);

        // Define table columns
        const analysisColumns = [
          "total_count",
          "min_duration_in_seconds",
          "max_duration_in_seconds",
          "avg_duration_in_seconds",
          "median_duration_in_seconds",
          "avg_fetch",
          "avg_primaryScan",
          "avg_indexScan",
          "normalized_statement",
          "user_query_counts",
        ];

        // Create header row
        const headerRow = document.createElement("tr");
        analysisColumns.forEach((col) => {
          const th = document.createElement("th");
          let displayName = col
            .replace(/_/g, " ")
            .replace("in seconds", " (mm:ss.sss)");
          if (col === "user_query_counts") {
            displayName = "user: (count)";
          }
          th.textContent = displayName;
          th.style.textAlign = "center";
          th.addEventListener('click', () => handleColumnSort(col, 'analysis'));
          headerRow.appendChild(th);
        });
        analysisTableHeader.appendChild(headerRow);

        // Prepare table data
        const analysisTableData = groupData.map((group) => {
          const rowData = {};
          analysisColumns.forEach((col) => {
            let value;
            if (col === "user_query_counts") {
              value = Object.entries(group.user_query_counts)
                .map(([user, count]) => `${user}: (${count})`)
                .join(", ");
            } else if (col === "total_count") {
              value = group.total_count;
            } else if (
              [
                "min_duration_in_seconds",
                "max_duration_in_seconds",
                "avg_duration_in_seconds",
                "median_duration_in_seconds",
              ].includes(col)
            ) {
              value = isNaN(group[col]) ? "N/A" : formatTime(Number(group[col]) * 1000);
            } else if (
              [
                "avg_fetch",
                "avg_primaryScan",
                "avg_indexScan",
              ].includes(col)
            ) {
              value = isNaN(group[col]) ? "N/A" : Number(group[col]).toFixed(3);
            } else {
              value = group[col] || "N/A";
            }
            rowData[col] = value;
          });
          return rowData;
        });

        // Sort by total_count by default
        const sortedData = sortData(analysisTableData, 'total_count', 'desc');
        analysisData = sortedData;
        currentSortColumn = 'total_count';
        currentSortDirection = 'desc';
        currentTableType = 'analysis';
        
        populateAnalysisTable(sortedData);
        updateSortArrows('analysis-table-header', 'total_count', 'desc');
      }

      // Populate Analysis table body
      function populateAnalysisTable(data) {
        const analysisTableBody = document.getElementById("analysis-table-body");
        analysisTableBody.innerHTML = "";
        
        // Clear statement store for new data
        analysisStatementStore = {};
        
        const analysisColumns = [
          "total_count",
          "min_duration_in_seconds",
          "max_duration_in_seconds",
          "avg_duration_in_seconds",
          "median_duration_in_seconds",
          "avg_fetch",
          "avg_primaryScan",
          "avg_indexScan",
          "normalized_statement",
          "user_query_counts",
        ];

        data.forEach((rowData, index) => {
          const row = document.createElement("tr");
          analysisColumns.forEach((col) => {
            const td = document.createElement("td");
            const value = rowData[col];
            
            if (col === "normalized_statement") {
              // Handle normalized_statement column with truncation and controls
              const statement = value || "";
              const statementId = `analysis-statement-${index}`;
              
              // Store the statement safely
              analysisStatementStore[statementId] = statement;
              
              if (statement.length > 500) {
                // Create truncated version
                const truncated = statement.substring(0, 500);
                
                td.innerHTML = `
                  <div id="${statementId}-truncated">
                    <span>${truncated}...</span>
                    <br>
                    <button onclick="toggleAnalysisStatement('${statementId}', true)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">show more</button>
                    <button onclick="copyAnalysisStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                  <div id="${statementId}-full" style="display: none;">
                    <span>${statement}</span>
                    <br>
                    <button onclick="toggleAnalysisStatement('${statementId}', false)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">hide</button>
                    <button onclick="copyAnalysisStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
              } else {
                // Short statement - just show it with copy button
                td.innerHTML = `
                  <div>
                    <span>${statement}</span>
                    <br>
                    <button onclick="copyAnalysisStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
              }
            } else if (col === "user_query_counts") {
              // Bold the counts in parentheses
              const formattedValue = value.replace(/\((\d+)\)/g, '<b>($1)</b>');
              td.innerHTML = formattedValue;
            } else {
              td.textContent = value;
            }
            
            row.appendChild(td);
          });
          analysisTableBody.appendChild(row);
        });
      }

      // Helper function to get time grouping settings
      function getTimeGrouping() {
        const selectedGrouping =
          document.querySelector('input[name="timeGrouping"]:checked')?.value ||
          "optimizer";
        return selectedGrouping;
      }

      // Helper function to round timestamp based on grouping and optimal unit
      function roundTimestamp(timestamp, grouping, requests) {
        const date = new Date(timestamp);
        
        // Determine actual unit to use
        let actualUnit;
        if (grouping === "optimizer") {
          actualUnit = getOptimalTimeUnit(requests);
        } else {
          // Use exactly what the user selected
          actualUnit = grouping;
        }

        // Round based on actual unit
        switch (actualUnit) {
          case "second":
            date.setMilliseconds(0);
            break;
          case "minute":
            date.setSeconds(0, 0);
            break;
          case "hour":
            date.setMinutes(0, 0, 0);
            break;
          case "day":
            date.setHours(0, 0, 0, 0);
            break;
          case "week":
            const dayOfWeek = date.getDay();
            date.setDate(date.getDate() - dayOfWeek);
            date.setHours(0, 0, 0, 0);
            break;
          case "month":
            date.setDate(1);
            date.setHours(0, 0, 0, 0);
            break;
          case "year":
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
            break;
          default:
            date.setSeconds(0, 0);
        }
        return date;
      }

      // Helper function to automatically determine optimal time unit based on data span
      function getOptimalTimeUnit(requests) {
        if (!requests || requests.length === 0) return "minute";

        const times = requests
          .map((r) => new Date(r.requestTime))
          .filter((t) => !isNaN(t));
        if (times.length === 0) return "minute";

        const minTime = Math.min(...times);
        const maxTime = Math.max(...times);
        const timeSpanMs = maxTime - minTime;
        const timeSpanHours = timeSpanMs / (1000 * 60 * 60);
        const timeSpanDays = timeSpanHours / 24;

        // Choose time unit based on span to keep Chart.js happy
        if (timeSpanDays > 365) {
          return "year";
        } else if (timeSpanDays > 60) {
          return "month";
        } else if (timeSpanDays > 14) {
          return "week";
        } else if (timeSpanDays > 2) {
          return "day";
        } else if (timeSpanHours > 2) {
          return "hour";
        } else if (timeSpanHours > 0.1) {
          return "minute";
        } else {
          return "second";
        }
      }

      // Helper function to get Chart.js time configuration with auto-adjustment
      function getTimeConfig(requestedGrouping, requests) {
        // Use exactly the unit that was requested
        let actualUnit = requestedGrouping;

        // Calculate appropriate stepSize based on data span to prevent Chart.js errors
        let stepSize = 1;
        if (requests && requests.length > 0) {
          const times = requests
            .map((r) => new Date(r.requestTime))
            .filter((t) => !isNaN(t));
          if (times.length > 0) {
            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            const timeSpanMs = maxTime - minTime;

            // Calculate stepSize to keep data points reasonable (max ~1000 points)
            switch (actualUnit) {
              case "second":
                stepSize = Math.max(1, Math.ceil(timeSpanMs / (1000 * 1000))); // timeSpanMs / (1000ms * 1000 points)
                break;
              case "minute":
                stepSize = Math.max(
                  1,
                  Math.ceil(timeSpanMs / (60 * 1000 * 1000))
                ); // timeSpanMs / (60s * 1000ms * 1000 points)
                break;
              case "hour":
                stepSize = Math.max(
                  1,
                  Math.ceil(timeSpanMs / (60 * 60 * 1000 * 1000))
                ); // timeSpanMs / (3600s * 1000ms * 1000 points)
                break;
              case "day":
                stepSize = Math.max(
                  1,
                  Math.ceil(timeSpanMs / (24 * 60 * 60 * 1000 * 1000))
                ); // timeSpanMs / (86400s * 1000ms * 1000 points)
                break;
              case "week":
                stepSize = Math.max(
                  1,
                  Math.ceil(timeSpanMs / (7 * 24 * 60 * 60 * 1000 * 1000))
                ); // timeSpanMs / (604800s * 1000ms * 1000 points)
                break;
              case "month":
                stepSize = Math.max(
                  1,
                  Math.ceil(timeSpanMs / (30 * 24 * 60 * 60 * 1000 * 1000))
                ); // timeSpanMs / (~2592000s * 1000ms * 1000 points)
                break;
              case "year":
                stepSize = Math.max(
                  1,
                  Math.ceil(timeSpanMs / (365 * 24 * 60 * 60 * 1000 * 1000))
                ); // timeSpanMs / (~31536000s * 1000ms * 1000 points)
                break;
            }
          }
        }

        // Return appropriate config based on actual unit
        const configs = {
          second: {
            unit: "second",
            stepSize: stepSize,
            displayFormats: { second: "HH:mm:ss" },
          },
          minute: {
            unit: "minute",
            stepSize: stepSize,
            displayFormats: { minute: "MMM dd HH:mm" },
          },
          hour: {
            unit: "hour",
            stepSize: stepSize,
            displayFormats: { hour: "MMM dd HH:mm" },
          },
          day: {
            unit: "day",
            stepSize: stepSize,
            displayFormats: { day: "MMM dd" },
          },
          week: {
            unit: "week",
            stepSize: stepSize,
            displayFormats: { week: "MMM dd" },
          },
          month: {
            unit: "month",
            stepSize: stepSize,
            displayFormats: { month: "MMM yyyy" },
          },
          year: {
            unit: "year",
            stepSize: stepSize,
            displayFormats: { year: "yyyy" },
          },
        };

        return configs[actualUnit] || configs["minute"];
      }

      // Helper function to get current time config with requests data
      function getCurrentTimeConfig(requests) {
        const grouping = getTimeGrouping();
        let actualUnit;
        if (grouping === "optimizer") {
          actualUnit = getOptimalTimeUnit(requests);
        } else {
          actualUnit = grouping;
        }
        return getTimeConfig(actualUnit, requests);
      }

      // Helper function to update the optimizer label
      function updateOptimizerLabel(requests) {
        const optimizedUnit = getOptimalTimeUnit(requests);
        const label = document.getElementById("optimizer-label");
        if (label) {
          label.textContent = `By Optimizer (${optimizedUnit})`;
        }
      }

      // Generate operations chart showing index scan vs fetch operations
      function generateOperationsChart(requests) {
        // Destroy existing chart if it exists - do this first
        if (window.operationsChart) {
          window.operationsChart.destroy();
          window.operationsChart = null;
        }

        const canvas = document.getElementById("operations-chart");
        const ctx = canvas.getContext("2d");

        // Group requests by selected time unit
        const timeGroups = {};
        const grouping = getTimeGrouping();

        requests.forEach((request) => {
          if (!request.requestTime) return;

          // Parse requestTime and round based on selected grouping
          const requestDate = new Date(request.requestTime);
          const timeKey = roundTimestamp(requestDate, grouping, requests);

          const key = timeKey.toISOString();

          if (!timeGroups[key]) {
            timeGroups[key] = {
              timestamp: timeKey,
              totalIndexScan: 0,
              totalFetch: 0,
            };
          }

          // Use pre-calculated values from indexInfo
          const indexInfo = request.indexInfo || { stats: { primaryScan: 0, indexScan: 0, fetch: 0 } };
          const { primaryScan, indexScan, fetch } = indexInfo.stats;

          timeGroups[key].totalIndexScan += primaryScan + indexScan;
          timeGroups[key].totalFetch += fetch;
        });

        // Convert to sorted array
        const sortedData = Object.values(timeGroups).sort(
          (a, b) => a.timestamp - b.timestamp
        );

        // Prepare chart data
        const labels = sortedData.map((item) => item.timestamp);
        const indexScanData = sortedData.map((item) => item.totalIndexScan);
        const fetchData = sortedData.map((item) => item.totalFetch);

        // Create new side-by-side bar chart
        window.operationsChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [
                {
                label: "Fetch Documents",
                data: fetchData,
                backgroundColor: "#28a745", // Green
                borderColor: "#1e7e34",
                borderWidth: 1,
              },
              {
                label: "Index Scan Items",
                data: indexScanData,
                backgroundColor: "#007bff", // Blue
                borderColor: "#0056b3",
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: "Database Operations Timeline: Index Scans vs Document Fetches",
              },
              legend: {
                display: true,
                position: "top",
              },
              zoom: {
                limits: {
                  x: { min: "original", max: "original" },
                  y: { min: "original", max: "original" },
                },
                pan: {
                  enabled: true,
                  mode: "xy",
                  onPan: function ({ chart }) {
                  // Sync pan with other charts
                  if (window.filterChart && chart !== window.filterChart) {
                  window.filterChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (
                  window.timelineChart &&
                  chart !== window.timelineChart
                  ) {
                  window.timelineChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (window.queryTypesChart && chart !== window.queryTypesChart) {
                  window.queryTypesChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                     if (window.durationBucketsChart && chart !== window.durationBucketsChart) {
                       window.durationBucketsChart.zoomScale(
                         "x",
                         { min: chart.scales.x.min, max: chart.scales.x.max },
                         "none"
                       );
                     }
                  if (window.durationBucketsChart && chart !== window.durationBucketsChart) {
                  window.durationBucketsChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                       if (window.memoryChart && chart !== window.memoryChart) {
                       window.memoryChart.zoomScale(
                       "x",
                       { min: chart.scales.x.min, max: chart.scales.x.max },
                       "none"
                       );
                       }
                   
                     },
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  drag: {
                    enabled: true,
                    backgroundColor: "rgba(225,225,225,0.3)",
                    borderColor: "rgba(225,225,225)",
                    borderWidth: 1,
                  },
                  mode: "xy",
                  onZoom: function ({ chart }) {
                  // Sync zoom with other charts
                  if (window.filterChart && chart !== window.filterChart) {
                  window.filterChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (
                  window.timelineChart &&
                  chart !== window.timelineChart
                  ) {
                  window.timelineChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (window.queryTypesChart && chart !== window.queryTypesChart) {
                  window.queryTypesChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (window.durationBucketsChart && chart !== window.durationBucketsChart) {
                  window.durationBucketsChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                    if (window.memoryChart && chart !== window.memoryChart) {
                    window.memoryChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                   
                     },
                },
              },
            },
            scales: {
              x: {
                type: "time",
                time: getCurrentTimeConfig(requests),
                title: {
                  display: true,
                  text: "Request Time",
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Operation Count",
                },
                beginAtZero: true,
              },
            },
            interaction: {
              mode: "index",
              intersect: false,
            },
          },
        });
      }

      // Generate filter chart showing filter efficiency (IN vs OUT)
      function generateFilterChart(requests) {
        // Destroy existing chart if it exists - do this first
        if (window.filterChart) {
          window.filterChart.destroy();
          window.filterChart = null;
        }

        const canvas = document.getElementById("filter-chart");
        const ctx = canvas.getContext("2d");

        // Group requests by selected time unit
        const timeGroups = {};
        const grouping = getTimeGrouping();

        requests.forEach((request) => {
          if (!request.requestTime || !request.plan) return;

          // Parse requestTime and round based on selected grouping
          const requestDate = new Date(request.requestTime);
          const timeKey = roundTimestamp(requestDate, grouping, requests);

          const key = timeKey.toISOString();

          if (!timeGroups[key]) {
            timeGroups[key] = {
              timestamp: timeKey,
              filtersEqual: 0,
              filtersNotEqual: 0,
            };
          }

          // Find all Filter operators in the plan
          const operators = getOperators(request.plan);
          operators.forEach((operator) => {
            if (operator["#operator"] === "Filter") {
              const stats = operator["#stats"] || {};
              const itemsIn = stats["#itemsIn"];
              const itemsOut = stats["#itemsOut"];

              if (itemsIn !== undefined && itemsOut !== undefined) {
                if (itemsIn === itemsOut) {
                  timeGroups[key].filtersEqual++;
                } else {
                  timeGroups[key].filtersNotEqual++;
                }
              }
            }
          });
        });

        // Convert to sorted array
        const sortedData = Object.values(timeGroups).sort(
          (a, b) => a.timestamp - b.timestamp
        );

        // Prepare chart data
        const labels = sortedData.map((item) => item.timestamp);
        const filtersEqualData = sortedData.map((item) => item.filtersEqual);
        const filtersNotEqualData = sortedData.map(
          (item) => item.filtersNotEqual
        );

        // Create new stacked bar chart
        window.filterChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Filters: IN = OUT",
                data: filtersEqualData,
                backgroundColor: "#007bff", // Blue
                borderColor: "#0056b3",
                borderWidth: 1,
              },
              {
                label: "Filters: IN ≠ OUT",
                data: filtersNotEqualData,
                backgroundColor: "#fd7e14", // Orange
                borderColor: "#e8590c",
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: "Filter Operations Timeline: Efficiency Analysis (IN vs OUT)",
              },
              legend: {
                display: true,
                position: "top",
              },
              zoom: {
                limits: {
                  x: { min: "original", max: "original" },
                  y: { min: "original", max: "original" },
                },
                pan: {
                  enabled: true,
                  mode: "xy",
                  onPan: function ({ chart }) {
                  // Sync pan with other charts
                  if (
                  window.operationsChart &&
                  chart !== window.operationsChart
                  ) {
                  window.operationsChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (
                  window.timelineChart &&
                  chart !== window.timelineChart
                  ) {
                  window.timelineChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (window.queryTypesChart && chart !== window.queryTypesChart) {
                  window.queryTypesChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (window.durationBucketsChart && chart !== window.durationBucketsChart) {
                  window.durationBucketsChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                       if (window.memoryChart && chart !== window.memoryChart) {
                       window.memoryChart.zoomScale(
                       "x",
                       { min: chart.scales.x.min, max: chart.scales.x.max },
                       "none"
                       );
                       }
                   
                     },
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  drag: {
                    enabled: true,
                    backgroundColor: "rgba(225,225,225,0.3)",
                    borderColor: "rgba(225,225,225)",
                    borderWidth: 1,
                  },
                  mode: "xy",
                  onZoom: function ({ chart }) {
                  // Sync zoom with other charts
                  if (
                  window.operationsChart &&
                  chart !== window.operationsChart
                  ) {
                  window.operationsChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (
                  window.timelineChart &&
                  chart !== window.timelineChart
                  ) {
                  window.timelineChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                  if (window.queryTypesChart && chart !== window.queryTypesChart) {
                  window.queryTypesChart.zoomScale(
                  "x",
                  { min: chart.scales.x.min, max: chart.scales.x.max },
                  "none"
                  );
                  }
                   if (window.memoryChart && chart !== window.memoryChart) {
                   window.memoryChart.zoomScale(
                   "x",
                   { min: chart.scales.x.min, max: chart.scales.x.max },
                   "none"
                   );
                   }
                   
                     },
                },
              },
            },
            scales: {
              x: {
                type: "time",
                time: getCurrentTimeConfig(requests),
                title: {
                  display: true,
                  text: "Request Time",
                },
                stacked: true,
              },
              y: {
                title: {
                  display: true,
                  text: "Filter Count",
                },
                stacked: true,
                beginAtZero: true,
              },
            },
            interaction: {
              mode: "index",
              intersect: false,
            },
          },
        });
      }

      // Generate timeline chart showing kernel time vs execution time performance
      function generateTimelineChart(requests) {
        // Destroy existing chart if it exists - do this first
        if (window.timelineChart) {
          window.timelineChart.destroy();
          window.timelineChart = null;
        }

        const canvas = document.getElementById("timeline-chart");
        const ctx = canvas.getContext("2d");

        // Group requests by selected time unit
        const timeGroups = {};
        const grouping = getTimeGrouping();

        requests.forEach((request) => {
          if (!request.requestTime) return;

          // Parse requestTime and round based on selected grouping
          const requestDate = new Date(request.requestTime);
          const timeKey = roundTimestamp(requestDate, grouping, requests);

          const key = timeKey.toISOString();

          if (!timeGroups[key]) {
            timeGroups[key] = {
              timestamp: timeKey,
              percent0to10: 0,
              percent10to20: 0,
              percent20to30: 0,
              percent30to40: 0,
              percent40to50: 0,
              percent50to60: 0,
              percent60to70: 0,
              percent70to80: 0,
              percent80to90: 0,
              percent90to100: 0,
              percentOver100: 0,
            };
          }

          // Use pre-calculated values
          const totalKernTimeMs = request.kernTimeMs || 0;
          const elapsedTimeMs = request.elapsedTimeMs || 0;

          // Calculate percentage of kernTime vs executionTime
          const kernTimePercentage = elapsedTimeMs > 0 ? (totalKernTimeMs / elapsedTimeMs) * 100 : 0;

          // Group by percentage ranges
          if (kernTimePercentage < 10) {
            timeGroups[key].percent0to10++;
          } else if (kernTimePercentage < 20) {
            timeGroups[key].percent10to20++;
          } else if (kernTimePercentage < 30) {
            timeGroups[key].percent20to30++;
          } else if (kernTimePercentage < 40) {
            timeGroups[key].percent30to40++;
          } else if (kernTimePercentage < 50) {
            timeGroups[key].percent40to50++;
          } else if (kernTimePercentage < 60) {
            timeGroups[key].percent50to60++;
          } else if (kernTimePercentage < 70) {
            timeGroups[key].percent60to70++;
          } else if (kernTimePercentage < 80) {
            timeGroups[key].percent70to80++;
          } else if (kernTimePercentage < 90) {
            timeGroups[key].percent80to90++;
          } else if (kernTimePercentage <= 100) {
            timeGroups[key].percent90to100++;
          } else {
            timeGroups[key].percentOver100++;
          }
        });

        // Convert to sorted array
        const sortedData = Object.values(timeGroups).sort(
          (a, b) => a.timestamp - b.timestamp
        );

        // Set original time range from data
        if (sortedData.length > 0) {
          originalTimeRange.min = sortedData[0].timestamp;
          originalTimeRange.max = sortedData[sortedData.length - 1].timestamp;
          currentTimeRange = { ...originalTimeRange };
          updateTimeRangeDisplay();
        }

        // Prepare chart data
        const labels = sortedData.map((item) => item.timestamp);
        const percent0to10Data = sortedData.map((item) => item.percent0to10);
        const percent10to20Data = sortedData.map((item) => item.percent10to20);
        const percent20to30Data = sortedData.map((item) => item.percent20to30);
        const percent30to40Data = sortedData.map((item) => item.percent30to40);
        const percent40to50Data = sortedData.map((item) => item.percent40to50);
        const percent50to60Data = sortedData.map((item) => item.percent50to60);
        const percent60to70Data = sortedData.map((item) => item.percent60to70);
        const percent70to80Data = sortedData.map((item) => item.percent70to80);
        const percent80to90Data = sortedData.map((item) => item.percent80to90);
        const percent90to100Data = sortedData.map((item) => item.percent90to100);
        const percentOver100Data = sortedData.map((item) => item.percentOver100);

        // Create new stacked bar chart
        window.timelineChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [
              {
                label: "0-10%",
                data: percent0to10Data,
                backgroundColor: "#28a745", // Green
                borderColor: "#1e7e34",
                borderWidth: 1,
              },
              {
                label: "10-20%",
                data: percent10to20Data,
                backgroundColor: "#6cb2eb", // Light blue
                borderColor: "#3490dc",
                borderWidth: 1,
              },
              {
                label: "20-30%",
                data: percent20to30Data,
                backgroundColor: "#a78bfa", // Light purple
                borderColor: "#8b5cf6",
                borderWidth: 1,
              },
              {
                label: "30-40%",
                data: percent30to40Data,
                backgroundColor: "#34d399", // Light green
                borderColor: "#10b981",
                borderWidth: 1,
              },
              {
                label: "40-50%",
                data: percent40to50Data,
                backgroundColor: "#fbbf24", // Yellow
                borderColor: "#f59e0b",
                borderWidth: 1,
              },
              {
                label: "50-60%",
                data: percent50to60Data,
                backgroundColor: "#fb923c", // Orange
                borderColor: "#ea580c",
                borderWidth: 1,
              },
              {
                label: "60-70%",
                data: percent60to70Data,
                backgroundColor: "#f472b6", // Pink
                borderColor: "#ec4899",
                borderWidth: 1,
              },
              {
                label: "70-80%",
                data: percent70to80Data,
                backgroundColor: "#a855f7", // Purple
                borderColor: "#9333ea",
                borderWidth: 1,
              },
              {
                label: "80-90%",
                data: percent80to90Data,
                backgroundColor: "#ef4444", // Red
                borderColor: "#dc2626",
                borderWidth: 1,
              },
              {
                label: "90-100%",
                data: percent90to100Data,
                backgroundColor: "#991b1b", // Dark red
                borderColor: "#7f1d1d",
                borderWidth: 1,
              },
              {
                label: "100%+",
                data: percentOver100Data,
                backgroundColor: "#450a0a", // Very dark red
                borderColor: "#1c0a0a",
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            scales: {
              x: { stacked: true },
              y: { stacked: true }
            },
            plugins: {
              title: {
                display: true,
                text: "Query Performance Timeline: KernTime % of ExecutionTime",
              },
              legend: {
                display: true,
                position: "top",
              },
              zoom: {
                limits: {
                  x: { min: "original", max: "original" },
                  y: { min: "original", max: "original" },
                },
                pan: {
                  enabled: true,
                  mode: "xy",
                  onPan: function ({ chart }) {
                    // Update current time range - convert chart scale values to Date objects
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync pan with other charts
                    if (
                    window.operationsChart &&
                    chart !== window.operationsChart
                    ) {
                    window.operationsChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                    window.filterChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                    window.queryTypesChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                      if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                      "x",
                      { min: chart.scales.x.min, max: chart.scales.x.max },
                      "none"
                      );
                      }
                      
                    },
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  drag: {
                    enabled: true,
                    backgroundColor: "rgba(225,225,225,0.3)",
                    borderColor: "rgba(225,225,225)",
                    borderWidth: 1,
                  },
                  mode: "xy",
                  onZoom: function ({ chart }) {
                    // Update current time range - convert chart scale values to Date objects
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync zoom with other charts
                    if (
                    window.operationsChart &&
                    chart !== window.operationsChart
                    ) {
                    window.operationsChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                    window.filterChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                    window.queryTypesChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                      if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                      "x",
                      { min: chart.scales.x.min, max: chart.scales.x.max },
                      "none"
                      );
                      }
                      
                    },
                },
              },
            },
            scales: {
              x: {
                type: "time",
                time: getCurrentTimeConfig(requests),
                title: {
                  display: true,
                  text: "Request Time",
                },
                stacked: true,
              },
              y: {
                title: {
                  display: true,
                  text: "Query Count",
                },
                stacked: true,
                beginAtZero: true,
              },
            },
            interaction: {
              mode: "index",
              intersect: false,
            },
          },
        });
        
        // Create Query Types Scatter Plot Chart
        createQueryTypesChart(requests, grouping);
        
        // Create Duration Buckets Chart
        createDurationBucketsChart(requests, grouping);
        
        // Create Memory Usage Chart
        createMemoryChart(requests, grouping);

      }

      // Create Query Types Scatter Plot Chart
      function createQueryTypesChart(requests, grouping) {
        const canvas = document.getElementById("query-types-chart");
        if (!canvas) return;

        const ctx = canvas.getContext("2d");

        // Destroy existing chart if it exists
        if (window.queryTypesChart) {
          window.queryTypesChart.destroy();
        }

        // Group requests by time and statement type
        const timeGroups = {};
        
        requests.forEach((request) => {
          const requestDate = new Date(request.requestTime);
          const timeKey = roundTimestamp(requestDate, grouping, requests);
          const key = timeKey.toISOString();
          
          if (!timeGroups[key]) {
            timeGroups[key] = {
              timestamp: timeKey,
              statementTypes: {}
            };
          }

          let statementType = 'UNKNOWN';
          if (request.statement && typeof request.statement === 'string') {
            const trimmed = request.statement.trim();
            if (trimmed) {
              statementType = trimmed.split(/\s+/)[0].toUpperCase();
            } else {
              console.log('Empty statement after trim:', request.statement);
            }
          } else {
            console.log('Non-string or null statement:', request.statement, typeof request.statement);
          }

          if (!timeGroups[key].statementTypes[statementType]) {
            timeGroups[key].statementTypes[statementType] = {
              count: 0,
              durations: []
            };
          }
          
          timeGroups[key].statementTypes[statementType].count++;
          
          // Get duration in seconds
          const elapsedTimeMs = parseTime(request.elapsedTime);
          const durationSeconds = elapsedTimeMs / 1000;
          timeGroups[key].statementTypes[statementType].durations.push(durationSeconds);
        });

        // Get all unique statement types
        const allStatementTypes = new Set();
        Object.values(timeGroups).forEach(group => {
          Object.keys(group.statementTypes).forEach(type => {
            allStatementTypes.add(type);
          });
        });

        // Console log all statement types found
        console.log('Statement types found:', Array.from(allStatementTypes).sort());
        

        console.log('First timeGroup sample:', Object.values(timeGroups)[0]);

        // Predefined colors for all statement types found
        const colorMap = {
          'SELECT': '#007bff',      // Blue
          'INSERT': '#28a745',      // Green
          'DELETE': '#dc3545',      // Red
          'UPSERT': '#6f42c1',      // Purple
          'CREATE': '#fd7e14',      // Orange
          'DROP': '#e83e8c',        // Pink
          'EXPLAIN': '#20c997',     // Teal
          'ADVISE': '#17a2b8',      // Cyan
          'INFER': '#ffc107',       // Yellow
          'WITH': '#6c757d',        // Gray
          'PREPARE': '#fd7e14',     // Orange-red
          'EXECUTE': '#6610f2',     // Indigo
          '--': '#343a40',          // Dark gray (comments)
          'UNKNOWN': '#868e96'      // Light gray
        };

        // Calculate min/max counts for circle sizing
        let minCount = Infinity;
        let maxCount = 0;
        Object.values(timeGroups).forEach(group => {
          Object.values(group.statementTypes).forEach(typeData => {
            minCount = Math.min(minCount, typeData.count);
            maxCount = Math.max(maxCount, typeData.count);
          });
        });

        // Generate datasets for each statement type with variable circle sizes
        const datasets = Array.from(allStatementTypes).map(statementType => {
          const data = [];
          
          Object.values(timeGroups).forEach(group => {
            if (group.statementTypes[statementType]) {
              const typeData = group.statementTypes[statementType];
              // Calculate average duration for this time group and statement type
              const avgDuration = typeData.durations.reduce((sum, d) => sum + d, 0) / typeData.durations.length;
              
              // Calculate circle size based on count (3-15 pixel radius)
              const sizeRatio = maxCount > minCount ? (typeData.count - minCount) / (maxCount - minCount) : 0.5;
              const circleSize = 3 + (sizeRatio * 12); // Range from 3 to 15 pixels
              
              data.push({
                x: group.timestamp,
                y: avgDuration,
                r: circleSize,
                count: typeData.count,
                maxDuration: Math.max(...typeData.durations),
                minDuration: Math.min(...typeData.durations)
              });
            }
          });

          return {
            label: `${statementType} (${data.reduce((sum, point) => sum + point.count, 0)} total)`,
            data: data,
            backgroundColor: colorMap[statementType] || `hsl(${Array.from(allStatementTypes).indexOf(statementType) * 137.5 % 360}, 70%, 50%)`,
            borderColor: colorMap[statementType] || `hsl(${Array.from(allStatementTypes).indexOf(statementType) * 137.5 % 360}, 70%, 40%)`,
            borderWidth: 1
          };
        });

        // Create bubble chart
        window.queryTypesChart = new Chart(ctx, {
          type: "bubble",
          data: {
            datasets: datasets
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: "Query Duration by Statement Type (Bubble Size = Query Count)",
              },
              legend: {
                display: true,
                position: "top",
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const dataPoint = context.raw;
                    const statementType = context.dataset.label.split(' (')[0];
                    return [
                      `${statementType}`,
                      `Count: ${dataPoint.count}`,
                      `Avg Duration: ${dataPoint.y.toFixed(3)}s`,
                      `Min Duration: ${dataPoint.minDuration.toFixed(3)}s`,
                      `Max Duration: ${dataPoint.maxDuration.toFixed(3)}s`
                    ];
                  }
                }
              },
              zoom: {
                limits: {
                  x: { min: "original", max: "original" },
                  y: { min: "original", max: "original" },
                },
                pan: {
                  enabled: true,
                  mode: "xy",
                  onPan: function ({ chart }) {
                    // Update current time range
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync pan with other charts
                    if (window.operationsChart && chart !== window.operationsChart) {
                    window.operationsChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                    window.filterChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.timelineChart && chart !== window.timelineChart) {
                    window.timelineChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                    window.queryTypesChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                      if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                      "x",
                      { min: chart.scales.x.min, max: chart.scales.x.max },
                      "none"
                      );
                      }
                      
                    },
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  drag: {
                    enabled: true,
                    backgroundColor: "rgba(225,225,225,0.3)",
                    borderColor: "rgba(225,225,225)",
                    borderWidth: 1,
                  },
                  mode: "xy",
                  onZoom: function ({ chart }) {
                    // Update current time range
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync zoom with other charts
                    if (window.operationsChart && chart !== window.operationsChart) {
                    window.operationsChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                    window.filterChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.timelineChart && chart !== window.timelineChart) {
                    window.timelineChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                    window.queryTypesChart.zoomScale(
                    "x",
                    { min: chart.scales.x.min, max: chart.scales.x.max },
                    "none"
                    );
                    }
                      if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                      "x",
                      { min: chart.scales.x.min, max: chart.scales.x.max },
                      "none"
                      );
                      }
                      
                    },
                },
              },
            },
            scales: {
              x: {
                type: "time",
                time: getCurrentTimeConfig(requests),
                title: {
                  display: true,
                  text: "Request Time",
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Average Duration (seconds)",
                },
                beginAtZero: true,
              },
            },
            interaction: {
              mode: "point",
              intersect: false,
            },
          },
        });
      }

      // Create Duration Buckets Chart
      function createDurationBucketsChart(requests, grouping) {
        const canvas = document.getElementById("duration-buckets-chart");
        if (!canvas) return;

        const ctx = canvas.getContext("2d");

        // Destroy existing chart if it exists
        if (window.durationBucketsChart) {
          window.durationBucketsChart.destroy();
        }

        // Group requests by time and duration buckets
        const timeGroups = {};
        
        console.log('Duration buckets chart - processing requests:', requests.length);
        
        requests.forEach((request) => {
          const requestDate = new Date(request.requestTime);
          const timeKey = roundTimestamp(requestDate, grouping, requests);
          const key = timeKey.toISOString();
          
          if (!timeGroups[key]) {
            timeGroups[key] = {
              timestamp: timeKey,
              durationBuckets: {
                '0-1s': 0,
                '1-2s': 0,
                '2-3s': 0,
                '3-4s': 0,
                '4-5s': 0,
                '5-10s': 0,
                '10-30s': 0,
                '30-60s': 0,
                '60-120s': 0,
                '120-240s': 0,
                '240-500s': 0,
                '500-900s': 0,
                '900s+': 0
              }
            };
          }

          // Get duration in seconds
          const durationMs = parseTime(request.elapsedTime);
          const durationSeconds = durationMs / 1000;

          // Categorize into duration buckets
          if (durationSeconds < 1) {
            timeGroups[key].durationBuckets['0-1s']++;
          } else if (durationSeconds < 2) {
            timeGroups[key].durationBuckets['1-2s']++;
          } else if (durationSeconds < 3) {
            timeGroups[key].durationBuckets['2-3s']++;
          } else if (durationSeconds < 4) {
            timeGroups[key].durationBuckets['3-4s']++;
          } else if (durationSeconds < 5) {
            timeGroups[key].durationBuckets['4-5s']++;
          } else if (durationSeconds < 10) {
            timeGroups[key].durationBuckets['5-10s']++;
          } else if (durationSeconds < 30) {
            timeGroups[key].durationBuckets['10-30s']++;
          } else if (durationSeconds < 60) {
            timeGroups[key].durationBuckets['30-60s']++;
          } else if (durationSeconds < 120) {
            timeGroups[key].durationBuckets['60-120s']++;
          } else if (durationSeconds < 240) {
            timeGroups[key].durationBuckets['120-240s']++;
          } else if (durationSeconds < 500) {
            timeGroups[key].durationBuckets['240-500s']++;
          } else if (durationSeconds < 900) {
            timeGroups[key].durationBuckets['500-900s']++;
          } else {
            timeGroups[key].durationBuckets['900s+']++;
          }
        });

        console.log('Duration buckets chart - timeGroups count:', Object.keys(timeGroups).length);
        if (Object.keys(timeGroups).length > 0) {
          console.log('First timeGroup sample:', Object.values(timeGroups)[0]);
        }

        // Calculate min/max counts for circle sizing
        let minCount = Infinity;
        let maxCount = 0;
        Object.values(timeGroups).forEach(group => {
          Object.values(group.durationBuckets).forEach(count => {
            if (count > 0) {
              minCount = Math.min(minCount, count);
              maxCount = Math.max(maxCount, count);
            }
          });
        });

        // Color mapping for duration buckets - progressive darkness
        const bucketColors = {
          '0-1s': '#28a745',     // Green - fast
          '1-2s': '#6cb2eb',     // Light blue
          '2-3s': '#ffc107',     // Yellow
          '3-4s': '#fd7e14',     // Orange
          '4-5s': '#dc3545',     // Red
          '5-10s': '#6f42c1',    // Purple
          '10-30s': '#495057',   // Dark gray
          '30-60s': '#343a40',   // Darker gray
          '60-120s': '#721c24',  // Dark red
          '120-240s': '#5a1a1a', // Darker red
          '240-500s': '#450a0a', // Very dark red
          '500-900s': '#2d0a0a', // Extremely dark red
          '900s+': '#1a0404'     // Nearly black red
        };

        // Generate datasets for each duration bucket
        const datasets = Object.keys(bucketColors).map(bucket => {
          const data = [];
          
          Object.values(timeGroups).forEach(group => {
            const count = group.durationBuckets[bucket];
            if (count > 0) {
              // Calculate circle size based on count (5-20 pixel radius)
              const sizeRatio = maxCount > minCount ? (count - minCount) / (maxCount - minCount) : 0.5;
              const circleSize = 5 + (sizeRatio * 15); // Range from 5 to 20 pixels
              
              // Use bucket midpoint for y-axis position
              let yPosition;
              switch(bucket) {
                case '0-1s': yPosition = 0.5; break;
                case '1-2s': yPosition = 1.5; break;
                case '2-3s': yPosition = 2.5; break;
                case '3-4s': yPosition = 3.5; break;
                case '4-5s': yPosition = 4.5; break;
                case '5-10s': yPosition = 7.5; break;
                case '10-30s': yPosition = 20; break;
                case '30-60s': yPosition = 45; break;
                case '60-120s': yPosition = 90; break;
                case '120-240s': yPosition = 180; break;
                case '240-500s': yPosition = 370; break;
                case '500-900s': yPosition = 700; break;
                case '900s+': yPosition = 1200; break;
              }
              
              data.push({
                x: group.timestamp,
                y: yPosition,
                r: circleSize,
                count: count
              });
            }
          });

          return {
            label: `${bucket} (${data.reduce((sum, point) => sum + point.count, 0)} total)`,
            data: data,
            backgroundColor: bucketColors[bucket],
            borderColor: bucketColors[bucket],
            borderWidth: 1
          };
        });

        // Create bubble chart
        window.durationBucketsChart = new Chart(ctx, {
          type: "bubble",
          data: {
            datasets: datasets
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: "Query Duration Distribution by Time Buckets (Bubble Size = Query Count)",
              },
              legend: {
                display: true,
                position: "top",
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const dataPoint = context.raw;
                    const bucket = context.dataset.label.split(' (')[0];
                    return [
                      `Duration: ${bucket}`,
                      `Count: ${dataPoint.count}`,
                      `Time: ${new Date(dataPoint.x).toLocaleString()}`
                    ];
                  }
                }
              },
              zoom: {
                limits: {
                  x: { min: "original", max: "original" },
                  y: { min: "original", max: "original" },
                },
                pan: {
                  enabled: true,
                  mode: "xy",
                  onPan: function ({ chart }) {
                    // Update current time range
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync pan with other charts
                    if (window.timelineChart && chart !== window.timelineChart) {
                      window.timelineChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.operationsChart && chart !== window.operationsChart) {
                      window.operationsChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                      window.filterChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                      window.queryTypesChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                  },
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  drag: {
                    enabled: true,
                    backgroundColor: "rgba(225,225,225,0.3)",
                    borderColor: "rgba(225,225,225)",
                    borderWidth: 1,
                  },
                  mode: "xy",
                  onZoom: function ({ chart }) {
                    // Update current time range
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync zoom with other charts
                    if (window.timelineChart && chart !== window.timelineChart) {
                      window.timelineChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.operationsChart && chart !== window.operationsChart) {
                      window.operationsChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                      window.filterChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                      window.queryTypesChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                  },
                },
              },
            },
            scales: {
              x: {
                type: "time",
                time: {
                  displayFormats: {
                    millisecond: "HH:mm:ss.SSS",
                    second: "HH:mm:ss",
                    minute: "HH:mm",
                    hour: "HH:mm",
                    day: "MM/dd",
                    week: "MM/dd",
                    month: "MM/yy",
                    quarter: "MM/yy",
                    year: "yyyy",
                  },
                },
                title: {
                  display: true,
                  text: "Request Time",
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Duration Range (seconds)",
                },
                beginAtZero: true,
                type: 'logarithmic',
                ticks: {
                  callback: function(value) {
                    if (value === 0.5) return '0-1s';
                    if (value === 1.5) return '1-2s';
                    if (value === 2.5) return '2-3s';
                    if (value === 3.5) return '3-4s';
                    if (value === 4.5) return '4-5s';
                    if (value === 7.5) return '5-10s';
                    if (value === 20) return '10-30s';
                    if (value === 45) return '30-60s';
                    if (value === 90) return '60-120s';
                    if (value === 180) return '120-240s';
                    if (value === 370) return '240-500s';
                    if (value === 700) return '500-900s';
                    if (value === 1200) return '900s+';
                    return '';
                  }
                }
              },
            },
            interaction: {
              mode: "point",
              intersect: false,
            },
          },
        });
      }

      // Create Memory Usage Chart
      function createMemoryChart(requests, grouping) {
        const canvas = document.getElementById("memory-chart");
        if (!canvas) return;

        const ctx = canvas.getContext("2d");

        // Destroy existing chart if it exists
        if (window.memoryChart) {
          window.memoryChart.destroy();
        }

        // Group requests by time and sum memory usage
        const timeGroups = {};
        
        requests.forEach((request) => {
          const requestDate = new Date(request.requestTime);
          const timeKey = roundTimestamp(requestDate, grouping, requests);
          const key = timeKey.toISOString();
          
          if (!timeGroups[key]) {
            timeGroups[key] = {
              timestamp: timeKey,
              totalMemoryBytes: 0,
              queryCount: 0
            };
          }

          // Use pre-calculated memory value
          const usedMemoryBytes = request.memoryBytes || 0;
          timeGroups[key].totalMemoryBytes += usedMemoryBytes;
          timeGroups[key].queryCount++;
        });

        // Convert to sorted array and convert bytes to MB
        const sortedData = Object.values(timeGroups)
          .sort((a, b) => a.timestamp - b.timestamp)
          .map(item => ({
            timestamp: item.timestamp,
            totalMemoryMB: item.totalMemoryBytes / (1024 * 1024), // Convert bytes to MB
            queryCount: item.queryCount
          }));

        // Prepare chart data
        const labels = sortedData.map((item) => item.timestamp);
        const memoryData = sortedData.map((item) => item.totalMemoryMB);

        // Create memory usage bar chart
        window.memoryChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Memory Usage (MB)",
                data: memoryData,
                backgroundColor: "#17a2b8", // Info blue-cyan
                borderColor: "#138496",
                borderWidth: 1,
              }
            ],
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: "Total Memory Usage by Time Period",
              },
              legend: {
                display: true,
                position: "top",
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const dataIndex = context.dataIndex;
                    const memoryMB = context.parsed.y;
                    const queryCount = sortedData[dataIndex].queryCount;
                    return [
                      `Memory Usage: ${memoryMB.toFixed(2)} MB`,
                      `Queries: ${queryCount}`,
                      `Avg per Query: ${(memoryMB / queryCount).toFixed(2)} MB`
                    ];
                  }
                }
              },
              zoom: {
                limits: {
                  x: { min: "original", max: "original" },
                  y: { min: "original", max: "original" },
                },
                pan: {
                  enabled: true,
                  mode: "xy",
                  onPan: function ({ chart }) {
                    // Update current time range
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync pan with other charts
                    if (window.operationsChart && chart !== window.operationsChart) {
                      window.operationsChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                      window.filterChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.timelineChart && chart !== window.timelineChart) {
                      window.timelineChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                      window.queryTypesChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    
                  },
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  drag: {
                    enabled: true,
                    backgroundColor: "rgba(225,225,225,0.3)",
                    borderColor: "rgba(225,225,225)",
                    borderWidth: 1,
                  },
                  mode: "xy",
                  onZoom: function ({ chart }) {
                    // Update current time range
                    currentTimeRange.min = new Date(chart.scales.x.min);
                    currentTimeRange.max = new Date(chart.scales.x.max);
                    updateTimeRangeDisplay();
                    
                    // Sync zoom with other charts
                    if (window.operationsChart && chart !== window.operationsChart) {
                      window.operationsChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.filterChart && chart !== window.filterChart) {
                      window.filterChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.timelineChart && chart !== window.timelineChart) {
                      window.timelineChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.queryTypesChart && chart !== window.queryTypesChart) {
                      window.queryTypesChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    if (window.memoryChart && chart !== window.memoryChart) {
                      window.memoryChart.zoomScale(
                        "x",
                        { min: chart.scales.x.min, max: chart.scales.x.max },
                        "none"
                      );
                    }
                    
                  },
                },
              },
            },
            scales: {
              x: {
                type: "time",
                time: getCurrentTimeConfig(requests),
                title: {
                  display: true,
                  text: "Request Time",
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Memory Usage (MB)",
                },
                beginAtZero: true,
              },
            },
            interaction: {
              mode: "index",
              intersect: false,
            },
          },
        });
      }

      // Reset timeline chart zoom
      function resetTimelineZoom() {
        if (window.timelineChart) {
          window.timelineChart.resetZoom();
        }
        if (window.operationsChart) {
          window.operationsChart.resetZoom();
        }
        if (window.filterChart) {
          window.filterChart.resetZoom();
        }
        if (window.queryTypesChart) {
          window.queryTypesChart.resetZoom();
        }
        if (window.durationBucketsChart) {
          window.durationBucketsChart.resetZoom();
        }
        if (window.memoryChart) {
          window.memoryChart.resetZoom();
        }

        // Reset to original time range
        currentTimeRange = { ...originalTimeRange };
        updateTimeRangeDisplay();
      }

      // Format date to datetime-local format
      function formatDateForInput(date) {
        if (!date) return '';
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      }

      // Update the time range display
      function updateTimeRangeDisplay() {
        // Function kept for compatibility but display removed
      }

      // Use current time range in the date pickers
      function useCurrentTimeRange() {
        // Get current x-axis range directly from the chart
        if (window.timelineChart && window.timelineChart.scales && window.timelineChart.scales.x) {
          const xScale = window.timelineChart.scales.x;
          const currentMin = new Date(xScale.min);
          const currentMax = new Date(xScale.max);
          
          const startValue = formatDateForInput(currentMin);
          const endValue = formatDateForInput(currentMax);
          
          document.getElementById('start-date').value = startValue;
          document.getElementById('end-date').value = endValue;
        }
      }

      // Change Y-axis scale for both charts
      function changeYAxisScale() {
        const selectedScale = document.querySelector(
          'input[name="yScale"]:checked'
        ).value;
        const scaleType =
          selectedScale === "logarithmic" ? "logarithmic" : "linear";

        // Update operations chart Y-axis scale
        if (window.operationsChart) {
          window.operationsChart.options.scales.y.type = scaleType;
          if (scaleType === "logarithmic") {
            window.operationsChart.options.scales.y.beginAtZero = false;
            window.operationsChart.options.scales.y.min = 1; // Avoid log(0)
          } else {
            window.operationsChart.options.scales.y.beginAtZero = true;
            delete window.operationsChart.options.scales.y.min;
          }
          window.operationsChart.update();
        }

        // Update filter chart Y-axis scale
        if (window.filterChart) {
          window.filterChart.options.scales.y.type = scaleType;
          if (scaleType === "logarithmic") {
            window.filterChart.options.scales.y.beginAtZero = false;
            window.filterChart.options.scales.y.min = 1; // Avoid log(0)
          } else {
            window.filterChart.options.scales.y.beginAtZero = true;
            delete window.filterChart.options.scales.y.min;
          }
          window.filterChart.update();
        }

        // Update timeline chart Y-axis scale
        if (window.timelineChart) {
          window.timelineChart.options.scales.y.type = scaleType;
          if (scaleType === "logarithmic") {
            window.timelineChart.options.scales.y.beginAtZero = false;
            window.timelineChart.options.scales.y.min = 1; // Avoid log(0)
          } else {
            window.timelineChart.options.scales.y.beginAtZero = true;
            delete window.timelineChart.options.scales.y.min;
          }
          window.timelineChart.update();
        }

        // Update query types chart Y-axis scale
        if (window.queryTypesChart) {
          window.queryTypesChart.options.scales.y.type = scaleType;
          if (scaleType === "logarithmic") {
            window.queryTypesChart.options.scales.y.beginAtZero = false;
            window.queryTypesChart.options.scales.y.min = 0.001; // Avoid log(0) for very small durations
          } else {
            window.queryTypesChart.options.scales.y.beginAtZero = true;
            delete window.queryTypesChart.options.scales.y.min;
          }
          window.queryTypesChart.update();
        }

        // Update memory chart Y-axis scale
        if (window.memoryChart) {
          window.memoryChart.options.scales.y.type = scaleType;
          if (scaleType === "logarithmic") {
            window.memoryChart.options.scales.y.beginAtZero = false;
            window.memoryChart.options.scales.y.min = 0.001; // Avoid log(0) for small memory values
          } else {
            window.memoryChart.options.scales.y.beginAtZero = true;
            delete window.memoryChart.options.scales.y.min;
          }
          window.memoryChart.update();
        }


      }

      // Change time grouping for all charts
      function changeTimeGrouping() {
        // Use the filtered data if available, otherwise fall back to parsing JSON
        let requests = [];
        if (originalRequests.length > 0) {
          // Apply current date filtering to original data
          const startDateInput = document.getElementById('start-date');
          const endDateInput = document.getElementById('end-date');
          const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
          const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
          requests = filterRequestsByDateRange(originalRequests, startDate, endDate);
        } else {
          // Fallback to parsing JSON if no original data
          const jsonInput = document.getElementById("json-input").value;
          if (!jsonInput.trim()) return;
          
          try {
            const data = JSON.parse(jsonInput);
            if (Array.isArray(data)) {
              requests = data.map((item) => ({
                ...item.completed_requests,
                plan: item.plan
                  ? typeof item.plan === "string"
                    ? JSON.parse(item.plan)
                    : item.plan
                  : null,
              }));
            }
          } catch (e) {
            console.error("Error parsing JSON for time grouping change:", e);
            return;
          }
        }

        // Validate date range for the selected grouping
        const grouping = getTimeGrouping();
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
        const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
        
        const validation = validateDateRangeForGrouping(startDate, endDate, grouping);
        if (!validation.valid) {
          alert(validation.message);
          return;
        }

        try {
          // Update the optimizer label to show current optimization
          updateOptimizerLabel(requests);

          // Regenerate all charts with new time grouping
          generateOperationsChart(requests);
          generateFilterChart(requests);
          generateTimelineChart(requests);
        } catch (e) {
          console.error("Error regenerating charts:", e);
          alert("Error generating charts. Try reducing the date range or selecting a coarser time grouping.");
        }
      }

      // Global variable to store original unfiltered data
      let originalRequests = [];
      let originalStartDate = null;
      let originalEndDate = null;
      
      // Store statements for safe access without HTML escaping issues
      let statementStore = {};
      let analysisStatementStore = {};

        // Parse Couchbase datetime to JavaScript Date
        function parseCouchbaseDateTime(dateTimeStr) {
            if (!dateTimeStr) return null;
            // Handle various Couchbase datetime formats
            const isoString = dateTimeStr.replace(' ', 'T');
            return new Date(isoString);
        }

        // Convert Date to datetime-local input format
        function toDateTimeLocal(date) {
            if (!date || isNaN(date.getTime())) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Filter requests by date range
        function filterRequestsByDateRange(requests, startDate, endDate) {
            if (!startDate && !endDate) return requests;
            
            return requests.filter(request => {
                const requestDate = parseCouchbaseDateTime(request.requestTime);
                if (!requestDate) return true; // Include requests with invalid dates
                
                if (startDate && requestDate < startDate) return false;
                if (endDate && requestDate > endDate) return false;
                return true;
            });
        }

        // Update filter info display
        function updateFilterInfo(originalCount, filteredCount) {
            const filterInfo = document.getElementById('filter-info');
            if (originalCount === filteredCount) {
                filterInfo.textContent = `Showing all ${originalCount} queries`;
            } else {
                filterInfo.textContent = `Showing ${filteredCount} of ${originalCount} queries`;
            }
        }

        // Generate Dashboard Charts
        function generateDashboardCharts(requests) {
          generatePrimaryScanChart(requests);
          generateStateChart(requests);
          generateStatementTypeChart(requests);
          generateElapsedTimeChart(requests);
          generateQueryPatternChart(requests);
          generateUserCountTable(requests);
          generateIndexCountTable(requests);
        }

        // Check if a query uses primary index by analyzing the plan
        function usesPrimaryIndex(request) {
          if (!request.plan) return false;
          
          try {
            const planObj = typeof request.plan === 'string' ? JSON.parse(request.plan) : request.plan;
            return checkOperatorForPrimary(planObj);
          } catch (e) {
            return false;
          }
        }

        // Recursively check operators for primary index usage
        function checkOperatorForPrimary(operator) {
          if (!operator) return false;
          
          // Check for primary index indicators
          if (operator['#operator'] === 'PrimaryScan' || 
              operator['#operator'] === 'PrimaryScan3' ||
              operator.index === '#primary' ||
              operator.using === 'sequentialScan' ||
              (operator.spans && operator.spans.length === 0)) {
            return true;
          }
          
          // Recursively check child operators
          if (operator['~child'] && checkOperatorForPrimary(operator['~child'])) return true;
          if (operator['~children'] && Array.isArray(operator['~children'])) {
            for (const child of operator['~children']) {
              if (checkOperatorForPrimary(child)) return true;
            }
          }
          if (operator.input && checkOperatorForPrimary(operator.input)) return true;
          if (operator.inputs && Array.isArray(operator.inputs)) {
            for (const input of operator.inputs) {
              if (checkOperatorForPrimary(input)) return true;
            }
          }
          if (operator.left && checkOperatorForPrimary(operator.left)) return true;
          if (operator.right && checkOperatorForPrimary(operator.right)) return true;
          
          return false;
        }

        // Primary Scan Used Pie Chart
        function generatePrimaryScanChart(requests) {
          const scanCounts = { 'Yes': 0, 'No': 0 };
          
          requests.forEach(request => {
            const primaryScan = request.usesPrimary ? 'Yes' : 'No';
            scanCounts[primaryScan]++;
          });

          const total = scanCounts.Yes + scanCounts.No;
          const yesPercent = total > 0 ? ((scanCounts.Yes / total) * 100).toFixed(1) : 0;
          const noPercent = total > 0 ? ((scanCounts.No / total) * 100).toFixed(1) : 0;

          const ctx = document.getElementById('primary-scan-chart').getContext('2d');
          if (window.primaryScanChart) {
            window.primaryScanChart.destroy();
          }
          
          window.primaryScanChart = new Chart(ctx, {
            type: 'pie',
            data: {
              labels: ['Yes', 'No'],
              datasets: [{
                data: [scanCounts.Yes, scanCounts.No],
                backgroundColor: ['#ff6384', '#36a2eb'],
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'bottom'
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const percent = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : 0;
                      return context.label + ': ' + context.parsed + ' (' + percent + '%)';
                    }
                  }
                },
                datalabels: {
                  display: true,
                  color: 'white',
                  font: {
                    weight: 'bold',
                    size: 14
                  },
                  formatter: function(value, context) {
                    const percent = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                    return percent + '%';
                  }
                }
              }
            },
            plugins: [{
              beforeDraw: function(chart) {
                const ctx = chart.ctx;
                ctx.save();
                chart.data.datasets[0].data.forEach((value, index) => {
                  const meta = chart.getDatasetMeta(0);
                  const arc = meta.data[index];
                  const percent = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                  
                  if (value > 0) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(percent + '%', arc.x, arc.y);
                  }
                });
                ctx.restore();
              }
            }]
          });
        }

        // Query State Pie Chart
        function generateStateChart(requests) {
          const stateCounts = {};
          
          requests.forEach(request => {
            const state = request.state || 'Unknown';
            stateCounts[state] = (stateCounts[state] || 0) + 1;
          });

          const total = Object.values(stateCounts).reduce((sum, count) => sum + count, 0);
          const labels = Object.keys(stateCounts);
          const data = Object.values(stateCounts);
          const colors = ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#ff9f40'];

          const ctx = document.getElementById('state-chart').getContext('2d');
          if (window.stateChart) {
            window.stateChart.destroy();
          }
          
          window.stateChart = new Chart(ctx, {
            type: 'pie',
            data: {
              labels: labels,
              datasets: [{
                data: data,
                backgroundColor: colors.slice(0, labels.length),
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'bottom'
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const percent = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : 0;
                      return context.label + ': ' + context.parsed + ' (' + percent + '%)';
                    }
                  }
                }
              }
            },
            plugins: [{
              beforeDraw: function(chart) {
                const ctx = chart.ctx;
                ctx.save();
                chart.data.datasets[0].data.forEach((value, index) => {
                  const meta = chart.getDatasetMeta(0);
                  const arc = meta.data[index];
                  const percent = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                  
                  if (value > 0 && percent >= 5) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(percent + '%', arc.x, arc.y);
                  }
                });
                ctx.restore();
              }
            }]
          });
        }

        // Statement Type Pie Chart
        function generateStatementTypeChart(requests) {
          const typeCounts = {};
          
          requests.forEach(request => {
            const type = request.statementType || 'Unknown';
            typeCounts[type] = (typeCounts[type] || 0) + 1;
          });

          const total = Object.values(typeCounts).reduce((sum, count) => sum + count, 0);
          const labels = Object.keys(typeCounts);
          const data = Object.values(typeCounts);
          const colors = ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#ff9f40', '#c9cbcf', '#4bc0c0'];

          const ctx = document.getElementById('statement-type-chart').getContext('2d');
          if (window.statementTypeChart) {
            window.statementTypeChart.destroy();
          }
          
          window.statementTypeChart = new Chart(ctx, {
            type: 'pie',
            data: {
              labels: labels,
              datasets: [{
                data: data,
                backgroundColor: colors.slice(0, labels.length),
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'bottom',
                  labels: {
                    generateLabels: function(chart) {
                      const data = chart.data;
                      return data.labels.map((label, index) => ({
                        text: label,
                        fillStyle: data.datasets[0].backgroundColor[index],
                        strokeStyle: data.datasets[0].backgroundColor[index],
                        lineWidth: 1,
                        hidden: false,
                        index: index
                      }));
                    }
                  }
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const percent = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : 0;
                      return context.label + ': ' + context.parsed + ' (' + percent + '%)';
                    }
                  }
                }
              }
            },
            plugins: [{
              beforeDraw: function(chart) {
                const ctx = chart.ctx;
                ctx.save();
                chart.data.datasets[0].data.forEach((value, index) => {
                  const meta = chart.getDatasetMeta(0);
                  const arc = meta.data[index];
                  const percent = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                  
                  if (value > 0 && percent >= 5) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(percent + '%', arc.x, arc.y);
                  }
                });
                ctx.restore();
              }
            }]
          });
        }

        // Elapsed Time Distribution Bar Chart
        function generateElapsedTimeChart(requests) {
          const timeBuckets = {
            '0-1s': 0,
            '1-2s': 0,
            '2-5s': 0,
            '5-10s': 0,
            '10-20s': 0,
            '20-40s': 0,
            '40-60s': 0,
            '60-90s': 0,
            '90s-5m': 0,
            '5-15m': 0,
            '15-30m': 0,
            '30-60m': 0,
            '>60m': 0
          };

          requests.forEach(request => {
            const elapsed = (request.elapsedTimeMs || 0) / 1000; // Convert ms to seconds
            
            if (elapsed <= 1) timeBuckets['0-1s']++;
            else if (elapsed <= 2) timeBuckets['1-2s']++;
            else if (elapsed <= 5) timeBuckets['2-5s']++;
            else if (elapsed <= 10) timeBuckets['5-10s']++;
            else if (elapsed <= 20) timeBuckets['10-20s']++;
            else if (elapsed <= 40) timeBuckets['20-40s']++;
            else if (elapsed <= 60) timeBuckets['40-60s']++;
            else if (elapsed <= 90) timeBuckets['60-90s']++;
            else if (elapsed <= 300) timeBuckets['90s-5m']++;
            else if (elapsed <= 900) timeBuckets['5-15m']++;
            else if (elapsed <= 1800) timeBuckets['15-30m']++;
            else if (elapsed <= 3600) timeBuckets['30-60m']++;
            else timeBuckets['>60m']++;
          });

          const ctx = document.getElementById('elapsed-time-chart').getContext('2d');
          if (window.elapsedTimeChart) {
            window.elapsedTimeChart.destroy();
          }
          
          window.elapsedTimeChart = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: Object.keys(timeBuckets),
              datasets: [{
                label: 'Query Count',
                data: Object.values(timeBuckets),
                backgroundColor: '#36a2eb',
                borderColor: '#36a2eb',
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      return 'Queries: ' + context.parsed.y;
                    }
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Number of Queries'
                  }
                },
                x: {
                  title: {
                    display: true,
                    text: 'Elapsed Time Range'
                  }
                }
              }
            }
          });
        }

        // Generate Query Pattern Chart
        function generateQueryPatternChart(requests) {
          const patternCounts = {
            'No WHERE': 0,
            'GROUP BY': 0,
            'ORDER BY': 0,
            'USE INDEX': 0,
            'USE KEYS': 0,
            'JOIN': 0,
            'NEST': 0,
            'UNNEST': 0,
            'OFFSET': 0,
            'SEARCH': 0,
            'WITH': 0,
            'ARRAY QUERY': 0,
            'SELECT *': 0,
            'LIKE': 0
          };

          requests.forEach(request => {
            const statement = (request.statement || '').toUpperCase();
            
            // No WHERE
            if (!statement.includes(' WHERE ')) {
              patternCounts['No WHERE']++;
            }
            
            // GROUP BY
            if (statement.includes(' GROUP BY ')) {
              patternCounts['GROUP BY']++;
            }
            
            // ORDER BY
            if (statement.includes(' ORDER BY ')) {
              patternCounts['ORDER BY']++;
            }
            
            // USE INDEX
            if (statement.includes('USE INDEX(')) {
              patternCounts['USE INDEX']++;
            }
            
            // USE KEYS
            if (statement.includes('USE KEYS')) {
              patternCounts['USE KEYS']++;
            }
            
            // JOIN
            if (statement.includes(' JOIN ')) {
              patternCounts['JOIN']++;
            }
            
            // NEST
            if (statement.includes(' NEST ')) {
              patternCounts['NEST']++;
            }
            
            // UNNEST
            if (statement.includes(' UNNEST ')) {
              patternCounts['UNNEST']++;
            }
            
            // OFFSET
            if (statement.includes(' OFFSET ')) {
              patternCounts['OFFSET']++;
            }
            
            // SEARCH
            if (statement.includes(' SEARCH(')) {
              patternCounts['SEARCH']++;
            }
            
            // WITH
            if (statement.includes('WITH ')) {
              patternCounts['WITH']++;
            }
            
            // ARRAY QUERY (has both SATISFIES and END)
            if (statement.includes(' SATISFIES ') && statement.includes(' END ')) {
              patternCounts['ARRAY QUERY']++;
            }
            
            // SELECT * (between SELECT and FROM)
            const selectMatch = statement.match(/SELECT\s+(.+?)\s+FROM/);
            if (selectMatch) {
              const selectPart = selectMatch[1].trim();
              if (selectPart === '*' || selectPart.includes('.*')) {
                patternCounts['SELECT *']++;
              }
            }
            
            // LIKE
            if (statement.includes(' LIKE ')) {
              patternCounts['LIKE']++;
            }
            
            // COUNT
            if (statement.includes(' COUNT')) {
              patternCounts['COUNT']++;
            }
            
            // REGEX
            if (statement.includes(' REGEXP_')) {
              patternCounts['REGEX']++;
            }
          });

          const ctx = document.getElementById('query-pattern-chart').getContext('2d');
          if (window.queryPatternChart) {
            window.queryPatternChart.destroy();
          }
          
          // Generate colors based on pattern names
          const colors = Object.keys(patternCounts).map(pattern => {
            if (pattern === 'SELECT *') {
              return '#dc3545'; // Red
            } else if (pattern === 'LIKE' || pattern === 'No WHERE' || pattern === 'REGEX') {
              return '#fd7e14'; // Orange
            } else {
              return '#28a745'; // Green
            }
          });

          window.queryPatternChart = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: Object.keys(patternCounts),
              datasets: [{
                label: 'Query Count',
                data: Object.values(patternCounts),
                backgroundColor: colors,
                borderColor: colors,
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      return 'Queries: ' + context.parsed.y;
                    }
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Number of Queries'
                  }
                },
                x: {
                  title: {
                    display: true,
                    text: 'Query Pattern Features'
                  },
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45
                  }
                }
              }
            }
          });
        }

        // Generate User Count Table
        function generateUserCountTable(requests) {
          const userCounts = {};
          
          requests.forEach(request => {
            const user = request.users || 'Unknown';
            userCounts[user] = (userCounts[user] || 0) + 1;
          });

          const sortedUsers = Object.entries(userCounts)
            .sort(([,a], [,b]) => b - a);

          const tbody = document.getElementById('user-count-body');
          tbody.innerHTML = '';

          sortedUsers.forEach(([user, count]) => {
            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid #eee';
            row.innerHTML = `
              <td style="padding: 8px; text-align: right; font-weight: bold;">${count}</td>
              <td style="padding: 8px; word-break: break-word;">
                ${user}
                <button onclick="copyToClipboard('${user.replace(/'/g, "\\'")}', this)" 
                        style="margin-left: 8px; padding: 2px 8px; font-size: 12px; background: #6c757d; color: white; border: none; border-radius: 2px; cursor: pointer;">
                  copy
                </button>
              </td>
            `;
            tbody.appendChild(row);
          });
        }

        // Generate Index Count Table
        function generateIndexCountTable(requests) {
          const indexCounts = {};
          
          requests.forEach(request => {
            if (request.plan) {
              try {
                // Parse the plan JSON string
                const planObj = typeof request.plan === 'string' ? JSON.parse(request.plan) : request.plan;
                
                if (planObj && planObj['#operator']) {
                  extractIndexNames(planObj, indexCounts);
                }
              } catch (e) {
                console.error('Error parsing plan JSON:', e, request.plan);
              }
            }
          });

          const sortedIndexes = Object.entries(indexCounts)
            .sort(([,a], [,b]) => b - a);

          const tbody = document.getElementById('index-count-body');
          tbody.innerHTML = '';

          sortedIndexes.forEach(([indexName, count]) => {
            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid #eee';
            row.innerHTML = `
              <td style="padding: 8px; text-align: right; font-weight: bold;">${count}</td>
              <td style="padding: 8px; word-break: break-word;">
                ${indexName}
                <button onclick="copyToClipboard('${indexName.replace(/'/g, "\\'")}', this)" 
                        style="margin-left: 8px; padding: 2px 8px; font-size: 12px; background: #6c757d; color: white; border: none; border-radius: 2px; cursor: pointer;">
                  copy
                </button>
              </td>
            `;
            tbody.appendChild(row);
          });
        }

        // Recursively extract index names from plan operators
        function extractIndexNames(operator, indexCounts) {
          if (!operator) return;
          
          // Check for index name in various operator properties
          if (operator.index) {
            indexCounts[operator.index] = (indexCounts[operator.index] || 0) + 1;
          }
          if (operator.indexName) {
            indexCounts[operator.indexName] = (indexCounts[operator.indexName] || 0) + 1;
          }
          
          // Check for primary scan operators
          if (operator['#operator'] === 'PrimaryScan' || 
              operator['#operator'] === 'PrimaryScan3' ||
              operator.index === '#primary' ||
              operator.using === 'sequentialScan') {
            indexCounts['#primary'] = (indexCounts['#primary'] || 0) + 1;
          }
          
          // Recursively check child operators
          if (operator['~child']) {
            extractIndexNames(operator['~child'], indexCounts);
          }
          if (operator['~children'] && Array.isArray(operator['~children'])) {
            operator['~children'].forEach(child => extractIndexNames(child, indexCounts));
          }
          if (operator.input) {
            extractIndexNames(operator.input, indexCounts);
          }
          if (operator.inputs && Array.isArray(operator.inputs)) {
            operator.inputs.forEach(input => extractIndexNames(input, indexCounts));
          }
          if (operator.left) {
            extractIndexNames(operator.left, indexCounts);
          }
          if (operator.right) {
            extractIndexNames(operator.right, indexCounts);
          }
        }

        // Copy to clipboard function
        function copyToClipboard(text, button) {
          navigator.clipboard.writeText(text).then(() => {
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.style.background = '#28a745';
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '#007bff';
            }, 1000);
          }).catch(err => {
            console.error('Failed to copy text: ', err);
            button.textContent = 'Error';
            button.style.background = '#dc3545';
            setTimeout(() => {
              button.textContent = 'Copy';
              button.style.background = '#007bff';
            }, 1000);
          });
        }

        // Validate date range for time grouping
        function validateDateRangeForGrouping(startDate, endDate, grouping) {
            if (!startDate || !endDate || grouping === 'optimizer') return { valid: true };
            
            const diffMs = endDate.getTime() - startDate.getTime();
            const diffHours = diffMs / (1000 * 60 * 60);
            const diffDays = diffMs / (1000 * 60 * 60 * 24);
            
            switch (grouping) {
                case 'second':
                    if (diffHours > 1) {
                        return {
                            valid: false,
                            message: 'For "by Second" grouping, please restrict the date range to 1 hour or less to avoid chart rendering issues.'
                        };
                    }
                    break;
                case 'minute':
                    if (diffDays > 1) {
                        return {
                            valid: false,
                            message: 'For "by Minute" grouping, please restrict the date range to 1 day or less to avoid chart rendering issues.'
                        };
                    }
                    break;
                case 'hour':
                    if (diffDays > 31) {
                        return {
                            valid: false,
                            message: 'For "by Hour" grouping, please restrict the date range to 1 month or less for optimal performance.'
                        };
                    }
                    break;
            }
            
            return { valid: true };
        }

        // Optimized request data processor
        function processRequestData(item) {
          const request = item.completed_requests || item;
          
          // Parse and cache plan data immediately
          const plan = item.plan ? 
            (typeof item.plan === "string" ? JSON.parse(item.plan) : item.plan) : 
            null;
          
          // Pre-calculate commonly used values
          const processedRequest = {
            ...request,
            plan: plan,
            // Pre-calculate time values
            elapsedTimeMs: parseTime(request.elapsedTime),
            kernTimeMs: plan ? calculateTotalKernTime(plan) : 0,
            memoryBytes: plan ? calculateTotalMemoryUsage(plan) : 0,
            // Pre-calculate boolean flags
            usesPrimary: plan ? usesPrimaryIndex({plan: plan}) : false,
            // Pre-extract index information
            indexInfo: plan ? extractIndexInfo(plan) : null,
            // Pre-calculate aggregations
            planStats: plan ? extractPlanStats(plan) : null
          };
          
          return processedRequest;
        }

        // Fast index information extraction
        function extractIndexInfo(plan) {
          const operators = getOperators(plan);
          const indexes = [];
          const stats = { primaryScan: 0, indexScan: 0, fetch: 0 };
          
          operators.forEach(operator => {
            const operatorType = operator["#operator"];
            const operatorStats = operator["#stats"] || {};
            
            // Extract index names
            if (operator.index) {
              indexes.push(operator.index);
            }
            
            // Aggregate stats
            if (operatorType === "PrimaryScan" || operatorType === "PrimaryScan3") {
              stats.primaryScan += operatorStats["#itemsOut"] || 0;
            } else if (operatorType === "IndexScan" || operatorType === "IndexScan3") {
              stats.indexScan += operatorStats["#itemsOut"] || 0;
            } else if (operatorType === "Fetch") {
              stats.fetch += operatorStats["#itemsOut"] || 0;
            }
          });
          
          return { indexes, stats };
        }

        // Fast plan stats extraction
        function extractPlanStats(plan) {
          const operators = getOperators(plan);
          let totalItemsIn = 0;
          let totalItemsOut = 0;
          
          operators.forEach(operator => {
            const stats = operator["#stats"] || {};
            totalItemsIn += stats["#itemsIn"] || 0;
            totalItemsOut += stats["#itemsOut"] || 0;
          });
          
          return { totalItemsIn, totalItemsOut };
        }

        // Parse JSON input - Optimized
        function parseJSON() {
          const jsonInput = document.getElementById("json-input").value;
          const startDateInput = document.getElementById('start-date');
          const endDateInput = document.getElementById('end-date');
          
          try {
            const data = JSON.parse(jsonInput);
            if (Array.isArray(data)) {
              // Process data in batches to avoid blocking UI
              const batchSize = 1000;
              const processedRequests = [];
              
              console.log(`Processing ${data.length} requests in batches of ${batchSize}...`);
              
              function processBatch(startIndex) {
                const endIndex = Math.min(startIndex + batchSize, data.length);
                
                for (let i = startIndex; i < endIndex; i++) {
                  try {
                    processedRequests.push(processRequestData(data[i]));
                  } catch (e) {
                    console.warn(`Error processing request ${i}:`, e);
                  }
                }
                
                // Update progress
                const progress = Math.round((endIndex / data.length) * 100);
                document.getElementById("json-input").placeholder = `Processing... ${progress}%`;
                
                if (endIndex < data.length) {
                  // Process next batch asynchronously
                  setTimeout(() => processBatch(endIndex), 10);
                } else {
                  // All batches processed
                  finishProcessing(processedRequests);
                }
              }
              
              // Start processing
              processBatch(0);
              
            } else {
              alert("Please provide a valid JSON array.");
            }
          } catch (e) {
            alert("Invalid JSON: " + e.message);
          }
        }

        // Finish processing after all batches are done
        function finishProcessing(allRequests) {
          const startDateInput = document.getElementById('start-date');
          const endDateInput = document.getElementById('end-date');
          
          // Reset placeholder
          document.getElementById("json-input").placeholder = "Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests;";
          
          // If this is the first parse (no date filters set), populate date range
          if (!startDateInput.value && !endDateInput.value && allRequests.length > 0) {
            originalRequests = allRequests;
            const dates = allRequests
              .map(r => parseCouchbaseDateTime(r.requestTime))
              .filter(d => d && !isNaN(d.getTime()))
              .sort((a, b) => a - b);
            
            if (dates.length > 0) {
              const minDate = dates[0];
              const maxDate = dates[dates.length - 1];
              originalStartDate = minDate;
              originalEndDate = maxDate;
              startDateInput.value = toDateTimeLocal(minDate);
              endDateInput.value = toDateTimeLocal(maxDate);
            }
          } else {
            // Use existing originalRequests if available, otherwise use current data
            if (originalRequests.length === 0) {
              originalRequests = allRequests;
            }
          }

          // Apply date filtering
          const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
          const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
          const filteredRequests = filterRequestsByDateRange(originalRequests, startDate, endDate);

          // Validate date range for current time grouping
          const grouping = getTimeGrouping();
          const validation = validateDateRangeForGrouping(startDate, endDate, grouping);
          if (!validation.valid) {
            alert(validation.message);
            // Still continue with table generation, just skip charts
            updateFilterInfo(originalRequests.length, filteredRequests.length);
            generateTable(filteredRequests);
            generateAnalysisTable(filteredRequests);
            document.getElementById("flow-diagram").innerHTML =
              "Select a query from the table to view the flow diagram.";
            return;
          }

          // Update UI with filtered data
          updateFilterInfo(originalRequests.length, filteredRequests.length);
          try {
            generateTable(filteredRequests);
            generateAnalysisTable(filteredRequests);
            updateOptimizerLabel(filteredRequests);
            generateOperationsChart(filteredRequests);
            generateFilterChart(filteredRequests);
            generateTimelineChart(filteredRequests);
            generateDashboardCharts(filteredRequests);
          } catch (e) {
            console.error("Error generating charts:", e);
            alert("Error generating charts. Try reducing the date range or selecting a coarser time grouping.");
          }
          document.getElementById("flow-diagram").innerHTML =
            "Select a query from the table to view the flow diagram.";
        }

      // Modal event listeners
      const planModal = document.getElementById("plan-modal");
      const planCloseBtn = planModal.querySelector(".close");
      planCloseBtn.addEventListener("click", () => {
        planModal.style.display = "none";
      });
      planModal.addEventListener("click", (event) => {
        if (event.target === planModal) {
          planModal.style.display = "none";
        }
      });

      const operatorModal = document.getElementById("operator-modal");
      const operatorCloseBtn = operatorModal.querySelector(".close");
      operatorCloseBtn.addEventListener("click", () => {
        operatorModal.style.display = "none";
      });
      operatorModal.addEventListener("click", (event) => {
        if (event.target === operatorModal) {
          operatorModal.style.display = "none";
        }
      });

      // Function to set time range based on button selection
      function setTimeRange(type) {
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        
        if (type === 'original') {
          if (originalStartDate && originalEndDate) {
            startDateInput.value = toDateTimeLocal(originalStartDate);
            endDateInput.value = toDateTimeLocal(originalEndDate);
          }
        } else if (type === '1day' || type === '1hour') {
          const endDate = endDateInput.value ? new Date(endDateInput.value) : new Date();
          const startDate = new Date(endDate);
          
          if (type === '1day') {
            startDate.setDate(startDate.getDate() - 1);
          } else if (type === '1hour') {
            startDate.setHours(startDate.getHours() - 1);
          }
          
          startDateInput.value = toDateTimeLocal(startDate);
        }
        
        // Trigger filtering with new date range
        if (originalRequests.length > 0) {
          const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
          const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
          const filteredRequests = filterRequestsByDateRange(originalRequests, startDate, endDate);
          
          updateFilterInfo(originalRequests.length, filteredRequests.length);
          generateTable(filteredRequests);
          generateTimeline(filteredRequests);
          generateAnalysis(filteredRequests);
        }
      }

      // Initialize jQuery UI Tabs
      $(function () {
        $("#tabs").tabs();
      });
    </script>
  </body>
</html>
