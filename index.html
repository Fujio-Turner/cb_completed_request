<!DOCTYPE html>
<html lang="en">
<!--
    Couchbase Query Analyzer
    Version: 2.1.0
    Last Updated: 2025-01-19
    
    🤖 AI AGENT NOTE: When making changes to this file, please update the version number above.
    Use semantic versioning: MAJOR.MINOR.PATCH
    - MAJOR: Breaking changes or complete rewrites
    - MINOR: New features, significant enhancements  
    - PATCH: Bug fixes, small improvements
-->

<head>
    <meta charset="UTF-8" />
    <meta name="version" content="2.1.0" />
    <meta name="last-updated" content="2025-01-19" />
    <title>Query Analyzer v2.1.0</title>
    <!-- Include jQuery UI CSS -->
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.0/themes/base/jquery-ui.css" />
    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <!-- Include Chart.js datetime adapter -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Include Chart.js zoom plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <!-- Include Hammer.js for touch/gesture support -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <!-- Include DOMPurify for security -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        #input-section {
            margin-bottom: 20px;
        }

        textarea {
            width: 100%;
            height: 50px;
            margin-bottom: 10px;
        }

        #tabs {
            flex: 1;
            overflow: auto;
        }

        #every-query,
        #analysis {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #flow-diagram-section,
        #charts-placeholder {
            flex: 0 0 250px;
            /* Fixed height for charts and flow diagram */
            overflow: auto;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #fff;
        }

        #flow-diagram {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .step-bubble {
            border: 1px solid #000;
            border-radius: 10px;
            padding: 10px;
            /*min-width: 110px;*/
            text-align: center;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .step-bubble p {
            margin: 5px 0;
            line-height: 1;
            /* Default is around 1.4–1.6, so this tightens the text */
        }

        .green {
            background-color: #d4edda;
        }

        .yellow {
            background-color: #fff3cd;
        }

        .orange {
            background-color: #ffe5d0;
        }

        .red {
            background-color: #f8d7da;
        }

        .connector {
            width: 20px;
            height: 2px;
            background-color: #000;
        }

        /* Index/Query Flow Tab Styles */
        .index-item,
        .query-item {
            border: 2px solid #007bff;
            border-radius: 12px;
            padding: 12px;
            margin: 10px 0;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: move;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .index-item:hover,
        .query-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .index-item.primary {
            background-color: #ffebee;
            border-color: #f44336;
        }

        .index-stats {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
            line-height: 1.3;
        }

        .query-text {
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            max-height: 60px;
            overflow: hidden;
            position: relative;
        }

        .query-text.expanded {
            max-height: none;
        }

        .query-controls {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .query-controls button {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .query-controls button:hover {
            background: #f0f0f0;
        }

        .usage-count {
            background: white;
            border: 1px solid #333;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            border-radius: 3px;
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        #table-section,
        #analysis-table-section {
            flex: 1;
            overflow-y: auto;
        }

        #table-container,
        #analysis-table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #fff;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        th {
            background-color: #f2f2f2;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background-color: #e8e8e8;
        }

        .sort-arrow {
            margin-left: 5px;
            font-size: 12px;
            color: #666;
        }

        tr:hover {
            background-color: #f1f1f1;
            cursor: pointer;
        }

        .primary-scan-yes {
            font-weight: bold;
            color: red;
        }

        .fatal-state {
            font-weight: bold;
            color: red;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        #plan-modal-body ul {
            list-style-type: none;
            padding-left: 20px;
        }

        #plan-modal-body li {
            margin-bottom: 5px;
        }

        #operator-modal-body dl {
            margin: 0;
        }

        #operator-modal-body dt {
            font-weight: bold;
        }

        #operator-modal-body dd {
            margin-left: 20px;
        }

        #operator-modal-body,
        #plan-modal-body {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        #operator-modal-body *,
        #plan-modal-body * {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .copy-button {
            background-color: #4caf50;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
            font-size: 12px;
        }

        .copy-button:hover {
            background-color: #45a049;
        }

        /* Dark mode styles */
        :root {
            --bg-color: #f5f5f5;
            --text-color: #333;
            --border-color: #ccc;
            --input-bg: #fff;
            --modal-bg: #fff;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --border-color: #555;
            --input-bg: #2d2d2d;
            --modal-bg: #2d2d2d;
            --button-bg: #0d7377;
            --button-hover-bg: #14a085;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        textarea,
        #flow-diagram-section,
        #charts-placeholder,
        .modal-content {
            background-color: var(--input-bg);
            color: var(--text-color);
            border-color: var(--border-color);
        }

        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 20px;
            z-index: 1000;
            transition: background-color 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--button-hover-bg);
        }

        .theme-toggle:focus {
            outline: 2px solid #ff6b35;
            outline-offset: 2px;
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.3s ease;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.error {
            background: #dc3545;
        }

        /* Version display */
        .version-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-family: monospace;
            z-index: 999;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .version-info:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.2);
        }
    </style>
    <!-- Include Panzoom, jQuery, and jQuery UI -->
    <script src="https://cdn.jsdelivr.net/npm/panzoom@9.4.2/dist/panzoom.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://code.jquery.com/ui/1.14.0/jquery-ui.min.js"></script>
</head>

<body>
    <!-- Dark mode toggle -->
    <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode" title="Toggle dark/light theme">
        🌙
    </button>

    <!-- Version info -->
    <div class="version-info" title="Couchbase Query Analyzer Version">
        v2.1.0
    </div>

    <!-- Input Section (outside tabs) -->
    <div id="input-section">
        <textarea id="json-input"
            placeholder="Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests;"
            aria-label="JSON input field for Couchbase query data" role="textbox"></textarea>
        <div style="
          margin: 10px 0;
          display: flex;
          align-items: center;
          gap: 10px;
          flex-wrap: wrap;
        ">
            <button onclick="parseJSON()" aria-label="Parse and analyze JSON data" tabindex="0" role="button">Parse
                JSON</button>
            <label style="display: flex; align-items: center; gap: 5px; margin-left: 15px;">
                <input type="checkbox" id="exclude-system-queries" checked
                    title="Excludes INFER, ADVISE, CREATE, ALTER INDEX statements and queries from system: keyspaces"
                    aria-label="Exclude system queries from analysis">
                <span style="font-size: 0.9em; user-select: none; cursor: pointer;"
                    title="Excludes INFER, ADVISE, CREATE, ALTER INDEX statements and queries from system: keyspaces">
                    Exclude System Queries
                </span>
            </label>
            <div id="progress-container" style="display: none; margin-top: 10px">
                <div style="
              background-color: #f0f0f0;
              border-radius: 5px;
              height: 20px;
              position: relative;
            ">
                    <div id="progress-bar" style="
                background-color: #4caf50;
                height: 100%;
                border-radius: 5px;
                width: 0%;
                transition: width 0.3s ease;
              "></div>
                    <span id="progress-text" style="
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                font-size: 12px;
                font-weight: bold;
              ">0%</span>
                </div>
            </div>
            <label for="start-date">From:</label>
            <input type="datetime-local" id="start-date" step="1" title="Start date/time for filtering" />
            <label for="end-date">To:</label>
            <input type="datetime-local" id="end-date" step="1" title="End date/time for filtering" />
            <div style="display: flex; gap: 5px; align-items: center">
                <button onclick="setTimeRange('original')" style="padding: 4px 8px; font-size: 0.8em">
                    Original
                </button>
                <button onclick="setTimeRange('1day')" style="padding: 4px 8px; font-size: 0.8em">
                    1 Day
                </button>
                <button onclick="setTimeRange('1hour')" style="padding: 4px 8px; font-size: 0.8em">
                    1 Hour
                </button>
            </div>
            <span id="filter-info" style="color: #666; font-size: 0.9em"></span>
        </div>
    </div>

    <!-- Tabs Container -->
    <div id="tabs" role="tabpanel" aria-label="Query analysis tabs">
        <!-- Tab Headers -->
        <ul role="tablist" aria-label="Analysis views">
            <li role="tab"><a href="#dashboard" aria-controls="dashboard" tabindex="0">Dashboard</a></li>
            <li role="tab"><a href="#timeline" aria-controls="timeline" tabindex="0">Timeline</a></li>
            <li role="tab"><a href="#analysis" aria-controls="analysis" tabindex="0">Query Groups</a></li>
            <li role="tab"><a href="#every-query" aria-controls="every-query" tabindex="0">Every Query</a></li>
            <li role="tab"><a href="#index-query-flow" aria-controls="index-query-flow" tabindex="0">Index/Query
                    Flow</a></li>
        </ul>

        <!-- Dashboard Tab Content -->
        <div id="dashboard">
            <div style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            grid-template-rows: 300px;
          ">
                <!-- Elapsed Time Distribution Bar Chart -->
                <div style="
              background: white;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 5px;
              height: 300px;
              overflow: hidden;
            ">
                    <h3 style="
                margin-top: 0;
                margin-bottom: 10px;
                text-align: center;
                height: 30px;
              ">
                        Query Duration Distribution
                    </h3>
                    <div style="height: 250px; position: relative">
                        <canvas id="elapsed-time-chart"></canvas>
                    </div>
                </div>
                <!-- Primary Scan Used Pie Chart -->
                <div style="
              background: white;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 5px;
              height: 300px;
              overflow: hidden;
            ">
                    <h3 style="
                margin-top: 0;
                margin-bottom: 10px;
                text-align: center;
                height: 30px;
              ">
                        Primary Scan Used
                    </h3>
                    <div style="height: 250px; position: relative">
                        <canvas id="primary-scan-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Query Pattern Analysis Row -->
            <div style="
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
            grid-template-rows: 400px;
          ">
                <!-- Query Pattern Features Bar Chart -->
                <div style="
              background: white;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 5px;
              height: 400px;
              overflow: hidden;
            ">
                    <h3 style="
                margin-top: 0;
                margin-bottom: 10px;
                text-align: center;
                height: 30px;
              ">
                        Query Pattern Features
                    </h3>
                    <div style="height: 350px; position: relative">
                        <canvas id="query-pattern-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Data Tables Row -->
            <div style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
          ">
                <!-- User Query Count Table -->
                <div style="
              background: white;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 5px;
            ">
                    <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center">
                        Users by Query Count
                    </h3>
                    <div style="height: 250px; overflow-y: auto; border: 1px solid #eee">
                        <table id="user-count-table" style="width: 100%; border-collapse: collapse">
                            <thead style="position: sticky; top: 0; background: #f5f5f5">
                                <tr>
                                    <th style="
                        padding: 8px;
                        text-align: center;
                        border-bottom: 1px solid #ddd;
                        width: 80px;
                      ">
                                        Count
                                    </th>
                                    <th style="
                        padding: 8px;
                        text-align: center;
                        border-bottom: 1px solid #ddd;
                      ">
                                        User
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="user-count-body"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Index Usage Count Table -->
                <div style="
              background: white;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 5px;
            ">
                    <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center">
                        Index Usage Count
                    </h3>
                    <div
                        style="font-size: 12px; color: #666; margin-bottom: 10px; text-align: center; font-style: italic;">
                        Note: #primary count shows total operations, not unique queries
                    </div>
                    <div style="height: 250px; overflow-y: auto; border: 1px solid #eee">
                        <table id="index-count-table" style="width: 100%; border-collapse: collapse">
                            <thead style="position: sticky; top: 0; background: #f5f5f5">
                                <tr>
                                    <th style="
                        padding: 8px;
                        text-align: center;
                        border-bottom: 1px solid #ddd;
                        width: 80px;
                      ">
                                        Count
                                    </th>
                                    <th style="
                    padding: 8px;
                    text-align: center;
                    border-bottom: 1px solid #ddd;
                    ">
                                        Index Name
                                    </th>
                                    <th style="
                         padding: 8px;
                         text-align: center;
                         border-bottom: 1px solid #ddd;
                       ">
                                        Bucket.Scope.Collection
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="index-count-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            grid-template-rows: 300px;
          ">
                <!-- Statement Type Pie Chart -->
                <div style="
              background: white;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 5px;
              height: 300px;
              overflow: hidden;
            ">
                    <h3 style="
                margin-top: 0;
                margin-bottom: 10px;
                text-align: center;
                height: 30px;
              ">
                        Statement Type
                    </h3>
                    <div style="height: 250px; position: relative">
                        <canvas id="statement-type-chart"></canvas>
                    </div>
                </div>

                <!-- Query State Pie Chart -->
                <div style="
              background: white;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 5px;
              height: 300px;
              overflow: hidden;
            ">
                    <h3 style="
                margin-top: 0;
                margin-bottom: 10px;
                text-align: center;
                height: 30px;
              ">
                        Query State
                    </h3>
                    <div style="height: 250px; position: relative">
                        <canvas id="state-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Tab Content -->
        <div id="timeline">
            <div style="margin-bottom: 10px">
                <button id="reset-zoom-btn" onclick="resetTimelineZoom()">
                    Reset Zoom
                </button>
                <span style="margin-left: 20px">
                    <label><input type="radio" name="yScale" value="linear" checked onchange="changeYAxisScale()" />
                        Linear</label>
                    <label style="margin-left: 10px"><input type="radio" name="yScale" value="logarithmic"
                            onchange="changeYAxisScale()" />
                        Logarithmic</label>
                </span>
                <span style="margin-left: 30px">
                    <label><input type="radio" name="timeGrouping" value="optimizer" checked
                            onchange="changeTimeGrouping()" />
                        <span id="optimizer-label">By Optimizer</span></label>
                    <label style="margin-left: 10px"><input type="radio" name="timeGrouping" value="minute"
                            onchange="changeTimeGrouping()" />
                        By Minute</label>
                    <label style="margin-left: 10px"><input type="radio" name="timeGrouping" value="second"
                            onchange="changeTimeGrouping()" />
                        By Second</label>
                </span>
                <span style="margin-left: 20px; color: #666; font-size: 12px">
                    Drag to pan • Scroll to zoom • Drag box to zoom area
                </span>
                <button id="use-time-range-btn" onclick="useCurrentTimeRange()"
                    style="margin-left: 20px; padding: 4px 8px; font-size: 0.8em">
                    Use Time Range
                </button>
            </div>
            <div style="display: flex; gap: 20px; margin-bottom: 20px">
                <div style="flex: 1; height: 400px; position: relative">
                    <canvas id="duration-buckets-chart"></canvas>
                </div>
                <div style="flex: 1; height: 400px; position: relative">
                    <canvas id="query-types-chart"></canvas>
                </div>
            </div>

            <div style="display: flex; gap: 20px; margin-bottom: 20px">
                <div style="flex: 1; height: 400px; position: relative">
                    <canvas id="operations-chart"></canvas>
                </div>
                <div style="flex: 1; height: 400px; position: relative">
                    <canvas id="filter-chart"></canvas>
                </div>
            </div>

            <div style="display: flex; gap: 20px; margin-bottom: 20px">
                <div style="flex: 1; height: 400px; position: relative">
                    <canvas id="timeline-chart"></canvas>
                </div>
                <div style="flex: 1; height: 400px; position: relative">
                    <canvas id="memory-chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Analysis Tab Content -->
        <div id="analysis">
            <!--
        <div id="charts-placeholder">
          *Future charts and visualizations will be displayed here.
          <canvas id="analysis-chart" width="10" height="10"></canvas>
        </div>
      -->
            <div id="analysis-table-section">
                <!-- Search Controls for Analysis Table -->
                <div id="analysis-search-controls"
                    style="background: #f5f5f5; padding: 15px; border: 1px solid #ddd; margin-bottom: 10px; border-radius: 5px;">
                    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                        <div>
                            <label for="analysis-statement-search" style="font-weight: bold; margin-right: 5px;">Search
                                Statement:</label>
                            <input type="text" id="analysis-statement-search"
                                placeholder="Search in SQL++ statements..."
                                style="width: 250px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        </div>
                        <div>
                            <label for="analysis-username-search" style="font-weight: bold; margin-right: 5px;">Search
                                Username:</label>
                            <input type="text" id="analysis-username-search" placeholder="Search usernames..."
                                style="width: 200px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        </div>
                        <button id="analysis-clear-search"
                            style="padding: 5px 15px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">
                            Clear All
                        </button>
                        <div id="analysis-search-results-info" style="font-weight: bold; color: #666;">
                        </div>
                    </div>
                </div>
                <div id="analysis-table-container">
                    <table id="analysis-table">
                        <thead id="analysis-table-header"></thead>
                        <tbody id="analysis-table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Every Query Tab Content -->
        <div id="every-query">
            <div id="flow-diagram-section">
                <div id="flow-diagram"></div>
            </div>
            <div id="table-section">
                <!-- Search Controls -->
                <div id="search-controls"
                    style="background: #f5f5f5; padding: 15px; border: 1px solid #ddd; margin-bottom: 10px; border-radius: 5px;">
                    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                        <div>
                            <label for="statement-search" style="font-weight: bold; margin-right: 5px;">Search
                                Statement:</label>
                            <input type="text" id="statement-search" placeholder="Search in SQL++ statements..."
                                style="width: 250px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        </div>
                        <div>
                            <label for="username-search" style="font-weight: bold; margin-right: 5px;">Search
                                Username:</label>
                            <input type="text" id="username-search" placeholder="Search usernames..."
                                style="width: 200px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        </div>
                        <button id="clear-search"
                            style="padding: 5px 15px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">
                            Clear All
                        </button>
                        <div id="search-results-info" style="font-weight: bold; color: #666;">
                        </div>
                    </div>
                </div>
                <div id="table-container">
                    <table id="query-table">
                        <thead id="table-header"></thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Index/Query Flow Tab Content -->
        <div id="index-query-flow">
            <div style="height: 100%; position: relative; background: #f8f9fa; border-radius: 8px; overflow: hidden;">
                <div id="flow-canvas" style="width: 100%; height: 100%; position: relative; overflow: auto;">
                    <svg id="flow-svg"
                        style="width: 100%; height: 100%; position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;"></svg>
                    <div id="flow-elements" style="position: relative; z-index: 2; padding: 20px;"></div>
                </div>
            </div>
        </div>
    </div>
    <!-- Modals (outside tabs) -->
    <div id="plan-modal" class="modal">
        <div class="modal-content">
            <span class="close">×</span>
            <div id="plan-modal-body"></div>
        </div>
    </div>
    <div id="operator-modal" class="modal">
        <div class="modal-content">
            <span class="close">×</span>
            <div id="operator-modal-body"></div>
        </div>
    </div>

    <script>
        // Disable Chart.js animations globally for better performance
        Chart.defaults.animation = false;
        Chart.defaults.animations = false;
        Chart.defaults.responsive = true;
        Chart.defaults.maintainAspectRatio = false;

        // Register the zoom plugin
        try {
            if (window.ChartZoom) {
                Chart.register(window.ChartZoom);
            } else if (window.chartjsPluginZoom) {
                Chart.register(window.chartjsPluginZoom);
            } else if (window.zoomPlugin) {
                Chart.register(window.zoomPlugin);
            }
        } catch (error) {
            // Silent fallback
        }

        // Global variables for time range tracking
        let originalTimeRange = { min: null, max: null };
        let currentTimeRange = { min: null, max: null };

        // Theme management
        function toggleTheme() {
            const body = document.body;
            const toggleButton = document.querySelector('.theme-toggle');
            const currentTheme = body.getAttribute('data-theme');

            if (currentTheme === 'dark') {
                body.removeAttribute('data-theme');
                toggleButton.textContent = '🌙';
                localStorage.setItem('theme', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                toggleButton.textContent = '☀️';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Initialize theme from localStorage
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const toggleButton = document.querySelector('.theme-toggle');

            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                toggleButton.textContent = '☀️';
            } else {
                toggleButton.textContent = '🌙';
            }
        }

        // Toast notification system
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type === 'error' ? 'error' : ''}`;
            toast.textContent = message;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'polite');

            document.body.appendChild(toast);

            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 100);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // Enhanced clipboard copy function
        async function copyToClipboard(text, button) {
            try {
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    showToast('Copied to clipboard!');
                } else {
                    fallbackCopyTextToClipboard(text, button);
                }
            } catch (err) {
                console.error('Failed to copy: ', err);
                showToast('Failed to copy to clipboard', 'error');
            }
        }

        // Keyboard navigation enhancement
        function enhanceKeyboardNavigation() {
            // Add keyboard support for tab elements
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    const target = e.target;
                    if (target.matches('a[href^="#"]') || target.matches('.step-bubble')) {
                        e.preventDefault();
                        target.click();
                    }
                }
            });
        }

        // Chart optimization utilities
        function getOptimizedChartOptions(baseOptions = {}) {
            return {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 4
                    },
                    line: {
                        tension: 0 // Disable bezier curves for better performance
                    }
                },
                ...baseOptions
            };
        }

        // Enhanced error handling for data processing
        function processRequestData(requestData) {
            try {
                if (!requestData || typeof requestData !== 'object') {
                    throw new Error('Invalid request data');
                }

                // Validate required fields
                const requiredFields = ['requestTime', 'statement'];
                for (const field of requiredFields) {
                    if (!(field in requestData)) {
                        console.warn(`Missing required field: ${field}`);
                        return null;
                    }
                }

                return requestData;
            } catch (error) {
                console.error('Error processing request data:', error);
                return null;
            }
        }

        // Memory cleanup for charts
        function destroyAllCharts() {
            const chartNames = [
                'operationsChart', 'filterChart', 'timelineChart', 'queryTypesChart',
                'durationBucketsChart', 'memoryChart', 'primaryScanChart', 'stateChart',
                'statementTypeChart', 'elapsedTimeChart', 'queryPatternChart'
            ];

            chartNames.forEach(chartName => {
                if (window[chartName]) {
                    window[chartName].destroy();
                    window[chartName] = null;
                }
            });
        }

        // Global system query filtering
        function shouldExcludeSystemQuery(request) {
            const excludeCheckbox = document.getElementById('exclude-system-queries');
            const isChecked = excludeCheckbox ? excludeCheckbox.checked : false;

            console.log(`Checkbox state: ${isChecked ? 'CHECKED (excluding)' : 'UNCHECKED (including)'}`);

            // If checkbox doesn't exist or is unchecked, don't exclude anything
            if (!excludeCheckbox || !excludeCheckbox.checked) {
                return false;
            }

            const stmt = request.preparedText || request.statement;
            if (!stmt) {
                console.log('No statement found in request:', Object.keys(request));
                return false;
            }

            console.log(`Checking statement: "${stmt.substring(0, 50)}..." (type: ${request.statementType})`);


            const upperStmt = stmt.toUpperCase();

            // Apply same filtering logic as Query Groups tab
            const shouldExclude = (
                upperStmt.startsWith("INFER ") ||
                upperStmt.startsWith("ADVISE ") ||
                upperStmt.startsWith("CREATE ") ||
                upperStmt.startsWith("CREATE INDEX") ||
                upperStmt.startsWith("ALTER INDEX") ||
                upperStmt.startsWith("DROP INDEX") ||
                upperStmt.startsWith("EXPLAIN ") ||
                upperStmt.includes(" SYSTEM:")
            );

            if (shouldExclude) {
                console.log(`Excluding system query: ${stmt.substring(0, 50)}...`);
            }

            return shouldExclude;
        }

        // Filter requests based on system query exclusion setting
        function filterSystemQueries(requests) {
            const excludeCheckbox = document.getElementById('exclude-system-queries');
            const isExcluding = excludeCheckbox && excludeCheckbox.checked;

            console.log(`Filtering system queries: ${isExcluding ? 'ENABLED' : 'DISABLED'}`);

            const filtered = requests.filter(request => !shouldExcludeSystemQuery(request));

            console.log(`Original: ${requests.length} requests, After filtering: ${filtered.length} requests`);

            return filtered;
        }

        // Parse time strings to milliseconds
        function parseTime(timeStr) {
            if (!timeStr) {
                return 0;
            }

            // Handle empty or invalid strings
            timeStr = timeStr.trim();
            if (!timeStr) {
                return 0;
            }

            // Try different regex patterns for different time formats

            // Pattern 1: Handle ms, ns, µs, us formats like "681.413039ms", "250ns", "146.266µs"
            const simplePattern = /^(\d+\.?\d*)(ms|ns|µs|us)$/;
            let simpleMatch = timeStr.match(simplePattern);

            if (simpleMatch) {
                const value = parseFloat(simpleMatch[1]);
                const unit = simpleMatch[2];

                let totalMs = 0;
                if (unit === "ms") {
                    totalMs = value;
                } else if (unit === "ns") {
                    totalMs = value / 1000000; // nanoseconds to milliseconds
                } else if (unit === "µs" || unit === "us") {
                    totalMs = value / 1000; // microseconds to milliseconds
                }

                return totalMs;
            }

            // Pattern 2: Handle complex formats like "1h4m17.8098098s" or "4m17.8098098s" or "1h"
            const complexPattern = /(?:(\d+)h)?(?:(\d+)m)?(?:(\d+\.?\d*)s)?/;
            const complexMatch = timeStr.match(complexPattern);

            if (
                !complexMatch ||
                (complexMatch[1] === undefined &&
                    complexMatch[2] === undefined &&
                    complexMatch[3] === undefined)
            ) {
                return 0;
            }

            let totalMs = 0;
            const hours = parseInt(complexMatch[1] || 0); // Hours (optional)
            const minutes = parseInt(complexMatch[2] || 0); // Minutes (optional)
            const seconds = parseFloat(complexMatch[3] || 0); // Seconds (optional, including decimals)

            // Convert to milliseconds
            totalMs += hours * 60 * 60 * 1000; // Hours to milliseconds
            totalMs += minutes * 60 * 1000; // Minutes to milliseconds
            totalMs += seconds * 1000; // Seconds to milliseconds

            return totalMs;
        }

        // Format time in standardized mm:ss.sss format
        function formatTime(milliseconds) {
            if (!milliseconds || isNaN(milliseconds) || milliseconds <= 0) {
                return "00:00.000";
            }

            const totalSeconds = Math.floor(milliseconds / 1000);
            const ms = Math.floor(milliseconds % 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;

            // Format with leading zeros
            const formattedMinutes = minutes.toString().padStart(2, "0");
            const formattedSeconds = seconds.toString().padStart(2, "0");
            const formattedMs = ms.toString().padStart(3, "0");

            return `${formattedMinutes}:${formattedSeconds}.${formattedMs}`;
        }

        // Cache for normalized statements with size limit
        const normalizeCache = new Map();
        const MAX_CACHE_SIZE = 5000;

        // Normalize statement by replacing literals and numbers with "?" (with improved caching)
        function normalizeStatement(statement) {
            if (!statement) return "";

            // Check cache first
            if (normalizeCache.has(statement)) {
                return normalizeCache.get(statement);
            }

            let normalized = statement
                .replace(/"(?:[^"\\]|\\.)*"/g, "?")
                .replace(/'(?:[^'\\]|\\.)*'/g, "?")
                .replace(/\b\d+\.?\d*\b/g, "?");

            // Cache the result with size management
            if (normalizeCache.size >= MAX_CACHE_SIZE) {
                // Remove oldest entries (LRU-like behavior)
                const firstKey = normalizeCache.keys().next().value;
                normalizeCache.delete(firstKey);
            }
            normalizeCache.set(statement, normalized);

            return normalized;
        }

        // Get color class based on percentage
        function getColorClass(percentage) {
            if (percentage === "N/A" || isNaN(percentage)) return "green";
            if (percentage < 25) return "green";
            if (percentage < 50) return "yellow";
            if (percentage < 75) return "orange";
            return "red";
        }

        // Recursively extract operators from the plan
        function getOperators(operator, operators = []) {
            if (operator) {
                if (operator["#operator"]) {
                    operators.push(operator);
                }
                if (operator["~child"]) {
                    getOperators(operator["~child"], operators);
                } else if (operator["~children"]) {
                    operator["~children"].forEach((child) =>
                        getOperators(child, operators)
                    );
                }
                // Check for input/inputs
                if (operator.input) {
                    getOperators(operator.input, operators);
                }
                if (operator.inputs && Array.isArray(operator.inputs)) {
                    operator.inputs.forEach((input) =>
                        getOperators(input, operators)
                    );
                }
                // Check for left/right (binary operations)
                if (operator.left) {
                    getOperators(operator.left, operators);
                }
                if (operator.right) {
                    getOperators(operator.right, operators);
                }
                // Check for first and second properties (used in set operations like ExceptAll)
                if (operator.first) {
                    getOperators(operator.first, operators);
                }
                if (operator.second) {
                    getOperators(operator.second, operators);
                }
                // Check for scans array (used in UnionScan, IntersectScan, etc.)
                if (operator.scans && Array.isArray(operator.scans)) {
                    operator.scans.forEach((scan) =>
                        getOperators(scan, operators)
                    );
                }
                // Check for scan property (used in DistinctScan)
                if (operator.scan) {
                    getOperators(operator.scan, operators);
                }
                // Check for subqueries array
                if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                    operator["~subqueries"].forEach((subquery) => {
                        if (subquery.executionTimings) {
                            getOperators(subquery.executionTimings, operators);
                        }
                    });
                }
            }
            return operators;
        }

        // Calculate the maximum of all kernTimes
        function calculateTotalKernTime(plan) {
            const operators = getOperators(plan);
            let maxKernTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const kernTime = parseTime(stats.kernTime);
                if (!isNaN(kernTime)) {
                    maxKernTime = Math.max(maxKernTime, kernTime);
                }
            });
            return maxKernTime;
        }

        // Calculate the total memory usage from all operators in the plan
        function calculateTotalMemoryUsage(plan) {
            const operators = getOperators(plan);
            let totalMemory = 0;

            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const usedMemory = stats.usedMemory || 0;
                if (!isNaN(usedMemory)) {
                    totalMemory += usedMemory;
                }
            });
            return totalMemory;
        }

        // Calculate the sum of all execution times for percentage calculation
        function calculateTotalExecTime(plan) {
            const operators = getOperators(plan);
            let totalExecTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const execTime = parseTime(stats.execTime);
                if (!isNaN(execTime)) {
                    totalExecTime += execTime;
                }
            });
            return totalExecTime;
        }

        // Build operator stats for modal
        function buildOperatorStats(operator) {
            const operatorType = operator["#operator"] || "Unknown";
            let html = `<h3>Operator: ${operatorType}</h3>`;

            // Add copy button
            html += `<button class="copy-button" onclick="copyOperatorStats(this)">Copy Stats</button>`;

            // Show index name for specific operators
            if (
                (operatorType === "PrimaryScan3" ||
                    operatorType === "IndexFtsSearch" ||
                    operatorType === "IndexScan3") &&
                operator.index
            ) {
                html += `<p><strong>Index Used: ${operator.index}</strong></p>`;
            }

            if (operator["#stats"]) {
                html += "<dl>";
                for (const [key, value] of Object.entries(operator["#stats"])) {
                    let formattedValue = value;
                    // Format time fields
                    if (
                        key === "execTime" ||
                        key === "kernTime" ||
                        key === "servTime"
                    ) {
                        const timeMs = parseTime(value);
                        formattedValue = timeMs > 0 ? formatTime(timeMs) : value;
                    }
                    html += `<dt>${key}</dt><dd>${formattedValue}</dd>`;
                }
                html += "</dl>";
            } else {
                html += "<p>No stats available.</p>";
            }
            return html;
        }

        // Function to copy operator stats to clipboard
        function copyOperatorStats(button) {
            const modalBody = document.getElementById("operator-modal-body");
            const text = modalBody.innerText || modalBody.textContent;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard
                    .writeText(text)
                    .then(() => {
                        button.textContent = "Copied!";
                        setTimeout(() => {
                            button.textContent = "Copy Stats";
                        }, 2000);
                    })
                    .catch((err) => {
                        console.error("Failed to copy: ", err);
                        fallbackCopyTextToClipboard(text, button);
                    });
            } else {
                fallbackCopyTextToClipboard(text, button);
            }
        }

        // Fallback copy function for older browsers
        function fallbackCopyTextToClipboard(text, button) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.top = "-1000px";
            textArea.style.left = "-1000px";
            textArea.setAttribute('aria-hidden', 'true');
            textArea.setAttribute('tabindex', '-1');

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand("copy");
                if (successful) {
                    showToast('Copied to clipboard!');
                } else {
                    showToast('Failed to copy to clipboard', 'error');
                }
            } catch (err) {
                console.error("Fallback: Oops, unable to copy", err);
                showToast('Failed to copy to clipboard', 'error');
            }

            document.body.removeChild(textArea);
        }

        // Generate flow diagram
        function generateFlowDiagram(request) {
            const flowDiagram = document.getElementById("flow-diagram");
            flowDiagram.innerHTML = "";
            if (!request || !request.plan) {
                flowDiagram.textContent = "No execution plan available.";
                return;
            }

            const totalKernTime = calculateTotalKernTime(request.plan);
            const totalExecTime = calculateTotalExecTime(request.plan);
            const operators = getOperators(request.plan);

            if (operators.length === 0) {
                flowDiagram.textContent = "No operators found in the execution plan.";
                return;
            }

            operators.forEach((operator, index) => {
                const operatorName = operator["#operator"] || "Unknown Operator";
                const stats = operator["#stats"] || {};
                const kernTime = stats.kernTime || "N/A";
                const execTime = stats.execTime || "N/A";
                const servTime = stats.servTime || "N/A";
                const itemsIn =
                    stats["#itemsIn"] !== undefined ? stats["#itemsIn"] : "-";
                const itemsOut =
                    stats["#itemsOut"] !== undefined ? stats["#itemsOut"] : "-";

                const kernTimeMs = parseTime(kernTime);
                const execTimeMs = parseTime(execTime);
                const servTimeMs = parseTime(servTime);

                const percentage =
                    totalExecTime > 0 && !isNaN(execTimeMs)
                        ? ((execTimeMs / totalExecTime) * 100).toFixed(2)
                        : "N/A";

                const bubble = document.createElement("div");
                bubble.className = "step-bubble";
                const colorClass = getColorClass(parseFloat(percentage));
                bubble.classList.add(colorClass);

                // Build the HTML content
                let bubbleContent = `
                    <h4>${operatorName}</h4>
                    <p>${formatTime(execTimeMs)} (${percentage}%)</p>`;

                // Add servTime if available
                if (servTime !== "N/A" && !isNaN(servTimeMs) && servTimeMs > 0) {
                    bubbleContent += `<p>${formatTime(servTimeMs)} servTime</p>`;
                }

                // Only show in/out line if both values are present and not "-"
                if (itemsIn !== "-" && itemsOut !== "-") {
                    bubbleContent += `<p>${itemsIn} in / ${itemsOut} out</p>`;
                }

                bubble.innerHTML = bubbleContent;
                bubble.addEventListener("click", () => {
                    const statsHtml = buildOperatorStats(operator);
                    document.getElementById("operator-modal-body").innerHTML =
                        statsHtml;
                    document.getElementById("operator-modal").style.display = "block";
                });
                flowDiagram.appendChild(bubble);

                if (index < operators.length - 1) {
                    const connector = document.createElement("div");
                    connector.className = "connector";
                    flowDiagram.appendChild(connector);
                }
            });

            if (request.plan) {
                const viewPlanButton = document.createElement("button");
                viewPlanButton.textContent = "View Detailed Execution Plan";
                viewPlanButton.style.marginTop = "10px";
                viewPlanButton.addEventListener("click", () => {
                    const planTreeHtml = "<ul>" + buildPlanTree(request.plan) + "</ul>";
                    document.getElementById("plan-modal-body").innerHTML = planTreeHtml;
                    document.getElementById("plan-modal").style.display = "block";
                });
                flowDiagram.appendChild(viewPlanButton);
            }

            panzoom(flowDiagram, { smoothScroll: false });
        }

        // Build plan tree for modal
        function buildPlanTree(operator) {
            if (!operator) return "";
            let html = `<li>${operator["#operator"] || "Unknown Operator"}`;
            if (operator["#stats"]) {
                const stats = operator["#stats"];
                html += ` - itemsIn: ${stats["#itemsIn"] !== undefined ? stats["#itemsIn"] : "N/A"
                    }, itemsOut: ${stats["#itemsOut"] !== undefined ? stats["#itemsOut"] : "N/A"
                    }, execTime: ${stats.execTime || "N/A"}, kernTime: ${stats.kernTime || "N/A"
                    }`;
            }
            if (operator["~child"]) {
                html += "<ul>" + buildPlanTree(operator["~child"]) + "</ul>";
            } else if (operator["~children"]) {
                html += "<ul>";
                operator["~children"].forEach((child) => {
                    html += buildPlanTree(child);
                });
                html += "</ul>";
            }
            // Check for input/inputs
            if (operator.input) {
                html += "<ul>" + buildPlanTree(operator.input) + "</ul>";
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                html += "<ul>";
                operator.inputs.forEach((input) => {
                    html += buildPlanTree(input);
                });
                html += "</ul>";
            }
            // Check for left/right (binary operations)
            if (operator.left) {
                html += "<ul>" + buildPlanTree(operator.left) + "</ul>";
            }
            if (operator.right) {
                html += "<ul>" + buildPlanTree(operator.right) + "</ul>";
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                html += "<ul>" + buildPlanTree(operator.first) + "</ul>";
            }
            if (operator.second) {
                html += "<ul>" + buildPlanTree(operator.second) + "</ul>";
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                html += "<ul>";
                operator.scans.forEach((scan) => {
                    html += buildPlanTree(scan);
                });
                html += "</ul>";
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                html += "<ul>" + buildPlanTree(operator.scan) + "</ul>";
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                html += "<ul>";
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        html += buildPlanTree(subquery.executionTimings);
                    }
                });
                html += "</ul>";
            }
            html += "</li>";
            return html;
        }

        // Sorting functionality
        let currentSortColumn = null;
        let currentSortDirection = "asc";
        let currentTableType = "every-query"; // 'every-query' or 'analysis'
        let everyQueryData = [];
        let analysisData = [];

        // Pagination variables
        let currentPage = 1;
        const pageSize = 50; // Records per page

        // Search/filter variables
        let filteredEveryQueryData = [];
        let currentStatementFilter = "";
        let currentUsernameFilter = "";

        // Analysis table search/filter variables
        let filteredAnalysisData = [];
        let currentAnalysisStatementFilter = "";
        let currentAnalysisUsernameFilter = "";

        // Enhanced time parsing for sorting (handles various units and mm:ss.sss format)
        function parseTimeForSorting(timeStr) {
            if (!timeStr || timeStr === "N/A" || timeStr === "-") return 0;

            // Check if it's in mm:ss.sss format
            const mmssMatch = timeStr.match(/^(\d+):(\d{2})\.(\d{3})$/);
            if (mmssMatch) {
                const minutes = parseInt(mmssMatch[1]);
                const seconds = parseInt(mmssMatch[2]);
                const milliseconds = parseInt(mmssMatch[3]);
                return minutes * 60000 + seconds * 1000 + milliseconds;
            }

            // Handle legacy formats
            const match = timeStr
                .replace(/(\d+\.?\d*)(\D+)/, "$1 $2")
                .match(/(\d+\.?\d*)\s*(\D+)/);
            if (!match) return 0;
            const value = parseFloat(match[1]);
            const unit = match[2].toLowerCase().trim();
            // Convert everything to milliseconds for consistent sorting
            if (unit === "h" || unit === "hour" || unit === "hours")
                return value * 3600000;
            if (
                unit === "m" ||
                unit === "min" ||
                unit === "minute" ||
                unit === "minutes"
            )
                return value * 60000;
            if (
                unit === "s" ||
                unit === "sec" ||
                unit === "second" ||
                unit === "seconds"
            )
                return value * 1000;
            if (unit === "ms" || unit === "millisecond" || unit === "milliseconds")
                return value;
            if (
                unit === "us" ||
                unit === "µs" ||
                unit === "microsecond" ||
                unit === "microseconds"
            )
                return value / 1000;
            if (unit === "ns" || unit === "nanosecond" || unit === "nanoseconds")
                return value / 1000000;
            return value;
        }

        // Get sortable value for a column
        function getSortableValue(item, column) {
            let value = item[column];

            // Handle columns with newlines in their names
            const cleanColumn = column.replace(/\n/g, " ");

            // Handle special columns for Every Query table
            if (column === "#") {
                // "#" column is calculated dynamically, use a default sort order
                return parseInt(item.rowIndex) || 0;
            }
            if (column === "requestTime" || cleanColumn === "request Time") {
                return new Date(value).getTime() || 0;
            }
            if (
                ["elapsedTime", "kernTime", "cpuTime", "serviceTime"].includes(column) ||
                ["elapsed Time", "kern Time", "cpu Time", "service Time"].includes(cleanColumn)
            ) {
                return parseTimeForSorting(value);
            }
            if (column === "KernTime %" || cleanColumn === "KernTime %") {
                const numStr = String(value).replace("%", "");
                return parseFloat(numStr) || 0;
            }
            if (column === "memory (MB)" || cleanColumn === "memory (MB)") {
                return parseFloat(value) || 0;
            }
            if (
                [
                    "resultCount",
                    "resultSize",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                ].includes(column) ||
                [
                    "result Count",
                    "result Size",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                ].includes(cleanColumn)
            ) {
                return parseInt(value) || 0;
            }
            if (column === "Primary Scan Used" || cleanColumn === "Primary Scan Used") {
                return value === "Yes" ? 1 : 0;
            }
            if (column === "statementType" || cleanColumn === "statement Type") {
                return String(value || "").toLowerCase();
            }
            if (column === "state") {
                // Sort fatal states first, then by alphabetical order
                if (value === "fatal") return "aaa_fatal";
                if (value === "completed") return "bbb_completed";
                return String(value || "zzz_unknown").toLowerCase();
            }
            if (column === "statement") {
                return String(value || "").toLowerCase();
            }
            if (column === "users") {
                return String(value || "").toLowerCase();
            }

            // Handle Analysis table columns
            if (
                [
                    "min_duration_in_seconds",
                    "max_duration_in_seconds",
                    "avg_duration_in_seconds",
                    "median_duration_in_seconds",
                ].includes(column)
            ) {
                return parseTimeForSorting(value);
            }
            if (
                [
                    "total_count",
                    "avg_fetch",
                    "avg_primaryScan",
                    "avg_indexScan",
                ].includes(column)
            ) {
                return parseFloat(value) || 0;
            }

            // Default: string comparison
            return String(value || "").toLowerCase();
        }

        // Sort data
        function sortData(data, column, direction) {
            return [...data].sort((a, b) => {
                const aVal = getSortableValue(a, column);
                const bVal = getSortableValue(b, column);

                let comparison = 0;
                if (aVal < bVal) comparison = -1;
                else if (aVal > bVal) comparison = 1;

                return direction === "asc" ? comparison : -comparison;
            });
        }

        // Update sort arrows in headers
        function updateSortArrows(tableHeaderId, column, direction) {
            const headers = document.querySelectorAll(`#${tableHeaderId} th`);
            headers.forEach((th) => {
                // Remove existing sort indicators
                const existingArrow = th.querySelector(".sort-arrow");
                const existingSortHint = th.querySelector(".sort-hint");
                if (existingArrow) existingArrow.remove();
                if (existingSortHint) existingSortHint.remove();

                // Handle multi-line headers by removing newlines for comparison
                const headerText = th.innerHTML.replace(/<br>/g, " ").replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
                const columnText = column.replace(/\n/g, " ").trim();

                if (headerText.includes(columnText) || columnText.includes(headerText)) {
                    // Remove the old sort hint and add prominent arrow
                    const oldHint = th.querySelector('div');
                    if (oldHint && oldHint.textContent === "↕ Sort") {
                        oldHint.remove();
                    }

                    const arrow = document.createElement("div");
                    arrow.className = "sort-arrow";
                    arrow.style.fontSize = "14px";
                    arrow.style.color = "#0066cc";
                    arrow.style.fontWeight = "bold";
                    arrow.style.marginTop = "2px";

                    if (direction === "asc") {
                        arrow.textContent = "▲ ASC";
                        arrow.style.color = "#28a745";
                    } else {
                        arrow.textContent = "▼ DESC";
                        arrow.style.color = "#dc3545";
                    }

                    th.appendChild(arrow);
                } else {
                    // Add back the sort hint for non-active columns
                    const sortHint = document.createElement("div");
                    sortHint.className = "sort-hint";
                    sortHint.style.fontSize = "10px";
                    sortHint.style.color = "#6c757d";
                    sortHint.style.fontWeight = "normal";
                    sortHint.style.marginTop = "2px";
                    sortHint.textContent = "↕ Sort";
                    th.appendChild(sortHint);
                }
            });
        }

        // Map display column names to data field names
        function getDataFieldName(displayColumn) {
            // Map display names back to data field names (same logic as in populateEveryQueryTable)
            if (displayColumn === "request\nTime") return "requestTime";
            else if (displayColumn === "statement\nType") return "statementType";
            else if (displayColumn === "elapsed\nTime") return "elapsedTime";
            else if (displayColumn === "service\nTime") return "serviceTime";
            else if (displayColumn === "kern\nTime") return "kernTime";
            else if (displayColumn === "KernTime\n%") return "KernTime %";
            else if (displayColumn === "cpu\nTime") return "cpuTime";
            else if (displayColumn === "memory\n(MB)") return "memory (MB)";
            else if (displayColumn === "result\nCount") return "resultCount";
            else if (displayColumn === "result\nSize") return "resultSize";
            else if (displayColumn === "Items from\nIndex Scan") return "Items from Index Scan";
            else if (displayColumn === "Doc Fetch\nCount") return "Doc Fetch Count";
            else if (displayColumn === "Primary Scan\nUsed") return "Primary Scan Used";
            else return displayColumn; // For columns without newlines like "#", "state", "statement", "users"
        }

        // Handle column sort click
        function handleColumnSort(column, tableType) {
            console.log("=== handleColumnSort Called ===");
            console.log("Display Column:", column);

            // Map display column to data field
            const dataField = getDataFieldName(column);
            console.log("Data Field:", dataField);
            console.log("Table Type:", tableType);
            console.log("Current Sort Column:", currentSortColumn);
            console.log("Current Sort Direction:", currentSortDirection);

            if (currentSortColumn === column && currentTableType === tableType) {
                currentSortDirection =
                    currentSortDirection === "asc" ? "desc" : "asc";
            } else {
                currentSortColumn = column;
                currentSortDirection = "asc";
                currentTableType = tableType;
            }

            console.log("New Sort Direction:", currentSortDirection);
            console.log("Filtered Data Length:", filteredEveryQueryData.length);

            if (tableType === "every-query") {
                currentPage = 1; // Reset to first page after sorting

                console.log("Before sorting - first 3 items:", filteredEveryQueryData.slice(0, 3).map(item => ({
                    displayValue: item[column],
                    dataFieldValue: item[dataField],
                    sortValue: getSortableValue(item, dataField)
                })));

                // Sort using the data field name, not the display name
                const sortedData = sortData(
                    filteredEveryQueryData,
                    dataField,
                    currentSortDirection
                );

                console.log("After sorting - first 3 items:", sortedData.slice(0, 3).map(item => ({
                    displayValue: item[column],
                    dataFieldValue: item[dataField],
                    sortValue: getSortableValue(item, dataField)
                })));

                filteredEveryQueryData = sortedData;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSortArrows("table-header", column, currentSortDirection);
            } else if (tableType === "analysis") {
                // Sort the filtered analysis data
                const sortedData = sortData(
                    filteredAnalysisData,
                    column,
                    currentSortDirection
                );
                filteredAnalysisData = sortedData;
                populateAnalysisTable(filteredAnalysisData);
                updateSortArrows(
                    "analysis-table-header",
                    column,
                    currentSortDirection
                );
            }
        }

        // Create pagination controls
        function addPaginationControls(totalRecords) {
            const tableContainer = document.getElementById("table-container");
            let paginationDiv = document.getElementById("pagination");
            if (!paginationDiv) {
                paginationDiv = document.createElement("div");
                paginationDiv.id = "pagination";
                paginationDiv.style.textAlign = "center";
                paginationDiv.style.marginTop = "10px";
                paginationDiv.style.backgroundColor = "#f5f5f5";
                paginationDiv.style.padding = "10px";
                paginationDiv.style.borderTop = "1px solid #ddd";
                tableContainer.appendChild(paginationDiv);
            }
            paginationDiv.innerHTML = "";

            const totalPages = Math.ceil(totalRecords / pageSize);

            // Previous button
            const prevButton = createButton("◀ Prev", () => {
                if (currentPage > 1) {
                    currentPage--;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            prevButton.disabled = currentPage === 1;

            // Next button
            const nextButton = createButton("Next ▶", () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            nextButton.disabled = currentPage === totalPages;

            // Page info
            const pageInfo = document.createElement("span");
            pageInfo.textContent = ` Page ${currentPage} of ${totalPages} (${totalRecords} records) `;
            pageInfo.style.margin = "0 15px";
            pageInfo.style.fontWeight = "bold";

            // Page jump input
            const pageInput = document.createElement("input");
            pageInput.type = "number";
            pageInput.min = "1";
            pageInput.max = totalPages.toString();
            pageInput.value = currentPage.toString();
            pageInput.style.width = "60px";
            pageInput.style.margin = "0 5px";
            pageInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                    const newPage = parseInt(pageInput.value);
                    if (newPage >= 1 && newPage <= totalPages) {
                        currentPage = newPage;
                        populateEveryQueryTable(filteredEveryQueryData);
                    }
                }
            });

            const jumpLabel = document.createElement("span");
            jumpLabel.textContent = "Go to page: ";
            jumpLabel.style.marginLeft = "20px";

            paginationDiv.appendChild(prevButton);
            paginationDiv.appendChild(pageInfo);
            paginationDiv.appendChild(nextButton);
            paginationDiv.appendChild(jumpLabel);
            paginationDiv.appendChild(pageInput);
        }

        function createButton(text, onClick) {
            const btn = document.createElement("button");
            btn.textContent = text;
            btn.style.margin = "0 5px";
            btn.style.padding = "5px 10px";
            btn.style.cursor = "pointer";
            btn.onclick = onClick;
            return btn;
        }

        // Filter data based on search criteria
        function filterEveryQueryData(data) {
            return data.filter(rowData => {
                // Filter by statement
                if (currentStatementFilter) {
                    const statement = (rowData.statement || "").toLowerCase();
                    if (!statement.includes(currentStatementFilter.toLowerCase())) {
                        return false;
                    }
                }

                // Filter by username
                if (currentUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update search results info
        function updateSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} records`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} records`;
            }
        }

        // Filter analysis data based on search criteria
        function filterAnalysisData(data) {
            return data.filter(rowData => {
                // Filter by statement
                if (currentAnalysisStatementFilter) {
                    const statement = (rowData.statement || "").toLowerCase();
                    if (!statement.includes(currentAnalysisStatementFilter.toLowerCase())) {
                        return false;
                    }
                }

                // Filter by username
                if (currentAnalysisUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentAnalysisUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update analysis search results info
        function updateAnalysisSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("analysis-search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} groups`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} groups`;
            }
        }

        // Setup analysis search event listeners
        function setupAnalysisSearchListeners() {
            const statementSearch = document.getElementById("analysis-statement-search");
            const usernameSearch = document.getElementById("analysis-username-search");
            const clearButton = document.getElementById("analysis-clear-search");

            function performAnalysisSearch() {
                currentAnalysisStatementFilter = statementSearch.value.trim();
                currentAnalysisUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredAnalysisData = filterAnalysisData(analysisData);

                // Update display
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(filteredAnalysisData.length, analysisData.length);
            }

            // Add debouncing to search inputs
            let analysisSearchTimeout;
            function debouncedAnalysisSearch() {
                clearTimeout(analysisSearchTimeout);
                analysisSearchTimeout = setTimeout(performAnalysisSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedAnalysisSearch);
            usernameSearch.addEventListener("input", debouncedAnalysisSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentAnalysisStatementFilter = "";
                currentAnalysisUsernameFilter = "";
                filteredAnalysisData = [...analysisData];
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(filteredAnalysisData.length, analysisData.length);
            });
        }

        // Setup search event listeners
        function setupSearchListeners() {
            const statementSearch = document.getElementById("statement-search");
            const usernameSearch = document.getElementById("username-search");
            const clearButton = document.getElementById("clear-search");

            function performSearch() {
                currentStatementFilter = statementSearch.value.trim();
                currentUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredEveryQueryData = filterEveryQueryData(everyQueryData);

                // Reset to first page
                currentPage = 1;

                // Update display
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(filteredEveryQueryData.length, everyQueryData.length);
            }

            // Add debouncing to search inputs
            let searchTimeout;
            function debouncedSearch() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(performSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedSearch);
            usernameSearch.addEventListener("input", debouncedSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentStatementFilter = "";
                currentUsernameFilter = "";
                filteredEveryQueryData = [...everyQueryData];
                currentPage = 1;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(filteredEveryQueryData.length, everyQueryData.length);
            });
        }

        // Generate main table
        function generateTable(requests) {
            const tableHeader = document.getElementById("table-header");
            const tableBody = document.getElementById("table-body");
            tableHeader.innerHTML = "";
            tableBody.innerHTML = "";

            const columns = [
                "#",
                "request\nTime",
                "statement\nType",
                "elapsed\nTime",
                "service\nTime",
                "kern\nTime",
                "KernTime\n%",
                "cpu\nTime",
                "memory\n(MB)",
                "result\nCount",
                "result\nSize",
                "Items from\nIndex Scan",
                "Doc Fetch\nCount",
                "Primary Scan\nUsed",
                "state",
                "statement",
                "users",
            ];

            const headerRow = document.createElement("tr");
            columns.forEach((col) => {
                const th = document.createElement("th");
                th.innerHTML = col.replace(/\n/g, "<br>");
                th.style.textAlign = "center";
                th.style.whiteSpace = "nowrap";
                th.style.cursor = "pointer";
                th.style.userSelect = "none";
                th.style.padding = "8px";
                th.style.backgroundColor = "#f8f9fa";
                th.style.border = "1px solid #dee2e6";
                th.style.fontWeight = "bold";
                th.style.position = "relative";

                // Add hover effect
                th.addEventListener("mouseenter", () => {
                    th.style.backgroundColor = "#e9ecef";
                });
                th.addEventListener("mouseleave", () => {
                    th.style.backgroundColor = "#f8f9fa";
                });

                if (col === "statement") {
                    th.style.width = "300px";
                    th.style.maxWidth = "300px";
                }

                // Add sorting indicator text
                const sortHint = document.createElement("div");
                sortHint.className = "sort-hint";
                sortHint.style.fontSize = "10px";
                sortHint.style.color = "#6c757d";
                sortHint.style.fontWeight = "normal";
                sortHint.style.marginTop = "2px";
                sortHint.textContent = "↕ Sort";
                th.appendChild(sortHint);

                th.addEventListener("click", () => {
                    handleColumnSort(col, "every-query");
                });
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);

            // Prepare data with pre-calculated values
            const tableData = requests.map((request, index) => {
                // Use pre-calculated values from processRequestData
                const totalKernTimeMs = request.kernTimeMs || 0;
                const totalMemoryBytes = request.memoryBytes || 0;
                const elapsedTimeMs = request.elapsedTimeMs || 0;

                // Create row data object
                const rowData = {
                    rowIndex: index + 1,
                    request: request, // Keep original request for click handler
                };

                // Add all column values (skip "#" as it's calculated dynamically)
                [
                    "requestTime",
                    "statementType",
                    "elapsedTime",
                    "serviceTime",
                    "kernTime",
                    "KernTime %",
                    "cpuTime",
                    "memory (MB)",
                    "resultCount",
                    "resultSize",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                    "Primary Scan Used",
                    "state",
                    "statement",
                    "users",
                ].forEach((col) => {
                    let value;
                    if (col === "Primary Scan Used") {
                        value = request.usesPrimary ? "Yes" : "No";
                    } else if (col === "Items from Index Scan") {
                        if (request.indexInfo) {
                            const stats = request.indexInfo.stats;
                            if (stats.primaryScan > 0) {
                                value = stats.primaryScan;
                            } else if (stats.indexScan > 0) {
                                value = stats.indexScan;
                            } else {
                                value = "N/A";
                            }
                        } else {
                            value = "N/A";
                        }
                    } else if (col === "Doc Fetch Count") {
                        value = request.indexInfo
                            ? request.indexInfo.stats.fetch || "N/A"
                            : "N/A";
                    } else if (col === "kernTime") {
                        value = totalKernTimeMs > 0 ? formatTime(totalKernTimeMs) : "N/A";
                    } else if (col === "KernTime %") {
                        value =
                            elapsedTimeMs > 0 && totalKernTimeMs > 0
                                ? ((totalKernTimeMs / elapsedTimeMs) * 100).toFixed(2) + "%"
                                : "N/A";
                    } else if (col === "memory (MB)") {
                        value =
                            totalMemoryBytes > 0
                                ? (totalMemoryBytes / 1024 / 1024).toFixed(2)
                                : "0.00";
                    } else if (col === "elapsedTime") {
                        value = formatTime(elapsedTimeMs);
                    } else if (col === "cpuTime") {
                        value = formatTime(parseTime(request[col]));
                    } else if (col === "serviceTime") {
                        value = formatTime(parseTime(request[col]));
                    } else {
                        value = request[col] || "N/A";
                    }
                    rowData[col] = value;
                });

                return rowData;
            });

            // Sort by elapsedTime by default
            const sortedData = sortData(tableData, "elapsedTime", "desc");
            everyQueryData = sortedData;
            filteredEveryQueryData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "elapsedTime";
            currentSortDirection = "desc";
            currentTableType = "every-query";

            // Reset pagination when new data is loaded
            currentPage = 1;

            // Setup search listeners (only once)
            if (!document.getElementById("statement-search").hasAttribute("data-listeners-added")) {
                setupSearchListeners();
                document.getElementById("statement-search").setAttribute("data-listeners-added", "true");
            }

            populateEveryQueryTable(filteredEveryQueryData);
            updateSortArrows("table-header", "elapsedTime", "desc");
            updateSearchResultsInfo(filteredEveryQueryData.length, everyQueryData.length);
        }

        // Populate Every Query table body
        function populateEveryQueryTable(data) {
            const tableBody = document.getElementById("table-body");
            tableBody.innerHTML = "";

            // Clear statement store for new data (only for current page)
            statementStore = {};

            const columns = [
                "#",
                "request\nTime",
                "statement\nType",
                "elapsed\nTime",
                "service\nTime",
                "kern\nTime",
                "KernTime\n%",
                "cpu\nTime",
                "memory\n(MB)",
                "result\nCount",
                "result\nSize",
                "Items from\nIndex Scan",
                "Doc Fetch\nCount",
                "Primary Scan\nUsed",
                "state",
                "statement",
                "users",
            ];

            // Pagination: get only the current page data
            const start = (currentPage - 1) * pageSize;
            const end = Math.min(start + pageSize, data.length);
            const pageData = data.slice(start, end);

            // Use DocumentFragment for batch DOM insertion
            const fragment = document.createDocumentFragment();

            pageData.forEach((rowData, pageIndex) => {
                const globalIndex = start + pageIndex; // For "#" column and statement IDs
                const row = document.createElement("tr");

                columns.forEach((col) => {
                    const td = document.createElement("td");
                    // Map display names back to data field names
                    let dataField;
                    if (col === "request\nTime") dataField = "requestTime";
                    else if (col === "statement\nType") dataField = "statementType";
                    else if (col === "elapsed\nTime") dataField = "elapsedTime";
                    else if (col === "service\nTime") dataField = "serviceTime";
                    else if (col === "kern\nTime") dataField = "kernTime";
                    else if (col === "KernTime\n%") dataField = "KernTime %";
                    else if (col === "cpu\nTime") dataField = "cpuTime";
                    else if (col === "memory\n(MB)") dataField = "memory (MB)";
                    else if (col === "result\nCount") dataField = "resultCount";
                    else if (col === "result\nSize") dataField = "resultSize";
                    else if (col === "Items from\nIndex Scan")
                        dataField = "Items from Index Scan";
                    else if (col === "Doc Fetch\nCount") dataField = "Doc Fetch Count";
                    else if (col === "Primary Scan\nUsed")
                        dataField = "Primary Scan Used";
                    else dataField = col;

                    // Use globalIndex for row number to maintain correct numbering across pages
                    let value;
                    if (col === "#") {
                        value = globalIndex + 1;
                    } else {
                        value = rowData[dataField];
                    }

                    if (col === "statement") {
                        // Set fixed width for statement column
                        td.style.width = "300px";
                        td.style.maxWidth = "300px";
                        td.style.overflow = "hidden";
                        td.style.wordWrap = "break-word";
                        // Handle statement column with truncation and controls
                        const statement = value || "";
                        const statementId = `statement-${globalIndex}`;

                        // Store the statement safely
                        statementStore[statementId] = statement;

                        if (statement.length > 500) {
                            // Create truncated version
                            const truncated = statement.substring(0, 500);

                            td.innerHTML = `
                  <div id="${statementId}-truncated">
                    <span>${truncated}...</span>
                    <br>
                    <button onclick="toggleStatement('${statementId}', true)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">show more</button>
                    <button onclick="copyStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                  <div id="${statementId}-full" style="display: none;">
                    <span>${statement}</span>
                    <br>
                    <button onclick="toggleStatement('${statementId}', false)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">hide</button>
                    <button onclick="copyStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
                        } else {
                            // Short statement - just show it with copy button
                            td.innerHTML = `
                  <div>
                    <span>${statement}</span>
                    <br>
                    <button onclick="copyStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
                        }
                    } else {
                        td.textContent = value;
                    }

                    if (col === "Primary Scan Used" && value === "Yes") {
                        td.classList.add("primary-scan-yes");
                    }

                    if (col === "state" && value === "fatal") {
                        td.classList.add("fatal-state");
                    }
                    row.appendChild(td);
                });

                row.addEventListener("click", () => {
                    document
                        .querySelectorAll("tr")
                        .forEach((r) => (r.style.backgroundColor = ""));
                    row.style.backgroundColor = "#e0e0e0";
                    generateFlowDiagram(rowData.request);
                });
                fragment.appendChild(row);
            });

            // Batch insert all rows at once
            tableBody.appendChild(fragment);

            // Add pagination controls
            addPaginationControls(data.length);
        }

        // Toggle statement display between truncated and full view
        function toggleStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy statement to clipboard
        function copyStatement(statementId) {
            const statement = statementStore[statementId];
            if (!statement) {
                console.error("Statement not found in store:", statementId);
                alert("Statement not found");
                return;
            }

            navigator.clipboard
                .writeText(statement)
                .then(() => {
                    // Show brief feedback
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "copied!";
                    button.style.backgroundColor = "#4CAF50";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy statement:", err);
                    alert("Failed to copy to clipboard");
                });
        }

        // Toggle analysis statement display between truncated and full view
        function toggleAnalysisStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy analysis statement to clipboard
        function copyAnalysisStatement(statementId) {
            const statement = analysisStatementStore[statementId];
            if (!statement) {
                console.error("Statement not found in store:", statementId);
                alert("Statement not found");
                return;
            }

            navigator.clipboard
                .writeText(statement)
                .then(() => {
                    // Show brief feedback
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "copied!";
                    button.style.backgroundColor = "#4CAF50";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy statement:", err);
                    alert("Failed to copy to clipboard");
                });
        }

        // Calculate statistics for a group of requests based on SQL++ query logic
        function calculateGroupStats(normalized_statement, groupedRequests) {
            const users_agg = groupedRequests.map((r) => r.users).filter((u) => u);
            const durations = groupedRequests
                .map((r) => {
                    const ms = parseTime(r.serviceTime);
                    return isNaN(ms) ? NaN : ms / 1000; // Convert ms to seconds
                })
                .filter((d) => !isNaN(d));
            const total_count = durations.length;
            if (total_count === 0) return null;

            const min_duration = Math.min(...durations);
            const max_duration = Math.max(...durations);
            const avg_duration =
                durations.reduce((sum, d) => sum + d, 0) / total_count;
            const sorted_durations = [...durations].sort((a, b) => a - b);
            const midFloor = Math.floor(total_count / 2);
            const midCeil = Math.ceil(total_count / 2) - 1;
            const median_duration =
                (sorted_durations[midFloor] + sorted_durations[midCeil]) / 2;

            const fetchValues = groupedRequests.map(
                (r) => r.phaseCounts?.fetch || 0
            );
            const primaryScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.primaryScan || 0
            );
            const indexScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.indexScan || 0
            );
            const avg_fetch =
                fetchValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_primaryScan =
                primaryScanValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_indexScan =
                indexScanValues.reduce((sum, v) => sum + v, 0) / total_count;

            // Compute user_query_counts as an object: { user: count }
            const uniqueUsers = [...new Set(users_agg)];
            const user_query_counts = {};
            uniqueUsers.forEach((user) => {
                user_query_counts[user] = users_agg.filter((v) => v === user).length;
            });

            return {
                normalized_statement,
                user_query_counts,
                total_count,
                min_duration_in_seconds: min_duration,
                max_duration_in_seconds: max_duration,
                avg_duration_in_seconds: avg_duration,
                median_duration_in_seconds: median_duration,
                avg_fetch,
                avg_primaryScan,
                avg_indexScan,
            };
        }

        // Generate analysis table based on SQL++ query logic
        function generateAnalysisTable(requests) {
            const analysisTableHeader = document.getElementById(
                "analysis-table-header"
            );
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableHeader.innerHTML = "";
            analysisTableBody.innerHTML = "";

            // Group requests by normalized_statement
            const groups = {};
            requests.forEach((request) => {
                const stmt = request.preparedText || request.statement;
                if (!stmt) return;
                // Note: System query filtering is now handled globally in parseJSON()
                const normalized = normalizeStatement(stmt);
                if (!groups[normalized]) {
                    groups[normalized] = [];
                }
                groups[normalized].push(request);
            });

            // Calculate stats for each group
            const groupData = Object.keys(groups)
                .map((key) => calculateGroupStats(key, groups[key]))
                .filter((data) => data !== null);
            groupData.sort((a, b) => b.total_count - a.total_count);

            // Define table columns
            const analysisColumns = [
                "total_count",
                "min_duration_in_seconds",
                "max_duration_in_seconds",
                "avg_duration_in_seconds",
                "median_duration_in_seconds",
                "avg_fetch",
                "avg_primaryScan",
                "avg_indexScan",
                "normalized_statement",
                "user_query_counts",
            ];

            // Create header row
            const headerRow = document.createElement("tr");
            analysisColumns.forEach((col) => {
                const th = document.createElement("th");
                let displayName = col
                    .replace(/_/g, " ")
                    .replace("in seconds", " (mm:ss.sss)");
                if (col === "user_query_counts") {
                    displayName = "user: (count)";
                }
                th.textContent = displayName;
                th.style.textAlign = "center";
                th.addEventListener("click", () => handleColumnSort(col, "analysis"));
                headerRow.appendChild(th);
            });
            analysisTableHeader.appendChild(headerRow);

            // Prepare table data
            const analysisTableData = groupData.map((group) => {
                const rowData = {};
                analysisColumns.forEach((col) => {
                    let value;
                    if (col === "user_query_counts") {
                        value = Object.entries(group.user_query_counts)
                            .map(([user, count]) => `${user}: (${count})`)
                            .join(", ");
                    } else if (col === "total_count") {
                        value = group.total_count;
                    } else if (
                        [
                            "min_duration_in_seconds",
                            "max_duration_in_seconds",
                            "avg_duration_in_seconds",
                            "median_duration_in_seconds",
                        ].includes(col)
                    ) {
                        value = isNaN(group[col])
                            ? "N/A"
                            : formatTime(Number(group[col]) * 1000);
                    } else if (
                        ["avg_fetch", "avg_primaryScan", "avg_indexScan"].includes(col)
                    ) {
                        value = isNaN(group[col]) ? "N/A" : Number(group[col]).toFixed(3);
                    } else {
                        value = group[col] || "N/A";
                    }
                    rowData[col] = value;
                });

                // Add fields for search filtering
                rowData.statement = group.normalized_statement || "";
                rowData.users = Object.keys(group.user_query_counts || {}).join(", ");

                return rowData;
            });

            // Sort by total_count by default
            const sortedData = sortData(analysisTableData, "total_count", "desc");
            analysisData = sortedData;
            filteredAnalysisData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "total_count";
            currentSortDirection = "desc";
            currentTableType = "analysis";

            // Setup search listeners (only once)
            if (!document.getElementById("analysis-statement-search").hasAttribute("data-listeners-added")) {
                setupAnalysisSearchListeners();
                document.getElementById("analysis-statement-search").setAttribute("data-listeners-added", "true");
            }

            populateAnalysisTable(filteredAnalysisData);
            updateSortArrows("analysis-table-header", "total_count", "desc");
            updateAnalysisSearchResultsInfo(filteredAnalysisData.length, analysisData.length);
        }

        // Populate Analysis table body
        function populateAnalysisTable(data) {
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableBody.innerHTML = "";

            // Clear statement store for new data
            analysisStatementStore = {};

            const analysisColumns = [
                "total_count",
                "min_duration_in_seconds",
                "max_duration_in_seconds",
                "avg_duration_in_seconds",
                "median_duration_in_seconds",
                "avg_fetch",
                "avg_primaryScan",
                "avg_indexScan",
                "normalized_statement",
                "user_query_counts",
            ];

            data.forEach((rowData, index) => {
                const row = document.createElement("tr");
                analysisColumns.forEach((col) => {
                    const td = document.createElement("td");
                    const value = rowData[col];

                    if (col === "normalized_statement") {
                        // Handle normalized_statement column with truncation and controls
                        const statement = value || "";
                        const statementId = `analysis-statement-${index}`;

                        // Store the statement safely
                        analysisStatementStore[statementId] = statement;

                        if (statement.length > 500) {
                            // Create truncated version
                            const truncated = statement.substring(0, 500);

                            td.innerHTML = `
                  <div id="${statementId}-truncated">
                    <span>${truncated}...</span>
                    <br>
                    <button onclick="toggleAnalysisStatement('${statementId}', true)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">show more</button>
                    <button onclick="copyAnalysisStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                  <div id="${statementId}-full" style="display: none;">
                    <span>${statement}</span>
                    <br>
                    <button onclick="toggleAnalysisStatement('${statementId}', false)" 
                            style="font-size: 12px; margin-top: 5px; margin-right: 5px;">hide</button>
                    <button onclick="copyAnalysisStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
                        } else {
                            // Short statement - just show it with copy button
                            td.innerHTML = `
                  <div>
                    <span>${statement}</span>
                    <br>
                    <button onclick="copyAnalysisStatement('${statementId}')" 
                            style="font-size: 12px; margin-top: 5px;">copy</button>
                  </div>
                `;
                        }
                    } else if (col === "user_query_counts") {
                        // Bold the counts in parentheses
                        const formattedValue = value.replace(/\((\d+)\)/g, "<b>($1)</b>");
                        td.innerHTML = formattedValue;
                    } else {
                        td.textContent = value;
                    }

                    row.appendChild(td);
                });
                analysisTableBody.appendChild(row);
            });
        }

        // Helper function to get time grouping settings
        function getTimeGrouping() {
            const selectedGrouping =
                document.querySelector('input[name="timeGrouping"]:checked')?.value ||
                "optimizer";
            return selectedGrouping;
        }

        // Helper function to round timestamp based on grouping and optimal unit
        function roundTimestamp(timestamp, grouping, requests) {
            const date = new Date(timestamp);

            // Determine actual unit to use
            let actualUnit;
            if (grouping === "optimizer") {
                actualUnit = getOptimalTimeUnit(requests);
            } else {
                // Use exactly what the user selected
                actualUnit = grouping;
            }

            // Round based on actual unit
            switch (actualUnit) {
                case "second":
                    date.setMilliseconds(0);
                    break;
                case "minute":
                    date.setSeconds(0, 0);
                    break;
                case "hour":
                    date.setMinutes(0, 0, 0);
                    break;
                case "day":
                    date.setHours(0, 0, 0, 0);
                    break;
                case "week":
                    const dayOfWeek = date.getDay();
                    date.setDate(date.getDate() - dayOfWeek);
                    date.setHours(0, 0, 0, 0);
                    break;
                case "month":
                    date.setDate(1);
                    date.setHours(0, 0, 0, 0);
                    break;
                case "year":
                    date.setMonth(0, 1);
                    date.setHours(0, 0, 0, 0);
                    break;
                default:
                    date.setSeconds(0, 0);
            }
            return date;
        }

        // Helper function to automatically determine optimal time unit based on data span
        function getOptimalTimeUnit(requests) {
            if (!requests || requests.length === 0) return "minute";

            const times = requests
                .map((r) => new Date(r.requestTime))
                .filter((t) => !isNaN(t));
            if (times.length === 0) return "minute";

            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            const timeSpanMs = maxTime - minTime;
            const timeSpanHours = timeSpanMs / (1000 * 60 * 60);
            const timeSpanDays = timeSpanHours / 24;

            // Choose time unit based on span to keep Chart.js happy
            if (timeSpanDays > 365) {
                return "year";
            } else if (timeSpanDays > 60) {
                return "month";
            } else if (timeSpanDays > 14) {
                return "week";
            } else if (timeSpanDays > 2) {
                return "day";
            } else if (timeSpanHours > 2) {
                return "hour";
            } else if (timeSpanHours > 0.1) {
                return "minute";
            } else {
                return "second";
            }
        }

        // Helper function to get Chart.js time configuration with auto-adjustment
        function getTimeConfig(requestedGrouping, requests) {
            // Use exactly the unit that was requested
            let actualUnit = requestedGrouping;

            // Calculate appropriate stepSize based on data span to prevent Chart.js errors
            let stepSize = 1;
            if (requests && requests.length > 0) {
                const times = requests
                    .map((r) => new Date(r.requestTime))
                    .filter((t) => !isNaN(t));
                if (times.length > 0) {
                    const minTime = Math.min(...times);
                    const maxTime = Math.max(...times);
                    const timeSpanMs = maxTime - minTime;

                    // Calculate stepSize to keep data points reasonable (max ~1000 points)
                    switch (actualUnit) {
                        case "second":
                            stepSize = Math.max(1, Math.ceil(timeSpanMs / (1000 * 1000))); // timeSpanMs / (1000ms * 1000 points)
                            break;
                        case "minute":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (60 * 1000 * 1000))
                            ); // timeSpanMs / (60s * 1000ms * 1000 points)
                            break;
                        case "hour":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (3600s * 1000ms * 1000 points)
                            break;
                        case "day":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (86400s * 1000ms * 1000 points)
                            break;
                        case "week":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (7 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (604800s * 1000ms * 1000 points)
                            break;
                        case "month":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (30 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (~2592000s * 1000ms * 1000 points)
                            break;
                        case "year":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (365 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (~31536000s * 1000ms * 1000 points)
                            break;
                    }
                }
            }

            // Return appropriate config based on actual unit
            const configs = {
                second: {
                    unit: "second",
                    stepSize: stepSize,
                    displayFormats: { second: "HH:mm:ss" },
                },
                minute: {
                    unit: "minute",
                    stepSize: stepSize,
                    displayFormats: { minute: "MMM dd HH:mm" },
                },
                hour: {
                    unit: "hour",
                    stepSize: stepSize,
                    displayFormats: { hour: "MMM dd HH:mm" },
                },
                day: {
                    unit: "day",
                    stepSize: stepSize,
                    displayFormats: { day: "MMM dd" },
                },
                week: {
                    unit: "week",
                    stepSize: stepSize,
                    displayFormats: { week: "MMM dd" },
                },
                month: {
                    unit: "month",
                    stepSize: stepSize,
                    displayFormats: { month: "MMM yyyy" },
                },
                year: {
                    unit: "year",
                    stepSize: stepSize,
                    displayFormats: { year: "yyyy" },
                },
            };

            return configs[actualUnit] || configs["minute"];
        }

        // Helper function to get current time config with requests data
        function getCurrentTimeConfig(requests) {
            const grouping = getTimeGrouping();
            let actualUnit;
            if (grouping === "optimizer") {
                actualUnit = getOptimalTimeUnit(requests);
            } else {
                actualUnit = grouping;
            }
            return getTimeConfig(actualUnit, requests);
        }

        // Helper function to update the optimizer label
        function updateOptimizerLabel(requests) {
            const optimizedUnit = getOptimalTimeUnit(requests);
            const label = document.getElementById("optimizer-label");
            if (label) {
                label.textContent = `By Optimizer (${optimizedUnit})`;
            }
        }

        // Generate operations chart showing index scan vs fetch operations
        function generateOperationsChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.operationsChart) {
                window.operationsChart.destroy();
                window.operationsChart = null;
            }

            const canvas = document.getElementById("operations-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalIndexScan: 0,
                        totalFetch: 0,
                    };
                }

                // Use pre-calculated values from indexInfo
                const indexInfo = request.indexInfo || {
                    stats: { primaryScan: 0, indexScan: 0, fetch: 0 },
                };
                const { primaryScan, indexScan, fetch } = indexInfo.stats;

                timeGroups[key].totalIndexScan += primaryScan + indexScan;
                timeGroups[key].totalFetch += fetch;
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const indexScanData = sortedData.map((item) => item.totalIndexScan);
            const fetchData = sortedData.map((item) => item.totalFetch);

            // Create new side-by-side bar chart
            window.operationsChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Fetch Documents",
                            data: fetchData,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                        },
                        {
                            label: "Index Scan Items",
                            data: indexScanData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Database Operations Timeline: Index Scans vs Document Fetches",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Sync pan with other charts
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(225,225,225,0.3)",
                                    borderColor: "rgba(225,225,225)",
                                    borderWidth: 1,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Sync zoom with other charts
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Operation Count",
                            },
                            beginAtZero: true,
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
            });
        }

        // Generate filter chart showing filter efficiency (IN vs OUT)
        function generateFilterChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.filterChart) {
                window.filterChart.destroy();
                window.filterChart = null;
            }

            const canvas = document.getElementById("filter-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime || !request.plan) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        filtersEqual: 0,
                        filtersNotEqual: 0,
                    };
                }

                // Find all Filter operators in the plan
                const operators = getOperators(request.plan);
                operators.forEach((operator) => {
                    if (operator["#operator"] === "Filter") {
                        const stats = operator["#stats"] || {};
                        const itemsIn = stats["#itemsIn"];
                        const itemsOut = stats["#itemsOut"];

                        if (itemsIn !== undefined && itemsOut !== undefined) {
                            if (itemsIn === itemsOut) {
                                timeGroups[key].filtersEqual++;
                            } else {
                                timeGroups[key].filtersNotEqual++;
                            }
                        }
                    }
                });
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const filtersEqualData = sortedData.map((item) => item.filtersEqual);
            const filtersNotEqualData = sortedData.map((item) => item.filtersNotEqual);
            const percentageData = sortedData.map((item) => {
                const total = item.filtersEqual + item.filtersNotEqual;
                return total > 0 ? (item.filtersNotEqual / total) * 100 : 0;
            });

            // Create new mixed chart with bars and line
            window.filterChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Filters: IN = OUT",
                            data: filtersEqualData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                        },
                        {
                            label: "Filters: IN ≠ OUT",
                            data: filtersNotEqualData,
                            backgroundColor: "#dc3545", // Red
                            borderColor: "#b02a37",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                        },
                        {
                            label: "Efficiency %",
                            data: percentageData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            tension: 0.1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Filter Operations Timeline: Efficiency Analysis (IN vs OUT)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(225,225,225,0.3)",
                                    borderColor: "rgba(225,225,225)",
                                    borderWidth: 1,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Sync zoom with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Filter Count",
                            },
                            beginAtZero: true,
                            stacked: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Efficiency %",
                            },
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
            });
        }

        // Generate timeline chart showing kernel time vs execution time performance
        function generateTimelineChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.timelineChart) {
                window.timelineChart.destroy();
                window.timelineChart = null;
            }

            const canvas = document.getElementById("timeline-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        percent0to10: 0,
                        percent10to20: 0,
                        percent20to30: 0,
                        percent30to40: 0,
                        percent40to50: 0,
                        percent50to60: 0,
                        percent60to70: 0,
                        percent70to80: 0,
                        percent80to90: 0,
                        percent90to100: 0,
                        percentOver100: 0,
                    };
                }

                // Use pre-calculated values
                const totalKernTimeMs = request.kernTimeMs || 0;
                const elapsedTimeMs = request.elapsedTimeMs || 0;

                // Calculate percentage of kernTime vs executionTime
                const kernTimePercentage =
                    elapsedTimeMs > 0 ? (totalKernTimeMs / elapsedTimeMs) * 100 : 0;

                // Group by percentage ranges
                if (kernTimePercentage < 10) {
                    timeGroups[key].percent0to10++;
                } else if (kernTimePercentage < 20) {
                    timeGroups[key].percent10to20++;
                } else if (kernTimePercentage < 30) {
                    timeGroups[key].percent20to30++;
                } else if (kernTimePercentage < 40) {
                    timeGroups[key].percent30to40++;
                } else if (kernTimePercentage < 50) {
                    timeGroups[key].percent40to50++;
                } else if (kernTimePercentage < 60) {
                    timeGroups[key].percent50to60++;
                } else if (kernTimePercentage < 70) {
                    timeGroups[key].percent60to70++;
                } else if (kernTimePercentage < 80) {
                    timeGroups[key].percent70to80++;
                } else if (kernTimePercentage < 90) {
                    timeGroups[key].percent80to90++;
                } else if (kernTimePercentage <= 100) {
                    timeGroups[key].percent90to100++;
                } else {
                    timeGroups[key].percentOver100++;
                }
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Set original time range from data
            if (sortedData.length > 0) {
                originalTimeRange.min = sortedData[0].timestamp;
                originalTimeRange.max = sortedData[sortedData.length - 1].timestamp;
                currentTimeRange = { ...originalTimeRange };
                updateTimeRangeDisplay();
            }

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const percent0to10Data = sortedData.map((item) => item.percent0to10);
            const percent10to20Data = sortedData.map((item) => item.percent10to20);
            const percent20to30Data = sortedData.map((item) => item.percent20to30);
            const percent30to40Data = sortedData.map((item) => item.percent30to40);
            const percent40to50Data = sortedData.map((item) => item.percent40to50);
            const percent50to60Data = sortedData.map((item) => item.percent50to60);
            const percent60to70Data = sortedData.map((item) => item.percent60to70);
            const percent70to80Data = sortedData.map((item) => item.percent70to80);
            const percent80to90Data = sortedData.map((item) => item.percent80to90);
            const percent90to100Data = sortedData.map(
                (item) => item.percent90to100
            );
            const percentOver100Data = sortedData.map(
                (item) => item.percentOver100
            );

            // Create new stacked bar chart
            window.timelineChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "0-10%",
                            data: percent0to10Data,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                        },
                        {
                            label: "10-20%",
                            data: percent10to20Data,
                            backgroundColor: "#6cb2eb", // Light blue
                            borderColor: "#3490dc",
                            borderWidth: 1,
                        },
                        {
                            label: "20-30%",
                            data: percent20to30Data,
                            backgroundColor: "#a78bfa", // Light purple
                            borderColor: "#8b5cf6",
                            borderWidth: 1,
                        },
                        {
                            label: "30-40%",
                            data: percent30to40Data,
                            backgroundColor: "#34d399", // Light green
                            borderColor: "#10b981",
                            borderWidth: 1,
                        },
                        {
                            label: "40-50%",
                            data: percent40to50Data,
                            backgroundColor: "#fbbf24", // Yellow
                            borderColor: "#f59e0b",
                            borderWidth: 1,
                        },
                        {
                            label: "50-60%",
                            data: percent50to60Data,
                            backgroundColor: "#fb923c", // Orange
                            borderColor: "#ea580c",
                            borderWidth: 1,
                        },
                        {
                            label: "60-70%",
                            data: percent60to70Data,
                            backgroundColor: "#f472b6", // Pink
                            borderColor: "#ec4899",
                            borderWidth: 1,
                        },
                        {
                            label: "70-80%",
                            data: percent70to80Data,
                            backgroundColor: "#a855f7", // Purple
                            borderColor: "#9333ea",
                            borderWidth: 1,
                        },
                        {
                            label: "80-90%",
                            data: percent80to90Data,
                            backgroundColor: "#ef4444", // Red
                            borderColor: "#dc2626",
                            borderWidth: 1,
                        },
                        {
                            label: "90-100%",
                            data: percent90to100Data,
                            backgroundColor: "#991b1b", // Dark red
                            borderColor: "#7f1d1d",
                            borderWidth: 1,
                        },
                        {
                            label: "100%+",
                            data: percentOver100Data,
                            backgroundColor: "#450a0a", // Very dark red
                            borderColor: "#1c0a0a",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    elements: {
                        point: {
                            radius: 0, // Hide points for better performance
                            hoverRadius: 4
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            type: 'time',
                            time: {
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'MM-DD HH:mm'
                                }
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Performance Timeline: KernTime % of ExecutionTime",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range - convert chart scale values to Date objects
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(225,225,225,0.3)",
                                    borderColor: "rgba(225,225,225)",
                                    borderWidth: 1,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range - convert chart scale values to Date objects
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync zoom with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                            stacked: true,
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Query Count",
                            },
                            stacked: true,
                            beginAtZero: true,
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
            });

            // Create Query Types Scatter Plot Chart
            createQueryTypesChart(requests, grouping);

            // Create Duration Buckets Chart
            createDurationBucketsChart(requests, grouping);

            // Create Memory Usage Chart
            createMemoryChart(requests, grouping);
        }

        // Create Query Types Scatter Plot Chart
        function createQueryTypesChart(requests, grouping) {
            const canvas = document.getElementById("query-types-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.queryTypesChart) {
                window.queryTypesChart.destroy();
            }

            // Group requests by time and statement type
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        statementTypes: {},
                    };
                }

                let statementType = "UNKNOWN";
                if (request.statement && typeof request.statement === "string") {
                    const trimmed = request.statement.trim();
                    if (trimmed) {
                        statementType = trimmed.split(/\s+/)[0].toUpperCase();
                    } else {
                        console.log("Empty statement after trim:", request.statement);
                    }
                } else {
                    console.log(
                        "Non-string or null statement:",
                        request.statement,
                        typeof request.statement
                    );
                }

                if (!timeGroups[key].statementTypes[statementType]) {
                    timeGroups[key].statementTypes[statementType] = {
                        count: 0,
                        durations: [],
                    };
                }

                timeGroups[key].statementTypes[statementType].count++;

                // Get duration in seconds
                const elapsedTimeMs = parseTime(request.elapsedTime);
                const durationSeconds = elapsedTimeMs / 1000;
                timeGroups[key].statementTypes[statementType].durations.push(
                    durationSeconds
                );
            });

            // Get all unique statement types
            const allStatementTypes = new Set();
            Object.values(timeGroups).forEach((group) => {
                Object.keys(group.statementTypes).forEach((type) => {
                    allStatementTypes.add(type);
                });
            });

            // Console log all statement types found
            console.log(
                "Statement types found:",
                Array.from(allStatementTypes).sort()
            );

            console.log("First timeGroup sample:", Object.values(timeGroups)[0]);

            // Predefined colors for all statement types found
            const colorMap = {
                SELECT: "#007bff", // Blue
                INSERT: "#28a745", // Green
                DELETE: "#dc3545", // Red
                UPSERT: "#6f42c1", // Purple
                CREATE: "#fd7e14", // Orange
                DROP: "#e83e8c", // Pink
                EXPLAIN: "#20c997", // Teal
                ADVISE: "#17a2b8", // Cyan
                INFER: "#ffc107", // Yellow
                WITH: "#6c757d", // Gray
                PREPARE: "#fd7e14", // Orange-red
                EXECUTE: "#6610f2", // Indigo
                "--": "#343a40", // Dark gray (comments)
                UNKNOWN: "#868e96", // Light gray
            };

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.statementTypes).forEach((typeData) => {
                    minCount = Math.min(minCount, typeData.count);
                    maxCount = Math.max(maxCount, typeData.count);
                });
            });

            // Generate datasets for each statement type with variable circle sizes
            const datasets = Array.from(allStatementTypes).map((statementType) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    if (group.statementTypes[statementType]) {
                        const typeData = group.statementTypes[statementType];
                        // Calculate average duration for this time group and statement type
                        const avgDuration =
                            typeData.durations.reduce((sum, d) => sum + d, 0) /
                            typeData.durations.length;

                        // Calculate circle size based on count (3-15 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (typeData.count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 3 + sizeRatio * 12; // Range from 3 to 15 pixels

                        data.push({
                            x: group.timestamp,
                            y: avgDuration,
                            r: circleSize,
                            count: typeData.count,
                            maxDuration: Math.max(...typeData.durations),
                            minDuration: Math.min(...typeData.durations),
                        });
                    }
                });

                return {
                    label: `${statementType} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 50%)`,
                    borderColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 40%)`,
                    borderWidth: 1,
                };
            });

            // Create bubble chart
            window.queryTypesChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Duration by Statement Type (Bubble Size = Query Count)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const statementType = context.dataset.label.split(" (")[0];
                                    return [
                                        `${statementType}`,
                                        `Count: ${dataPoint.count}`,
                                        `Avg Duration: ${dataPoint.y.toFixed(3)}s`,
                                        `Min Duration: ${dataPoint.minDuration.toFixed(3)}s`,
                                        `Max Duration: ${dataPoint.maxDuration.toFixed(3)}s`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(225,225,225,0.3)",
                                    borderColor: "rgba(225,225,225)",
                                    borderWidth: 1,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync zoom with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Average Duration (seconds)",
                            },
                            beginAtZero: true,
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
            });
        }

        // Create Duration Buckets Chart
        function createDurationBucketsChart(requests, grouping) {
            const canvas = document.getElementById("duration-buckets-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.durationBucketsChart) {
                window.durationBucketsChart.destroy();
            }

            // Group requests by time and duration buckets
            const timeGroups = {};

            console.log(
                "Duration buckets chart - processing requests:",
                requests.length
            );

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        durationBuckets: {
                            "0-1s": 0,
                            "1-2s": 0,
                            "2-3s": 0,
                            "3-4s": 0,
                            "4-5s": 0,
                            "5-10s": 0,
                            "10-30s": 0,
                            "30-60s": 0,
                            "60-120s": 0,
                            "120-240s": 0,
                            "240-500s": 0,
                            "500-900s": 0,
                            "900s+": 0,
                        },
                    };
                }

                // Get duration in seconds
                const durationMs = parseTime(request.elapsedTime);
                const durationSeconds = durationMs / 1000;

                // Categorize into duration buckets
                if (durationSeconds < 1) {
                    timeGroups[key].durationBuckets["0-1s"]++;
                } else if (durationSeconds < 2) {
                    timeGroups[key].durationBuckets["1-2s"]++;
                } else if (durationSeconds < 3) {
                    timeGroups[key].durationBuckets["2-3s"]++;
                } else if (durationSeconds < 4) {
                    timeGroups[key].durationBuckets["3-4s"]++;
                } else if (durationSeconds < 5) {
                    timeGroups[key].durationBuckets["4-5s"]++;
                } else if (durationSeconds < 10) {
                    timeGroups[key].durationBuckets["5-10s"]++;
                } else if (durationSeconds < 30) {
                    timeGroups[key].durationBuckets["10-30s"]++;
                } else if (durationSeconds < 60) {
                    timeGroups[key].durationBuckets["30-60s"]++;
                } else if (durationSeconds < 120) {
                    timeGroups[key].durationBuckets["60-120s"]++;
                } else if (durationSeconds < 240) {
                    timeGroups[key].durationBuckets["120-240s"]++;
                } else if (durationSeconds < 500) {
                    timeGroups[key].durationBuckets["240-500s"]++;
                } else if (durationSeconds < 900) {
                    timeGroups[key].durationBuckets["500-900s"]++;
                } else {
                    timeGroups[key].durationBuckets["900s+"]++;
                }
            });

            console.log(
                "Duration buckets chart - timeGroups count:",
                Object.keys(timeGroups).length
            );
            if (Object.keys(timeGroups).length > 0) {
                console.log("First timeGroup sample:", Object.values(timeGroups)[0]);
            }

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.durationBuckets).forEach((count) => {
                    if (count > 0) {
                        minCount = Math.min(minCount, count);
                        maxCount = Math.max(maxCount, count);
                    }
                });
            });

            // Color mapping for duration buckets - progressive darkness
            const bucketColors = {
                "0-1s": "#28a745", // Green - fast
                "1-2s": "#6cb2eb", // Light blue
                "2-3s": "#ffc107", // Yellow
                "3-4s": "#fd7e14", // Orange
                "4-5s": "#dc3545", // Red
                "5-10s": "#6f42c1", // Purple
                "10-30s": "#495057", // Dark gray
                "30-60s": "#343a40", // Darker gray
                "60-120s": "#721c24", // Dark red
                "120-240s": "#5a1a1a", // Darker red
                "240-500s": "#450a0a", // Very dark red
                "500-900s": "#2d0a0a", // Extremely dark red
                "900s+": "#1a0404", // Nearly black red
            };

            // Generate datasets for each duration bucket
            const datasets = Object.keys(bucketColors).map((bucket) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    const count = group.durationBuckets[bucket];
                    if (count > 0) {
                        // Calculate circle size based on count (5-20 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 5 + sizeRatio * 15; // Range from 5 to 20 pixels

                        // Use bucket midpoint for y-axis position
                        let yPosition;
                        switch (bucket) {
                            case "0-1s":
                                yPosition = 0.5;
                                break;
                            case "1-2s":
                                yPosition = 1.5;
                                break;
                            case "2-3s":
                                yPosition = 2.5;
                                break;
                            case "3-4s":
                                yPosition = 3.5;
                                break;
                            case "4-5s":
                                yPosition = 4.5;
                                break;
                            case "5-10s":
                                yPosition = 7.5;
                                break;
                            case "10-30s":
                                yPosition = 20;
                                break;
                            case "30-60s":
                                yPosition = 45;
                                break;
                            case "60-120s":
                                yPosition = 90;
                                break;
                            case "120-240s":
                                yPosition = 180;
                                break;
                            case "240-500s":
                                yPosition = 370;
                                break;
                            case "500-900s":
                                yPosition = 700;
                                break;
                            case "900s+":
                                yPosition = 1200;
                                break;
                        }

                        data.push({
                            x: group.timestamp,
                            y: yPosition,
                            r: circleSize,
                            count: count,
                        });
                    }
                });

                return {
                    label: `${bucket} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor: bucketColors[bucket],
                    borderColor: bucketColors[bucket],
                    borderWidth: 1,
                };
            });

            // Create bubble chart
            window.durationBucketsChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Duration Distribution by Time Buckets (Bubble Size = Query Count)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const bucket = context.dataset.label.split(" (")[0];
                                    return [
                                        `Duration: ${bucket}`,
                                        `Count: ${dataPoint.count}`,
                                        `Time: ${new Date(dataPoint.x).toLocaleString()}`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(225,225,225,0.3)",
                                    borderColor: "rgba(225,225,225)",
                                    borderWidth: 1,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync zoom with other charts
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: {
                                displayFormats: {
                                    millisecond: "HH:mm:ss.SSS",
                                    second: "HH:mm:ss",
                                    minute: "HH:mm",
                                    hour: "HH:mm",
                                    day: "MM/dd",
                                    week: "MM/dd",
                                    month: "MM/yy",
                                    quarter: "MM/yy",
                                    year: "yyyy",
                                },
                            },
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Duration Range (seconds)",
                            },
                            beginAtZero: true,
                            type: "logarithmic",
                            ticks: {
                                callback: function (value) {
                                    if (value === 0.5) return "0-1s";
                                    if (value === 1.5) return "1-2s";
                                    if (value === 2.5) return "2-3s";
                                    if (value === 3.5) return "3-4s";
                                    if (value === 4.5) return "4-5s";
                                    if (value === 7.5) return "5-10s";
                                    if (value === 20) return "10-30s";
                                    if (value === 45) return "30-60s";
                                    if (value === 90) return "60-120s";
                                    if (value === 180) return "120-240s";
                                    if (value === 370) return "240-500s";
                                    if (value === 700) return "500-900s";
                                    if (value === 1200) return "900s+";
                                    return "";
                                },
                            },
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
            });
        }

        // Create Memory Usage Chart
        function createMemoryChart(requests, grouping) {
            const canvas = document.getElementById("memory-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.memoryChart) {
                window.memoryChart.destroy();
            }

            // Group requests by time and sum memory usage
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalMemoryBytes: 0,
                        queryCount: 0,
                    };
                }

                // Use pre-calculated memory value
                const usedMemoryBytes = request.memoryBytes || 0;
                timeGroups[key].totalMemoryBytes += usedMemoryBytes;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array and convert bytes to MB
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map((item) => ({
                    timestamp: item.timestamp,
                    totalMemoryMB: item.totalMemoryBytes / (1024 * 1024), // Convert bytes to MB
                    queryCount: item.queryCount,
                }));

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const memoryData = sortedData.map((item) => item.totalMemoryMB);

            // Calculate average memory per query for line chart
            const avgMemoryData = sortedData.map((item) => item.totalMemoryMB / item.queryCount);

            // Create memory usage bar chart with line overlay
            window.memoryChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Memory Usage (MB)",
                            data: memoryData,
                            backgroundColor: "#17a2b8", // Info blue-cyan
                            borderColor: "#138496",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg per Query (MB)",
                            data: avgMemoryData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            tension: 0.1,
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Total Query Process Memory Usage",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataIndex = context.dataIndex;
                                    const memoryMB = context.parsed.y;
                                    const queryCount = sortedData[dataIndex].queryCount;
                                    return [
                                        `Memory Usage: ${memoryMB.toFixed(2)} MB`,
                                        `Queries: ${queryCount}`,
                                        `Avg per Query: ${(memoryMB / queryCount).toFixed(2)} MB`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(225,225,225,0.3)",
                                    borderColor: "rgba(225,225,225)",
                                    borderWidth: 1,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync zoom with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Memory Usage (MB)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query (MB)",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
            });
        }

        // Reset timeline chart zoom
        function resetTimelineZoom() {
            if (window.timelineChart) {
                window.timelineChart.resetZoom();
            }
            if (window.operationsChart) {
                window.operationsChart.resetZoom();
            }
            if (window.filterChart) {
                window.filterChart.resetZoom();
            }
            if (window.queryTypesChart) {
                window.queryTypesChart.resetZoom();
            }
            if (window.durationBucketsChart) {
                window.durationBucketsChart.resetZoom();
            }
            if (window.memoryChart) {
                window.memoryChart.resetZoom();
            }

            // Reset to original time range
            currentTimeRange = { ...originalTimeRange };
            updateTimeRangeDisplay();
        }

        // Format date to datetime-local format
        function formatDateForInput(date) {
            if (!date) return "";
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            const hours = String(d.getHours()).padStart(2, "0");
            const minutes = String(d.getMinutes()).padStart(2, "0");
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Update the time range display
        function updateTimeRangeDisplay() {
            // Function kept for compatibility but display removed
        }

        // Use current time range in the date pickers
        function useCurrentTimeRange() {
            // Get current x-axis range directly from the chart
            if (
                window.timelineChart &&
                window.timelineChart.scales &&
                window.timelineChart.scales.x
            ) {
                const xScale = window.timelineChart.scales.x;
                const currentMin = new Date(xScale.min);
                const currentMax = new Date(xScale.max);

                const startValue = formatDateForInput(currentMin);
                const endValue = formatDateForInput(currentMax);

                document.getElementById("start-date").value = startValue;
                document.getElementById("end-date").value = endValue;
            }
        }

        // Change Y-axis scale for both charts
        function changeYAxisScale() {
            const selectedScale = document.querySelector(
                'input[name="yScale"]:checked'
            ).value;
            const scaleType =
                selectedScale === "logarithmic" ? "logarithmic" : "linear";

            // Update operations chart Y-axis scale
            if (window.operationsChart) {
                window.operationsChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.operationsChart.options.scales.y.beginAtZero = false;
                    window.operationsChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.operationsChart.options.scales.y.beginAtZero = true;
                    delete window.operationsChart.options.scales.y.min;
                }
                window.operationsChart.update();
            }

            // Update filter chart Y-axis scale
            if (window.filterChart) {
                window.filterChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.filterChart.options.scales.y.beginAtZero = false;
                    window.filterChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.filterChart.options.scales.y.beginAtZero = true;
                    delete window.filterChart.options.scales.y.min;
                }
                window.filterChart.update();
            }

            // Update timeline chart Y-axis scale
            if (window.timelineChart) {
                window.timelineChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.timelineChart.options.scales.y.beginAtZero = false;
                    window.timelineChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.timelineChart.options.scales.y.beginAtZero = true;
                    delete window.timelineChart.options.scales.y.min;
                }
                window.timelineChart.update();
            }

            // Update query types chart Y-axis scale
            if (window.queryTypesChart) {
                window.queryTypesChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.queryTypesChart.options.scales.y.beginAtZero = false;
                    window.queryTypesChart.options.scales.y.min = 0.001; // Avoid log(0) for very small durations
                } else {
                    window.queryTypesChart.options.scales.y.beginAtZero = true;
                    delete window.queryTypesChart.options.scales.y.min;
                }
                window.queryTypesChart.update();
            }

            // Update memory chart Y-axis scale
            if (window.memoryChart) {
                window.memoryChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.memoryChart.options.scales.y.beginAtZero = false;
                    window.memoryChart.options.scales.y.min = 0.001; // Avoid log(0) for small memory values
                } else {
                    window.memoryChart.options.scales.y.beginAtZero = true;
                    delete window.memoryChart.options.scales.y.min;
                }
                window.memoryChart.update();
            }
        }

        // Change time grouping for all charts
        function changeTimeGrouping() {
            // Use the filtered data if available, otherwise fall back to parsing JSON
            let requests = [];
            if (originalRequests.length > 0) {
                // Apply current date filtering to original data
                const startDateInput = document.getElementById("start-date");
                const endDateInput = document.getElementById("end-date");
                const startDate = startDateInput.value
                    ? new Date(startDateInput.value)
                    : null;
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : null;
                requests = filterRequestsByDateRange(
                    originalRequests,
                    startDate,
                    endDate
                );
            } else {
                // Fallback to parsing JSON if no original data
                const jsonInput = document.getElementById("json-input").value;
                if (!jsonInput.trim()) return;

                try {
                    const data = JSON.parse(jsonInput);
                    if (Array.isArray(data)) {
                        requests = data.map((item) => ({
                            ...item.completed_requests,
                            plan: item.plan
                                ? typeof item.plan === "string"
                                    ? JSON.parse(item.plan)
                                    : item.plan
                                : null,
                        }));
                    }
                } catch (e) {
                    console.error("Error parsing JSON for time grouping change:", e);
                    return;
                }
            }

            // Validate date range for the selected grouping
            const grouping = getTimeGrouping();
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");
            const startDate = startDateInput.value
                ? new Date(startDateInput.value)
                : null;
            const endDate = endDateInput.value
                ? new Date(endDateInput.value)
                : null;

            const validation = validateDateRangeForGrouping(
                startDate,
                endDate,
                grouping
            );
            if (!validation.valid) {
                alert(validation.message);
                return;
            }

            try {
                // Update the optimizer label to show current optimization
                updateOptimizerLabel(requests);

                // Regenerate all charts with new time grouping
                generateOperationsChart(requests);
                generateFilterChart(requests);
                generateTimelineChart(requests);
            } catch (e) {
                console.error("Error regenerating charts:", e);
                alert(
                    "Error generating charts. Try reducing the date range or selecting a coarser time grouping."
                );
            }
        }

        // Global variable to store original unfiltered data
        let originalRequests = [];
        let originalStartDate = null;
        let originalEndDate = null;

        // Store statements for safe access without HTML escaping issues
        let statementStore = {};
        let analysisStatementStore = {};

        // Parse Couchbase datetime to JavaScript Date
        function parseCouchbaseDateTime(dateTimeStr) {
            if (!dateTimeStr) return null;
            // Handle various Couchbase datetime formats
            const isoString = dateTimeStr.replace(" ", "T");
            return new Date(isoString);
        }

        // Convert Date to datetime-local input format
        function toDateTimeLocal(date) {
            if (!date || isNaN(date.getTime())) return "";
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            const hours = String(date.getHours()).padStart(2, "0");
            const minutes = String(date.getMinutes()).padStart(2, "0");
            const seconds = String(date.getSeconds()).padStart(2, "0");
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
        }

        // Filter requests by date range
        function filterRequestsByDateRange(requests, startDate, endDate) {
            if (!startDate && !endDate) return requests;

            return requests.filter((request) => {
                const requestDate = parseCouchbaseDateTime(request.requestTime);
                if (!requestDate) return true; // Include requests with invalid dates

                if (startDate && requestDate < startDate) return false;
                if (endDate && requestDate > endDate) return false;
                return true;
            });
        }

        // Update filter info display
        function updateFilterInfo(originalCount, filteredCount) {
            const filterInfo = document.getElementById("filter-info");
            if (originalCount === filteredCount) {
                filterInfo.textContent = `Showing all ${originalCount} queries`;
            } else {
                filterInfo.textContent = `Showing ${filteredCount} of ${originalCount} queries`;
            }
        }

        // Generate Dashboard Charts
        function generateDashboardCharts(requests) {
            generatePrimaryScanChart(requests);
            generateStateChart(requests);
            generateStatementTypeChart(requests);
            generateElapsedTimeChart(requests);
            generateQueryPatternChart(requests);
            generateUserCountTable(requests);
            generateIndexCountTable(requests);
        }

        // Check if a query uses primary index by analyzing the plan
        function usesPrimaryIndex(request) {
            if (!request.plan) return false;

            try {
                const planObj =
                    typeof request.plan === "string"
                        ? JSON.parse(request.plan)
                        : request.plan;
                return checkOperatorForPrimary(planObj);
            } catch (e) {
                return false;
            }
        }

        // Recursively check operators for primary index usage
        function checkOperatorForPrimary(operator) {
            if (!operator) return false;

            // Check for primary index indicators
            if (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                operator.using === "sequentialScan" ||
                (operator.spans && operator.spans.length === 0)
            ) {
                return true;
            }

            // Recursively check child operators
            if (operator["~child"] && checkOperatorForPrimary(operator["~child"]))
                return true;
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                for (const child of operator["~children"]) {
                    if (checkOperatorForPrimary(child)) return true;
                }
            }
            if (operator.input && checkOperatorForPrimary(operator.input))
                return true;
            if (operator.inputs && Array.isArray(operator.inputs)) {
                for (const input of operator.inputs) {
                    if (checkOperatorForPrimary(input)) return true;
                }
            }
            if (operator.left && checkOperatorForPrimary(operator.left))
                return true;
            if (operator.right && checkOperatorForPrimary(operator.right))
                return true;
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first && checkOperatorForPrimary(operator.first))
                return true;
            if (operator.second && checkOperatorForPrimary(operator.second))
                return true;
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                for (const scan of operator.scans) {
                    if (checkOperatorForPrimary(scan)) return true;
                }
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan && checkOperatorForPrimary(operator.scan))
                return true;
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                for (const subquery of operator["~subqueries"]) {
                    if (subquery.executionTimings && checkOperatorForPrimary(subquery.executionTimings))
                        return true;
                }
            }

            return false;
        }

        // Primary Scan Used Pie Chart
        function generatePrimaryScanChart(requests) {
            const scanCounts = { Yes: 0, No: 0 };

            requests.forEach((request) => {
                const primaryScan = request.usesPrimary ? "Yes" : "No";
                scanCounts[primaryScan]++;
            });

            const total = scanCounts.Yes + scanCounts.No;
            const yesPercent =
                total > 0 ? ((scanCounts.Yes / total) * 100).toFixed(1) : 0;
            const noPercent =
                total > 0 ? ((scanCounts.No / total) * 100).toFixed(1) : 0;

            const ctx = document
                .getElementById("primary-scan-chart")
                .getContext("2d");
            if (window.primaryScanChart) {
                window.primaryScanChart.destroy();
            }

            window.primaryScanChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: ["Yes", "No"],
                    datasets: [
                        {
                            data: [scanCounts.Yes, scanCounts.No],
                            backgroundColor: ["#ff6384", "#36a2eb"],
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                        datalabels: {
                            display: true,
                            color: "white",
                            font: {
                                weight: "bold",
                                size: 14,
                            },
                            formatter: function (value, context) {
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return percent + "%";
                            },
                        },
                    },
                },
                plugins: [
                    {
                        beforeDraw: function (chart) {
                            const ctx = chart.ctx;
                            ctx.save();
                            chart.data.datasets[0].data.forEach((value, index) => {
                                const meta = chart.getDatasetMeta(0);
                                const arc = meta.data[index];
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;

                                if (value > 0) {
                                    ctx.fillStyle = "white";
                                    ctx.font = "bold 14px Arial";
                                    ctx.textAlign = "center";
                                    ctx.textBaseline = "middle";
                                    ctx.fillText(percent + "%", arc.x, arc.y);
                                }
                            });
                            ctx.restore();
                        },
                    },
                ],
            });
        }

        // Query State Pie Chart
        function generateStateChart(requests) {
            const stateCounts = {};

            requests.forEach((request) => {
                const state = request.state || "Unknown";
                stateCounts[state] = (stateCounts[state] || 0) + 1;
            });

            const total = Object.values(stateCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(stateCounts);
            const data = Object.values(stateCounts);
            const colors = [
                "#ff6384",
                "#36a2eb",
                "#ffce56",
                "#4bc0c0",
                "#9966ff",
                "#ff9f40",
            ];

            const ctx = document.getElementById("state-chart").getContext("2d");
            if (window.stateChart) {
                window.stateChart.destroy();
            }

            window.stateChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        beforeDraw: function (chart) {
                            const ctx = chart.ctx;
                            ctx.save();
                            chart.data.datasets[0].data.forEach((value, index) => {
                                const meta = chart.getDatasetMeta(0);
                                const arc = meta.data[index];
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;

                                if (value > 0 && percent >= 5) {
                                    ctx.fillStyle = "white";
                                    ctx.font = "bold 12px Arial";
                                    ctx.textAlign = "center";
                                    ctx.textBaseline = "middle";
                                    ctx.fillText(percent + "%", arc.x, arc.y);
                                }
                            });
                            ctx.restore();
                        },
                    },
                ],
            });
        }

        // Statement Type Pie Chart
        function generateStatementTypeChart(requests) {
            const typeCounts = {};

            requests.forEach((request) => {
                const type = request.statementType || "Unknown";
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            });

            const total = Object.values(typeCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(typeCounts);
            const data = Object.values(typeCounts);
            const colors = [
                "#ff6384",
                "#36a2eb",
                "#ffce56",
                "#4bc0c0",
                "#9966ff",
                "#ff9f40",
                "#c9cbcf",
                "#4bc0c0",
            ];

            const ctx = document
                .getElementById("statement-type-chart")
                .getContext("2d");
            if (window.statementTypeChart) {
                window.statementTypeChart.destroy();
            }

            window.statementTypeChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label,
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        beforeDraw: function (chart) {
                            const ctx = chart.ctx;
                            ctx.save();
                            chart.data.datasets[0].data.forEach((value, index) => {
                                const meta = chart.getDatasetMeta(0);
                                const arc = meta.data[index];
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;

                                if (value > 0 && percent >= 5) {
                                    ctx.fillStyle = "white";
                                    ctx.font = "bold 12px Arial";
                                    ctx.textAlign = "center";
                                    ctx.textBaseline = "middle";
                                    ctx.fillText(percent + "%", arc.x, arc.y);
                                }
                            });
                            ctx.restore();
                        },
                    },
                ],
            });
        }

        // Elapsed Time Distribution Bar Chart
        function generateElapsedTimeChart(requests) {
            const timeBuckets = {
                "0-1s": 0,
                "1-2s": 0,
                "2-5s": 0,
                "5-10s": 0,
                "10-20s": 0,
                "20-40s": 0,
                "40-60s": 0,
                "60-90s": 0,
                "90s-5m": 0,
                "5-15m": 0,
                "15-30m": 0,
                "30-60m": 0,
                ">60m": 0,
            };

            requests.forEach((request) => {
                const elapsed = (request.elapsedTimeMs || 0) / 1000; // Convert ms to seconds

                if (elapsed <= 1) timeBuckets["0-1s"]++;
                else if (elapsed <= 2) timeBuckets["1-2s"]++;
                else if (elapsed <= 5) timeBuckets["2-5s"]++;
                else if (elapsed <= 10) timeBuckets["5-10s"]++;
                else if (elapsed <= 20) timeBuckets["10-20s"]++;
                else if (elapsed <= 40) timeBuckets["20-40s"]++;
                else if (elapsed <= 60) timeBuckets["40-60s"]++;
                else if (elapsed <= 90) timeBuckets["60-90s"]++;
                else if (elapsed <= 300) timeBuckets["90s-5m"]++;
                else if (elapsed <= 900) timeBuckets["5-15m"]++;
                else if (elapsed <= 1800) timeBuckets["15-30m"]++;
                else if (elapsed <= 3600) timeBuckets["30-60m"]++;
                else timeBuckets[">60m"]++;
            });

            const ctx = document
                .getElementById("elapsed-time-chart")
                .getContext("2d");
            if (window.elapsedTimeChart) {
                window.elapsedTimeChart.destroy();
            }

            window.elapsedTimeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(timeBuckets),
                    datasets: [
                        {
                            label: "Query Count",
                            data: Object.values(timeBuckets),
                            backgroundColor: "#36a2eb",
                            borderColor: "#36a2eb",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Elapsed Time Range",
                            },
                        },
                    },
                },
            });
        }

        // Generate Query Pattern Chart
        function generateQueryPatternChart(requests) {
            const patternCounts = {
                "No WHERE": 0,
                "GROUP BY": 0,
                "ORDER BY": 0,
                "USE INDEX": 0,
                "USE KEYS": 0,
                JOIN: 0,
                NEST: 0,
                UNNEST: 0,
                OFFSET: 0,
                SEARCH: 0,
                WITH: 0,
                "ARRAY QUERY": 0,
                "SELECT *": 0,
                LIKE: 0,
                COUNT: 0,
                REGEX: 0,
            };

            requests.forEach((request) => {
                const statement = (request.statement || "").toUpperCase();

                // No WHERE
                if (!statement.includes(" WHERE ")) {
                    patternCounts["No WHERE"]++;
                }

                // GROUP BY
                if (statement.includes(" GROUP BY ")) {
                    patternCounts["GROUP BY"]++;
                }

                // ORDER BY
                if (statement.includes(" ORDER BY ")) {
                    patternCounts["ORDER BY"]++;
                }

                // USE INDEX
                if (statement.includes("USE INDEX")) {
                    patternCounts["USE INDEX"]++;
                }

                // USE KEYS
                if (statement.includes("USE KEYS")) {
                    patternCounts["USE KEYS"]++;
                }

                // JOIN
                if (statement.includes(" JOIN ")) {
                    patternCounts["JOIN"]++;
                }

                // NEST
                if (statement.includes(" NEST ")) {
                    patternCounts["NEST"]++;
                }

                // UNNEST
                if (statement.includes(" UNNEST ")) {
                    patternCounts["UNNEST"]++;
                }

                // OFFSET
                if (statement.includes(" OFFSET ")) {
                    patternCounts["OFFSET"]++;
                }

                // SEARCH
                if (statement.includes(" SEARCH(")) {
                    patternCounts["SEARCH"]++;
                }

                // WITH
                if (statement.includes("WITH ")) {
                    patternCounts["WITH"]++;
                }

                // ARRAY QUERY (has both SATISFIES and END)
                if (
                    statement.includes(" SATISFIES ") &&
                    statement.includes(" END ")
                ) {
                    patternCounts["ARRAY QUERY"]++;
                }

                // SELECT * (between SELECT and FROM)
                const selectMatch = statement.match(/SELECT\s+(.+?)\s+FROM/);
                if (selectMatch) {
                    const selectPart = selectMatch[1].trim();
                    if (selectPart === "*" || selectPart.includes(".*")) {
                        patternCounts["SELECT *"]++;
                    }
                }

                // LIKE
                if (statement.includes(" LIKE ")) {
                    patternCounts["LIKE"]++;
                }

                // COUNT
                if (statement.includes(" COUNT(")) {
                    patternCounts["COUNT"]++;
                }

                // REGEX
                if (statement.includes("REGEXP_") || /REGEX\s*\(/.test(statement)) {
                    patternCounts["REGEX"]++;
                }
            });

            console.log("=== Query Pattern Chart Data ===");
            console.log("Pattern Counts Object:", patternCounts);
            console.log("Pattern Labels:", Object.keys(patternCounts));
            console.log("Pattern Values:", Object.values(patternCounts));
            console.log("Total patterns found:", Object.keys(patternCounts).length);

            const ctx = document
                .getElementById("query-pattern-chart")
                .getContext("2d");
            if (window.queryPatternChart) {
                window.queryPatternChart.destroy();
            }

            // Generate colors based on pattern names
            const colors = Object.keys(patternCounts).map((pattern) => {
                if (pattern === "SELECT *") {
                    return "#dc3545"; // Red
                } else if (
                    pattern === "LIKE" ||
                    pattern === "No WHERE" ||
                    pattern === "REGEX"
                ) {
                    return "#fd7e14"; // Orange
                } else {
                    return "#28a745"; // Green
                }
            });

            window.queryPatternChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(patternCounts),
                    datasets: [
                        {
                            label: "Query Count",
                            data: Object.values(patternCounts),
                            backgroundColor: colors,
                            borderColor: colors,
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Query Pattern Features",
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                            },
                        },
                    },
                },
            });
        }

        // Generate User Count Table
        function generateUserCountTable(requests) {
            const userCounts = {};

            requests.forEach((request) => {
                const user = request.users || "Unknown";
                userCounts[user] = (userCounts[user] || 0) + 1;
            });

            const sortedUsers = Object.entries(userCounts).sort(
                ([, a], [, b]) => b - a
            );

            const tbody = document.getElementById("user-count-body");
            tbody.innerHTML = "";

            sortedUsers.forEach(([user, count]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";
                row.innerHTML = `
              <td style="padding: 8px; text-align: right; font-weight: bold;">${count}</td>
              <td style="padding: 8px; word-break: break-word;">
                ${user}
                <button onclick="copyToClipboard('${user.replace(
                    /'/g,
                    "\\'"
                )}', this)" 
                        style="margin-left: 8px; padding: 2px 8px; font-size: 12px; background: #6c757d; color: white; border: none; border-radius: 2px; cursor: pointer;">
                  copy
                </button>
              </td>
            `;
                tbody.appendChild(row);
            });
        }

        // Parse FROM clause to extract bucket.scope.collection
        function parseFromClause(statement) {
            if (!statement) return "_default._default._default";

            try {
                // Remove comments and normalize whitespace
                let cleanStatement = statement
                    .replace(/--.*$/gm, '') // Remove line comments
                    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove block comments
                    .replace(/\s+/g, ' ') // Normalize whitespace
                    .trim();

                // Look for the main FROM clause (not subquery FROM)
                // Use a more specific regex that avoids matching FROM inside parentheses
                const fromPattern = /\bFROM\s+([`\w]+(?:\.[`\w]+)*(?:\.[`\w]+)*)/i;
                const fromMatch = cleanStatement.match(fromPattern);

                if (!fromMatch) {
                    // Fallback: try to find any table-like reference after FROM
                    const fallbackPattern = /\bFROM\s+([`\w]+)/i;
                    const fallbackMatch = cleanStatement.match(fallbackPattern);
                    if (!fallbackMatch) return "_default._default._default";

                    const tableRef = fallbackMatch[1].replace(/`/g, '').trim();
                    return `${tableRef}._default._default`;
                }

                const tableRef = fromMatch[1].trim();

                // Handle backticks and clean the reference
                const cleanRef = tableRef.replace(/`/g, '');

                // Skip if it looks like a SQL keyword or function
                if (/^(SELECT|WITH|CASE|WHEN|IF|EXISTS|NOT|AND|OR)$/i.test(cleanRef)) {
                    return "_default._default._default";
                }

                // Split by dots
                const parts = cleanRef.split('.');

                if (parts.length === 1) {
                    // Only bucket specified
                    return `${parts[0]}._default._default`;
                } else if (parts.length === 2) {
                    // Bucket and scope specified
                    return `${parts[0]}.${parts[1]}._default`;
                } else if (parts.length >= 3) {
                    // Full bucket.scope.collection
                    return `${parts[0]}.${parts[1]}.${parts[2]}`;
                }

                return "_default._default._default";
            } catch (error) {
                console.warn("Error parsing FROM clause:", error, statement);
                return "_default._default._default";
            }
        }

        // Generate Index Count Table
        function generateIndexCountTable(requests) {
            const indexData = {};

            requests.forEach((request) => {
                const bucketScopeCollection = parseFromClause(request.statement);

                // Debug problematic parsing
                if (bucketScopeCollection.includes('SELECT') || bucketScopeCollection.includes('(')) {
                    console.warn("Potentially incorrect bucket parsing:", {
                        statement: request.statement?.substring(0, 100) + "...",
                        parsed: bucketScopeCollection
                    });
                    // Use default for obviously wrong parsing
                    const correctedBSC = "_default._default._default";

                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, correctedBSC);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                } else {
                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, bucketScopeCollection);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                }
            });

            const sortedIndexes = Object.entries(indexData).sort(
                ([, a], [, b]) => b.count - a.count
            );

            const tbody = document.getElementById("index-count-body");
            tbody.innerHTML = "";

            sortedIndexes.forEach(([indexName, data]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";
                row.innerHTML = `
              <td style="padding: 8px; text-align: right; font-weight: bold;">${data.count}</td>
              <td style="padding: 8px; word-break: break-word;">
                ${indexName}
                <button onclick="copyToClipboard('${indexName.replace(
                    /'/g,
                    "\\'"
                )}', this)" 
                        style="margin-left: 8px; padding: 2px 8px; font-size: 12px; background: #6c757d; color: white; border: none; border-radius: 2px; cursor: pointer;">
                  copy
                </button>
              </td>
              <td style="padding: 8px; word-break: break-word; font-family: monospace; font-size: 12px;">
                ${data.bucketScopeCollection}
              </td>
            `;
                tbody.appendChild(row);
            });
        }

        // Recursively extract index names from plan operators with improved error handling
        function extractIndexNames(operator, indexData, bucketScopeCollection, depth = 0) {
            if (!operator || !indexData) return;

            // Prevent infinite recursion
            if (depth > 50) {
                console.warn("Maximum recursion depth reached in extractIndexNames");
                return;
            }

            try {
                // Check for index name in various operator properties
                if (operator.index && typeof operator.index === 'string') {
                    if (!indexData[operator.index]) {
                        indexData[operator.index] = { count: 0, bucketScopeCollection: bucketScopeCollection || 'unknown' };
                    }
                    indexData[operator.index].count++;
                }
                if (operator.indexName && typeof operator.indexName === 'string') {
                    if (!indexData[operator.indexName]) {
                        indexData[operator.indexName] = { count: 0, bucketScopeCollection: bucketScopeCollection || 'unknown' };
                    }
                    indexData[operator.indexName].count++;
                }

                // Check for primary scan operators (align with usesPrimaryIndex logic)
                if (
                    operator["#operator"] === "PrimaryScan" ||
                    operator["#operator"] === "PrimaryScan3" ||
                    operator.index === "#primary" ||
                    operator.using === "sequentialScan" ||
                    (operator.spans && Array.isArray(operator.spans) && operator.spans.length === 0)
                ) {
                    if (!indexData["#primary"]) {
                        indexData["#primary"] = { count: 0, bucketScopeCollection: bucketScopeCollection || 'unknown' };
                    }
                    indexData["#primary"].count++;
                }

                // Recursively check child operators
                if (operator["~child"]) {
                    extractIndexNames(operator["~child"], indexData, bucketScopeCollection, depth + 1);
                }
                if (operator["~children"] && Array.isArray(operator["~children"])) {
                    operator["~children"].forEach((child) =>
                        extractIndexNames(child, indexData, bucketScopeCollection, depth + 1)
                    );
                }
            } catch (e) {
                console.warn("Error in extractIndexNames:", e);
            }
            if (operator.input) {
                extractIndexNames(operator.input, indexData, bucketScopeCollection);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexNames(input, indexData, bucketScopeCollection)
                );
            }
            if (operator.left) {
                extractIndexNames(operator.left, indexData, bucketScopeCollection);
            }
            if (operator.right) {
                extractIndexNames(operator.right, indexData, bucketScopeCollection);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexNames(operator.first, indexData, bucketScopeCollection);
            }
            if (operator.second) {
                extractIndexNames(operator.second, indexData, bucketScopeCollection);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexNames(scan, indexData, bucketScopeCollection)
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexNames(operator.scan, indexData, bucketScopeCollection);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexNames(subquery.executionTimings, indexData, bucketScopeCollection);
                    }
                });
            }
        }

        // Copy to clipboard function with improved fallback and security
        function copyToClipboard(text, button) {
            // Sanitize the text being copied
            const sanitizedText = DOMPurify ? DOMPurify.sanitize(text, { ALLOWED_TAGS: [] }) : text;

            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard
                    .writeText(sanitizedText)
                    .then(() => {
                        const originalText = button.textContent;
                        button.textContent = "Copied!";
                        button.style.background = "#28a745";
                        showToast("Copied to clipboard", "success");
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = "#007bff";
                        }, 1000);
                    })
                    .catch((err) => {
                        console.error("Failed to copy text: ", err);
                        button.textContent = "Error";
                        button.style.background = "#dc3545";
                        showToast("Failed to copy to clipboard", "error");
                        setTimeout(() => {
                            button.textContent = "Copy";
                            button.style.background = "#007bff";
                        }, 1000);
                    });
            } else {
                // Fallback for older browsers or non-secure contexts
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = sanitizedText;
                    textArea.style.cssText = 'position: fixed; top: -9999px; left: -9999px;';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();

                    const successful = document.execCommand("copy");
                    document.body.removeChild(textArea);

                    if (successful) {
                        const originalText = button.textContent;
                        button.textContent = "Copied!";
                        button.style.background = "#28a745";
                        showToast("Copied to clipboard", "success");
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = "#007bff";
                        }, 1000);
                    } else {
                        throw new Error("execCommand failed");
                    }
                } catch (err) {
                    console.error("Failed to copy text (fallback): ", err);
                    button.textContent = "Error";
                    button.style.background = "#dc3545";
                    showToast("Failed to copy to clipboard", "error");
                    setTimeout(() => {
                        button.textContent = "Copy";
                        button.style.background = "#007bff";
                    }, 1000);
                }
            }
        }

        // Validate date range for time grouping
        function validateDateRangeForGrouping(startDate, endDate, grouping) {
            if (!startDate || !endDate || grouping === "optimizer")
                return { valid: true };

            const diffMs = endDate.getTime() - startDate.getTime();
            const diffHours = diffMs / (1000 * 60 * 60);
            const diffDays = diffMs / (1000 * 60 * 60 * 24);

            switch (grouping) {
                case "second":
                    if (diffHours > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Second" grouping, please restrict the date range to 1 hour or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "minute":
                    if (diffDays > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Minute" grouping, please restrict the date range to 1 day or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "hour":
                    if (diffDays > 31) {
                        return {
                            valid: false,
                            message:
                                'For "by Hour" grouping, please restrict the date range to 1 month or less for optimal performance.',
                        };
                    }
                    break;
            }

            return { valid: true };
        }

        // Optimized request data processor
        function processRequestData(item) {
            const request = item.completed_requests || item;

            // Parse and cache plan data immediately
            const plan = item.plan
                ? typeof item.plan === "string"
                    ? JSON.parse(item.plan)
                    : item.plan
                : null;

            // Pre-calculate commonly used values
            const processedRequest = {
                ...request,
                plan: plan,
                // Pre-calculate time values
                elapsedTimeMs: parseTime(request.elapsedTime),
                kernTimeMs: plan ? calculateTotalKernTime(plan) : 0,
                memoryBytes: request.usedMemory || 0,
                // Pre-calculate boolean flags
                usesPrimary: plan ? usesPrimaryIndex({ plan: plan }) : false,
                // Pre-extract index information
                indexInfo: plan ? extractIndexInfo(plan) : null,
                // Pre-calculate aggregations
                planStats: plan ? extractPlanStats(plan) : null,
            };

            return processedRequest;
        }

        // Fast index information extraction
        function extractIndexInfo(plan) {
            const operators = getOperators(plan);
            const indexes = [];
            const stats = { primaryScan: 0, indexScan: 0, fetch: 0 };

            operators.forEach((operator) => {
                const operatorType = operator["#operator"];
                const operatorStats = operator["#stats"] || {};

                // Extract index names
                if (operator.index) {
                    indexes.push(operator.index);
                }

                // Aggregate stats
                if (
                    operatorType === "PrimaryScan" ||
                    operatorType === "PrimaryScan3"
                ) {
                    stats.primaryScan += operatorStats["#itemsOut"] || 0;
                } else if (
                    operatorType === "IndexScan" ||
                    operatorType === "IndexScan3"
                ) {
                    stats.indexScan += operatorStats["#itemsOut"] || 0;
                } else if (operatorType === "Fetch") {
                    stats.fetch += operatorStats["#itemsOut"] || 0;
                }
            });

            return { indexes, stats };
        }

        // Fast plan stats extraction
        function extractPlanStats(plan) {
            const operators = getOperators(plan);
            let totalItemsIn = 0;
            let totalItemsOut = 0;

            operators.forEach((operator) => {
                const stats = operator["#stats"] || {};
                totalItemsIn += stats["#itemsIn"] || 0;
                totalItemsOut += stats["#itemsOut"] || 0;
            });

            return { totalItemsIn, totalItemsOut };
        }

        // Parse JSON input - Optimized
        function parseJSON() {
            const jsonInput = document.getElementById("json-input").value.trim();
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Input validation
            if (!jsonInput) {
                showToast("Please paste your JSON data first", "warning");
                return;
            }

            if (jsonInput.length > 50 * 1024 * 1024) { // 50MB limit
                showToast("Input too large. Please use smaller datasets.", "error");
                return;
            }

            try {
                const data = JSON.parse(jsonInput);
                let processData = [];

                if (Array.isArray(data)) {
                    processData = data;
                } else if (data && data.results && Array.isArray(data.results)) {
                    processData = data.results;
                } else {
                    showToast("Please provide a valid JSON array or object with results.", "error");
                    return;
                }

                if (processData.length === 0) {
                    showToast("No data found in the JSON", "warning");
                    return;
                }

                if (Array.isArray(processData)) {
                    // Process data in batches to avoid blocking UI
                    const batchSize = 200; // Reduced from 1000 for better responsiveness
                    const processedRequests = [];

                    console.log(
                        `Processing ${processData.length} requests in batches of ${batchSize}...`
                    );

                    // Show progress bar
                    document.getElementById("progress-container").style.display =
                        "block";

                    function processBatch(startIndex) {
                        const endIndex = Math.min(startIndex + batchSize, processData.length);

                        for (let i = startIndex; i < endIndex; i++) {
                            try {
                                processedRequests.push(processRequestData(processData[i]));
                            } catch (e) {
                                console.warn(`Error processing request ${i}:`, e);
                            }
                        }

                        // Update progress bar
                        const progress = Math.round((endIndex / processData.length) * 100);
                        document.getElementById(
                            "progress-bar"
                        ).style.width = `${progress}%`;
                        document.getElementById(
                            "progress-text"
                        ).textContent = `${progress}%`;

                        if (endIndex < processData.length) {
                            // Process next batch asynchronously with optimized timing
                            requestAnimationFrame(() => {
                                setTimeout(() => processBatch(endIndex), 10);
                            });
                        } else {
                            // All batches processed
                            finishProcessing(processedRequests);
                        }
                    }

                    // Start processing
                    processBatch(0);
                } else {
                    showToast("Unexpected data format in JSON", "error");
                }
            } catch (e) {
                console.error("JSON parsing error:", e);
                showToast(`Error parsing JSON: ${e.message}`, "error");
                document.getElementById("progress-container").style.display = "none";
            }
        }

        // Toast notification system
        function showToast(message, type = "info") {
            // Remove any existing toasts
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(toast => toast.remove());

            const toast = document.createElement("div");
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 20px;
          border-radius: 4px;
          color: white;
          font-weight: bold;
          z-index: 10000;
          max-width: 300px;
          word-wrap: break-word;
          opacity: 0;
          transition: opacity 0.3s ease;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;

            if (type === "error") {
                toast.style.backgroundColor = "#f44336";
            } else if (type === "warning") {
                toast.style.backgroundColor = "#ff9800";
            } else if (type === "success") {
                toast.style.backgroundColor = "#4caf50";
            } else {
                toast.style.backgroundColor = "#2196f3";
            }

            document.body.appendChild(toast);

            // Fade in
            setTimeout(() => toast.style.opacity = "1", 10);

            // Remove after 4 seconds
            setTimeout(() => {
                toast.style.opacity = "0";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 4000);
        }

        // Finish processing after all batches are done
        function finishProcessing(allRequests) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Hide progress bar and reset placeholder
            document.getElementById("progress-container").style.display = "none";
            document.getElementById("progress-bar").style.width = "0%";
            document.getElementById("progress-text").textContent = "0%";
            document.getElementById("json-input").placeholder =
                "Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests;";

            // Clear normalize cache if it gets too large to prevent memory issues
            if (normalizeCache.size > 5000) {
                normalizeCache.clear();
                console.log("Cleared statement normalize cache to free memory");
            }

            // Apply global system query filtering
            const filteredAllRequests = filterSystemQueries(allRequests);
            console.log(`Filtered ${allRequests.length - filteredAllRequests.length} system queries from ${allRequests.length} total requests`);

            // If this is the first parse (no date filters set), populate date range
            if (
                !startDateInput.value &&
                !endDateInput.value &&
                filteredAllRequests.length > 0
            ) {
                originalRequests = filteredAllRequests;
                const dates = filteredAllRequests
                    .map((r) => parseCouchbaseDateTime(r.requestTime))
                    .filter((d) => d && !isNaN(d.getTime()))
                    .sort((a, b) => a - b);

                if (dates.length > 0) {
                    const minDate = dates[0];
                    const maxDate = dates[dates.length - 1];

                    // Add 1-minute buffer to ensure edge records aren't excluded by minute rounding
                    const startWithBuffer = new Date(minDate.getTime() - 60000); // -1 minute
                    const endWithBuffer = new Date(maxDate.getTime() + 60000);   // +1 minute

                    originalStartDate = minDate;
                    originalEndDate = maxDate;
                    startDateInput.value = toDateTimeLocal(startWithBuffer);
                    endDateInput.value = toDateTimeLocal(endWithBuffer);

                    console.log(`Date range with buffer: ${startWithBuffer} to ${endWithBuffer}`);
                }
            } else {
                // Use existing originalRequests if available, otherwise use current data
                if (originalRequests.length === 0) {
                    originalRequests = filteredAllRequests;
                }
            }

            // Apply date filtering
            const startDate = startDateInput.value
                ? new Date(startDateInput.value)
                : null;
            const endDate = endDateInput.value
                ? new Date(endDateInput.value)
                : null;
            console.log(`Date filtering: start=${startDate}, end=${endDate}, originalRequests.length=${originalRequests.length}`);
            const filteredRequests = filterRequestsByDateRange(
                originalRequests,
                startDate,
                endDate
            );
            console.log(`After date filtering: ${filteredRequests.length} requests remaining`);

            // Validate date range for current time grouping
            const grouping = getTimeGrouping();
            const validation = validateDateRangeForGrouping(
                startDate,
                endDate,
                grouping
            );
            if (!validation.valid) {
                alert(validation.message);
                // Still continue with table generation, just skip charts
                updateFilterInfo(originalRequests.length, filteredRequests.length);
                generateTable(filteredRequests);
                generateAnalysisTable(filteredRequests);
                buildIndexQueryFlow(filteredRequests);
                document.getElementById("flow-diagram").innerHTML =
                    "Select a query from the table to view the flow diagram.";
                return;
            }

            // Update UI with filtered data
            updateFilterInfo(originalRequests.length, filteredRequests.length);
            try {
                generateTable(filteredRequests);
                generateAnalysisTable(filteredRequests);
                updateOptimizerLabel(filteredRequests);
                generateOperationsChart(filteredRequests);
                generateFilterChart(filteredRequests);
                generateTimelineChart(filteredRequests);
                generateDashboardCharts(filteredRequests);
                buildIndexQueryFlow(filteredRequests);
            } catch (e) {
                console.error("Error generating charts:", e);
                alert(
                    "Error generating charts. Try reducing the date range or selecting a coarser time grouping."
                );
            }
            document.getElementById("flow-diagram").innerHTML =
                "Select a query from the table to view the flow diagram.";
        }

        // Modal event listeners
        const planModal = document.getElementById("plan-modal");
        const planCloseBtn = planModal.querySelector(".close");
        planCloseBtn.addEventListener("click", () => {
            planModal.style.display = "none";
        });
        planModal.addEventListener("click", (event) => {
            if (event.target === planModal) {
                planModal.style.display = "none";
            }
        });

        const operatorModal = document.getElementById("operator-modal");
        const operatorCloseBtn = operatorModal.querySelector(".close");
        operatorCloseBtn.addEventListener("click", () => {
            operatorModal.style.display = "none";
        });
        operatorModal.addEventListener("click", (event) => {
            if (event.target === operatorModal) {
                operatorModal.style.display = "none";
            }
        });

        // Function to set time range based on button selection
        function setTimeRange(type) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            if (type === "original") {
                if (originalStartDate && originalEndDate) {
                    startDateInput.value = toDateTimeLocal(originalStartDate);
                    endDateInput.value = toDateTimeLocal(originalEndDate);
                }
            } else if (type === "1day" || type === "1hour") {
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : new Date();
                const startDate = new Date(endDate);

                if (type === "1day") {
                    startDate.setDate(startDate.getDate() - 1);
                } else if (type === "1hour") {
                    startDate.setHours(startDate.getHours() - 1);
                }

                startDateInput.value = toDateTimeLocal(startDate);
            }

            // Trigger filtering with new date range
            if (originalRequests.length > 0) {
                const startDate = startDateInput.value
                    ? new Date(startDateInput.value)
                    : null;
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : null;
                const filteredRequests = filterRequestsByDateRange(
                    originalRequests,
                    startDate,
                    endDate
                );

                updateFilterInfo(originalRequests.length, filteredRequests.length);
                generateTable(filteredRequests);
                generateTimeline(filteredRequests);
                generateAnalysis(filteredRequests);
                buildIndexQueryFlow(filteredRequests);
            }
        }

        // Track which tabs have been loaded
        let loadedTabs = new Set();

        // Initialize jQuery UI Tabs with lazy loading
        $(function () {
            $("#tabs").tabs({
                activate: function (event, ui) {
                    const tabId = ui.newPanel.attr("id");

                    // Lazy load charts when tabs are first activated
                    if (!loadedTabs.has(tabId)) {
                        loadedTabs.add(tabId);

                        if (tabId === "timeline" && originalRequests.length > 0) {
                            // Generate timeline charts only when tab is activated
                            generateTimelineChart(originalRequests);
                        } else if (tabId === "dashboard" && originalRequests.length > 0) {
                            // Generate dashboard charts only when tab is activated
                            generateDashboardCharts(originalRequests);
                        }
                    }
                },
            });
        });

        // Index/Query Flow functionality
        let indexQueryFlowData = {
            indexes: new Map(),
            queries: new Map(),
            connections: new Map()
        };

        function buildIndexQueryFlow(requests = null) {
            // Use provided requests or fall back to original requests
            const requestsToUse = requests || originalRequests;

            console.log(`Building Index/Query Flow with ${requestsToUse?.length || 0} requests`,
                requests ? '(filtered data)' : '(original data)');

            if (!requestsToUse || requestsToUse.length === 0) {
                console.log('No requests available for Index/Query Flow');
                return;
            }

            // Clear previous data
            indexQueryFlowData.indexes.clear();
            indexQueryFlowData.queries.clear();
            indexQueryFlowData.connections.clear();

            // Step 1: Track which indexes each request uses (by request index)
            const requestIndexMap = new Map(); // requestIndex -> Set of index names

            let requestsWithPlans = 0;
            let requestsWithOperators = 0;
            requestsToUse.forEach((request, requestIndex) => {
                requestIndexMap.set(requestIndex, new Set());
                if (request.plan) {
                    requestsWithPlans++;

                    // Debug: Show the actual plan structure
                    if (requestIndex < 3) {

                        if (typeof request.plan === 'string') {
                            try {
                                const parsedPlan = JSON.parse(request.plan);
                            } catch (e) {
                            }
                        }
                    }

                    // Parse the plan JSON string if needed (same as Dashboard logic)
                    const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;

                    if (planObj && planObj["#operator"]) {
                        requestsWithOperators++;

                        extractIndexUsage(planObj, requestIndex, requestIndexMap);
                    }
                }
            });


            // Step 2: Build query groups and track which request indices belong to each group
            const queryGroups = new Map();
            requestsToUse.forEach((request, requestIndex) => {
                const stmt = request.preparedText || request.statement;
                const normalizedStatement = normalizeStatement(stmt);
                if (!queryGroups.has(normalizedStatement)) {
                    queryGroups.set(normalizedStatement, {
                        statement: stmt,
                        normalizedStatement,
                        count: 0,
                        totalDuration: 0,
                        requestIndices: []
                    });
                }
                const group = queryGroups.get(normalizedStatement);
                group.count++;
                group.totalDuration += parseTime(request.elapsedTime);
                group.requestIndices.push(requestIndex);
            });

            // Step 3: Build final index data and connections using request indices
            const allIndexes = new Map();
            let connectionCount = 0;

            queryGroups.forEach((queryGroup, queryKey) => {


                queryGroup.requestIndices.forEach(requestIndex => {
                    const indexesForRequest = requestIndexMap.get(requestIndex);


                    if (indexesForRequest && indexesForRequest.size > 0) {
                        indexesForRequest.forEach(indexName => {


                            // Track index usage
                            if (!allIndexes.has(indexName)) {
                                allIndexes.set(indexName, {
                                    name: indexName,
                                    totalUsage: 0,
                                    isPrimary: indexName === '#primary' || indexName.includes('#primary'),
                                    scanTimes: [],
                                    itemsScanned: [],
                                    itemsFetched: []
                                });
                                console.log(`    Created new index entry for: ${indexName}`);
                            }

                            const indexObj = allIndexes.get(indexName);
                            indexObj.totalUsage++;

                            // Collect statistics from the request
                            const request = originalRequests[requestIndex];
                            if (request) {
                                // Add execution time as scan time
                                const executionTime = parseTime(request.elapsedTime);
                                if (!isNaN(executionTime)) {
                                    indexObj.scanTimes.push(executionTime);
                                }

                                // Add phase counts as items scanned/fetched
                                if (request.phaseCounts) {
                                    if (request.phaseCounts.indexScan) {
                                        indexObj.itemsScanned.push(request.phaseCounts.indexScan);
                                    }
                                    if (request.phaseCounts.fetch) {
                                        indexObj.itemsFetched.push(request.phaseCounts.fetch);
                                    }
                                }
                            }

                            // Track connection
                            const connectionKey = `${queryGroup.normalizedStatement}::${indexName}`;
                            if (!indexQueryFlowData.connections.has(connectionKey)) {
                                indexQueryFlowData.connections.set(connectionKey, {
                                    queryStatement: queryGroup.normalizedStatement,
                                    indexName: indexName,
                                    count: 0
                                });
                                console.log(`    Created new connection: ${connectionKey}`);
                            }
                            indexQueryFlowData.connections.get(connectionKey).count++;
                            connectionCount++;
                        });
                    }
                });
            });



            // Convert to sorted arrays
            const sortedIndexes = Array.from(allIndexes.values())
                .sort((a, b) => b.totalUsage - a.totalUsage);
            const sortedQueries = Array.from(queryGroups.values())
                .sort((a, b) => b.count - a.count);

            indexQueryFlowData.queries = new Map(sortedQueries.map(q => [q.normalizedStatement, q]));


            renderIndexQueryFlow(sortedIndexes, sortedQueries);
        }

        function extractIndexUsage(operator, requestIndex, requestIndexMap) {
            if (!operator) {
                return;
            }

            // Function to record index usage for this request
            function recordIndexUsage(indexName) {
                requestIndexMap.get(requestIndex).add(indexName);
            }

            // Check for index name in various operator properties (same as Dashboard logic)
            if (operator.index) {
                recordIndexUsage(operator.index);
            }
            if (operator.indexName) {
                recordIndexUsage(operator.indexName);
            }

            // Check for primary scan operators (same as Dashboard logic)
            const isPrimaryScan = (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                operator.using === "sequentialScan" ||
                (operator.spans && operator.spans.length === 0)
            );

            if (isPrimaryScan) {
                // Record as #sequentialscan if it's explicitly a sequential scan
                if (operator.using === "sequentialScan") {
                    recordIndexUsage("#sequentialscan");
                } else {
                    recordIndexUsage("#primary");
                }
            }

            // Recursively check child operators (same as Dashboard logic)
            if (operator["~child"]) {
                extractIndexUsage(operator["~child"], requestIndex, requestIndexMap);
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                operator["~children"].forEach((child) =>
                    extractIndexUsage(child, requestIndex, requestIndexMap)
                );
            }
            if (operator.input) {
                extractIndexUsage(operator.input, requestIndex, requestIndexMap);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexUsage(input, requestIndex, requestIndexMap)
                );
            }
            if (operator.left) {
                extractIndexUsage(operator.left, requestIndex, requestIndexMap);
            }
            if (operator.right) {
                extractIndexUsage(operator.right, requestIndex, requestIndexMap);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexUsage(operator.first, requestIndex, requestIndexMap);
            }
            if (operator.second) {
                extractIndexUsage(operator.second, requestIndex, requestIndexMap);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexUsage(scan, requestIndex, requestIndexMap)
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexUsage(operator.scan, requestIndex, requestIndexMap);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexUsage(subquery.executionTimings, requestIndex, requestIndexMap);
                    }
                });
            }
        }

        function renderIndexQueryFlow(indexes, queries) {
            const flowElements = document.getElementById('flow-elements');

            if (!flowElements) {
                console.error('flow-elements container not found');
                return;
            }

            // Clear container
            flowElements.innerHTML = '';

            if (indexes.length === 0) {
                flowElements.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-style: italic;">No index usage found in the queries.<br><br>This could mean:<br>• Queries use sequential scans<br>• Index information not in execution plans<br>• All queries are prepared statements without index details</div>';
                return;
            }

            // Generate colors for indexes
            const colors = generateColors(indexes.length);

            // Calculate layout - indexes on left, queries on right
            const canvasWidth = flowElements.offsetWidth || 1200;
            const indexItemHeight = 144; // Index spacing
            const queryItemHeight = 173; // Query spacing with additional 20% (144 * 1.2)
            const canvasHeight = Math.max(indexes.length * indexItemHeight, queries.length * queryItemHeight, 400);

            // Set container height
            flowElements.style.height = canvasHeight + 'px';

            // Position indexes on the left
            const indexPositions = [];
            indexes.forEach((index, i) => {
                const x = 50;
                const y = 50 + (i * indexItemHeight);
                const indexDiv = createIndexDiv(index, colors[i], x, y);
                flowElements.appendChild(indexDiv);
                indexPositions.push({ element: indexDiv, x: x + 150, y: y + 40, index: index }); // right edge + center
            });

            // Position queries on the right
            const queryPositions = [];
            queries.forEach((query, queryIndex) => {
                const x = canvasWidth - 350;
                const y = 50 + (queryIndex * queryItemHeight);
                const queryDiv = createQueryDiv(query, queryIndex, x, y);
                flowElements.appendChild(queryDiv);
                queryPositions.push({ element: queryDiv, x: x, y: y + 40, query: query }); // left edge + center
            });

            // Draw connections after elements are positioned
            setTimeout(() => {
                drawSimpleConnections(indexPositions, queryPositions, colors);
            }, 50);
        }

        function createIndexDiv(index, color, x, y) {
            const div = document.createElement('div');
            let className = 'index-item';
            if (index.isPrimary) className += ' primary';
            if (index.name === '#sequentialscan') className += ' sequential-scan';

            div.className = className;
            div.style.borderColor = color;
            div.style.position = 'absolute';
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.width = '280px';
            div.style.margin = '0'; // Override CSS margin for absolute positioning

            // Add orange background for sequential scan
            if (index.name === '#sequentialscan') {
                div.style.backgroundColor = '#fff3cd';
                div.style.borderColor = '#ff9800';
            }

            div.draggable = true;
            div.dataset.indexName = index.name;

            const stats = calculateIndexStats(index);

            div.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="font-weight: bold; font-size: 14px; color: #333;">${index.name}</div>
            <button onclick="copyIndexName('${index.name.replace(/'/g, "\\'")}', event)" style="padding: 2px 8px; font-size: 11px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">Copy</button>
          </div>
          <div style="font-size: 12px; color: #666; margin: 4px 0;">Usage: ${index.totalUsage}</div>
          <div class="index-stats">
            Avg Scan Time: ${stats.avgScanTime}<br>
            Avg Items Scanned: ${stats.avgItemsScanned}<br>
            Avg Items Fetched: ${stats.avgItemsFetched}<br>
            Min/Max Scan Time: ${stats.minScanTime} / ${stats.maxScanTime}<br>
            Min/Max Items: ${stats.minItems} / ${stats.maxItems}
          </div>
        `;

            makeDraggable(div);
            return div;
        }

        function createQueryDiv(query, queryIndex, x, y) {
            const div = document.createElement('div');
            div.className = 'query-item';
            div.style.position = 'absolute';
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.width = '320px';
            div.style.margin = '0'; // Override CSS margin for absolute positioning
            div.draggable = true;
            div.dataset.queryId = `query-${queryIndex}`;
            div.dataset.queryStatement = query.normalizedStatement;

            const avgDuration = query.totalDuration / query.count;

            div.innerHTML = `
          <div style="font-weight: bold; font-size: 14px; color: #333;">Executions: ${query.count}</div>
          <div style="font-size: 12px; color: #666; margin: 4px 0;">Avg Duration: ${formatTime(avgDuration)}</div>
          <div class="query-text" id="query-text-${query.normalizedStatement.replace(/[^a-zA-Z0-9]/g, '')}">
            ${query.statement}
          </div>
          <div class="query-controls">
            <button onclick="toggleQueryText('${query.normalizedStatement.replace(/[^a-zA-Z0-9]/g, '')}')">Show More</button>
            <button class="query-copy-btn" data-query-statement="${encodeURIComponent(query.statement)}">Copy</button>
          </div>
        `;

            // Add event listener for copy button
            const copyBtn = div.querySelector('.query-copy-btn');
            if (copyBtn) {
                copyBtn.addEventListener('click', function (e) {
                    e.stopPropagation(); // Prevent drag from starting
                    const statement = decodeURIComponent(this.dataset.queryStatement);
                    copyQueryText(statement, e);
                });
            }

            makeDraggable(div);
            return div;
        }

        function calculateIndexStats(index) {
            const scanTimes = index.scanTimes || [];
            const itemsScanned = index.itemsScanned || [];
            const itemsFetched = index.itemsFetched || [];

            return {
                avgScanTime: scanTimes.length ? formatTime(scanTimes.reduce((a, b) => a + b, 0) / scanTimes.length) : 'N/A',
                minScanTime: scanTimes.length ? formatTime(Math.min(...scanTimes)) : 'N/A',
                maxScanTime: scanTimes.length ? formatTime(Math.max(...scanTimes)) : 'N/A',
                avgItemsScanned: itemsScanned.length ? Math.round(itemsScanned.reduce((a, b) => a + b, 0) / itemsScanned.length) : 'N/A',
                avgItemsFetched: itemsFetched.length ? Math.round(itemsFetched.reduce((a, b) => a + b, 0) / itemsFetched.length) : 'N/A',
                minItems: itemsScanned.length ? Math.min(...itemsScanned) : 'N/A',
                maxItems: itemsScanned.length ? Math.max(...itemsScanned) : 'N/A'
            };
        }

        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                colors.push(`hsl(${hue}, 70%, 50%)`);
            }
            return colors;
        }

        function drawSimpleConnections(indexPositions, queryPositions, colors) {
            console.log('drawSimpleConnections called');
            const svg = document.getElementById('flow-svg');
            if (!svg) {
                console.error('SVG element not found');
                return;
            }

            svg.innerHTML = '';

            // Create maps for easy lookup
            const indexMap = new Map();
            indexPositions.forEach((pos, i) => {
                indexMap.set(pos.index.name, { ...pos, color: colors[i] });
            });

            const queryMap = new Map();
            queryPositions.forEach(pos => {
                queryMap.set(pos.query.normalizedStatement, pos);
            });

            let connectionsDrawn = 0;

            indexQueryFlowData.connections.forEach(connection => {
                const indexPos = indexMap.get(connection.indexName);
                const queryPos = queryMap.get(connection.queryStatement);

                if (indexPos && queryPos) {
                    console.log(`Drawing connection: ${connection.indexName} -> query (${connection.count} times)`);
                    drawSimpleConnection(svg, indexPos, queryPos, connection.count);
                    connectionsDrawn++;
                }
            });

            console.log(`Drew ${connectionsDrawn} connections`);
        }

        function drawSimpleConnection(svg, indexPos, queryPos, count) {
            const startX = indexPos.x;
            const startY = indexPos.y;
            const endX = queryPos.x;
            const endY = queryPos.y;

            console.log(`Drawing line from (${startX}, ${startY}) to (${endX}, ${endY}) with count ${count}`);

            // Calculate line thickness (scale between 2 and 12 pixels)
            const maxCount = Math.max(...Array.from(indexQueryFlowData.connections.values()).map(c => c.count));
            const thickness = Math.max(2, Math.min(12, (count / maxCount) * 10 + 2));

            // Create curved path instead of straight line
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

            // Calculate control points for the curve
            const curveAmount = Math.abs(endX - startX) * 0.4; // Curve intensity based on distance

            // Create a smooth S-curve
            const d = `M ${startX} ${startY} C ${startX + curveAmount} ${startY}, ${endX - curveAmount} ${endY}, ${endX} ${endY}`;

            path.setAttribute('d', d);
            path.setAttribute('stroke', indexPos.color);
            path.setAttribute('stroke-width', thickness);
            path.setAttribute('opacity', '0.7');
            path.setAttribute('fill', 'none');

            // Create usage count label
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');

            text.setAttribute('x', midX);
            text.setAttribute('y', midY + 4);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '11');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', '#333');
            text.textContent = count;

            // Estimate text dimensions
            const textWidth = count.toString().length * 7;
            rect.setAttribute('x', midX - textWidth / 2 - 3);
            rect.setAttribute('y', midY - 7);
            rect.setAttribute('width', textWidth + 6);
            rect.setAttribute('height', 14);
            rect.setAttribute('fill', 'white');
            rect.setAttribute('stroke', '#333');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('rx', '3');

            svg.appendChild(path);
            svg.appendChild(rect);
            svg.appendChild(text);
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            element.addEventListener('mousedown', function (e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // Get current position relative to the container, not viewport
                const container = document.getElementById('flow-elements');
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();

                startLeft = elementRect.left - containerRect.left;
                startTop = elementRect.top - containerRect.top;

                element.style.position = 'absolute';
                element.style.zIndex = '1000';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function (e) {
                if (!isDragging) return;
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                element.style.left = (startLeft + deltaX) + 'px';
                element.style.top = (startTop + deltaY) + 'px';

                // Redraw connections during drag for smooth following
                if (document.getElementById('index-query-flow').style.display !== 'none') {
                    redrawConnectionsAfterDrag();
                }
            });

            document.addEventListener('mouseup', function () {
                if (isDragging) {
                    isDragging = false;
                    element.style.zIndex = '';
                    // Redraw connections after drag
                    setTimeout(() => {
                        if (document.getElementById('index-query-flow').style.display !== 'none') {
                            redrawConnectionsAfterDrag();
                        }
                    }, 50);
                }
            });
        }

        function redrawConnectionsAfterDrag() {
            // Get current positions of all elements
            const indexElements = document.querySelectorAll('[data-index-name]');
            const queryElements = document.querySelectorAll('[data-query-id]');

            const indexPositions = [];
            const queryPositions = [];
            const colors = generateColors(indexElements.length);

            // Build current index positions
            indexElements.forEach((element, i) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document.getElementById('flow-elements').getBoundingClientRect();
                const indexName = element.dataset.indexName;

                // Create a minimal index object with just the name
                const indexObj = { name: indexName };

                indexPositions.push({
                    element: element,
                    x: rect.right - containerRect.left,  // right edge
                    y: rect.top - containerRect.top + (rect.height / 2), // center
                    index: indexObj
                });
            });

            // Build current query positions  
            queryElements.forEach((element) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document.getElementById('flow-elements').getBoundingClientRect();
                const queryStatement = element.dataset.queryStatement;

                // Create a minimal query object with just the normalized statement
                const queryObj = { normalizedStatement: queryStatement };

                queryPositions.push({
                    element: element,
                    x: rect.left - containerRect.left, // left edge
                    y: rect.top - containerRect.top + (rect.height / 2), // center
                    query: queryObj
                });
            });

            // Redraw connections with current positions
            drawSimpleConnections(indexPositions, queryPositions, colors);
        }

        function toggleQueryText(id) {
            const element = document.getElementById(`query-text-${id}`);
            const button = element.nextElementSibling.firstElementChild;

            if (element.classList.contains('expanded')) {
                element.classList.remove('expanded');
                button.textContent = 'Show More';
            } else {
                element.classList.add('expanded');
                button.textContent = 'Hide';
            }
        }

        function copyQueryText(text, event) {
            navigator.clipboard.writeText(text).then(() => {
                // Brief visual feedback
                const button = event ? event.target : window.event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.backgroundColor = '#4CAF50';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '';
                }, 1000);
            });
        }

        function copyIndexName(indexName, event) {
            navigator.clipboard.writeText(indexName).then(() => {
                // Brief visual feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.backgroundColor = '#4CAF50';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '#f0f0f0';
                }, 1000);
            });
        }

        // Hook removed - buildIndexQueryFlow will be called directly after data processing

        // Version management
        const APP_VERSION = '2.1.0';
        const LAST_UPDATED = '2025-01-19';

        function getVersionInfo() {
            return {
                version: APP_VERSION,
                lastUpdated: LAST_UPDATED,
                features: [
                    'Global system query exclusion',
                    'Dark/light theme toggle',
                    'Enhanced accessibility (ARIA)',
                    'Chart performance optimizations',
                    'Time range filtering with buffers',
                    'Index/Query Flow analysis',
                    'Toast notification system'
                ]
            };
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function () {
            console.log('🚀 Initializing Couchbase Query Analyzer...');
            console.log(`📦 Version: ${APP_VERSION} (Updated: ${LAST_UPDATED})`);
            console.log('🔧 Features:', getVersionInfo().features.join(', '));

            // Initialize theme from localStorage
            initializeTheme();

            // Enhance keyboard navigation
            enhanceKeyboardNavigation();

            // Initialize tabs with enhanced accessibility
            $('#tabs').tabs({
                activate: function (event, ui) {
                    // Announce tab change to screen readers
                    const tabName = ui.newTab.find('a').text();
                    showToast(`Switched to ${tabName}`, 'info');
                }
            });

            // Add event listener for system query exclusion checkbox
            const excludeCheckbox = document.getElementById('exclude-system-queries');
            if (excludeCheckbox) {
                excludeCheckbox.addEventListener('change', function () {
                    console.log(`System query exclusion changed to: ${this.checked}`);
                    // Only reprocess if we have JSON data
                    const jsonInput = document.getElementById('json-input').value;
                    if (jsonInput.trim()) {
                        // Clear existing processed data AND date inputs to force complete reparse
                        originalRequests = [];
                        const startDateInput = document.getElementById('start-date');
                        const endDateInput = document.getElementById('end-date');
                        startDateInput.value = '';
                        endDateInput.value = '';
                        console.log('Clearing existing data, date filters, and reprocessing...');
                        parseJSON();
                    }
                });
            }

            console.log('✅ Query Analyzer initialized successfully');

            // Make version info globally accessible
            window.QueryAnalyzer = {
                version: getVersionInfo,
                about: () => {
                    const info = getVersionInfo();
                    console.log(`
🔍 Couchbase Query Analyzer v${info.version}
📅 Last Updated: ${info.lastUpdated}
🎯 Purpose: Analyze Couchbase N1QL query performance from system:completed_requests
                    
🚀 Features:
${info.features.map(f => `   • ${f}`).join('\n')}

💡 Usage: Type QueryAnalyzer.version() for version info
                    `);
                }
            };

            console.log('💡 Tip: Type QueryAnalyzer.about() for full app info');
        });
    </script>
</body>

</html>