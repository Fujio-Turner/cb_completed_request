<html>
<head>
    <title>How to Debug & Glossary</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; line-height: 1.6; color: #333; }
        h1 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 20px; }
        h2 { color: #34495e; margin-top: 40px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
        h3 { color: #2980b9; margin-top: 30px; }
        p { margin-bottom: 15px; }
        ul { list-style-type: disc; margin-left: 20px; margin-bottom: 15px; }
        code { background-color: #f8f9fa; padding: 2px 6px; border-radius: 4px; font-family: monospace; color: #e74c3c; }
        .sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 250px; background: #fff; padding: 20px; overflow-y: auto; border-right: 1px solid #ccc; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        .sidebar h2 { font-size: 18px; color: #2c3e50; margin-bottom: 10px; }
        .sidebar ul { list-style: none; margin: 0; padding: 0; }
        .sidebar li { margin-bottom: 10px; }
        .sidebar a { text-decoration: none; color: #2980b9; font-weight: bold; }
        .sidebar a:hover { text-decoration: underline; }
        .main-content { margin-left: 270px; max-width: 800px; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        .guide-step { margin-bottom: 40px; padding: 20px; background: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .guide-step p, .guide-step ul { color: #555; }
        .guide-step strong { color: #333; }
        .version-info { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.1); color: #333; padding: 4px 8px; border-radius: 4px; font-size: 0.75em; font-family: monospace; z-index: 999; opacity: 0.7; transition: opacity 0.3s ease; }
        .version-info:hover { opacity: 1; background: rgba(0,0,0,0.2); }
        footer { position: fixed; bottom: 10px; right: 10px; z-index: 999; text-align: center; font-size: 0.8em; color: #777; }
        .sql-code { background: #f6f8fa; color: #24292e; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.4; margin: 15px 0; overflow-x: auto; border-left: 4px solid #0366d6; }
        .sql-keyword { color: #0366d6; font-weight: bold; }
        .sql-string { color: #032f62; }
        .sql-comment { color: #6a737d; font-style: italic; }
        .performance-level { margin: 20px 0; padding: 20px; border-radius: 8px; border-left: 5px solid; }
        .walk-level { background: #fff5f5; border-color: #fc8181; }
        .crawl-level { background: #fffaf0; border-color: #f6ad55; }
        .run-level { background: #f0fff4; border-color: #68d391; }
        .level-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; }
        .level-icon { margin-right: 10px; font-size: 20px; }
        img { max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; margin: 15px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>Topics</h2>
        <ul>
            <li><strong>How To:</strong></li>
            <li style="margin-left: 20px;"><a href="#breakdown">Query Breakdown</a></li>
            <li style="margin-left: 20px;"><a href="#readStats">Understanding the Stats</a></li>
            <li><strong>Stats Glossary:</strong></li>
            <li style="margin-left: 20px;"><a href="#kernTime">kernTime</a></li>
            <li style="margin-left: 20px;"><a href="#serviceTime">serviceTime</a></li>
            <li style="margin-left: 20px;"><a href="#elapsedTime">elapsedTime</a></li>
            <li style="margin-left: 20px;"><a href="#cpuTime">cpuTime</a></li>
            <li style="margin-left: 20px;"><a href="#requestStats">Request Stats</a></li>
            <li style="margin-left: 20px;"><a href="#statementStats">Statement Stats</a></li>
        </ul>
    </div>
    
    <div class="main-content">
        <h1>How to Debug & Glossary - Beta/Draft</h1>
        <div class="guide-step" id="breakdown">
            <h2>Query Performance Optimization: Crawl, Walk, Run Approach</h2>
            <p>Optimizing Couchbase queries follows a progressive approach - start simple, then incrementally improve. Each step builds upon the previous one to achieve better performance.</p>

            <div class="performance-level walk-level">
                <div class="level-title">
                    <span class="level-icon">üçº</span>
                    CRAWL: Basic Index Strategy
                </div>
                <img src="img/full_index.png" alt="Basic index query execution flow">

                <p>Start with a simple index that covers your most common filter conditions. This establishes baseline performance and ensures your queries can use indexes instead of full bucket scans.</p>
                
                <div class="sql-code">
<span class="sql-keyword">CREATE INDEX</span> <span class="sql-string">`allTypes`</span> <span class="sql-keyword">ON</span> <span class="sql-string">`bucket`</span>(<span class="sql-string">`type`</span>);
                </div>

                <p><strong>General steps in a SQL++ query execution:</strong></p>
                <ol>
                    <li><strong>Plan</strong> - Query engine creates execution plan</li>
                    <li><strong>Index Scan</strong> - Scan the index for matching keys</li>
                    <li><strong>Document Fetch</strong> - Retrieve full documents from data service</li>
                    <li><strong>Filter</strong> - Apply remaining WHERE conditions</li>
                    <li><strong>Project</strong> - Select only requested fields</li>
                    <li><strong>Stream</strong> - Return results to client</li>
                </ol>

                <p><strong>Example query:</strong></p>
                <div class="sql-code">
<span class="sql-keyword">SELECT</span> * <span class="sql-keyword">FROM</span> <span class="sql-string">`bucket`</span> 
<span class="sql-keyword">WHERE</span> <span class="sql-string">`type`</span> = <span class="sql-string">"invoice"</span> 
  <span class="sql-keyword">AND</span> <span class="sql-string">`date`</span> = <span class="sql-string">"today"</span> 
        <span class="sql-keyword">AND</span> <span class="sql-string">`custId`</span> = <span class="sql-string">"12345"</span>
                </div>

                <p><strong>Performance characteristics:</strong> Basic index usage, requires document fetches, applies filters after retrieval.</p>
            </div>

            <div class="performance-level crawl-level">
                <div class="level-title">
                    <span class="level-icon">üö∂</span>
                    WALK: Composite Index with Filtering
                </div>

                <img src="img/reduced_index.png" alt="Composite index with reduced document fetches">
                <p>Create a composite index that matches your WHERE clause more precisely. This reduces the number of documents that need to be fetched and filtered.</p>

                <div class="sql-code">
<span class="sql-keyword">CREATE INDEX</span> <span class="sql-string">`custInvoices_v1`</span> <span class="sql-keyword">ON</span> <span class="sql-string">`bucket`</span>(<span class="sql-string">`date`</span>, <span class="sql-string">`custId`</span>) 
<span class="sql-keyword">WHERE</span> <span class="sql-string">`type`</span> = <span class="sql-string">"invoice"</span>
                </div>

                <p><strong>Key improvements:</strong></p>
                <ul>
                    <li>Smaller index size due to WHERE filter</li>
                    <li>Index provides pre-filtered document list</li>
                    <li>Fewer document fetches required</li>
                    <li>More efficient memory usage</li>
                </ul>

                <p><strong>Performance characteristics:</strong> Reduced I/O, fewer document fetches, faster filtering.</p>
            </div>

            <div class="performance-level run-level">
                <div class="level-title">
                    <span class="level-icon">üèÉ</span>
                    RUN: Covering Index Strategy
                </div>

                <img src="img/covered_index.png" alt="Covering index with no document fetches">
                <p>Create a covering index that includes all fields needed by your query. This eliminates document fetches entirely, providing maximum performance.</p>

                <p><strong>First, optimize your SELECT to only request needed fields:</strong></p>
                <div class="sql-code">
<span class="sql-keyword">SELECT</span> invoiceId, status, orderTotal, discounts 
<span class="sql-keyword">FROM</span> <span class="sql-string">`bucket`</span> 
<span class="sql-keyword">WHERE</span> <span class="sql-string">`type`</span> = <span class="sql-string">"invoice"</span> 
  <span class="sql-keyword">AND</span> <span class="sql-string">`date`</span> = <span class="sql-string">"today"</span> 
  <span class="sql-keyword">AND</span> <span class="sql-string">`custId`</span> = <span class="sql-string">"12345"</span>
                </div>

                <p><strong>Then create a covering index with proper field ordering:</strong></p>
                <div class="sql-code">
<span class="sql-keyword">CREATE INDEX</span> <span class="sql-string">`custInvoicesShort_v1`</span> <span class="sql-keyword">ON</span> <span class="sql-string">`bucket`</span>(
    <span class="sql-string">`custId`</span>, <span class="sql-string">`date`</span>,              <span class="sql-comment">-- Filter fields: highest cardinality first</span>
    <span class="sql-string">`invoiceId`</span>, <span class="sql-string">`status`</span>, <span class="sql-string">`orderTotal`</span>, <span class="sql-string">`discounts`</span>  <span class="sql-comment">-- SELECT fields at end</span>
) <span class="sql-keyword">WHERE</span> <span class="sql-string">`type`</span> = <span class="sql-string">"invoice"</span>
                </div>

                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 15px; margin: 15px 0;">
                    <h4 style="color: #856404; margin-top: 0;">üéØ Index Field Ordering Strategy</h4>
                    <p style="color: #664d03; margin-bottom: 10px;"><strong>Cardinality Rule:</strong> Place fields with highest cardinality (most unique values) first in filter section.</p>
                    <ul style="color: #664d03; margin-bottom: 0;">
                        <li><strong>custId</strong> (high cardinality) - thousands of unique customers</li>
                        <li><strong>date</strong> (medium cardinality) - limited date range values</li>
                        <li><strong>type</strong> (low cardinality) - handled by WHERE clause</li>
                    </ul>
                    <p style="color: #664d03; margin: 10px 0 0;"><strong>Result:</strong> Index scans fewer entries = faster performance</p>
                </div>

                <p><strong>üîë Key Principles:</strong></p>
                <ul>
                    <li>Place fields with <strong>highest cardinality first</strong> in filter section</li>
                    <li>Place <strong>SELECT fields at the end</strong> to create covering index</li>
                    <li>Use <strong>WHERE clause filters</strong> for low cardinality fields</li>
                </ul>

                <p><strong>Performance benefits:</strong></p>
                <ul>
                    <li><strong>Zero document fetches</strong> - All data comes from index</li>
                    <li><strong>Minimal network I/O</strong> - No KV service calls</li>
                    <li><strong>Fastest execution</strong> - Index-only operations</li>
                    <li><strong>Predictable performance</strong> - No dependency on document size</li>
                </ul>

            

                <p><strong>Performance characteristics:</strong> Index-only execution, minimal I/O, maximum throughput.</p>
            </div>

            <div style="background: #e6fffa; border: 1px solid #4fd1c7; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="color: #234e52; margin-top: 0;">üéØ Query Tuning Best Practices</h3>
                <ul style="color: #2d3748;">
                    <li><strong>Start Simple:</strong> Begin with basic indexes, measure performance</li>
                    <li><strong>Measure Impact:</strong> Use <code>EXPLAIN</code> and profiling data to validate improvements</li>
                    <li><strong>Index Strategy:</strong> Filter fields first, then SELECT fields for covering</li>
                    <li><strong>Iterative Approach:</strong> Make one change at a time, measure results</li>
                    <li><strong>Monitor Resources:</strong> Watch CPU, memory, and I/O patterns after changes</li>
                </ul>
            </div>
        </div>
       
         <div class="guide-step" id="readStats">
            <h2>üìä Understanding Query Statistics: Connecting Performance Data to Execution</h2>
            <p>The statistics table in our tool provides crucial performance metrics that directly correspond to the optimization levels shown above. Understanding these metrics helps you identify bottlenecks and measure the impact of your Walk ‚Üí Crawl ‚Üí Run improvements.</p>

            <img src="img/stats_to_plan.png" alt="Query statistics table showing performance metrics">

            <h3>üîç Key Statistics Breakdown</h3>
            
            <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-top: 0;">Timing Metrics (Click for detailed explanations)</h4>
                <ul style="line-height: 2;">
                    <li><strong><a href="#elapsedTime" style="color: #e74c3c;">elapsedTime</a></strong> - Total wall-clock time from request acknowledgment to completion</li>
                    <li><strong><a href="#serviceTime" style="color: #e67e22;">serviceTime</a></strong> - Active execution time (also called executionTime in some contexts)</li>
                    <li><strong><a href="#cpuTime" style="color: #f39c12;">cpuTime</a></strong> - Cumulative CPU consumption across all query threads</li>
                    <li><strong><a href="#kernTime" style="color: #3498db;">kernTime</a></strong> - Time spent waiting for CPU scheduling by the OS kernel</li>
                </ul>
            </div>

            <div style="background: #eef7ff; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-top: 0;">Execution Metrics</h4>
                <ul style="line-height: 1.8;">
                    <li><strong>resultCount</strong> - Number of documents returned to the client</li>
                    <li><strong>resultSize</strong> - Total size in bytes of the result set</li>
                    <li><strong>errorCount</strong> - Number of errors encountered during execution</li>
                    <li><strong>usedMemory</strong> - Peak memory consumption during query execution (in bytes)</li>
                </ul>
            </div>

            <div style="background: #f0f9ff; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-top: 0;">Phase-Level Metrics</h4>
                <ul style="line-height: 1.8;">
                    <li><strong>phaseCounts</strong> - Count of items processed in each phase (fetch, indexScan, sort, etc.)</li>
                    <li><strong>phaseOperators</strong> - Number of operators used in each phase</li>
                    <li><strong>phaseTimes</strong> - Time spent in each query execution phase</li>
                </ul>
                <p style="margin-top: 15px; font-size: 14px; color: #666;">
                    <strong>Common Phase Types:</strong> 
                    <code>indexScan</code>, <code>fetch</code>, <code>project</code>, <code>sort</code>, <code>authorize</code>, <code>parse</code>, <code>plan</code>, <code>run</code>, <code>stream</code>
                </p>
                
                <div style="background: #e8f5e8; border: 1px solid #4caf50; border-radius: 6px; padding: 12px; margin: 12px 0;">
                    <h5 style="color: #2e7d32; margin-top: 0; margin-bottom: 8px;">üîç Operator-Level Details</h5>
                    <p style="color: #388e3c; font-size: 13px; margin: 0;">For detailed breakdowns, enable profiling with <code>profile="timings"</code>. This exposes operator-level metrics:</p>
                    <ul style="color: #388e3c; font-size: 13px; margin: 5px 0 0 15px;">
                        <li><strong>execTime</strong> - Code execution time within operators</li>
                        <li><strong>servTime</strong> - Time waiting on services (KV, Index)</li>
                        <li><strong>kernTime</strong> - OS scheduling overhead per operator</li>
                    </ul>
                </div>
            </div>

            <h3>üéØ Connecting Statistics to Optimization Levels</h3>
            
            <div class="performance-level walk-level">
                <div class="level-title">
                    <span class="level-icon">üçº</span>
                    CRAWL Level Statistics
                </div>
                <p><strong>What to expect:</strong> High <code>phaseCounts.fetch</code>, high <code>resultSize</code>, moderate <code>serviceTime</code></p>
                <ul>
                    <li><strong>phaseCounts.fetch</strong> will be high - every matching document requires a KV fetch</li>
                    <li><strong>resultSize</strong> large due to fetching full documents</li>
                    <li>Higher <a href="#serviceTime">serviceTime</a> due to document fetch overhead</li>
                    <li><strong>phaseTimes.fetch</strong> dominates execution time</li>
                </ul>
            </div>

            <div class="performance-level crawl-level">
                <div class="level-title">
                    <span class="level-icon">üö∂</span>
                    WALK Level Statistics
                </div>
                <p><strong>What to expect:</strong> Reduced <code>phaseCounts.fetch</code>, targeted <code>phaseCounts.indexScan</code>, improved <code>serviceTime</code></p>
                <ul>
                    <li><strong>phaseCounts.fetch</strong> decreases - composite index pre-filters documents</li>
                    <li><strong>phaseCounts.indexScan</strong> is more efficient due to targeted scanning</li>
                    <li>Better <a href="#serviceTime">serviceTime</a> from reduced I/O operations</li>
                    <li><strong>phaseTimes.indexScan</strong> becomes smaller relative to fetch time</li>
                </ul>
            </div>

            <div class="performance-level run-level">
                <div class="level-title">
                    <span class="level-icon">üèÉ</span>
                    RUN Level Statistics
                </div>
                <p><strong>What to expect:</strong> Zero <code>phaseCounts.fetch</code>, minimal <code>resultSize</code>, optimal <code>serviceTime</code></p>
                <ul>
                    <li><strong>phaseCounts.fetch = 0</strong> - Covering index eliminates all document fetches</li>
                    <li><strong>resultSize</strong> minimal - only selected fields returned</li>
                    <li>Minimal <a href="#serviceTime">serviceTime</a> with index-only operations</li>
                    <li>Low <a href="#kernTime">kernTime</a> due to reduced resource contention</li>
                    <li><strong>phaseTimes.fetch</strong> absent or near zero</li>
                </ul>
            </div>

            <div style="background: #fff8e1; border: 1px solid #ffb74d; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="color: #e65100; margin-top: 0;">‚ö° Performance Analysis Tips</h3>
                <ul style="color: #2d3748;">
                    <li><strong>High <a href="#kernTime">kernTime</a>:</strong> CPU contention - check system load and thread counts</li>
                    <li><strong>High phaseCounts.fetch:</strong> Missing covering indexes - implement RUN level optimization</li>
                    <li><strong>Large resultSize relative to resultCount:</strong> Inefficient indexing - move to WALK or RUN level</li>
                    <li><strong>High <a href="#elapsedTime">elapsedTime</a> vs <a href="#serviceTime">serviceTime</a>:</strong> Queuing delays - scale query nodes</li>
                    <li><strong>High <a href="#cpuTime">cpuTime</a>:</strong> CPU-intensive operations - optimize query logic or add cores</li>
                    <li><strong>Large phaseTimes.fetch:</strong> Document fetch bottleneck - consider covering indexes</li>
                </ul>
            </div>

            <div style="background: #e8f5e8; border: 1px solid #4caf50; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="color: #2e7d32; margin-top: 0;">üìà Measuring Optimization Success</h3>
                <p><strong>Track these key improvements as you progress through optimization levels:</strong></p>
                <ul style="color: #2d3748;">
                    <li><strong>CRAWL ‚Üí WALK:</strong> Watch for 30-50% reduction in <code>phaseCounts.fetch</code> and <code>phaseTimes.fetch</code></li>
                    <li><strong>WALK ‚Üí RUN:</strong> Achieve <code>phaseCounts.fetch = 0</code> and 70-90% reduction in <code>serviceTime</code></li>
                    <li><strong>Overall Success:</strong> Lower <a href="#elapsedTime">elapsedTime</a>, reduced <a href="#kernTime">kernTime</a>, consistent <code>resultCount</code></li>
                    <li><strong>Efficiency Gains:</strong> Lower <code>resultSize</code>-to-<code>resultCount</code> ratio, minimal <code>usedMemory</code></li>
                </ul>
            </div>
         </div>

        <div class="guide-step" id="kernTime">
            <h2>-- `kernTime`</h2>
            <p>KernelTime (often abbreviated as <code>kernTime</code> in query profiling statistics) refers to the amount of time a query operator or phase spends waiting to be scheduled for execution on a CPU core by the operating system's kernel. This is essentially idle time due to scheduling delays in a multi-threaded environment, where multiple threads or processes are competing for limited CPU resources. It's not time spent doing actual computation or waiting on external services (like data fetches or index scans); instead, it's the overhead from the system deciding when and how to allocate CPU cycles to the query's threads.</p>
            <p>Think of it like this: Imagine a busy highway with more cars (threads) than lanes (CPU cores). KernelTime is the time your car (the query) spends stopped or slowed down in traffic, waiting for a lane to open up, rather than driving forward productively.</p>
            
            <h3>What a High KernelTime Means for a Slow Query</h3>
            <p>A high KernelTime indicates that CPU contention is a primary bottleneck contributing to the query's slowness. This doesn't mean the query itself is inefficient in terms of logic or data access‚Äîinstead, it points to systemic issues on the query node or cluster, such as:</p>
            <ul>
                <li><strong>Overloaded CPU resources</strong>: Too many concurrent queries, threads, or background processes (e.g., garbage collection, other services) are vying for CPU time, causing scheduling delays.</li>
                <li><strong>Insufficient CPU cores</strong>: The node might have fewer logical cores than needed for the workload, leading to frequent context switches and queuing.</li>
                <li><strong>High thread counts</strong>: As seen in system:vitals (e.g., <code>total.threads</code>), an excessive number of active threads can exacerbate scheduling overhead.</li>
                <li><strong>Resource imbalance</strong>: If CPU utilization (from system:vitals, like <code>cpu.user.percent</code> or <code>cpu.sys.percent</code>) is consistently high, or if the load factor is elevated, this amplifies KernelTime.</li>
            </ul>
            <p>In profiling data (e.g., from system:active_requests or meta().plan), compare KernelTime to other metrics like <code>execTime</code> (actual computation time in the query engine) and <code>servTime</code> (time waiting on services like KV or indexes). If KernelTime dominates, the query isn't slow because of data volume or complex operations‚Äîit's slow because it's starved for CPU. To diagnose:</p>
            <ul>
                <li>Check system:vitals for CPU metrics, thread counts, and garbage collection pauses.</li>
                <li>Look at phaseTimes in active/completed requests to see which phases (e.g., fetch, sort) have high KernelTime.</li>
                <li>Monitor for patterns across queries; if many show high KernelTime, scale up CPU resources, reduce concurrency, or isolate workloads.</li>
            </ul>
            
            <h3>Example: If KernelTime Equals 99% of ServiceTime</h3>
            <p>ServiceTime is the total wall-clock (calendar) time taken to complete the query, from start to finish. If KernelTime accounts for 99% of this (e.g., ServiceTime = 10 seconds, KernelTime = 9.9 seconds), it strongly indicates severe CPU overload or contention on the query node. Practically, this means:</p>
            <ul>
                <li>The query is doing almost no useful work‚Äîonly about 1% of the time is spent on actual execution (<code>execTime</code>) or service calls (<code>servTime</code>).</li>
                <li>The system is thrashing: Threads are constantly being paused and rescheduled, leading to inefficiency and potential cascading slowdowns across the cluster.</li>
                <li>Root causes could include an under-provisioned node (low <code>cores</code> in system:vitals), too many active requests (<code>request.active.count</code>), or external factors like high garbage collection (<code>gc.pause.percent</code>).</li>
                <li>Implications: This query (and others) will perform poorly until CPU pressure is relieved. Recommendations include adding more query nodes, optimizing query concurrency (e.g., via request quotas), or investigating non-query processes consuming CPU. Use tools like system:active_requests to terminate long-running queries contributing to the overload.</li>
            </ul>
        </div>
        
        <div class="guide-step" id="serviceTime">
            <h2>-- `serviceTime` / `executionTime`</h2>
            <p>ServiceTime (also called executionTime in some Couchbase contexts) refers to the total wall-clock time taken for active query execution within the query service. This metric captures the duration from when the query begins execution until it finishes, including time spent on computation, waiting for internal services like indexes or key-value stores, and other execution activities. It excludes initial queuing or scheduling delays.</p>
            
            <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h4 style="color: #856404; margin-top: 0;">üìù Terminology Note</h4>
                <p style="color: #664d03; margin: 0;"><strong>serviceTime vs executionTime:</strong> Couchbase uses both terms. "executionTime" is more common in meta() profiling and newer docs, while "serviceTime" appears in system:completed_requests. They represent the same concept - active execution time.</p>
            </div>
            <p>Think of it like this: Imagine baking a cake‚ÄîServiceTime is the total time the cake is in the oven, including preheating and cooling phases, but not the time spent gathering ingredients beforehand.</p>
            
            <h3>What a High ServiceTime Means for a Slow Query</h3>
            <p>A high ServiceTime indicates that the query execution phase itself is the main contributor to slowness, often due to operational complexities or dependencies on other services. This could stem from issues within the query processing, such as:</p>
            <ul>
                <li><strong>Complex query operations</strong>: Large data scans, intricate joins, sorts, or aggregations that require significant processing.</li>
                <li><strong>Delays in dependent services</strong>: Waiting on the indexer (GSI) for scans or the KV store for fetches, as reflected in <code>servTime</code>.</li>
                <li><strong>Resource contention within services</strong>: High load on index or data nodes leading to slower responses.</li>
                <li><strong>Inefficient query plan</strong>: Suboptimal index usage or lack of covering indexes, forcing more work during execution.</li>
            </ul>
            <p>In profiling data (e.g., from system:completed_requests or executionTimings), compare ServiceTime to metrics like <code>execTime</code> (computation time) and <code>servTime</code> (service waits). If ServiceTime is dominated by <code>servTime</code>, the bottleneck is external services; if by <code>execTime</code>, it's internal computation. To diagnose:</p>
            <ul>
                <li>Review phaseTimes and phaseOperators to identify slow phases (e.g., fetch or indexScan).</li>
                <li>Check system:vitals for service-related metrics like memory usage or network utilization.</li>
                <li>Analyze patterns in completed requests; if many queries show high ServiceTime, optimize indexes, tune query plans, or scale service resources.</li>
            </ul>
            
            <h3>Example: If ServiceTime Equals 99% of ElapsedTime</h3>
            <p>ElapsedTime is the total time from query acknowledgment to completion, including scheduling. If ServiceTime accounts for 99% of this (e.g., ElapsedTime = 10 seconds, ServiceTime = 9.9 seconds), it means minimal queuing delay, and the slowness is almost entirely due to execution. Practically, this means:</p>
            <ul>
                <li>The query spends nearly all its time in active processing, with little wait before starting.</li>
                <li>Potential overload in execution resources, leading to prolonged runs and reduced throughput.</li>
                <li>Root causes could include inefficient queries, large datasets, or stressed index/KV services.</li>
                <li>Implications: Queries will remain slow without optimization. Recommendations include rewriting queries for efficiency, creating better indexes, or distributing load across more nodes. Use tools like EXPLAIN or profiling to pinpoint and refactor slow operators.</li>
            </ul>
        </div>
        
        <div class="guide-step" id="elapsedTime">
            <h2>-- `elapsedTime`</h2>
            <p>ElapsedTime refers to the total time from when the query request is acknowledged by the query service until the request is completed and results are ready. This encompasses queuing or scheduling delays before execution, plus the active ServiceTime. It's an end-to-end wall-clock measure of how long the entire process takes from the service's perspective.</p>
            <p>Think of it like this: Imagine ordering food delivery‚ÄîElapsedTime is the total wait from placing the order until it arrives, including time in the restaurant's queue and cooking/delivery time.</p>
            
            <h3>What a High ElapsedTime Means for a Slow Query</h3>
            <p>A high ElapsedTime signals overall delays in query handling, which could be due to pre-execution queuing or slow execution. This points to broader system or workload issues, such as:</p>
            <ul>
                <li><strong>Queue backlogs</strong>: Too many concurrent requests overwhelming the service, as indicated by high <code>request.queued.count</code>.</li>
                <li><strong>Scheduling overhead</strong>: Delays in assigning resources, often linked to high load or limited servicers.</li>
                <li><strong>Execution bottlenecks</strong>: If close to ServiceTime, the issue is in processing; otherwise, it's queuing.</li>
                <li><strong>Cluster-wide pressure</strong>: High CPU, memory, or network usage affecting acknowledgment-to-completion flow.</li>
            </ul>
            <p>In metrics (e.g., from system:active_requests), compare ElapsedTime to ServiceTime‚Äîif ElapsedTime is much higher, queuing is the culprit. Also check <code>request_time</code> percentiles for trends. To diagnose:</p>
            <ul>
                <li>Monitor system:vitals for request rates and queue counts.</li>
                <li>Examine active_requests for stuck queries contributing to backlogs.</li>
                <li>Look for patterns; if widespread, increase servicers, add nodes, or limit concurrency via quotas.</li>
            </ul>
            
            <h3>Example: If ElapsedTime is Significantly Higher Than ServiceTime</h3>
            <p>For instance, if ElapsedTime = 10 seconds and ServiceTime = 2 seconds, it means 80% of the time (8 seconds) was spent waiting in queue. This indicates severe overload. Practically, this means:</p>
            <ul>
                <li>Queries are bottlenecked before even starting, reducing effective throughput.</li>
                <li>The system appears unresponsive, as requests pile up.</li>
                <li>Root causes could include insufficient servicers (defaults to 4x cores) or bursty workloads.</li>
                <li>Implications: Performance degrades under load. Recommendations include scaling query nodes, tuning servicers, or using prepared statements to reduce overhead. Terminate queued queries via system:active_requests if needed.</li>
            </ul>
        </div>
        
        <div class="guide-step" id="cpuTime">
            <h2>-- `cpuTime`</h2>
            <p>CPUTime refers to the cumulative time spent by the query consuming CPU resources during its execution. This metric aggregates the CPU usage across all threads involved in processing the query, including both user-level computations in the query engine and system-level operations. It's a measure of the query's CPU footprint, often reflecting the intensity of operations like sorting or filtering.</p>
            
            <div style="background: #e1f5fe; border: 1px solid #03a9f4; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h4 style="color: #01579b; margin-top: 0;">‚ÑπÔ∏è Availability Note</h4>
                <p style="color: #0277bd; margin: 0;"><strong>cpuTime availability:</strong> This metric is primarily available through system monitoring catalogs (system:active_requests, system:completed_requests). It may not appear in basic query meta() output without additional profiling enabled.</p>
            </div>
            <p>Think of it like this: Imagine running a marathon‚ÄîCPUTime is the total effort (energy) expended by the runner, which may exceed the race time if accounting for all movements, but in queries, it's the CPU "work" done.</p>
            
            <h3>What a High CPUTime Means for a Slow Query</h3>
            <p>A high CPUTime suggests the query is CPU-bound, consuming significant processor resources, which can lead to slowness if CPUs are contended. This doesn't always correlate directly with wall-clock time in parallel environments but indicates issues like:</p>
            <ul>
                <li><strong>CPU-intensive operations</strong>: Heavy computations, large sorts, or aggregations without proper optimization.</li>
                <li><strong>Parallelism overhead</strong>: Multi-threaded execution where total CPU exceeds wall time.</li>
                <li><strong>System-wide CPU strain</strong>: Combined with high <code>cpu.user.percent</code> or <code>cpu.sys.percent</code>, it points to overload.</li>
                <li><strong>Inefficient code paths</strong>: Loops or functions in user-defined functions eating CPU.</li>
            </ul>
            <p>In profiling (e.g., executionTimings), relate CPUTime to <code>execTime</code> across operators. If high, the query is computation-heavy. To diagnose:</p>
            <ul>
                <li>Check system:vitals for overall CPU metrics and gc pauses.</li>
                <li>Analyze phaseTimes for CPU-heavy phases like project or sort.</li>
                <li>Monitor across queries; if aggregate CPUTime is high, upgrade hardware or optimize queries.</li>
            </ul>
            
            <h3>Example: If CPUTime Equals 99% of ServiceTime</h3>
            <p>ServiceTime is wall-clock execution time. If CPUTime is 99% of this (e.g., ServiceTime = 10 seconds, CPUTime = 9.9 seconds), it means the query is almost fully CPU-bound with minimal waits. Practically, this means:</p>
            <ul>
                <li>Nearly all time is spent computing, with little I/O or service delay.</li>
                <li>The system is efficient in scheduling but the workload is processor-intensive.</li>
                <li>Root causes could include unoptimized expressions or large in-memory operations.</li>
                <li>Implications: CPU becomes the limiting factor. Recommendations include simplifying queries, using indexes to reduce data, or leveraging more cores. Watch for heat on nodes and balance load.</li>
            </ul>
        </div>
        
        <div class="guide-step" id="requestStats">
            <h2>üìä Request Statistics Glossary</h2>
            <p>Comprehensive reference for all request-level statistics available in Couchbase query monitoring. These metrics are sourced from the <a href="https://docs.couchbase.com/server/current/n1ql/n1ql-rest-api/admin.html#_requests" target="_blank">Couchbase N1QL REST API documentation</a>.</p>
            
            <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Request Identification & Context</h3>
                <ul style="line-height: 1.8;">
                    <li><strong>clientContextID</strong> - The opaque ID or context provided by the client application for request tracking</li>
                    <li><strong>requestId</strong> - Unique UUID internally generated for each query request</li>
                    <li><strong>requestTime</strong> - Timestamp when the query request was received by the service</li>
                    <li><strong>remoteAddr</strong> - IP address and port of the client application that sent the request</li>
                    <li><strong>node</strong> - IP address and port of the Couchbase node executing the query</li>
                    <li><strong>userAgent</strong> - Client application or program identifier that issued the query</li>
                    <li><strong>users</strong> - Username with whose privileges the query executes</li>
                </ul>
            </div>

            <div style="background: #eef7ff; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Core Performance Metrics</h3>
                <ul style="line-height: 1.8;">
                    <li><strong><a href="#elapsedTime">elapsedTime</a></strong> - Total time from request acknowledgment to completion, including scheduling overhead</li>
                    <li><strong><a href="#serviceTime">serviceTime</a></strong> - Calendar time spent actively executing the query (subset of <a href="#elapsedTime">elapsedTime</a>)</li>
                    <li><strong>scanConsistency</strong> - The scan consistency level used: unbounded, request_plus, or statement_plus</li>
                    <li><strong>state</strong> - Current execution state: completed, running, cancelled, timeout, or error</li>
                </ul>
            </div>

            <div style="background: #f0f9ff; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Result & Resource Metrics</h3>
                <ul style="line-height: 1.8;">
                    <li><strong>resultCount</strong> - Total number of documents returned in the query result set</li>
                    <li><strong>resultSize</strong> - Total bytes returned in the query result (larger = more data transferred)</li>
                    <li><strong>errorCount</strong> - Total number of errors encountered during query execution</li>
                    <li><strong>usedMemory</strong> - Peak document memory consumption in bytes (only shown when memory quota is set)</li>
                    <li><strong>memoryQuota</strong> - Memory quota for the request in MB (when configured)</li>
                </ul>
            </div>

            <div style="background: #fffbf0; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Execution Phase Details</h3>
                <ul style="line-height: 1.8;">
                    <li><strong>phaseCounts</strong> - Count of documents processed at each execution phase (fetch, indexScan, sort, etc.)</li>
                    <li><strong>phaseOperators</strong> - Number of each type of query operator used in different phases</li>
                    <li><strong>phaseTimes</strong> - Cumulative execution time breakdown by phase (authorize, parse, plan, run, stream)</li>
                </ul>
                <p style="margin-top: 15px; font-size: 14px; color: #666;">
                    <strong>Key Phase Types:</strong> authorize, parse, plan, instantiate, run, indexScan, fetch, project, sort, stream
                </p>
            </div>

            <div style="background: #f0fff4; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Query Configuration</h3>
                <ul style="line-height: 1.8;">
                    <li><strong>statement</strong> - The complete N1QL query text being executed</li>
                    <li><strong>useCBO</strong> - Boolean indicating if cost-based optimizer is enabled</li>
                    <li><strong>statementType</strong> - Type of SQL++ operation: SELECT, INSERT, UPDATE, DELETE, CREATE_INDEX, etc.</li>
                </ul>
            </div>
        </div>
        
        <div class="guide-step" id="statementStats">
            <h2>üìã Prepared Statement Statistics Glossary</h2>
            <p>Reference for prepared statement metrics that track performance across multiple executions. These help identify frequently-used queries and their performance patterns. Sourced from <a href="https://docs.couchbase.com/server/current/n1ql/n1ql-rest-api/admin.html#_requests" target="_blank">Couchbase N1QL REST API documentation</a>.</p>
            
            <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Statement Identity & Usage</h3>
                <ul style="line-height: 1.8;">
                    <li><strong>name</strong> - Prepared statement identifier (UUID or user-specified name)</li>
                    <li><strong>statement</strong> - The original N1QL query text that was prepared</li>
                    <li><strong>uses</strong> - Total execution count for this prepared statement</li>
                    <li><strong>lastUse</strong> - Date and time of most recent execution</li>
                    <li><strong>encoded_plan</strong> - Full prepared statement in encoded format for reuse</li>
                </ul>
            </div>

            <div style="background: #eef7ff; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Aggregate Performance Metrics</h3>
                <ul style="line-height: 1.8;">
                    <li><strong>avgElapsedTime</strong> - Mean time from acknowledgment to completion across all executions</li>
                    <li><strong>avgServiceTime</strong> - Mean active execution time (similar to <a href="#serviceTime">serviceTime</a>)</li>
                    <li><strong>minElapsedTime</strong> - Fastest execution time (best case performance)</li>
                    <li><strong>maxElapsedTime</strong> - Slowest execution time (worst case performance)</li>
                    <li><strong>minServiceTime</strong> - Minimum active execution time</li>
                    <li><strong>maxServiceTime</strong> - Maximum active execution time</li>
                </ul>
            </div>

            <div style="background: #fff8e1; border-radius: 8px; padding: 15px; margin: 20px 0;">
                <h3 style="color: #856404; margin-top: 0;">üí° Performance Analysis with Statement Stats</h3>
                <ul style="color: #664d03;">
                    <li><strong>High uses count:</strong> Indicates frequently executed queries - prime candidates for optimization</li>
                    <li><strong>Large avgElapsedTime vs avgServiceTime gap:</strong> Suggests queuing/scheduling issues</li>
                    <li><strong>Wide min/max ranges:</strong> Points to inconsistent performance - investigate data distribution</li>
                    <li><strong>Growing maxElapsedTime over time:</strong> May indicate resource pressure or data growth</li>
                </ul>
            </div>

            <div style="background: #f0f9ff; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Technical Support Fields</h3>
                <ul style="line-height: 1.8;">
                    <li><strong>featureControls</strong> - Internal feature flags (technical support use only)</li>
                    <li><strong>indexApiVersion</strong> - Index API version used (technical support use only)</li>
                </ul>
                <p style="margin-top: 15px; font-size: 14px; color: #666;">
                    <em>Note: These fields are provided for Couchbase technical support diagnosis and are not typically needed for performance analysis.</em>
                </p>
            </div>

            <div style="background: #e6fffa; border: 1px solid #4fd1c7; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="color: #234e52; margin-top: 0;">üîó Cross-Reference Guide</h3>
                <p style="color: #2d3748;">Understanding how metrics relate to optimization levels:</p>
                <ul style="color: #2d3748;">
                    <li><strong>Request <a href="#elapsedTime">elapsedTime</a> vs Statement avgElapsedTime:</strong> Compare single execution to historical average</li>
                    <li><strong>High phaseCounts.fetch:</strong> Look for covering index opportunities (see <a href="#breakdown">CRAWL ‚Üí WALK ‚Üí RUN approach</a>)</li>
                    <li><strong>Statement uses + high maxServiceTime:</strong> Priority candidates for <a href="#breakdown">index optimization</a></li>
                    <li><strong>Large resultSize with high <a href="#serviceTime">serviceTime</a>:</strong> Consider projection optimization</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="version-info">Beta/Draft - August 23, 2025</div>
    <footer>&copy; 2025 Debug Glossary</footer>
</body>
</html>
