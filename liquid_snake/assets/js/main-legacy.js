        // Global text constants - modify these for different languages
        const TEXT_CONSTANTS = {
        // Performance and logging messages
        PARSE_PERFORMANCE: "Parse performance:",
         PREPARED_TEXT: "Prepared:",
        CACHE_STATS: "Cache stats - parseTime:",
        ALL_CACHES_CLEARED: "All caches cleared for new JSON parse",
        LAZY_LOADED_TAB: "Lazy loaded",
        CHART_SAMPLING: "Chart sampling: Using",
        TIMELINE_CHARTS_USING: "Timeline charts: Using",
        REQUESTS_FOR_PERFORMANCE: "requests for performance",
        FILTERED_OUT_EARLY: "filtered out early",

        // Error messages
        JSON_PARSING_ERROR: "JSON parsing error:",
        ERROR_PROCESSING_REQUEST: "Error processing request",
        ERROR_GENERATING_UI: "Error generating UI:",
        ERROR_LAZY_LOADING: "Error lazy loading",

        // User messages and toasts
        PASTE_JSON_FIRST: "Please paste your JSON data first",
        INPUT_TOO_LARGE: "Input too large. Please use smaller datasets.",
        VALID_JSON_REQUIRED: "Please provide a valid JSON array or object with results.",
        NO_DATA_FOUND: "No data found in the JSON",
        UNEXPECTED_DATA_FORMAT: "Unexpected data format in JSON",
        ERROR_PARSING_JSON: "Error parsing JSON:",
        FILTERS_CHANGED_REMINDER: "‚ö†Ô∏è Filters changed. Click \"Analyze\" to apply changes.",

        // Chart and table captions
        SHOWING_TOP: "Showing top",
        OF_TOTAL: "of",
        USERS: "users",
        INDEXES: "indexes",
        REQUESTS: "requests",
        MS_FOR: "ms for",

        // Progress and status
        TAB_IN: "tab in",
        MS: "ms",

        // Operator modal and UI elements
        UNKNOWN: "Unknown",
        OPERATOR_LABEL: "Operator:",
        COPY_STATS: "Copy Stats",
        INDEX_USED: "Index Used:",
        COPY: "Copy",
        COPY_ALL: "Copy All",
        SHOW_MORE: "Show More",
        HIDE: "Hide",
        RESET_ZOOM: "Reset Zoom",

        // User interface messages
        COPIED_CLIPBOARD: "Copied to clipboard!",
        FAILED_COPY_CLIPBOARD: "Failed to copy to clipboard",
        COPIED: "Copied!",
        NO_EXECUTION_PLAN: "No execution plan available.",
        NO_OPERATORS_FOUND: "No operators found in the execution plan.",
        SELECT_QUERY_FLOW: "Select a query from the table to view the flow diagram.",
        STATEMENT_NOT_FOUND: "Statement not found",

        // Modal and plan display headers
        VIEW_DETAILED_PLAN: "View Detailed Execution Plan & Indexes/Keys Used",
        INDEXES_USED_HEADER: "üìã Indexes Used:",
        USE_KEYS_HEADER: "üîë USE KEYS:",
        EXECUTION_PLAN_HEADER: "‚öôÔ∏è Execution Plan:",
        KEYS_NOT_EXTRACTED: "Keys could not be extracted from the query",
        
        // Sample queries functionality
        SHOW_SAMPLE_QUERIES: "Show Sample Queries",
        HIDE_SAMPLE_QUERIES: "Hide Sample Queries",
        REQUEST_DATE: "Request Date",
        STATEMENT: "Statement",
        STATEMENT_UNIQUE: "Statement (unique)",

        // Console log messages
        COLLECTED_INDEX_DATA: "Collected index data for timing analysis:",
        INDEX_ANALYSIS_INITIALIZED: "‚úÖ Index analysis initialized",
        INITIALIZING_ANALYZER: "üöÄ Initializing Couchbase Query Analyzer...",
        FEATURES: "üîß Features:",
        ANALYZER_INITIALIZED: "‚úÖ Query Analyzer initialized successfully",
        TIP_ABOUT: "üí° Tip: Type QueryAnalyzer.about() for full app info",

        // Chart and table labels
        QUERY_DURATION_CHART_TITLE: "Query Duration by Statement Type (Bubble Size = Query Count)",
        USER_COUNT: "user: (count)",
        STATE_FATAL: "state\nfatal",
        COUNT_LABEL: "Count:",
        AVG_LABEL: "Avg:",
        MIN_LABEL: "Min:",
        MAX_LABEL: "Max:",
        FATAL_LABEL: "Fatal:",
        ELAPSED_LABEL: "Elapsed:",
        SWITCHED_TO: "Switched to",
        QUERY_GROUP_PHASE_TIMES_TITLE: "Phase Times by Query Group (avg)",
        PHASE_AUTHORIZE: "Authorize",
        PHASE_PARSE: "Parse",
        PHASE_PLAN: "Plan",
        PHASE_INDEX_SCAN: "Index Scan",
        PHASE_FETCH: "Doc Fetch",
        PHASE_FILTER: "Filter",
        PHASE_JOIN: "JOIN",
        PHASE_PROJECT: "Project",
        PHASE_DELETE_UPDATE: "DELETE / UPDATE",
        PHASE_DELETE: "DELETE",
        PHASE_UPDATE: "UPDATE",
        PHASE_INSERT: "INSERT",
        PHASE_STREAM: "Stream",
                PHASE_SORT: "ORDER BY",
        PHASE_GROUP_AGG: "GROUP BY",
        PHASE_LIMIT: "LIMIT",
        PHASE_NEST: "Nest/Unnest",
        AXIS_QUERY_PHASE: "Query Phase",
        AXIS_TIME_MS: "Time (ms)",

        // Phase timeline note (approximate)
        PHASE_TIMELINE_NOTE: "Approximate phase positions: many steps run concurrently and asynchronously; bars show average timing, not exact start times.",
 
            // Technical constants (DO NOT TRANSLATE - used in logic checks)
                N_A: "N/A",
                NO_DATA: "No data",
                LOADING: "Loading...",

            // Timezone selection
                TIMEZONE_LABEL: "Timezone:",
                TIMEZONE_DETECTED: "Detected:",
                TIMEZONE_UTC: "UTC",
                TIMEZONE_AUTO_DETECTED: "Auto-detected from data",

            // Input panel toggle
                SHOW_INPUT_PANEL: "Show",
                HIDE_INPUT_PANEL: "Hide",
                TOGGLE_INPUT_TOOLTIP: "‚Üê Click to Show/Hide Data & Filters",

            // Help badge
                HELP_DEBUG_TIPS: "NEED HELP? Debugging + Tool Tips ‚Äî Click Here",

            // Bug report CTA
                BUG_REPORT_CTA: "Report a Bug Click Here",

            // File upload UI + messages
                UPLOAD_JSON: "Upload .json",
                INVALID_FILE_TYPE: "Please select a .json file",
                FILE_READ_ERROR: "Error reading file",
                PASTE_OVERRIDES_UPLOAD: "Pasted JSON overrides uploaded file; cleared file selection",
                OR_LABEL: "OR",

            // Input section headers
            COMPLETED_JSON_HEADER: "Completed Requests JSON (system:completed_requests)",
            INDEXES_JSON_HEADER: "Indexes JSON (system:indexes output)",

                        // New features (v3.17.1+)
                WHOLE_RECORD: "Whole Record",
                REQUEST_ID: "Request ID",
                ENTER_REQUEST_ID: "Enter requestId",
                LOAD: "Load",
                RECORD_NOT_FOUND: "Request ID not found",
                VIEW_WHOLE_RECORD: "View Whole Record",
                COPY_REQUEST_ID: "Copy Request ID"
            };
// Extend TEXT_CONSTANTS with Report Maker strings (Phase 1)
if (window.TEXT_CONSTANTS) {
  Object.assign(TEXT_CONSTANTS, {
  REPORT_MAKER: "Report Maker",
  SELECT_SECTIONS: "Select sections",
  SELECT_TIMELINE_CHARTS: "Select Timeline charts",
  INCLUDE_HEADER_SUMMARY: "Include header summary",
  INCLUDE_FILTERS: "Include filters applied",
  FLATTEN_TABLES_FOR_PRINT: "Flatten scrollable tables for print",
  CONVERT_CHARTS_TO_IMAGES: "Convert charts to images for printing",
  PREVIEW_REPORT: "Preview Report",
  PRINT_SAVE_PDF: "Print / Save PDF",
  EXIT_REPORT_MODE: "Exit Report Mode",
  LOAD_TEST_SAMPLE: "Load test sample JSON",
  REPORT_GENERATED_AT: "Generated at",
  REPORT_TIME_RANGE: "Range",
  REPORT_FILTERS_APPLIED: "Filter",
  REPORT_OPTIONS: "Options",
  EXIT_REPORT_PREVIEW: "EXIT REPORT PREVIEW",
  COVER_TITLE: "Couchbase Query Analysis Report",
  COVER_SECTIONS_INCLUDED: "Sections included",
  COVER_TIMELINE_CHARTS: "Timeline charts",
  COVER_FILTERS_APPLIED: "Filters applied",
  COVER_TIME_RANGE: "Time range",
  COVER_DATA_COUNTS: "Data counts",
  COVER_NOTES: "Notes",
  COVER_BETA_NOTE: "Some charts marked Beta/Dev may display incomplete or placeholder content.",

    // Cover page rich content blocks (English)
     COVER_BLOCK_DASHBOARD_HTML: "<div class=\"section\"><h3>Dashboard</h3><p>High-level overview with draggable charts showing query duration distribution, index type usage, scan consistency patterns, result size analysis, and system health metrics. Perfect for at-a-glance performance monitoring.</p></div>",
     COVER_BLOCK_INSIGHTS_HTML: "<div class=\"section\"><h3>Insights Tab</h3><p>The Insights tab provides automated analysis organized into three main categories, each with expandable insights and live metrics based on your parsed query data:</p><h4> Analysis Categories</h4><div><h5> Index Performance Issues</h5><ul><li>Inefficient Index Scans - Identifies queries with poor selectivity ratios</li><li>Slow Index Scan Times - Flags indexes taking 2+ seconds to scan</li><li>Primary Index Over-Usage - Detects reliance on expensive primary indexes</li><li>ORDER BY / LIMIT / OFFSET Index Over-Scan - Highlights over-scanning due to pagination patterns (Beta)</li></ul><h5>‚ö° Resource Utilization Issues</h5><ul><li>High Kernel Time in Queries - CPU scheduling overhead analysis</li><li>High Memory Usage Detected - Memory-intensive query identification</li><li>Slow USE KEY Queries - KV service bottleneck detection</li></ul><h5> Query Pattern Analysis</h5><ul><li>Missing WHERE Clauses - Identifies full collection scans</li><li>Inefficient LIKE Operations - Detects leading wildcard usage</li><li>SELECT * Usage - Finds queries returning entire documents (Live)</li></ul><h5>üöÄ Performance Optimization Opportunities</h5><ul><li>Large Payload Streaming - Identifies queries with heavy network usage</li><li>Large Result Set Queries - Flags memory and bandwidth intensive operations</li><li>Timeout-Prone Queries - Detects queries approaching timeout limits</li></ul></div><p><strong>üí° Live Data:</strong> Insights marked with Live analyze your actual parsed data, while Beta insights are experimental and may show false positives.</p></div>",
     COVER_BLOCK_TIMELINE_DESC: "Chronological analysis with zoomable time-series charts. Track query patterns by time grouping (seconds to days), analyze duration buckets, operation types, result counts, and memory usage trends over time with dual Y-axis support.",
     COVER_BLOCK_QUERY_GROUPS_HTML: "<div class=\"section\"><h3>Query Groups</h3><p>Analyze similar queries grouped by normalized patterns. Compare aggregated statistics, identify frequently executed query types, and optimize query families that share similar execution characteristics and performance profiles.</p></div>",
     COVER_BLOCK_EVERY_QUERY_HTML: "<div class=\"section\"><h3>Every Query</h3><p>Detailed tabular view of individual query executions with sorting, filtering, and search capabilities. Drill down into specific query metrics, execution plans, and performance details for granular analysis and debugging.</p></div>",
     COVER_BLOCK_FLOW_HTML: "<div class=\"section\"><h3>Index/Query Flow</h3><p>Interactive visual flow diagram showing the relationship between indexes and queries. See which indexes are used by which queries, identify index usage patterns, and optimize index coverage with drag-and-pan visualization.</p></div>",
     COVER_BLOCK_INDEXES_HTML: "<div class=\"section\"><h3>Indexes</h3><p>Comprehensive index management with filtering by bucket/scope/collection. Analyze index performance metrics, memory residency, scan times, and usage patterns. Includes search and sorting capabilities for large index inventories.</p></div>"

   });
}
      (function(){
        var setBugText = function(){
          var el = document.getElementById('bug-report-link');
          try {
            if (!el) return;
            if (typeof TEXT_CONSTANTS !== 'undefined' && TEXT_CONSTANTS.BUG_REPORT_CTA) {
              el.textContent = TEXT_CONSTANTS.BUG_REPORT_CTA;
            }
          } catch (e) { /* no-op */ }
        };
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', setBugText);
        } else {
          setBugText();
        }
      })();
        // Disable Chart.js animations globally for better performance
        Chart.defaults.animation = false;
        Chart.defaults.animations = false;
        Chart.defaults.responsive = true;
        Chart.defaults.maintainAspectRatio = false;

        // Register the zoom plugin
        try {
            if (window.ChartZoom) {
                Chart.register(window.ChartZoom);
            } else if (window.chartjsPluginZoom) {
                Chart.register(window.chartjsPluginZoom);
            } else if (window.zoomPlugin) {
                Chart.register(window.zoomPlugin);
            }
        } catch (error) {
            // Silent fallback
        }

        // Global variables for time range tracking
        let originalTimeRange = { min: null, max: null };
        let currentTimeRange = { min: null, max: null };
        let isZoomSyncing = false;

        // Sync zoom across all timeline charts
        function syncChartZoom(sourceChart, xMin, xMax) {
            if (isZoomSyncing) return;
            isZoomSyncing = true;

            const charts = [
                window.filterChart,
                window.timelineChart,
                window.queryTypesChart,
                window.durationBucketsChart,
                window.memoryChart,
                window.resultCountChart,
                window.resultSizeChart,
                window.cpuTimeChart,
                window.indexScanThroughputChart,
                window.docFetchThroughputChart,
                window.docSizeBubbleChart,
                window.execVsKernelChart,
                window.execVsServChart,
                window.execVsElapsedChart,
                window.serviceTimeAnalysisLineChart,
                window.enhancedOperationsChart,
                window.collectionQueriesChart,
                window.parseDurationChart,
                window.planDurationChart,
            ];

            charts.forEach((chart) => {
                if (chart && chart !== sourceChart) {
                    chart.zoomScale("x", { min: xMin, max: xMax }, "none");
                }
            });

            setTimeout(() => {
                isZoomSyncing = false;
            }, 100);
        }

        // Vertical stake line functions (Issue #148)
        function addVerticalStake(timestamp) {
            verticalStakePosition = timestamp;
            
            const charts = [
                window.filterChart,
                window.timelineChart,
                window.queryTypesChart,
                window.durationBucketsChart,
                window.memoryChart,
                window.resultCountChart,
                window.resultSizeChart,
                window.cpuTimeChart,
                window.indexScanThroughputChart,
                window.docFetchThroughputChart,
                window.docSizeBubbleChart,
                window.execVsKernelChart,
                window.execVsServChart,
                window.execVsElapsedChart,
                window.serviceTimeAnalysisLineChart,
                window.enhancedOperationsChart,
                window.collectionQueriesChart,
                window.parseDurationChart,
                window.planDurationChart,
            ];

            charts.forEach((chart) => {
                if (chart && chart.options.plugins) {
                    if (!chart.options.plugins.annotation) {
                        chart.options.plugins.annotation = { annotations: {} };
                    }
                    
                    chart.options.plugins.annotation.annotations.verticalStake = {
                        type: 'line',
                        xMin: timestamp,
                        xMax: timestamp,
                        borderColor: '#007bff',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: 'Staked',
                            position: 'start',
                            backgroundColor: '#007bff',
                            color: '#fff',
                            font: {
                                size: 10
                            }
                        }
                    };
                    
                    chart.update('none');
                }
            });
            
            // Show the floating unstake button
            const unstakeBtn = document.getElementById('floating-unstake-btn');
            if (unstakeBtn) {
                unstakeBtn.style.display = 'block';
            }
        }

        function removeVerticalStake() {
            verticalStakePosition = null;
            
            const charts = [
                window.filterChart,
                window.timelineChart,
                window.queryTypesChart,
                window.durationBucketsChart,
                window.memoryChart,
                window.resultCountChart,
                window.resultSizeChart,
                window.cpuTimeChart,
                window.indexScanThroughputChart,
                window.docFetchThroughputChart,
                window.docSizeBubbleChart,
                window.execVsKernelChart,
                window.execVsServChart,
                window.execVsElapsedChart,
                window.serviceTimeAnalysisLineChart,
                window.enhancedOperationsChart,
                window.collectionQueriesChart,
                window.parseDurationChart,
                window.planDurationChart,
            ];

            charts.forEach((chart) => {
                if (chart && chart.options.plugins && chart.options.plugins.annotation) {
                    delete chart.options.plugins.annotation.annotations.verticalStake;
                    chart.update('none');
                }
            });
            
            // Hide the floating unstake button
            const unstakeBtn = document.getElementById('floating-unstake-btn');
            if (unstakeBtn) {
                unstakeBtn.style.display = 'none';
            }
        }

        function attachDoubleClickHandler(chartInstance) {
            if (!chartInstance || !chartInstance.canvas) {
                return;
            }
            
            const canvasId = chartInstance.canvas.id;
            const canvasElement = chartInstance.canvas;
            
            // Check if handler already attached to avoid duplicates
            if (canvasElement._stakeHandlerAttached) {
                return;
            }
            
            // Store the handler function so we can reference the current chart
            const handleDoubleClick = (event) => {
                // Prevent default zoom behavior
                event.preventDefault();
                event.stopPropagation();
                
                // Get the current chart instance from window (in case it was recreated)
                const currentChartMap = {
                    'filter-chart': window.filterChart,
                    'timeline-chart': window.timelineChart,
                    'query-types-chart': window.queryTypesChart,
                    'duration-buckets-chart': window.durationBucketsChart,
                    'memory-chart': window.memoryChart,
                    'result-count-chart': window.resultCountChart,
                    'result-size-chart': window.resultSizeChart,
                    'cpu-time-chart': window.cpuTimeChart,
                    'index-scan-throughput-chart': window.indexScanThroughputChart,
                    'doc-fetch-throughput-chart': window.docFetchThroughputChart,
                    'doc-size-bubble-chart': window.docSizeBubbleChart,
                    'exec-vs-kernel-chart': window.execVsKernelChart,
                    'exec-vs-serv-chart': window.execVsServChart,
                    'exec-vs-elapsed-chart': window.execVsElapsedChart,
                    'service-time-analysis-chart': window.serviceTimeAnalysisLineChart,
                    'enhanced-operations-chart': window.enhancedOperationsChart,
                    'collection-queries-chart': window.collectionQueriesChart,
                    'parse-duration-chart': window.parseDurationChart,
                    'plan-duration-chart': window.planDurationChart,
                };
                
                const currentChart = currentChartMap[canvasId];
                if (!currentChart) {
                    return;
                }
                
                const rect = event.target.getBoundingClientRect();
                const x = event.clientX - rect.left;
                
                const xScale = currentChart.scales.x;
                if (xScale) {
                    const timestamp = xScale.getValueForPixel(x);
                    addVerticalStake(timestamp);
                }
            };
            
            canvasElement.addEventListener('dblclick', handleDoubleClick, true);
            
            // Mark as attached
            canvasElement._stakeHandlerAttached = true;
        }

        // Toast notification system


        // Enhanced clipboard copy function


        // Keyboard navigation enhancement
        function enhanceKeyboardNavigation() {
            // Add keyboard support for tab elements
            document.addEventListener("keydown", function (e) {
                if (e.key === "Enter" || e.key === " ") {
                    const target = e.target;
                    if (
                        target.matches('a[href^="#"]') ||
                        target.matches(".step-bubble")
                    ) {
                        e.preventDefault();
                        target.click();
                    }
                }
            });
        }

        // Chart optimization utilities



        // ============================================================
        // DEBUG LOGGING UTILITY
        // ============================================================
        // Check if debug mode is enabled via URL parameter ?debug=true
        // Log level hierarchy (lower number = higher priority)
        const LOG_LEVELS = {
            error: 0,
            warn: 1,
            info: 2,
            debug: 3,
            trace: 4
        };

        // Get current log level from URL parameter
        function getLogLevel() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Backward compatibility: ?debug=true sets level to 'debug'
            if (urlParams.get('debug') === 'true') {
                return 'debug';
            }
            
            // New parameter: ?logLevel=trace|debug|info|warn|error
            const logLevel = urlParams.get('logLevel');
            if (logLevel && LOG_LEVELS.hasOwnProperty(logLevel)) {
                return logLevel;
            }
            
            // Default: info level (shows error, warn, info)
            return 'info';
        }

        // Check if a log message should be shown based on current log level
        function shouldLog(messageLevel) {
            const currentLevel = getLogLevel();
            return LOG_LEVELS[messageLevel] <= LOG_LEVELS[currentLevel];
        }

        // Legacy function for backward compatibility
        function isDebugMode() {
            const level = getLogLevel();
            return level === 'debug' || level === 'trace';
        }

        // Logging utility with granular levels
        // Usage: ?logLevel=error|warn|info|debug|trace (or ?debug=true for backward compatibility)
        const Logger = {
            // [error] - Critical errors (always shown unless logLevel=none)
            error: function(...args) {
                if (shouldLog('error')) {
                    console.error('[error]', ...args);
                }
            },
            
            // [warn] - Warnings (shown at warn level and above)
            warn: function(...args) {
                if (shouldLog('warn')) {
                    console.warn('[warn]', ...args);
                }
            },
            
            // [info] - Important user-facing information (shown at info level and above - DEFAULT)
            info: function(...args) {
                if (shouldLog('info')) {
                    console.log('[info]', ...args);
                }
            },
            
            // [debug] - Detailed technical information (shown at debug level and above)
            debug: function(...args) {
                if (shouldLog('debug')) {
                    console.log('[debug]', ...args);
                }
            },
            
            // [trace] - Verbose execution tracking (shown only at trace level)
            trace: function(...args) {
                if (shouldLog('trace')) {
                    console.log('[trace]', ...args);
                }
            }
        };

        // Memory cleanup for charts
        // ============================================================
        // DESTROY ALL CHARTS (Step 6 Enhancement)
        // Properly cleanup Chart.js instances and event listeners
        // ============================================================
        function destroyAllCharts() {
            // Trace logging to see who called this function
            Logger.trace(`üîç destroyAllCharts() called from:`, new Error().stack);
            
            const chartNames = [
                "operationsChart",
                "filterChart",
                "timelineChart",
                "queryTypesChart",
                "durationBucketsChart",
                "memoryChart",
                "resultCountChart",
                "resultSizeChart",
                "primaryScanChart",
                "stateChart",
                "statementTypeChart",
                "elapsedTimeChart",
                "queryPatternChart",
                "cpuTimeChart",
                "serviceTimeAnalysisChart",
                "execVsKernelChart",
                "execVsServChart",
                "execVsElapsedChart",
                "enhancedOperationsChart",
                "parseDurationChart",
                "planDurationChart",
                "collectionQueriesChart",
                "indexScanThroughputChart",
                "docFetchThroughputChart",
                "docSizeBubbleChart",
                "queryGroupPhaseTimesChart",
                "serviceTimeAnalysisLineChart"
            ];

            let destroyedCount = 0;
            chartNames.forEach((chartName) => {
                if (window[chartName]) {
                    try {
                        // Remove event listeners if they exist
                        if (window[chartName]._crosshairHandlers && window[chartName].canvas) {
                            const canvas = window[chartName].canvas;
                            const handlers = window[chartName]._crosshairHandlers;
                            canvas.removeEventListener('mousemove', handlers.mousemove);
                            canvas.removeEventListener('mouseleave', handlers.mouseleave);
                        }

                        window[chartName].destroy();
                        window[chartName] = null;
                        destroyedCount++;
                    } catch (e) {
                        Logger.warn(`Failed to destroy chart: ${chartName}`, e);
                    }
                }
            });

            // Clear timeline charts array
            timelineCharts.length = 0;
            
            Logger.debug(`üßπ Destroyed ${destroyedCount} chart instances`);
        }

        function destroyTimelineCharts() {
            // Trace logging to see who called this function
            Logger.trace(`üîç destroyTimelineCharts() called from:`, new Error().stack);
            
            const timelineChartNames = [
                "filterChart",
                "timelineChart",
                "memoryChart",
                "resultCountChart",
                "resultSizeChart",
                "cpuTimeChart",
                "serviceTimeAnalysisChart",
                "execVsKernelChart",
                "execVsServChart",
                "execVsElapsedChart",
                "enhancedOperationsChart",
                "parseDurationChart",
                "planDurationChart",
                "indexScanThroughputChart",
                "docFetchThroughputChart",
                "docSizeBubbleChart",
                "serviceTimeAnalysisLineChart"
            ];

            let destroyedCount = 0;
            timelineChartNames.forEach((chartName) => {
                if (window[chartName]) {
                    try {
                        // Remove event listeners if they exist
                        if (window[chartName]._crosshairHandlers && window[chartName].canvas) {
                            const canvas = window[chartName].canvas;
                            const handlers = window[chartName]._crosshairHandlers;
                            canvas.removeEventListener('mousemove', handlers.mousemove);
                            canvas.removeEventListener('mouseleave', handlers.mouseleave);
                        }

                        window[chartName].destroy();
                        window[chartName] = null;
                        destroyedCount++;
                    } catch (e) {
                        Logger.warn(`Failed to destroy chart: ${chartName}`, e);
                    }
                }
            });

            // Clear timeline charts array
            timelineCharts.length = 0;
            
            Logger.debug(`üßπ Destroyed ${destroyedCount} timeline chart instances`);
        }

        // Global system query filtering
        function shouldExcludeSystemQuery(request) {
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            const isChecked = excludeCheckbox ? excludeCheckbox.checked : false;

            // If checkbox doesn't exist or is unchecked, don't exclude anything
            if (!excludeCheckbox || !excludeCheckbox.checked) {
                return false;
            }

            const stmt = request.statement || request.preparedText;
            if (!stmt) {
                return false;
            }

            const upperStmt = stmt.toUpperCase();

            // Apply same filtering logic as Query Groups tab
            // Get derived statement type and normalize underscores to spaces
            const statementType = request.statementType || deriveStatementType(request.statement || request.preparedText) || "";
            const normalizedType = statementType.replace(/_/g, " ").toUpperCase();

            // Define system query patterns (both with and without underscores)
            const systemPatterns = [
                "INFER", "ADVISE", "CREATE", "ALTER", "DROP", "BUILD", "EXPLAIN"
            ];

            const shouldExclude =
                upperStmt.startsWith("INFER ") ||
                upperStmt.startsWith("ADVISE ") ||
                upperStmt.startsWith("CREATE ") ||
                upperStmt.startsWith("ALTER ") ||
                upperStmt.startsWith("DROP ") ||
                upperStmt.startsWith("BUILD ") ||
                upperStmt.startsWith("EXPLAIN ") ||
                upperStmt.includes(" SYSTEM:") ||
                // Check normalized statement type for any system operation with underscores
                systemPatterns.some(pattern => normalizedType.startsWith(pattern + " "));

            return shouldExclude;
        }

        // Filter requests based on system query exclusion setting and SQL statement filter
        function filterSystemQueries(requests) {
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            const isExcluding = excludeCheckbox && excludeCheckbox.checked;

            // Get SQL statement filter
            const sqlFilter = document.getElementById("sql-statement-filter");
            const sqlFilterText = sqlFilter ? sqlFilter.value.trim().toLowerCase() : "";

            // Get elapsed time filter predicate (if any)
            const elapsedFilterInput = document.getElementById("elapsed-time-filter");
            const elapsedFilterText = elapsedFilterInput ? elapsedFilterInput.value.trim() : "";
            const elapsedPredicate = makeElapsedFilterPredicate(elapsedFilterText);

            const filtered = requests.filter((request) => {
                // Apply system query exclusion first
                if (isExcluding && shouldExcludeSystemQuery(request)) {
                    return false;
                }

                // Apply SQL statement filtering only if filter text is not empty
                if (sqlFilterText && sqlFilterText.length > 0) {
                    const statement = (request.statement || request.preparedText || "").toLowerCase().replace(/\s+/g, ' ').trim();
                    const filterText = sqlFilterText.replace(/\s+/g, ' ').trim();
                    if (!statement.includes(filterText)) {
                        return false;
                    }
                }

                // Apply elapsedTime filter if provided
                if (elapsedPredicate) {
                    const ms = parseTime(request.elapsedTime || "");
                    if (!elapsedPredicate(ms)) {
                        return false;
                    }
                }

                return true;
            });


            return filtered;
        }

        // Parse time strings to milliseconds (with caching)
        // HTML escape utility function
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Strip presentational tags that sometimes appear around preparedText
        function stripEmTags(text) {
            if (text == null) return "";
            return String(text)
                .replace(/<\/?em>/gi, "")
                .replace(/<\/?ud>/gi, "");
        }

        // Detect if this request executed a prepared statement
        function isPreparedExecution(request) {
            if (!request) return false;
            const hasPrepared = typeof request.preparedText === 'string' && request.preparedText.trim().length > 0;
            const type = (request.statementType || '').toUpperCase();
            const stmt = (request.statement || '').toUpperCase().trim();
            const hasExecute = type === 'EXECUTE' || stmt.startsWith('EXECUTE ');
            return hasPrepared && hasExecute;
        }

        // Get a cleaned prepared text sample when applicable
        function getPreparedSample(request) {
            if (!isPreparedExecution(request)) return "";
            const txt = stripEmTags(request.preparedText || "");
            return txt.trim();
        }

        function parseTime(timeStr) {
            if (!timeStr) {
                return 0;
            }

            // Handle empty or invalid strings
            timeStr = timeStr.trim();
            if (!timeStr) {
                return 0;
            }

            // Check cache first
            if (parseTimeCache.has(timeStr)) {
                return parseTimeCache.get(timeStr);
            }

            // Try different regex patterns for different time formats

            // Pattern 1: Handle ms, ns, ¬µs, us formats like "681.413039ms", "250ns", "146.266¬µs"
            const simplePattern = /^(\d+\.?\d*)(ms|ns|¬µs|us)$/;
            let simpleMatch = timeStr.match(simplePattern);

            if (simpleMatch) {
                const value = parseFloat(simpleMatch[1]);
                const unit = simpleMatch[2];

                let totalMs = 0;
                if (unit === "ms") {
                    totalMs = value;
                } else if (unit === "ns") {
                    totalMs = value / 1000000; // nanoseconds to milliseconds
                } else if (unit === "¬µs" || unit === "us") {
                    totalMs = value / 1000; // microseconds to milliseconds
                }

                return totalMs;
            }

            // Pattern 2: Handle complex formats like "1h4m17.8098098s" or "4m17.8098098s" or "1h"
            const complexPattern = /(?:(\d+)h)?(?:(\d+)m)?(?:(\d+\.?\d*)s)?/;
            const complexMatch = timeStr.match(complexPattern);

            if (
                !complexMatch ||
                (complexMatch[1] === undefined &&
                    complexMatch[2] === undefined &&
                    complexMatch[3] === undefined)
            ) {
                return 0;
            }

            let totalMs = 0;
            const hours = parseInt(complexMatch[1] || 0); // Hours (optional)
            const minutes = parseInt(complexMatch[2] || 0); // Minutes (optional)
            const seconds = parseFloat(complexMatch[3] || 0); // Seconds (optional, including decimals)

            // Convert to milliseconds
            totalMs += hours * 60 * 60 * 1000; // Hours to milliseconds
            totalMs += minutes * 60 * 1000; // Minutes to milliseconds
            totalMs += seconds * 1000; // Seconds to milliseconds

            // Cache the result with size limit (Step 9)
            if (parseTimeCache.size >= CACHE_LIMITS.parseTime) {
                // Clear oldest entries (first 20%) when limit reached
                const keysToDelete = Array.from(parseTimeCache.keys()).slice(0, Math.floor(CACHE_LIMITS.parseTime * 0.2));
                keysToDelete.forEach(key => parseTimeCache.delete(key));
            }
            parseTimeCache.set(timeStr, totalMs);
            return totalMs;
        }

        // Format time in standardized mm:ss.sss format
        // ============================================================
        // FORMATTERS MODULE (Optimization Step 2b)
        // Consolidated formatting helper functions
        // ============================================================
        const Formatters = {
            // Format milliseconds to MM:SS.mmm
            formatTime(milliseconds) {
                if (!milliseconds || isNaN(milliseconds) || milliseconds <= 0) {
                    return "00:00.000";
                }

                // Handle very small values (less than 1ms) by rounding to nearest millisecond
                // but ensuring they show as at least 0.001 if they're greater than 0
                if (milliseconds < 1) {
                    milliseconds = Math.max(0.001, Math.round(milliseconds * 1000) / 1000);
                }

                const totalSeconds = Math.floor(milliseconds / 1000);
                const remainingMs = milliseconds % 1000;
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;

                // Format with leading zeros
                const formattedMinutes = minutes.toString().padStart(2, "0");
                const formattedSeconds = seconds.toString().padStart(2, "0");

                // Format milliseconds as 3-digit integer (rounded)
                const formattedMs = Math.round(remainingMs).toString().padStart(3, "0");

                return `${formattedMinutes}:${formattedSeconds}.${formattedMs}`;
            },

            // Format original time value for tooltip display
            formatTimeTooltip(timeStr, milliseconds) {
                if (!timeStr || timeStr === "N/A") {
                    return "";
                }

                // If it's a very small value, show the original string for precision
                if (milliseconds < 1) {
                    return `Original: ${timeStr}`;
                }

                // For larger values, show both formatted time and original
                const formatted = this.formatTime(milliseconds);
                if (timeStr !== formatted) {
                    return `Original: ${timeStr}`;
                }

                return "";
            }
        };

        // Backward compatibility - keep original function names as aliases
        const formatTime = (milliseconds) => Formatters.formatTime(milliseconds);
        const formatTimeTooltip = (timeStr, milliseconds) => Formatters.formatTimeTooltip(timeStr, milliseconds);



        // Normalize statement by replacing literals and numbers with "?" (with improved caching)
        function normalizeStatement(statement) {
            if (!statement) return "";

            // Check cache (Step 9 - unified cache)
            if (normalizeStatementCache.has(statement)) {
                return normalizeStatementCache.get(statement);
            }

            let normalized = statement
                .replace(/"(?:[^"\\]|\\.)*"/g, "?")
                .replace(/'(?:[^'\\]|\\.)*'/g, "?")
                .replace(/\b\d+\.?\d*\b/g, "?");

            // Cache with size limit (Step 9)
            if (normalizeStatementCache.size >= CACHE_LIMITS.normalizeStatement) {
                // Clear oldest 20% when limit reached
                const keysToDelete = Array.from(normalizeStatementCache.keys())
                    .slice(0, Math.floor(CACHE_LIMITS.normalizeStatement * 0.2));
                keysToDelete.forEach(key => normalizeStatementCache.delete(key));
            }
            normalizeStatementCache.set(statement, normalized);

            return normalized;
        }

        // Check if a query statement has filtering mechanism (WHERE clause or USE KEYS)
        function hasFilteringMechanism(statement) {
            if (!statement) return false;
            const upperStatement = statement.toUpperCase();
            // Check for WHERE clause or USE KEYS using word boundaries for precise matching
            return /\bWHERE\b/.test(upperStatement) || /\bUSE\s+KEYS\b/.test(upperStatement);
        }

        // Get color class based on percentage
        function getColorClass(percentage) {
            if (percentage === "N/A" || isNaN(percentage)) return "green";
            if (percentage < 25) return "green";
            if (percentage < 50) return "yellow";
            if (percentage < 75) return "orange";
            return "red";
        }

        // Get percentage-based background color for bubble
        function getPercentageColor(percentage) {
            if (percentage === "N/A" || isNaN(percentage)) {
                return { bg: "#d4edda", border: "#28a745" }; // Light green
            }

            const percent = parseFloat(percentage);

            if (percent <= 33) {
                // 0-33%: Light to darker green
                const intensity = Math.min(percent / 33, 1);
                // Start with very light green and go to medium green
                const red = Math.floor(212 - (84 * intensity)); // 212 to 128
                const green = Math.floor(237 - (18 * intensity)); // 237 to 219  
                const blue = Math.floor(218 - (90 * intensity)); // 218 to 128
                return {
                    bg: `rgb(${red}, ${green}, ${blue})`,
                    border: "#28a745"
                };
            } else if (percent <= 90) {
                // 33-90%: Light orange to hard orange
                const intensity = (percent - 33) / 57; // 0 to 1
                const red = Math.floor(255);
                const green = Math.floor(193 - (67 * intensity)); // 193 to 126
                const blue = Math.floor(7 + (93 * intensity)); // 7 to 100, then back to 7
                return {
                    bg: `rgb(${red}, ${green}, 7)`,
                    border: "#fd7e14"
                };
            } else {
                // 90-100%: Light red to darker red (less bright for readability)
                const intensity = (percent - 90) / 10; // 0 to 1
                const red = Math.floor(220 - (20 * intensity)); // 220 to 200 (less bright)
                const green = Math.floor(180 - (120 * intensity)); // 180 to 60
                const blue = Math.floor(180 - (120 * intensity)); // 180 to 60
                return {
                    bg: `rgb(${red}, ${green}, ${blue})`,
                    border: "#dc3545"
                };
            }
        }

        // Caches for performance optimization to avoid reprocessing
        // ============================================================
        // CACHING STRATEGY (Step 9)
        // All caches with size limits to prevent unbounded growth
        // ============================================================
        const CACHE_LIMITS = {
            parseTime: 10000,           // Time string parsing results
            normalizeStatement: 5000,   // Normalized SQL statements
            timestampRounding: 5000,    // Rounded timestamp calculations
        };

        const operatorsCache = new WeakMap();       // Auto-cleaned by GC
        const parseTimeCache = new Map();
        const normalizeStatementCache = new Map();
        const planStatsCache = new WeakMap();       // Auto-cleaned by GC
        const timeUnitCache = new WeakMap();        // Auto-cleaned by GC
        const timestampRoundingCache = new Map();

        // Clear caches to prevent memory leaks and stale data between parses
        // ============================================================
        // MEMORY LEAK PREVENTION (Step 6)
        // Clear all caches and destroy charts on new parse
        // ============================================================
        function clearCaches() {
            // Destroy all Chart.js instances to prevent memory leaks
            destroyAllCharts();
            
            // Clear data caches
            parseTimeCache.clear();
            normalizeStatementCache.clear();
            timestampRoundingCache.clear(); // Critical for Timeline tab performance
            
            // WeakMaps (operatorsCache, planStatsCache, timeUnitCache) clean themselves automatically
            Logger.debug(TEXT_CONSTANTS.ALL_CACHES_CLEARED);
        }

        // Performance benchmarking helper (Step 9 enhancement)
        function logCacheStats() {
            const parsePercent = ((parseTimeCache.size / CACHE_LIMITS.parseTime) * 100).toFixed(1);
            const normalizePercent = ((normalizeStatementCache.size / CACHE_LIMITS.normalizeStatement) * 100).toFixed(1);
            const timestampPercent = ((timestampRoundingCache.size / CACHE_LIMITS.timestampRounding) * 100).toFixed(1);
            
            Logger.debug(`Cache stats - parseTime: ${parseTimeCache.size}/${CACHE_LIMITS.parseTime} (${parsePercent}%), normalizeStatement: ${normalizeStatementCache.size}/${CACHE_LIMITS.normalizeStatement} (${normalizePercent}%), timestampRounding: ${timestampRoundingCache.size}/${CACHE_LIMITS.timestampRounding} (${timestampPercent}%)`);
            
            // Calculate approximate memory size
            let totalBytes = 0;
            
            // parseTimeCache (key: string, value: number)
            parseTimeCache.forEach((value, key) => {
                totalBytes += key.length * 2 + 8;
            });
            
            // normalizeStatementCache (key: string, value: string)
            normalizeStatementCache.forEach((value, key) => {
                totalBytes += (key.length + value.length) * 2;
            });
            
            // timestampRoundingCache (key: string, value: Date)
            timestampRoundingCache.forEach((value, key) => {
                totalBytes += key.length * 2 + 16;
            });
            
            // originalRequests array
            if (originalRequests.length > 0) {
                const sampleSize = JSON.stringify(originalRequests[0]).length;
                totalBytes += sampleSize * originalRequests.length;
            }
            
            // statementStore and analysisStatementStore
            const storeSize = JSON.stringify(statementStore).length + JSON.stringify(analysisStatementStore).length;
            totalBytes += storeSize * 2;
            
            const megabytes = (totalBytes / (1024 * 1024)).toFixed(2);
            Logger.debug(`üíæ Cache memory usage: ${megabytes} MB (${totalBytes.toLocaleString()} bytes) | Data stores: ${originalRequests.length} requests, ${Object.keys(statementStore).length} statement groups, ${Object.keys(analysisStatementStore).length} analysis groups`);
        }

        // Recursively extract operators from the plan
        function getOperators(
            operator,
            operators = [],
            visited = new WeakSet(),
            depth = 0
        ) {
            if (!operator) return operators;

            // Check cache first for the root operator
            if (depth === 0 && operatorsCache.has(operator)) {
                return operatorsCache.get(operator);
            }

            // Prevent infinite recursion by tracking visited objects
            if (visited.has(operator)) {
                return operators;
            }
            visited.add(operator);

            // Add depth limit as additional safety
            if (depth > 50) {
                return operators;
            }

            if (operator["#operator"]) {
                operators.push(operator);
            }
            if (operator["~child"]) {
                getOperators(operator["~child"], operators, visited, depth + 1);
            } else if (operator["~children"]) {
                operator["~children"].forEach((child, i) => {
                    getOperators(child, operators, visited, depth + 1);
                });
            }
            // Check for input/inputs
            if (operator.input) {
                getOperators(operator.input, operators, visited, depth + 1);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input, i) => {
                    getOperators(input, operators, visited, depth + 1);
                });
            }
            // Check for left/right (binary operations)
            if (operator.left) {
                getOperators(operator.left, operators, visited, depth + 1);
            }
            if (operator.right) {
                getOperators(operator.right, operators, visited, depth + 1);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                getOperators(operator.first, operators, visited, depth + 1);
            }
            if (operator.second) {
                getOperators(operator.second, operators, visited, depth + 1);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan, i) => {
                    getOperators(scan, operators, visited, depth + 1);
                });
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                getOperators(operator.scan, operators, visited, depth + 1);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery, i) => {
                    if (subquery.executionTimings) {
                        getOperators(
                            subquery.executionTimings,
                            operators,
                            visited,
                            depth + 1
                        );
                    }
                });
            }

            // Cache the result for root operator
            if (depth === 0) {
                operatorsCache.set(operator, operators);
            }

            return operators;
        }

        // Calculate the maximum of all kernTimes (optimized with cache)
        function calculateTotalKernTime(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).maxKernTime;
            }

            // Fallback to original calculation if not cached
            const operators = getOperators(plan);
            let maxKernTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const kernTime = parseTime(stats.kernTime);
                if (!isNaN(kernTime)) {
                    maxKernTime = Math.max(maxKernTime, kernTime);
                }
            });
            return maxKernTime;
        }



        // Calculate the total memory usage from all operators in the plan (optimized with cache)
        function calculateTotalMemoryUsage(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).totalMemoryUsage;
            }

            // Fallback to original calculation
            const operators = getOperators(plan);
            let totalMemory = 0;

            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const usedMemory = stats.usedMemory || 0;
                if (!isNaN(usedMemory)) {
                    totalMemory += usedMemory;
                }
            });
            return totalMemory;
        }

        // Calculate the sum of all execution times for percentage calculation (optimized with cache)
        function calculateTotalExecTime(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).totalExecTime;
            }

            // Fallback to original calculation if not cached
            const operators = getOperators(plan);
            let totalExecTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const execTime = parseTime(stats.execTime);
                if (!isNaN(execTime)) {
                    totalExecTime += execTime;
                }
            });
            return totalExecTime;
        }

        // Calculate the sum of all service times from all operators in the plan (optimized with cache)
        function calculateTotalServiceTime(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).totalServiceTime;
            }

            // Fallback to original calculation if not cached
            const operators = getOperators(plan);
            let totalServiceTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const servTime = parseTime(stats.servTime);
                if (!isNaN(servTime)) {
                    totalServiceTime += servTime;
                }
            });
            return totalServiceTime;
        }

        // Build operator stats for modal
        function buildOperatorStats(operator) {
            const operatorType = operator["#operator"] || TEXT_CONSTANTS.UNKNOWN;
            let html = `<h3>${TEXT_CONSTANTS.OPERATOR_LABEL} ${operatorType}</h3>`;

            // Add copy button
            html += `<button class="btn-standard" onclick="copyOperatorStats(this)">${TEXT_CONSTANTS.COPY_STATS}</button>`;

            // Show index name for specific operators
            if (
                (operatorType === "PrimaryScan3" ||
                    operatorType === "IndexFtsSearch" ||
                    operatorType === "IndexScan3") &&
                operator.index
            ) {
                html += `<p><strong>${TEXT_CONSTANTS.INDEX_USED} ${operator.index}</strong></p>`;
            }

            if (operator["#stats"]) {
                html += "<dl>";
                for (const [key, value] of Object.entries(operator["#stats"])) {
                    let formattedValue = value;
                    // Format time fields with tooltips
                    if (
                        key === "execTime" ||
                        key === "kernTime" ||
                        key === "servTime"
                    ) {
                        const timeMs = parseTime(value);
                        if (timeMs > 0) {
                            const tooltip = formatTimeTooltip(value, timeMs);
                            formattedValue = tooltip ?
                                `<span title="${tooltip}">${formatTime(timeMs)}</span>` :
                                formatTime(timeMs);
                        }
                    }
                    // Format number fields with commas
                    else if (typeof value === 'number' && value >= 1000) {
                        formattedValue = value.toLocaleString('en-US');
                    }
                    html += `<dt>${key}</dt><dd>${formattedValue}</dd>`;
                }
                html += "</dl>";
            } else {
                html += "<p>No stats available.</p>";
            }
            return html;
        }

        // Function to copy operator stats to clipboard
        // ============================================================
        // CLIPBOARD UTILITIES MODULE (Optimization Step 2c)
        // Consolidated clipboard copy functions with visual feedback
        // ============================================================
        const ClipboardUtils = {
            // Copy text to clipboard with button feedback
            copyToClipboard(text, button, options = {}) {
                const {
                    successText = TEXT_CONSTANTS.COPIED || "Copied!",
                    originalText = button.textContent,
                    successColor = "#4CAF50",
                    duration = 1000,
                    useToast = false
                } = options;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard
                        .writeText(text)
                        .then(() => {
                            this._showButtonFeedback(button, successText, originalText, successColor, duration);
                            if (useToast) showToast(TEXT_CONSTANTS.COPIED_CLIPBOARD);
                        })
                        .catch((err) => {
                            Logger.error("Failed to copy:", err);
                            this._fallbackCopy(text, button);
                        });
                } else {
                    this._fallbackCopy(text, button);
                }
            },

            // Show visual feedback on button
            _showButtonFeedback(button, successText, originalText, successColor, duration) {
                const originalBg = button.style.backgroundColor;
                button.textContent = successText;
                button.style.backgroundColor = successColor;
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = originalBg;
                }, duration);
            },

            // Fallback copy for older browsers
            _fallbackCopy(text, button) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.top = "-1000px";
                textArea.style.left = "-1000px";
                textArea.setAttribute("aria-hidden", "true");
                textArea.setAttribute("tabindex", "-1");

                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                try {
                    const successful = document.execCommand("copy");
                    if (successful) {
                        showToast(TEXT_CONSTANTS.COPIED_CLIPBOARD);
                    } else {
                        showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                    }
                } catch (err) {
                    Logger.error("Fallback: Unable to copy", err);
                    showToast("Failed to copy to clipboard", "error");
                }

                document.body.removeChild(textArea);
            }
        };

        // Backward compatibility wrappers
        function copyOperatorStats(button) {
            const modalBody = document.getElementById("operator-modal-body");
            const text = modalBody.innerText || modalBody.textContent;
            ClipboardUtils.copyToClipboard(text, button, {
                successText: TEXT_CONSTANTS.COPIED,
                originalText: TEXT_CONSTANTS.COPY_STATS,
                duration: 2000
            });
        }

        function fallbackCopyTextToClipboard(text, button) {
            ClipboardUtils._fallbackCopy(text, button);
        }

        // Copy whole record JSON from the pre element
        function copyWholeRecordJson() {
            const preElement = document.getElementById('whole-record-json');
            const button = event.target; // Get the button that was clicked
            
            if (!preElement) {
                Logger.error('whole-record-json element not found');
                showToast("Failed to copy: JSON element not found", "error");
                return;
            }
            
            const jsonContent = preElement.textContent.trim();
            
            if (!jsonContent) {
                showToast("No JSON record loaded. Please load a request ID first.", "warning");
                return;
            }
            
            ClipboardUtils.copyToClipboard(jsonContent, button, {
                successText: "‚úÖ Copied!",
                originalText: "üìã Copy JSON",
                successColor: "#4CAF50",
                duration: 2000,
                useToast: true
            });
        }

        // Generate flow diagram
        // =============================================================================
        // PlanNode Class - Couchbase-inspired execution plan tree structure
        // =============================================================================
        class PlanNode {
            constructor(op, predecessor = null, totalQueryTime = 0) {
                this.operator = op;               // Raw operator JSON
                this.predecessor = predecessor;   // Previous node in execution sequence
                this.subsequence = null;          // Next node in execution sequence
                this.children = [];               // Child nodes (for joins, unions, etc.)
                this.id = 'pn_' + Math.random().toString(36).slice(2);
                this.depthLen = 1;                // Depth of tree from this node
                this.branchHeight = 1;            // Height needed for branching
                this.totalQueryTime = totalQueryTime; // Total query elapsed time for % calculations
            }

            // Get operator type (normalized across different plan formats)
            type() {
                return this.operator?.['#operator'] || this.operator?.operator || 'Unknown';
            }

            // Get display name for operator
            getName() {
                const t = this.type();
                const nameMap = {
                    'PrimaryScan': 'Primary Scan',
                    'PrimaryScan3': 'Primary Scan',
                    'IndexScan': 'Index Scan',
                    'IndexScan2': 'Index Scan',
                    'IndexScan3': 'Index Scan',
                    'Fetch': 'Doc Fetch',
                    'Filter': 'Filter',
                    'InitialProject': 'Project',
                    'FinalProject': 'Project',
                    'Order': 'Order',
                    'Stream': 'Stream',
                    'Authorize': 'Authorize',
                    'Parallel': 'Parallel',
                    'NLJoin': 'Nested Loop Join',
                    'HashJoin': 'Hash Join',
                    'Join': 'Join',
                    'IndexJoin': 'Index Join',
                    'Nest': 'Nest',
                    'Unnest': 'Unnest',
                    'UnionAll': 'Union All',
                    'Union': 'Union',
                    'IntersectScan': 'Intersect Scan',
                    'ExceptAll': 'Except All',
                    'Distinct': 'Distinct',
                    'DistinctScan': 'Distinct Scan',
                    'Group': 'Group',
                    'InitialGroup': 'Group',
                    'IntermediateGroup': 'Group',
                    'FinalGroup': 'Group',
                    'Limit': 'Limit',
                    'Offset': 'Offset',
                    'Insert': 'Insert',
                    'Update': 'Update',
                    'Delete': 'Delete',
                    'Merge': 'Merge'
                };
                return nameMap[t] || t;
            }

            // ‚úÖ PRESERVE: Extract timing information (execTime, servTime)
            getTimeInfo() {
                const op = this.operator;
                const stats = op['#stats'] || {};
                
                const execTime = stats.execTime || op['#time'] || '0s';
                const servTime = stats.servTime || '0s';
                const execMs = parseTime(execTime);
                const servMs = parseTime(servTime);
                
                // Use servTime if available (actual bottleneck), fallback to execTime
                const timeForPercentage = (!isNaN(servMs) && servMs > 0) ? servMs : execMs;
                const percentage = (this.totalQueryTime > 0 && !isNaN(timeForPercentage) && timeForPercentage > 0)
                    ? ((timeForPercentage / this.totalQueryTime) * 100).toFixed(2)
                    : 'N/A';
                
                return {
                    execTimeMs: execMs,
                    servTimeMs: servMs,
                    execTimeFormatted: formatTime(execMs),
                    servTimeFormatted: formatTime(servMs),
                    execTimeTooltip: formatTimeTooltip(execTime, execMs),
                    servTimeTooltip: formatTimeTooltip(servTime, servMs),
                    percentage: percentage,
                    hasServTime: servTime !== 'N/A' && !isNaN(servMs) && servMs > 0
                };
            }

            // ‚úÖ PRESERVE: Extract items in/out (with comma formatting)
            getItemsInOut() {
                const stats = this.operator['#stats'] || {};
                const itemsIn = stats['#itemsIn'] !== undefined ? stats['#itemsIn'] : '-';
                const itemsOut = stats['#itemsOut'] !== undefined ? stats['#itemsOut'] : '-';
                
                // Format numbers with commas
                const formatNumber = (num) => {
                    if (num === '-' || num === undefined || num === null) return '-';
                    return num.toLocaleString('en-US');
                };
                
                return {
                    itemsIn: itemsIn,
                    itemsOut: itemsOut,
                    formatted: (itemsIn !== '-' && itemsOut !== '-') 
                        ? `${formatNumber(itemsIn)} in / ${formatNumber(itemsOut)} out` 
                        : null
                };
            }

            // ‚úÖ PRESERVE: Color coding based on percentage
            getColor() {
                const timeInfo = this.getTimeInfo();
                const pct = parseFloat(timeInfo.percentage);
                
                if (isNaN(pct)) return { bg: '#E8F5E9', border: '#4CAF50' }; // Default green
                
                // Use existing getPercentageColor function
                return getPercentageColor(pct);
            }
        }

        // =============================================================================
        // Normalized Field Getters - Handle variations across plan versions
        // =============================================================================
        function getOpType(op) {
            return op?.['#operator'] || op?.operator || 'Unknown';
        }

        function getChildren(op) {
            return op?.['~children'] || op?.children || [];
        }

        function getChild(op) {
            return op?.['~child'] || op?.child;
        }

        function getOuter(op) {
            return op?.['~outer'] || op?.outer || op?.left;
        }

        function getInner(op) {
            return op?.['~inner'] || op?.inner || op?.right;
        }

        function getScans(op) {
            return op?.scans || [];
        }

        function getFirst(op) {
            return op?.first;
        }

        function getSecond(op) {
            return op?.second;
        }

        function getScan(op) {
            return op?.scan;
        }

        // =============================================================================
        // convertN1QLPlanToPlanNodes - Main conversion function following Couchbase logic
        // =============================================================================
        function convertN1QLPlanToPlanNodes(planRoot, predecessor = null, totalQueryTime = 0) {
            if (!planRoot) return null;

            // Handle prepared queries or wrapped plans
            if (planRoot.operator && !planRoot['#operator']) {
                return convertN1QLPlanToPlanNodes(planRoot.operator, predecessor, totalQueryTime);
            }
            if (planRoot.plan && !planRoot['#operator']) {
                return convertN1QLPlanToPlanNodes(planRoot.plan, predecessor, totalQueryTime);
            }

            const opType = getOpType(planRoot);
            
            // ‚úÖ SEQUENCE: Flatten into linear chain (Couchbase pattern)
            if (opType === 'Sequence') {
                const children = getChildren(planRoot);
                let head = null;
                let prev = predecessor;
                
                for (const child of children) {
                    const node = convertN1QLPlanToPlanNodes(child, prev, totalQueryTime);
                    if (!head) head = node;
                    prev = tail(node);
                }
                
                return head;
            }

            // ‚úÖ PARALLEL: Keep node with subsequence
            if (opType === 'Parallel') {
                const node = new PlanNode(planRoot, predecessor, totalQueryTime);
                const child = getChild(planRoot);
                if (child) {
                    node.subsequence = convertN1QLPlanToPlanNodes(child, node, totalQueryTime);
                }
                return node;
            }

            // ‚úÖ UNION/INTERSECT/EXCEPT: Multiple children
            if (opType === 'UnionAll' || opType === 'Union' || opType === 'IntersectScan' || opType === 'ExceptAll') {
                const node = new PlanNode(planRoot, predecessor, totalQueryTime);
                const children = getChildren(planRoot) || getScans(planRoot);
                node.children = children.map(c => convertN1QLPlanToPlanNodes(c, null, totalQueryTime)).filter(Boolean);
                return node;
            }

            // ‚úÖ JOINS: Outer + Inner children
            if (opType === 'NLJoin' || opType === 'HashJoin' || opType === 'Join' || 
                opType === 'IndexJoin' || opType === 'LookupJoin' || 
                opType === 'Nest' || opType === 'Unnest' || opType === 'HashNest' || opType === 'NestedLoopNest') {
                const node = new PlanNode(planRoot, predecessor, totalQueryTime);
                const outer = getOuter(planRoot);
                const inner = getInner(planRoot) || getChild(planRoot);
                
                if (outer) {
                    node.children.push(convertN1QLPlanToPlanNodes(outer, null, totalQueryTime));
                }
                if (inner) {
                    node.children.push(convertN1QLPlanToPlanNodes(inner, null, totalQueryTime));
                }
                
                node.children = node.children.filter(Boolean);
                return node;
            }

            // ‚úÖ EXCEPT/INTERSECT with first/second
            if (opType === 'ExceptAll' || opType === 'IntersectAll') {
                const node = new PlanNode(planRoot, predecessor, totalQueryTime);
                const first = getFirst(planRoot);
                const second = getSecond(planRoot);
                
                if (first) {
                    node.children.push(convertN1QLPlanToPlanNodes(first, null, totalQueryTime));
                }
                if (second) {
                    node.children.push(convertN1QLPlanToPlanNodes(second, null, totalQueryTime));
                }
                
                node.children = node.children.filter(Boolean);
                return node;
            }

            // ‚úÖ AUTHORIZE: Child comes after (Couchbase pattern)
            if (opType === 'Authorize') {
                const node = new PlanNode(planRoot, predecessor, totalQueryTime);
                const child = getChild(planRoot);
                if (child) {
                    node.subsequence = convertN1QLPlanToPlanNodes(child, node, totalQueryTime);
                }
                return node;
            }

            // ‚úÖ DISTINCT SCAN: Single child
            if (opType === 'DistinctScan') {
                const scan = getScan(planRoot);
                if (scan) {
                    return convertN1QLPlanToPlanNodes(scan, predecessor, totalQueryTime);
                }
            }

            // ‚úÖ MERGE: Has multiple operation children
            if (opType === 'Merge') {
                const node = new PlanNode(planRoot, predecessor, totalQueryTime);
                
                if (predecessor) node.children.push(predecessor);
                
                const insertOp = planRoot.insert;
                const deleteOp = planRoot.delete;
                const updateOp = planRoot.update;
                
                if (insertOp) node.children.push(convertN1QLPlanToPlanNodes(insertOp, null, totalQueryTime));
                if (deleteOp) node.children.push(convertN1QLPlanToPlanNodes(deleteOp, null, totalQueryTime));
                if (updateOp) node.children.push(convertN1QLPlanToPlanNodes(updateOp, null, totalQueryTime));
                
                node.children = node.children.filter(Boolean);
                return node;
            }

            // ‚úÖ DEFAULT: Linear node (most operators)
            const node = new PlanNode(planRoot, predecessor, totalQueryTime);
            const child = getChild(planRoot);
            if (child) {
                node.subsequence = convertN1QLPlanToPlanNodes(child, node, totalQueryTime);
            }
            
            return node;
        }

        // Helper: Get tail of subsequence chain
        function tail(node) {
            if (!node) return null;
            let current = node;
            while (current.subsequence) {
                current = current.subsequence;
            }
            return current;
        }

        // =============================================================================
        // Enhanced Flow Diagram Renderer - Preserves all existing UI features
        // =============================================================================
        
        // Global panzoom instance for diagram controls
        let flowDiagramPanzoomInstance = null;
        
        // Feature flag: Check if ?dev=true in URL for new hierarchical flow diagram
        function isDevMode() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('dev') === 'true';
        }
        
        // ========== NEW HIERARCHICAL VERSION (dev mode only) ==========
        // Helper function to create a bubble element for an operator
        function createOperatorBubble(node, totalElapsedTimeMs, isNested = false) {
            const timeInfo = node.getTimeInfo();
            const itemsInfo = node.getItemsInOut();
            const colors = node.getColor();
            
            const bubble = document.createElement('div');
            bubble.className = 'step-bubble';
            if (isNested) bubble.classList.add('nested-operator');
            bubble.style.backgroundColor = colors.bg;
            bubble.style.borderColor = colors.border;
            bubble.style.borderWidth = '2px';
            
            let bubbleContent = `
                <h4>${node.getName()}</h4>
                <p><span title="${timeInfo.execTimeTooltip}">${timeInfo.execTimeFormatted}</span> (${timeInfo.percentage}%)</p>`;
            
            if (timeInfo.hasServTime) {
                bubbleContent += `<p><span title="${timeInfo.servTimeTooltip}">${timeInfo.servTimeFormatted}</span> servTime</p>`;
            }
            
            if (itemsInfo.formatted) {
                bubbleContent += `<p>${itemsInfo.formatted}</p>`;
            }
            
            bubble.innerHTML = bubbleContent;
            bubble.addEventListener('click', () => {
                const statsHtml = buildOperatorStats(node.operator);
                document.getElementById('operator-modal-body').innerHTML = statsHtml;
                document.getElementById('operator-modal').style.display = 'block';
            });
            
            return bubble;
        }

        // Helper function to render operator tree hierarchically
        function renderOperatorTree(operator, container, totalElapsedTimeMs, visited = new WeakSet(), skipSequence = true) {
            if (!operator || visited.has(operator)) return;
            visited.add(operator);

            const opType = operator['#operator'];
            
            // Skip Sequence operators by default
            if (skipSequence && opType === 'Sequence') {
                if (operator['~children']) {
                    operator['~children'].forEach(child => {
                        renderOperatorTree(child, container, totalElapsedTimeMs, visited, skipSequence);
                    });
                } else if (operator['~child']) {
                    renderOperatorTree(operator['~child'], container, totalElapsedTimeMs, visited, skipSequence);
                }
                return;
            }

            const node = new PlanNode(operator, null, totalElapsedTimeMs);
            
            // Special handling for operators with child operators that should be visualized nested
            if (opType === 'NestedLoopJoin' || opType === 'HashJoin' || opType === 'HashNest') {
                const joinContainer = document.createElement('div');
                joinContainer.className = 'join-container';
                joinContainer.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 15px; border: 2px dashed #666; border-radius: 8px; background: rgba(255,255,255,0.05);';
                
                // Add join operator bubble
                const joinBubble = createOperatorBubble(node, totalElapsedTimeMs);
                joinContainer.appendChild(joinBubble);
                
                // Add label
                const label = document.createElement('div');
                label.textContent = '‚Üì Joins with ‚Üì';
                label.style.cssText = 'font-size: 12px; color: #999;';
                joinContainer.appendChild(label);
                
                // Render child operator (e.g., ExpressionScan)
                if (operator['~child']) {
                    const childContainer = document.createElement('div');
                    childContainer.style.cssText = 'display: flex; flex-direction: row; align-items: center; gap: 10px;';
                    renderOperatorTree(operator['~child'], childContainer, totalElapsedTimeMs, visited, skipSequence);
                    joinContainer.appendChild(childContainer);
                }
                
                container.appendChild(joinContainer);
            } else if (opType === 'With') {
                // WITH operator - show info and continue with child (main query)
                const withBubble = createOperatorBubble(node, totalElapsedTimeMs);
                container.appendChild(withBubble);
                
                // Add connector
                const connector = document.createElement('div');
                connector.className = 'connector';
                container.appendChild(connector);
                
                // Continue with the main query portion
                if (operator['~child']) {
                    renderOperatorTree(operator['~child'], container, totalElapsedTimeMs, visited, skipSequence);
                }
            } else {
                // Regular operator
                const bubble = createOperatorBubble(node, totalElapsedTimeMs);
                container.appendChild(bubble);
                
                // Add connector if we'll have more children
                const hasChildren = operator['~child'] || (operator['~children'] && operator['~children'].length > 0);
                if (hasChildren) {
                    const connector = document.createElement('div');
                    connector.className = 'connector';
                    container.appendChild(connector);
                }
                
                // Render children
                if (operator['~children']) {
                    operator['~children'].forEach(child => {
                        renderOperatorTree(child, container, totalElapsedTimeMs, visited, skipSequence);
                    });
                } else if (operator['~child']) {
                    renderOperatorTree(operator['~child'], container, totalElapsedTimeMs, visited, skipSequence);
                }
            }
        }

        function generateFlowDiagram_New(request) {
            const flowDiagram = document.getElementById("flow-diagram");
            flowDiagram.innerHTML = "";
            
            const existingControls = document.getElementById('flow-diagram-controls');
            if (existingControls) {
                existingControls.remove();
            }
            
            if (!request || !request.plan) {
                flowDiagram.textContent = TEXT_CONSTANTS.NO_EXECUTION_PLAN;
                return;
            }

            const totalElapsedTimeMs = request.elapsedTimeMs || parseTime(request.elapsedTime) || 0;
            
            const controlsDiv = document.createElement('div');
            controlsDiv.id = 'flow-diagram-controls';
            controlsDiv.style.cssText = 'margin-bottom: 10px; display: flex; gap: 8px; align-items: center; justify-content: flex-end; position: relative; z-index: 10;';
            controlsDiv.innerHTML = `
                <button id="flow-zoom-in" class="btn-standard" style="padding: 6px 12px;" title="Zoom In">üîç+</button>
                <button id="flow-zoom-out" class="btn-standard" style="padding: 6px 12px;" title="Zoom Out">üîç‚àí</button>
                <button id="flow-reset-zoom" class="btn-standard" style="padding: 6px 12px;" title="Reset Zoom">‚åÇ Reset</button>
                <button id="flow-flip" class="btn-standard" style="padding: 6px 12px;" title="Flip Direction">‚áÑ Flip</button>
            `;
            flowDiagram.parentElement.insertBefore(controlsDiv, flowDiagram);

            // Check if there are subqueries (WITH clauses) and render them first
            const subqueries = request.plan['~subqueries'] || [];
            if (subqueries.length > 0) {
                subqueries.forEach((subquery, index) => {
                    const subqueryLabel = document.createElement('div');
                    subqueryLabel.className = 'subquery-label';
                    subqueryLabel.textContent = `üì¶ WITH Subquery ${index + 1} (executed first)`;
                    subqueryLabel.style.cssText = 'font-weight: bold; margin-bottom: 10px; padding: 8px; background: #2a4a5a; border-radius: 4px; color: #fff;';
                    flowDiagram.appendChild(subqueryLabel);
                    
                    const subqueryContainer = document.createElement('div');
                    subqueryContainer.className = 'subquery-flow';
                    subqueryContainer.style.cssText = 'display: flex; flex-direction: row; align-items: center; gap: 10px; padding: 15px; border: 2px solid #4a7a9a; border-radius: 8px; background: rgba(74, 122, 154, 0.1); margin-bottom: 20px;';
                    
                    if (subquery.executionTimings) {
                        renderOperatorTree(subquery.executionTimings, subqueryContainer, totalElapsedTimeMs, new WeakSet(), true);
                    }
                    
                    flowDiagram.appendChild(subqueryContainer);
                });
                
                // Add main query separator
                const separator = document.createElement('div');
                separator.className = 'main-query-separator';
                separator.textContent = '‚Üì Main Query ‚Üì';
                separator.style.cssText = 'font-weight: bold; margin: 20px 0; padding: 8px; background: #3a5a4a; border-radius: 4px; color: #fff; text-align: center;';
                flowDiagram.appendChild(separator);
            }

            // Render the operator tree hierarchically
            renderOperatorTree(request.plan, flowDiagram, totalElapsedTimeMs);

            const viewPlanButton = document.createElement('button');
            viewPlanButton.textContent = TEXT_CONSTANTS.VIEW_DETAILED_PLAN;
            viewPlanButton.style.marginTop = '10px';
            viewPlanButton.addEventListener('click', () => {
                const indexesAndKeys = extractIndexesAndKeys(request);
                const planTreeHtml = buildEnhancedPlanModal(request.plan, indexesAndKeys, request);
                document.getElementById('plan-modal-body').innerHTML = planTreeHtml;
                document.getElementById('plan-modal').style.display = 'block';
            });
            flowDiagram.appendChild(viewPlanButton);

            flowDiagramPanzoomInstance = panzoom(flowDiagram, { smoothScroll: false });

            document.getElementById('flow-zoom-in').addEventListener('click', () => {
                if (flowDiagramPanzoomInstance) {
                    const transform = flowDiagramPanzoomInstance.getTransform();
                    flowDiagramPanzoomInstance.zoomTo(transform.x + flowDiagram.offsetWidth / 2, transform.y + flowDiagram.offsetHeight / 2, 1.2);
                }
            });

            document.getElementById('flow-zoom-out').addEventListener('click', () => {
                if (flowDiagramPanzoomInstance) {
                    const transform = flowDiagramPanzoomInstance.getTransform();
                    flowDiagramPanzoomInstance.zoomTo(transform.x + flowDiagram.offsetWidth / 2, transform.y + flowDiagram.offsetHeight / 2, 0.8);
                }
            });

            document.getElementById('flow-reset-zoom').addEventListener('click', () => {
                if (flowDiagramPanzoomInstance) {
                    flowDiagramPanzoomInstance.moveTo(0, 0);
                    flowDiagramPanzoomInstance.zoomAbs(0, 0, 1);
                }
            });

            document.getElementById('flow-flip').addEventListener('click', () => {
                const currentDirection = flowDiagram.style.flexDirection;
                flowDiagram.style.flexDirection = (currentDirection === 'row-reverse') ? 'row' : 'row-reverse';
            });
        }
        
        // ========== ORIGINAL STABLE VERSION ==========
        function generateFlowDiagram_Original(request) {
            const flowDiagram = document.getElementById("flow-diagram");
            flowDiagram.innerHTML = "";
            if (!request || !request.plan) {
                flowDiagram.textContent = TEXT_CONSTANTS.NO_EXECUTION_PLAN;
                return;
            }

            const totalKernTime = calculateTotalKernTime(request.plan);
            const totalElapsedTimeMs = request.elapsedTimeMs || parseTime(request.elapsedTime) || 0;
            const allOperators = getOperators(request.plan);
            const operators = allOperators.filter(op => op["#operator"] !== "Sequence");

            if (operators.length === 0) {
                flowDiagram.textContent = TEXT_CONSTANTS.NO_OPERATORS_FOUND;
                return;
            }

            operators.forEach((operator, index) => {
                const operatorName = operator["#operator"] || "Unknown Operator";
                const stats = operator["#stats"] || {};
                const kernTime = stats.kernTime || "N/A";
                const execTime = stats.execTime || "N/A";
                const servTime = stats.servTime || "N/A";
                const itemsIn = stats["#itemsIn"] !== undefined ? stats["#itemsIn"] : "-";
                const itemsOut = stats["#itemsOut"] !== undefined ? stats["#itemsOut"] : "-";

                const kernTimeMs = parseTime(kernTime);
                const execTimeMs = parseTime(execTime);
                const servTimeMs = parseTime(servTime);

                const timeForPercentage = !isNaN(servTimeMs) && servTimeMs > 0 ? servTimeMs : execTimeMs;
                const percentage = totalElapsedTimeMs > 0 && !isNaN(timeForPercentage) && timeForPercentage > 0
                    ? ((timeForPercentage / totalElapsedTimeMs) * 100).toFixed(2)
                    : "N/A";

                const bubble = document.createElement("div");
                bubble.className = "step-bubble";

                const percentageColors = getPercentageColor(percentage);
                bubble.style.backgroundColor = percentageColors.bg;
                bubble.style.borderColor = percentageColors.border;
                bubble.style.borderWidth = "2px";

                const colorClass = getColorClass(parseFloat(percentage));
                bubble.classList.add(colorClass);

                const execTimeTooltip = formatTimeTooltip(execTime, execTimeMs);
                let bubbleContent = `
                    <h4>${operatorName}</h4>
                    <p><span title="${execTimeTooltip}">${formatTime(execTimeMs)}</span> (${percentage}%)</p>`;

                if (servTime !== "N/A" && !isNaN(servTimeMs) && servTimeMs > 0) {
                    const servTimeTooltip = formatTimeTooltip(servTime, servTimeMs);
                    bubbleContent += `<p><span title="${servTimeTooltip}">${formatTime(servTimeMs)}</span> servTime</p>`;
                }

                if (itemsIn !== "-" && itemsOut !== "-") {
                    bubbleContent += `<p>${itemsIn} in / ${itemsOut} out</p>`;
                }

                bubble.innerHTML = bubbleContent;
                bubble.addEventListener("click", () => {
                    const statsHtml = buildOperatorStats(operator);
                    document.getElementById("operator-modal-body").innerHTML = statsHtml;
                    document.getElementById("operator-modal").style.display = "block";
                });
                flowDiagram.appendChild(bubble);

                if (index < operators.length - 1) {
                    const connector = document.createElement("div");
                    connector.className = "connector";
                    flowDiagram.appendChild(connector);
                }
            });

            if (request.plan) {
                const viewPlanButton = document.createElement("button");
                viewPlanButton.textContent = TEXT_CONSTANTS.VIEW_DETAILED_PLAN;
                viewPlanButton.style.marginTop = "10px";
                viewPlanButton.addEventListener("click", () => {
                    const indexesAndKeys = extractIndexesAndKeys(request);
                    const planTreeHtml = buildEnhancedPlanModal(request.plan, indexesAndKeys, request);
                    document.getElementById("plan-modal-body").innerHTML = planTreeHtml;
                    document.getElementById("plan-modal").style.display = "block";
                });
                flowDiagram.appendChild(viewPlanButton);
            }

            panzoom(flowDiagram, { smoothScroll: false });
        }
        
        // ========== DISPATCHER FUNCTION ==========
        function generateFlowDiagram(request) {
            if (isDevMode()) {
                generateFlowDiagram_New(request);
            } else {
                generateFlowDiagram_Original(request);
            }
        }

        // Extract indexes and USE KEYS from request
        function extractIndexesAndKeys(request) {
            const indexes = new Set();
            const useKeys = [];
            let hasUseKeys = false;

            // Get bucket.scope.collection from the statement for primary index resolution
            const requestStatement =
                (request.statement || stripEmTags(request.preparedText || "") || "");
            let bucketScopeCollection = "unknown.unknown.unknown";

            const fromMatch = requestStatement.match(/FROM\s+([^\s\n\r\t]+)/i);
            if (fromMatch) {
                const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                const parts = target.split(".");
                if (parts.length === 1) {
                    bucketScopeCollection = `${parts[0]}._default._default`;
                } else if (parts.length === 2) {
                    bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                } else if (parts.length >= 3) {
                    bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                }
            }

            // Extract indexes from plan
            if (request.plan) {
                const operators = getOperators(request.plan);

                operators.forEach((operator, opIndex) => {
                    const opType = operator["#operator"];

                    if (
                        opType === "IndexScan" ||
                        opType === "IndexScan2" ||
                        opType === "IndexScan3"
                    ) {
                        if (operator.index) {
                            indexes.add(operator.index);
                        }
                    }

                    if (
                        opType === "PrimaryScan" ||
                        opType === "PrimaryScan2" ||
                        opType === "PrimaryScan3"
                    ) {
                        try {
                            // First try to resolve #primary to actual name
                            let resolvedName = resolvePrimaryIndexName(
                                bucketScopeCollection
                            );

                            // If we got a real index name (not #primary), use it
                            if (resolvedName && resolvedName !== "#primary") {
                                indexes.add(resolvedName);
                            }
                            // If operator has explicit index name, use that instead
                            else if (operator.index) {
                                indexes.add(operator.index);
                            }
                            // Fallback to #primary
                            else {
                                indexes.add("#primary");
                            }
                        } catch (error) {
                            // Fallback to operator.index if available
                            if (operator.index) {
                                indexes.add(operator.index);
                            } else {
                                indexes.add("#primary");
                            }
                        }
                    }
                });
            }

            // Extract USE KEYS from statement
            if (requestStatement.includes("USE KEYS")) {
                hasUseKeys = true;

                // Handle all USE KEYS formats:
                // USE KEYS(["key1","key2"]) or USE KEYS ["key1","key2"]
                // USE KEYS(['key1','key2']) or USE KEYS ['key1','key2']
                // USE KEYS("key1") or USE KEYS "key1"
                // USE KEYS('key1') or USE KEYS 'key1'

                let match;

                // Extract array format with double quotes: USE KEYS(?)["key1","key2"]
                const arrayDoubleQuotes = /USE\s+KEYS\s*\(?\s*\[(.*?)\]\s*\)?/gi;
                while ((match = arrayDoubleQuotes.exec(requestStatement)) !== null) {
                    // Split by comma and clean up each key, handle both single and double quotes
                    const keys = match[1]
                        .split(",")
                        .map((key) => {
                            return key.trim().replace(/^['"]|['"]$/g, ""); // Remove leading/trailing quotes
                        })
                        .filter((key) => key.length > 0);
                    useKeys.push(...keys);
                }

                // Reset regex for single key formats
                arrayDoubleQuotes.lastIndex = 0;

                // Extract single key format: USE KEYS(?) "key" or USE KEYS(?) 'key'
                // This should not match array formats, so we exclude those with brackets
                const singleKeyRegex =
                    /USE\s+KEYS\s*\(?\s*([^[\],]+?)\s*\)?(?:\s+WHERE|\s*$)/gi;
                while ((match = singleKeyRegex.exec(requestStatement)) !== null) {
                    const key = match[1].trim().replace(/^['"]|['"]$/g, ""); // Remove leading/trailing quotes
                    if (key && !key.includes("[") && !key.includes("]")) {
                        useKeys.push(key);
                    }
                }
            }

            return {
                indexes: Array.from(indexes),
                useKeys: [...new Set(useKeys)], // Remove duplicates
                hasUseKeys,
            };
        }

        // Build enhanced plan modal with indexes and keys
        function buildEnhancedPlanModal(plan, indexesAndKeys, request) {
            let html = '<div style="margin-bottom: 20px;">';

            // Indexes section
            if (indexesAndKeys.indexes.length > 0) {
                html += '<div style="margin-bottom: 15px;">';
                html +=
                    '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                html += `<h3 style="margin: 0; color: #333; font-size: 16px;">${TEXT_CONSTANTS.INDEXES_USED_HEADER}</h3>`;
                const allIndexes = indexesAndKeys.indexes.join(", ");
                html += `<button onclick="copyToClipboard('${allIndexes.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="background: #4CAF50;">${TEXT_CONSTANTS.COPY_ALL}</button>`;
                html += "</div>";
                html += '<div style="display: flex; flex-wrap: wrap; gap: 10px;">';
                indexesAndKeys.indexes.forEach((index) => {
                    html += `<div style="background: #f0f8ff; padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd;">
                        <code style="font-family: monospace; color: #333;">${index}</code>
                    </div>`;
                });
                html += "</div></div>";
            }

            // USE KEYS section
            if (indexesAndKeys.hasUseKeys) {
                html += '<div style="margin-bottom: 15px;">';

                if (indexesAndKeys.useKeys.length > 0) {
                    // Header with Copy All button
                    html +=
                        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                    html += `<h3 style="margin: 0; color: #333; font-size: 16px;">${TEXT_CONSTANTS.USE_KEYS_HEADER}</h3>`;
                    const allKeys = indexesAndKeys.useKeys.join(", ");
                    html += `<button onclick="copyToClipboard('${allKeys.replace(
                        /'/g,
                        "\\'"
                    )}', event)" 
                            class="btn-standard" style="background: #ff9800;">${TEXT_CONSTANTS.COPY_ALL}</button>`;
                    html += "</div>";

                    const maxKeysToShow = 15;
                    const shouldTruncate =
                        indexesAndKeys.useKeys.length > maxKeysToShow;

                    // Keys display container
                    html +=
                        '<div id="keys-container" style="display: flex; flex-wrap: wrap; gap: 8px;">';

                    // Show initial set of keys
                    const keysToShow = shouldTruncate
                        ? indexesAndKeys.useKeys.slice(0, maxKeysToShow)
                        : indexesAndKeys.useKeys;
                    keysToShow.forEach((key) => {
                        html += `<div style="background: #fff3cd; padding: 4px 8px; border-radius: 4px; border: 1px solid #ffeaa7;">
                            <code class="font-size-12" style="font-family: monospace; color: #856404;">${key}</code>
                        </div>`;
                    });

                    // Hidden keys (if truncated)
                    if (shouldTruncate) {
                        const remainingKeys = indexesAndKeys.useKeys.slice(maxKeysToShow);
                        remainingKeys.forEach((key) => {
                            html += `<div class="hidden-key display-none" style="background: #fff3cd; padding: 4px 8px; border-radius: 4px; border: 1px solid #ffeaa7;">
                                <code class="font-size-12" style="font-family: monospace; color: #856404;">${key}</code>
                            </div>`;
                        });
                    }

                    html += "</div>";

                    // Show more/hide button
                    if (shouldTruncate) {
                        const remainingCount =
                            indexesAndKeys.useKeys.length - maxKeysToShow;
                        html += `<div style="margin-top: 10px;">`;
                        html += `<button id="toggle-keys-btn" onclick="toggleUseKeys()" 
                                style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500;">
                                Show ${remainingCount} more keys
                            </button>`;
                        html += `</div>`;
                    }

                    // Summary info
                    html += `<div style="margin-top: 8px; font-size: 11px; color: #666; font-style: italic;">
                        Total: ${indexesAndKeys.useKeys.length} key${indexesAndKeys.useKeys.length !== 1 ? "s" : ""
                        }
                    </div>`;
                } else {
                    html += `<h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">${TEXT_CONSTANTS.USE_KEYS_HEADER}</h3>`;
                    html += `<div style="color: #666; font-style: italic;">${TEXT_CONSTANTS.KEYS_NOT_EXTRACTED}</div>`;
                }
                html += "</div>";
            }

            html += "</div>";

            // Execution plan section
            html += '<div style="border-top: 1px solid #ddd; padding-top: 15px;">';
            
            // Parse time above Execution Plan
            if (request && request.phaseTimes && request.phaseTimes.parse) {
                const parseTimeStr = request.phaseTimes.parse;
                const parseMs = parseTime(parseTimeStr);
                const parseColor = parseMs >= 1 ? '#dc3545' : '#333';
                
                html += `<div style="margin-bottom: 10px;">`;
                html += `<span style="color: #333; font-size: 14px;">Parse Statement: </span>`;
                html += `<span style="color: ${parseColor}; font-weight: bold; font-size: 14px;">${parseTimeStr}</span>`;
                html += `</div>`;
            }
            
            // Execution Plan header with Plan time
            let executionPlanHeader = TEXT_CONSTANTS.EXECUTION_PLAN_HEADER;
            if (request && request.phaseTimes && request.phaseTimes.plan) {
                const planTimeStr = request.phaseTimes.plan;
                const planMs = parseTime(planTimeStr);
                const planColor = planMs >= 1 ? '#dc3545' : '#333';
                
                html += `<h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">`;
                html += executionPlanHeader;
                html += ` <span style="color: ${planColor}; font-weight: bold;">${planTimeStr}</span>`;
                html += `</h3>`;
            } else {
                html += `<h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">${executionPlanHeader}</h3>`;
            }
            
            html += "<ul>" + buildPlanTree(plan) + "</ul>";
            html += "</div>";

            return html;
        }

        // Get operator icon and color based on type
        function getOperatorStyle(operatorName) {
            const styles = {
                Authorize: { icon: "üîê", color: "#6f42c1", bg: "#f8f7ff" },
                Sequence: { icon: "üìã", color: "#856404", bg: "#fff3cd" },
                IndexScan: { icon: "üîç", color: "#007bff", bg: "#e7f3ff" },
                IndexScan2: { icon: "üîç", color: "#007bff", bg: "#e7f3ff" },
                IndexScan3: { icon: "üîç", color: "#007bff", bg: "#e7f3ff" },
                PrimaryScan: { icon: "üîë", color: "#dc3545", bg: "#fff5f5" },
                PrimaryScan3: { icon: "üîë", color: "#dc3545", bg: "#fff5f5" },
                Fetch: { icon: "üì•", color: "#28a745", bg: "#f1f8e9" },
                Filter: { icon: "üîß", color: "#fd7e14", bg: "#fff4e6" },
                InitialGroup: { icon: "üìä", color: "#20c997", bg: "#e6fffa" },
                IntermediateGroup: { icon: "üìà", color: "#20c997", bg: "#e6fffa" },
                FinalGroup: { icon: "üéØ", color: "#20c997", bg: "#e6fffa" },
                InitialProject: { icon: "üìã", color: "#6f42c1", bg: "#f8f7ff" },
                Stream: { icon: "üåä", color: "#17a2b8", bg: "#e2f7fa" },
                Sort: { icon: "üîÑ", color: "#ffc107", bg: "#fff8e1" },
                Limit: { icon: "‚úÇÔ∏è", color: "#e83e8c", bg: "#fce4ec" },
                Offset: { icon: "‚è≠Ô∏è", color: "#6c757d", bg: "#f8f9fa" },
                Union: { icon: "üîó", color: "#795548", bg: "#f3e5f5" },
                Join: { icon: "ü§ù", color: "#9c27b0", bg: "#f3e5f5" },
            };

            return (
                styles[operatorName] || {
                    icon: "‚öôÔ∏è",
                    color: "#6c757d",
                    bg: "#f8f9fa",
                }
            );
        }

        // Format time values for better readability
        // Format time value with color coding for HTML display
        const formatTimeValue = (function() {
            return function(timeStr) {
                if (!timeStr || timeStr === "N/A")
                    return '<span style="color: #999;">N/A</span>';

                // Parse time and check if it's a high value (potential bottleneck)
                const timeMs = parseTime(timeStr);
                const isBottleneck = timeMs > 60000; // > 1 minute
                const isWarning = timeMs > 10000; // > 10 seconds

                let color = "#333";
                let bgColor = "transparent";
                let fontWeight = "normal";

                if (isBottleneck) {
                    color = "#dc3545";
                    bgColor = "#fff5f5";
                    fontWeight = "bold";
                } else if (isWarning) {
                    color = "#fd7e14";
                    bgColor = "#fff4e6";
                    fontWeight = "bold";
                }

                return `<span style="color: ${color}; background: ${bgColor}; font-weight: ${fontWeight}; padding: 1px 4px; border-radius: 3px;">${timeStr}</span>`;
            };
        })();

        // Format item count with color coding for HTML display
        const formatItemCount = (function() {
            return function(count) {
                if (count === undefined || count === null)
                    return '<span style="color: #999;">N/A</span>';

                const numCount = typeof count === "number" ? count : parseInt(count);
                let color = "#333";
                let icon = "";

                if (numCount > 1000000) {
                    color = "#dc3545";
                    icon = "‚ö†Ô∏è ";
                } else if (numCount > 100000) {
                    color = "#fd7e14";
                    icon = "‚ö° ";
                } else if (numCount > 10000) {
                    color = "#ffc107";
                }

                return `<span style="color: ${color};">${icon}${numCount.toLocaleString()}</span>`;
            };
        })();

        // Build plan tree for modal with enhanced formatting
        function buildPlanTree(operator) {
            if (!operator) return "";

            const operatorName = operator["#operator"] || "Unknown Operator";
            const style = getOperatorStyle(operatorName);

            let html = `<li style="margin: 8px 0; padding: 12px; border-left: 4px solid ${style.color}; background: ${style.bg}; border-radius: 6px;">`;

            // Operator header with icon and name
            html += `<div style="display: flex; align-items: center; margin-bottom: 8px;">`;
            html += `<span style="font-size: 18px; margin-right: 8px;">${style.icon}</span>`;
            html += `<strong style="color: ${style.color}; font-size: 16px;">${operatorName}</strong>`;
            html += `</div>`;

            // Statistics section
            if (operator["#stats"]) {
                const stats = operator["#stats"];
                html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; margin: 8px 0; font-size: 13px;">`;

                // Items In/Out
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">üì• Items In:</span> ${formatItemCount(
                    stats["#itemsIn"]
                )}`;
                html += `</div>`;

                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">üì§ Items Out:</span> ${formatItemCount(
                    stats["#itemsOut"]
                )}`;
                html += `</div>`;

                // Execution Time
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">‚è±Ô∏è Exec Time:</span> ${formatTimeValue(
                    stats.execTime
                )}`;
                html += `</div>`;

                // Kernel Time
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">üîß Kern Time:</span> ${formatTimeValue(
                    stats.kernTime
                )}`;
                html += `</div>`;

                html += `</div>`;

                // Efficiency indicator
                const itemsIn = stats["#itemsIn"];
                const itemsOut = stats["#itemsOut"];
                if (itemsIn !== undefined && itemsOut !== undefined && itemsIn > 0) {
                    const efficiency = (itemsOut / itemsIn) * 100;
                    let efficiencyColor = "#28a745";
                    let efficiencyIcon = "‚úÖ";

                    if (efficiency < 50) {
                        efficiencyColor = "#dc3545";
                        efficiencyIcon = "‚ö†Ô∏è";
                    } else if (efficiency < 80) {
                        efficiencyColor = "#ffc107";
                        efficiencyIcon = "‚ö°";
                    }

                    html += `<div style="margin-top: 6px; font-size: 12px;">`;
                    html += `<span style="color: ${efficiencyColor};">${efficiencyIcon} Efficiency: ${efficiency.toFixed(
                        1
                    )}%</span>`;
                    html += `</div>`;
                }
            }

            // Child operations
            const childContainerStyle =
                "margin-top: 10px; margin-left: 20px; border-left: 2px dashed #dee2e6; padding-left: 15px;";

            if (operator["~child"]) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator["~child"]) +
                    "</ul>";
            } else if (operator["~children"]) {
                html += `<ul style="${childContainerStyle}">`;
                operator["~children"].forEach((child) => {
                    html += buildPlanTree(child);
                });
                html += "</ul>";
            }

            // Handle other child properties
            if (operator.input) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.input) +
                    "</ul>";
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                html += `<ul style="${childContainerStyle}">`;
                operator.inputs.forEach((input) => {
                    html += buildPlanTree(input);
                });
                html += "</ul>";
            }
            if (operator.left) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.left) +
                    "</ul>";
            }
            if (operator.right) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.right) +
                    "</ul>";
            }
            if (operator.first) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.first) +
                    "</ul>";
            }
            if (operator.second) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.second) +
                    "</ul>";
            }
            if (operator.scans && Array.isArray(operator.scans)) {
                html += `<ul style="${childContainerStyle}">`;
                operator.scans.forEach((scan) => {
                    html += buildPlanTree(scan);
                });
                html += "</ul>";
            }
            if (operator.scan) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.scan) +
                    "</ul>";
            }
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                html += `<ul style="${childContainerStyle}">`;
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        html += buildPlanTree(subquery.executionTimings);
                    }
                });
                html += "</ul>";
            }

            html += "</li>";
            return html;
        }

        // Sorting functionality
        let currentSortColumn = null;
        let currentSortDirection = "asc";
        let currentTableType = "every-query"; // 'every-query' or 'analysis'
        let everyQueryData = [];
        let analysisData = [];

        // Pagination variables
        let currentPage = 1;
        const pageSize = 50; // Records per page

        // Search/filter variables
        let filteredEveryQueryData = [];
        let currentStatementFilter = "";
        let currentUsernameFilter = "";

        // Analysis table search/filter variables
        let filteredAnalysisData = [];
        let currentAnalysisStatementFilter = "";
        let currentAnalysisUsernameFilter = "";

        // Enhanced time parsing for sorting (handles various units and mm:ss.sss format)
        function parseTimeForSorting(timeStr) {
            if (!timeStr || timeStr === "N/A" || timeStr === "-") return 0;

            // Check if it's in mm:ss.sss format
            const mmssMatch = timeStr.match(/^(\d+):(\d{2})\.(\d{3})$/);
            if (mmssMatch) {
                const minutes = parseInt(mmssMatch[1]);
                const seconds = parseInt(mmssMatch[2]);
                const milliseconds = parseInt(mmssMatch[3]);
                return minutes * 60000 + seconds * 1000 + milliseconds;
            }

            // Handle legacy formats
            const match = timeStr
                .replace(/(\d+\.?\d*)(\D+)/, "$1 $2")
                .match(/(\d+\.?\d*)\s*(\D+)/);
            if (!match) return 0;
            const value = parseFloat(match[1]);
            const unit = match[2].toLowerCase().trim();
            // Convert everything to milliseconds for consistent sorting
            if (unit === "h" || unit === "hour" || unit === "hours")
                return value * 3600000;
            if (
                unit === "m" ||
                unit === "min" ||
                unit === "minute" ||
                unit === "minutes"
            )
                return value * 60000;
            if (
                unit === "s" ||
                unit === "sec" ||
                unit === "second" ||
                unit === "seconds"
            )
                return value * 1000;
            if (unit === "ms" || unit === "millisecond" || unit === "milliseconds")
                return value;
            if (
                unit === "us" ||
                unit === "¬µs" ||
                unit === "microsecond" ||
                unit === "microseconds"
            )
                return value / 1000;
            if (unit === "ns" || unit === "nanosecond" || unit === "nanoseconds")
                return value / 1000000;
            return value;
        }

        // Get sortable value for a column
        function getSortableValue(item, columnId) {
            // Try to find column config in Every Query columns or Analysis columns
            let colConfig = EVERY_QUERY_COLUMNS.find(col => col.id === columnId);
            
            if (!colConfig) {
                colConfig = ANALYSIS_COLUMNS.find(col => col.id === columnId);
            }
            
            // If still not found, return default
            if (!colConfig) {
                // Default for unknown columns: string comparison
                return String(item[columnId] || "").toLowerCase();
            }

            const value = item[columnId];

            // Use custom sort function if defined
            if (colConfig.sortFn) {
                return colConfig.sortFn(value);
            }

            // Use sortType to determine how to sort
            switch (colConfig.sortType) {
                case 'numeric':
                    return parseFloat(value) || 0;
                case 'time':
                    return parseTimeForSorting(value);
                case 'date':
                    return new Date(value).getTime() || 0;
                case 'percent':
                    return parseFloat(String(value).replace('%', '')) || 0;
                case 'boolean':
                    return value === 'Yes' ? 1 : 0;
                case 'string':
                default:
                    return String(value || '').toLowerCase();
            }
        }

        // Sort data
        function sortData(data, column, direction) {
            return [...data].sort((a, b) => {
                const aVal = getSortableValue(a, column);
                const bVal = getSortableValue(b, column);

                let comparison = 0;
                if (aVal < bVal) comparison = -1;
                else if (aVal > bVal) comparison = 1;

                return direction === "asc" ? comparison : -comparison;
            });
        }

        // Update sort arrows in headers
        function updateSortArrows(tableHeaderId, column, direction) {
            const headers = document.querySelectorAll(`#${tableHeaderId} th`);
            headers.forEach((th) => {
                // Remove existing sort indicators
                const existingArrow = th.querySelector(".sort-arrow");
                const existingSortHint = th.querySelector(".sort-hint");
                if (existingArrow) existingArrow.remove();
                if (existingSortHint) existingSortHint.remove();

                // Handle multi-line headers by removing newlines for comparison
                const headerText = th.innerHTML
                    .replace(/<br>/g, " ")
                    .replace(/<[^>]*>/g, "")
                    .replace(/\s+/g, " ")
                    .trim();
                const columnText = column.replace(/\n/g, " ").trim();

                if (headerText === columnText) {
                    // Remove the old sort hint and add prominent arrow
                    const oldHint = th.querySelector("div");
                    if (oldHint && oldHint.textContent === "‚Üï Sort") {
                        oldHint.remove();
                    }

                    const arrow = document.createElement("div");
                    arrow.className = "sort-arrow";
                    arrow.style.fontSize = "14px";
                    arrow.style.color = "#0066cc";
                    arrow.style.fontWeight = "bold";
                    arrow.style.marginTop = "2px";

                    if (direction === "asc") {
                        arrow.textContent = "‚ñ≤ ASC";
                        arrow.style.color = "#28a745";
                    } else {
                        arrow.textContent = "‚ñº DESC";
                        arrow.style.color = "#dc3545";
                    }

                    th.appendChild(arrow);
                } else {
                    // Add back the sort hint for non-active columns
                    const sortHint = document.createElement("div");
                    sortHint.className = "sort-hint";
                    sortHint.style.fontSize = "10px";
                    sortHint.style.color = "#6c757d";
                    sortHint.style.fontWeight = "normal";
                    sortHint.style.marginTop = "2px";
                    sortHint.textContent = "‚Üï Sort";
                    th.appendChild(sortHint);
                }
            });
        }

        // Map display column names to data field names
        function getDataFieldName(displayColumn) {
            // Map display names back to data field names (same logic as in populateEveryQueryTable)
            if (displayColumn === "request\nTime") return "requestTime";
            else if (displayColumn === "statement\nType") return "statementType";
            else if (displayColumn === "elapsed\nTime") return "elapsedTime";
            else if (displayColumn === "service\nTime") return "serviceTime";
            else if (displayColumn === "kern\nTime") return "kernTime";
            else if (displayColumn === "KernTime\n%") return "KernTime %";
            else if (displayColumn === "cpu\nTime") return "cpuTime";
            else if (displayColumn === "memory\n(MB)") return "memory (MB)";
            else if (displayColumn === "result\nCount") return "resultCount";
            else if (displayColumn === "result\nSize") return "resultSize";
            else if (displayColumn === "Items from\nIndex Scan")
                return "Items from Index Scan";
            else if (displayColumn === "Doc Fetch\nCount") return "Doc Fetch Count";
            else if (displayColumn === "Primary Scan\nUsed")
                return "Primary Scan Used";
            else if (displayColumn === "Scan\nConsistency")
                return "scanConsistency";
            else return displayColumn; // For columns without newlines like "#", "state", "statement", "users"
        }

        // Handle column sort click
        function handleColumnSort(column, tableType) {
            // Map display column to data field
            const dataField = getDataFieldName(column);

            if (currentSortColumn === column && currentTableType === tableType) {
                currentSortDirection =
                    currentSortDirection === "asc" ? "desc" : "asc";
            } else {
                currentSortColumn = column;
                currentSortDirection = "asc";
                currentTableType = tableType;
            }

            if (tableType === "every-query") {
                currentPage = 1; // Reset to first page after sorting

                // Sort using the data field name, not the display name
                const sortedData = sortData(
                    filteredEveryQueryData,
                    dataField,
                    currentSortDirection
                );

                filteredEveryQueryData = sortedData;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSortArrows("table-header", column, currentSortDirection);
            } else if (tableType === "analysis") {
                // Sort the filtered analysis data
                const sortedData = sortData(
                    filteredAnalysisData,
                    column,
                    currentSortDirection
                );
                filteredAnalysisData = sortedData;
                populateAnalysisTable(filteredAnalysisData);
                updateSortArrows(
                    "analysis-table-header",
                    column,
                    currentSortDirection
                );
            }
        }

        // Create pagination controls
        function addPaginationControls(totalRecords) {
            const tableContainer = document.getElementById("table-container");
            let paginationDiv = document.getElementById("pagination");
            if (!paginationDiv) {
                paginationDiv = document.createElement("div");
                paginationDiv.id = "pagination";
                paginationDiv.style.textAlign = "center";
                paginationDiv.style.marginTop = "10px";
                paginationDiv.style.backgroundColor = "#f5f5f5";
                paginationDiv.style.padding = "10px";
                paginationDiv.style.borderTop = "1px solid #ddd";
                tableContainer.appendChild(paginationDiv);
            }
            paginationDiv.innerHTML = "";

            const totalPages = Math.ceil(totalRecords / pageSize);

            // Previous button
            const prevButton = createButton("‚óÄ Prev", () => {
                if (currentPage > 1) {
                    currentPage--;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            prevButton.disabled = currentPage === 1;

            // Next button
            const nextButton = createButton("Next ‚ñ∂", () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            nextButton.disabled = currentPage === totalPages;

            // Page info
            const pageInfo = document.createElement("span");
            pageInfo.textContent = ` Page ${currentPage} of ${totalPages} (${totalRecords} records) `;
            pageInfo.style.margin = "0 15px";
            pageInfo.style.fontWeight = "bold";

            // Page jump input
            const pageInput = document.createElement("input");
            pageInput.type = "number";
            pageInput.min = "1";
            pageInput.max = totalPages.toString();
            pageInput.value = currentPage.toString();
            pageInput.style.width = "60px";
            pageInput.style.margin = "0 5px";
            pageInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                    const newPage = parseInt(pageInput.value);
                    if (newPage >= 1 && newPage <= totalPages) {
                        currentPage = newPage;
                        populateEveryQueryTable(filteredEveryQueryData);
                    }
                }
            });

            const jumpLabel = document.createElement("span");
            jumpLabel.textContent = "Go to page: ";
            jumpLabel.style.marginLeft = "20px";

            paginationDiv.appendChild(prevButton);
            paginationDiv.appendChild(pageInfo);
            paginationDiv.appendChild(nextButton);
            paginationDiv.appendChild(jumpLabel);
            paginationDiv.appendChild(pageInput);
        }

        function createButton(text, onClick) {
            const btn = document.createElement("button");
            btn.textContent = text;
            btn.style.margin = "0 5px";
            btn.style.padding = "5px 10px";
            btn.style.cursor = "pointer";
            btn.onclick = onClick;
            return btn;
        }

        // Filter data based on search criteria
        function filterEveryQueryData(data) {
            return data.filter((rowData) => {
                // Filter by statement
                if (currentStatementFilter) {
                const combined = (
                    ((rowData.request && rowData.request.statement) || "") +
                " " +
                    ((rowData.request && rowData.request.preparedText) || "")
                    ).toLowerCase();
                    if (!combined.includes(currentStatementFilter.toLowerCase())) {
                        return false;
                    }
                }

                // Filter by username
                if (currentUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update search results info
        function updateSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} records`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} records`;
            }
        }

        // Filter analysis data based on search criteria
        function filterAnalysisData(data) {
            return data.filter((rowData) => {
                // Filter by statement
                if (currentAnalysisStatementFilter) {
                    const combined = (
                        (rowData.statement || "") + " " + (rowData.preparedSample || "")
                    ).toLowerCase();
                    if (
                        !combined.includes(currentAnalysisStatementFilter.toLowerCase())
                    ) {
                        return false;
                    }
                }

                // Filter by username
                if (currentAnalysisUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentAnalysisUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update analysis search results info
        function updateAnalysisSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("analysis-search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} groups`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} groups`;
            }
        }

        // Setup analysis search event listeners
        function setupAnalysisSearchListeners() {
            const statementSearch = document.getElementById(
                "analysis-statement-search"
            );
            const usernameSearch = document.getElementById(
                "analysis-username-search"
            );
            const clearButton = document.getElementById("analysis-clear-search");

            function performAnalysisSearch() {
                currentAnalysisStatementFilter = statementSearch.value.trim();
                currentAnalysisUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredAnalysisData = filterAnalysisData(analysisData);

                // Update display
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(
                    filteredAnalysisData.length,
                    analysisData.length
                );
            }

            // Add debouncing to search inputs
            let analysisSearchTimeout;
            function debouncedAnalysisSearch() {
                clearTimeout(analysisSearchTimeout);
                analysisSearchTimeout = setTimeout(performAnalysisSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedAnalysisSearch);
            usernameSearch.addEventListener("input", debouncedAnalysisSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentAnalysisStatementFilter = "";
                currentAnalysisUsernameFilter = "";
                filteredAnalysisData = [...analysisData];
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(
                    filteredAnalysisData.length,
                    analysisData.length
                );
            });
        }

        // Setup search event listeners
        function setupSearchListeners() {
            const statementSearch = document.getElementById("statement-search");
            const usernameSearch = document.getElementById("username-search");
            const clearButton = document.getElementById("clear-search");

            function performSearch() {
                currentStatementFilter = statementSearch.value.trim();
                currentUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredEveryQueryData = filterEveryQueryData(everyQueryData);

                // Reset to first page
                currentPage = 1;

                // Update display
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(
                    filteredEveryQueryData.length,
                    everyQueryData.length
                );
            }

            // Add debouncing to search inputs
            let searchTimeout;
            function debouncedSearch() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(performSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedSearch);
            usernameSearch.addEventListener("input", debouncedSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentStatementFilter = "";
                currentUsernameFilter = "";
                filteredEveryQueryData = [...everyQueryData];
                currentPage = 1;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(
                    filteredEveryQueryData.length,
                    everyQueryData.length
                );
            });
        }

        // Column Configuration for Every Query Table
        const EVERY_QUERY_COLUMNS = [
            {
                id: 'rowNumber',
                header: '#',
                dataField: null,
                sortable: true,
                sortType: 'numeric',
                getValue: (request, index) => index + 1,
                render: (value) => value
            },
            {
                id: 'requestTime',
                header: 'request\nTime',
                dataField: 'requestTime',
                sortable: true,
                sortType: 'date',
                getValue: (request) => {
                    const originalTime = request.requestTime || 'N/A';
                    if (originalTime === 'N/A') return originalTime;
                    
                    // Apply timezone conversion
                    const convertedDate = getChartDate(originalTime);
                    return convertedDate ? formatTimestamp(convertedDate, "YYYY-MM-DD HH:MM:SS.sssZ") : originalTime;
                },
                render: (value) => value
            },
            {
                id: 'statementType',
                header: 'statement\nType',
                dataField: 'statementType',
                sortable: true,
                sortType: 'string',
                getValue: (request) => request.statementType || 'N/A',
                render: (value) => value
            },
            {
                id: 'elapsedTime',
                header: 'elapsed\nTime',
                dataField: 'elapsedTime',
                sortable: true,
                sortType: 'time',
                getValue: (request) => formatTime(request.elapsedTimeMs || 0),
                render: (value) => value
            },
            {
                id: 'serviceTime',
                header: 'service\nTime',
                dataField: 'serviceTime',
                sortable: true,
                sortType: 'time',
                getValue: (request) => formatTime(request.serviceTimeMs || parseTime(request.serviceTime)),
                render: (value) => value
            },
            {
                id: 'kernTime',
                header: 'kern\nTime',
                dataField: 'kernTime',
                sortable: true,
                sortType: 'time',
                getValue: (request) => {
                    const ms = request.kernTimeMs || 0;
                    return ms > 0 ? formatTime(ms) : 'N/A';
                },
                render: (value) => value
            },
            {
                id: 'kernTimePercent',
                header: 'KernTime\n%',
                dataField: 'KernTime %',
                sortable: true,
                sortType: 'percent',
                getValue: (request) => {
                    const elapsed = request.elapsedTimeMs || 0;
                    const kern = request.kernTimeMs || 0;
                    return elapsed > 0 && kern > 0 
                        ? ((kern / elapsed) * 100).toFixed(2) + '%' 
                        : 'N/A';
                },
                render: (value) => value
            },
            {
                id: 'cpuTime',
                header: 'cpu\nTime',
                dataField: 'cpuTime',
                sortable: true,
                sortType: 'time',
                getValue: (request) => formatTime(parseTime(request.cpuTime)),
                render: (value) => value
            },
            {
                id: 'memory',
                header: 'memory\n(MB)',
                dataField: 'memory (MB)',
                sortable: true,
                sortType: 'numeric',
                getValue: (request) => {
                    return (request.memoryBytes == null)
                        ? 'N/A'
                        : (request.memoryBytes / 1024 / 1024).toFixed(2);
                },
                render: (value) => value
            },
            {
                id: 'resultCount',
                header: 'result\nCount',
                dataField: 'resultCount',
                sortable: true,
                sortType: 'numeric',
                getValue: (request) => request.resultCount || 'N/A',
                render: (value, td, rowData) => {
                    const num = Number(value);
                    const formattedValue = isNaN(num) ? value : num.toLocaleString();
                    
                    // Issue #236: Highlight discrepancies between resultCount and itemsFromIndexScan
                    const indexScanValue = rowData.itemsFromIndexScan;
                    const resultCountValue = value;
                    
                    // Check if we should apply highlighting
                    const shouldHighlight = (
                        // Both values must be numeric (not N/A)
                        indexScanValue !== 'N/A' && 
                        resultCountValue !== 'N/A' &&
                        !isNaN(Number(indexScanValue)) &&
                        !isNaN(Number(resultCountValue)) &&
                        // Values must be different
                        Number(indexScanValue) !== Number(resultCountValue)
                    );
                    
                    if (shouldHighlight) {
                        td.style.fontWeight = 'bold';
                        td.style.color = '#FF8C00'; // Burnt orange (distinct from red)
                    }
                    
                    return formattedValue;
                }
            },
            {
                id: 'resultSize',
                header: 'result\nSize',
                dataField: 'resultSize',
                sortable: true,
                sortType: 'numeric',
                getValue: (request) => request.resultSize || 'N/A',
                render: (value) => {
                    const num = Number(value);
                    return isNaN(num) ? value : num.toLocaleString();
                }
            },
            {
                id: 'docFetchCount',
                header: 'Doc Fetch\nCount',
                dataField: 'Doc Fetch Count',
                sortable: true,
                sortType: 'numeric',
                getValue: (request) => {
                    const fetchCount = request.phaseCounts?.fetch || 0;
                    return fetchCount > 0 ? fetchCount : 'N/A';
                },
                render: (value) => {
                    const num = Number(value);
                    return isNaN(num) ? value : num.toLocaleString();
                }
            },
            {
                id: 'itemsFromIndexScan',
                header: 'Items from\nIndex Scan',
                dataField: 'Items from Index Scan',
                sortable: true,
                sortType: 'numeric',
                getValue: (request) => {
                    const indexScanCount = request.phaseCounts?.indexScan ||
                        request.phaseCounts?.primaryScan || 0;
                    return indexScanCount > 0 ? indexScanCount : 'N/A';
                },
                render: (value) => {
                    const num = Number(value);
                    return isNaN(num) ? value : num.toLocaleString();
                }
            },
            {
                id: 'primaryScanUsed',
                header: 'Primary Scan\nUsed',
                dataField: 'Primary Scan Used',
                sortable: true,
                sortType: 'boolean',
                getValue: (request) => request.usesPrimary ? 'Yes' : 'No',
                render: (value, td) => {
                    if (value === 'Yes' || value === 'True' || value === true) {
                        td.classList.add('primary-scan-yes');
                    }
                    return value;
                }
            },
            {
                id: 'state',
                header: 'state',
                dataField: 'state',
                sortable: true,
                sortType: 'custom',
                getValue: (request) => request.state || 'N/A',
                sortFn: (value) => {
                    if (value === 'fatal') return 'aaa_fatal';
                    if (value === 'completed') return 'bbb_completed';
                    return String(value || 'zzz_unknown').toLowerCase();
                },
                render: (value, td) => {
                    if (value === 'fatal') {
                        td.classList.add('fatal-state');
                    }
                    return value;
                }
            },
            {
                id: 'statement',
                header: 'statement',
                dataField: 'statement',
                width: '300px',
                maxWidth: '300px',
                sortable: true,
                sortType: 'string',
                getValue: (request) => request.statement || request.preparedText || 'N/A',
                render: (value, td, rowData, globalIndex) => {
                    const statementId = `statement-${globalIndex}`;
                    statementStore[statementId] = value;
                    
                    if (value.length > 500) {
                        const truncated = value.substring(0, 500);
                        const preparedSample = (rowData.request && isPreparedExecution(rowData.request)) 
                            ? getPreparedSample(rowData.request) : "";
                        const preparedSnippet = preparedSample 
                            ? `<div style="margin-top:6px; color:#555; font-size:12px;"><strong>${TEXT_CONSTANTS.PREPARED_TEXT || 'Prepared:'}</strong> ${escapeHtml(preparedSample.substring(0, 300))}${preparedSample.length > 300 ? '...' : ''}</div>` 
                            : '';
                        
                        return `
                            <div id="${statementId}-truncated">
                                <span>${truncated}...</span>
                                ${preparedSnippet}
                                <br>
                                <button onclick="toggleStatement('${statementId}', true)" 
                                        class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                                <button onclick="copyStatement('${statementId}', event)" 
                                        class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                            </div>
                            <div id="${statementId}-full" style="display: none;">
                                <span>${value}</span>
                                ${preparedSnippet}
                                <br>
                                <button onclick="toggleStatement('${statementId}', false)" 
                                        class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                                <button onclick="copyStatement('${statementId}', event)" 
                                        class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                            </div>
                        `;
                    } else {
                        const preparedSample = (rowData.request && isPreparedExecution(rowData.request)) 
                            ? getPreparedSample(rowData.request) : "";
                        const preparedSnippet = preparedSample 
                            ? `<div style="margin-top:6px; color:#555; font-size:12px;"><strong>${TEXT_CONSTANTS.PREPARED_TEXT || 'Prepared:'}</strong> ${escapeHtml(preparedSample.substring(0, 300))}${preparedSample.length > 300 ? '...' : ''}</div>` 
                            : '';
                        return `
                            <div>
                                <span>${value}</span>
                                ${preparedSnippet}
                                <br>
                                <button onclick="copyStatement('${statementId}', event)" 
                                        class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                            </div>
                        `;
                    }
                }
            },
            {
                id: 'scanConsistency',
                header: 'Scan\nConsistency',
                dataField: 'scanConsistency',
                sortable: true,
                sortType: 'string',
                getValue: (request) => {
                    return request.request && request.request.scanConsistency 
                        ? request.request.scanConsistency 
                        : 'N/A';
                },
                render: (value) => value
            },
            {
                id: 'users',
                header: 'users',
                dataField: 'users',
                sortable: true,
                sortType: 'string',
                getValue: (request) => request.users || 'N/A',
                render: (value) => value
            },
            {
                id: 'requestId',
                header: 'requestId',
                dataField: 'requestId',
                sortable: true,
                sortType: 'string',
                getValue: (request) => {
                    return (request.request && request.request.requestId) 
                        || request.requestId 
                        || '';
                },
                render: (value) => {
                    const safeId = String(value);
                    return `
                        <div style="display: flex; flex-direction: column; align-items: flex-start; gap: 4px;">
                            <code style="font-size:11px; word-break: break-all;">${escapeHtml(safeId)}</code>
                            <button data-id="${escapeHtml(safeId)}" 
                                    onclick="openRawRecordFullscreen(this.dataset.id, event)" 
                                    class="btn-standard" 
                                    style="padding: 4px 8px; font-size: 11px;">üëÅÔ∏è View</button>
                        </div>
                    `;
                }
            }
        ];

        // Generate main table
        function generateTable(requests) {
            const tableHeader = document.getElementById("table-header");
            const tableBody = document.getElementById("table-body");
            tableHeader.innerHTML = "";
            tableBody.innerHTML = "";

            const headerRow = document.createElement("tr");
            EVERY_QUERY_COLUMNS.forEach((colConfig) => {
                const th = document.createElement("th");
                th.innerHTML = colConfig.header.replace(/\n/g, "<br>");
                th.style.textAlign = "center";
                th.style.whiteSpace = "nowrap";
                th.style.cursor = "pointer";
                th.style.userSelect = "none";
                th.style.padding = "8px";
                th.style.backgroundColor = "#f8f9fa";
                th.style.border = "1px solid #dee2e6";
                th.style.fontWeight = "bold";
                th.style.position = "relative";

                // Apply column-specific width if defined
                if (colConfig.width) th.style.width = colConfig.width;
                if (colConfig.maxWidth) th.style.maxWidth = colConfig.maxWidth;

                // Add hover effect
                th.addEventListener("mouseenter", () => {
                    th.style.backgroundColor = "#e9ecef";
                });
                th.addEventListener("mouseleave", () => {
                    th.style.backgroundColor = "#f8f9fa";
                });

                // Add sorting indicator text
                if (colConfig.sortable) {
                    const sortHint = document.createElement("div");
                    sortHint.className = "sort-hint";
                    sortHint.style.fontSize = "10px";
                    sortHint.style.color = "#6c757d";
                    sortHint.style.fontWeight = "normal";
                    sortHint.style.marginTop = "2px";
                    sortHint.textContent = "‚Üï Sort";
                    th.appendChild(sortHint);

                    th.addEventListener("click", () => {
                        handleColumnSort(colConfig.id, "every-query");
                    });
                }
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);

            // Prepare data with pre-calculated values using column config
            const tableData = requests.map((request, index) => {
                const rowData = {
                    rowIndex: index + 1,
                    request: request, // Keep original request for click handler
                };

                EVERY_QUERY_COLUMNS.forEach((colConfig) => {
                    let value;
                    if (colConfig.getValue) {
                        value = colConfig.getValue(request, index);
                    } else if (colConfig.dataField) {
                        value = request[colConfig.dataField] || 'N/A';
                    }
                    rowData[colConfig.id] = value;
                });

                return rowData;
            });

            // Sort by elapsedTime by default
            const sortedData = sortData(tableData, "elapsedTime", "desc");
            everyQueryData = sortedData;
            filteredEveryQueryData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "elapsedTime";
            currentSortDirection = "desc";
            currentTableType = "every-query";

            // Reset pagination when new data is loaded
            currentPage = 1;

            // Setup search listeners (only once)
            if (
                !document
                    .getElementById("statement-search")
                    .hasAttribute("data-listeners-added")
            ) {
                setupSearchListeners();
                document
                    .getElementById("statement-search")
                    .setAttribute("data-listeners-added", "true");
            }

            populateEveryQueryTable(filteredEveryQueryData);
            updateSortArrows("table-header", "elapsedTime", "desc");
            updateSearchResultsInfo(
                filteredEveryQueryData.length,
                everyQueryData.length
            );
        }

        // Populate Every Query table body
        function populateEveryQueryTable(data) {
            const tableBody = document.getElementById("table-body");
            tableBody.innerHTML = "";

            // Clear statement store for new data (only for current page)
            statementStore = {};

            // Pagination: get only the current page data
            const start = (currentPage - 1) * pageSize;
            const end = Math.min(start + pageSize, data.length);
            const pageData = data.slice(start, end);

            // Use DocumentFragment for batch DOM insertion
            const fragment = document.createDocumentFragment();

            pageData.forEach((rowData, pageIndex) => {
                const globalIndex = start + pageIndex;
                const row = document.createElement("tr");

                EVERY_QUERY_COLUMNS.forEach((colConfig) => {
                    const td = document.createElement("td");
                    const value = rowData[colConfig.id];

                    // Apply custom rendering if defined
                    if (colConfig.render) {
                        const rendered = colConfig.render(value, td, rowData, globalIndex);
                        if (typeof rendered === 'string') {
                            td.innerHTML = rendered;
                        } else {
                            td.textContent = rendered;
                        }
                    } else {
                        td.textContent = value;
                    }

                    // Apply special CSS classes based on column ID
                    if (colConfig.id === 'requestTime') {
                        td.className = 'td-request-time';
                    } else if (colConfig.id === 'requestId') {
                        td.className = 'td-request-id';
                    } else if (colConfig.id === 'statement') {
                        td.className = 'td-statement';
                    }

                    row.appendChild(td);
                });

                row.addEventListener("click", (event) => {
                    // Allow text selection - only handle clicks, not text selection
                    if (window.getSelection().toString().length > 0) {
                        return;
                    }

                    document
                        .querySelectorAll("tr")
                        .forEach((r) => (r.style.backgroundColor = ""));
                    row.style.backgroundColor = "#e0e0e0";
                    generateFlowDiagram(rowData.request);
                });
                fragment.appendChild(row);
            });

            // Batch insert all rows at once
            tableBody.appendChild(fragment);

            // Auto-render the first row's flow diagram once (initial load or when diagram is empty)
            try {
                const flowEl = document.getElementById("flow-diagram");
                const shouldAuto = flowEl && (!flowEl.hasChildNodes() || flowEl.children.length === 0 || (flowEl.textContent || "").trim() === (TEXT_CONSTANTS.SELECT_QUERY_FLOW || ""));
                if (shouldAuto && pageData.length > 0) {
                    generateFlowDiagram(pageData[0].request);
                    if (tableBody.firstElementChild) {
                        tableBody.firstElementChild.style.backgroundColor = "#e0e0e0";
                    }
                }
            } catch (e) { /* no-op */ }

            // Add pagination controls
            addPaginationControls(data.length);
        }

        // Toggle statement display between truncated and full view
        function toggleStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy statement to clipboard
        function copyStatement(statementId, event) {
            const statement = statementStore[statementId];
            if (!statement) {
                Logger.error("Statement not found in store:", statementId);
                alert(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                return;
            }
            ClipboardUtils.copyToClipboard(statement, event.target, {
                successText: "copied!"
            });
        }

        // Toggle analysis statement display between truncated and full view
        function toggleAnalysisStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy analysis statement to clipboard
        function copyAnalysisStatement(statementId, event) {
            const statement = analysisStatementStore[statementId];
            if (!statement) {
                Logger.error("Statement not found in store:", statementId);
                alert(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                return;
            }
            ClipboardUtils.copyToClipboard(statement, event.target, {
                successText: "copied!"
            });
        }

        // Calculate statistics for a group of requests based on SQL++ query logic
        function calculateGroupStats(normalized_statement, groupedRequests) {
            const users_agg = groupedRequests.map((r) => r.users).filter((u) => u);
            const durations = groupedRequests
                .map((r) => {
                    const ms = parseTime(r.serviceTime);
                    return isNaN(ms) ? NaN : ms / 1000; // Convert ms to seconds
                })
                .filter((d) => !isNaN(d));
            const total_count = durations.length;
            if (total_count === 0) return null;

            const min_duration = Math.min(...durations);
            const max_duration = Math.max(...durations);
            const avg_duration =
                durations.reduce((sum, d) => sum + d, 0) / total_count;
            const sorted_durations = [...durations].sort((a, b) => a - b);
            const midFloor = Math.floor(total_count / 2);
            const midCeil = Math.ceil(total_count / 2) - 1;
            const median_duration =
                (sorted_durations[midFloor] + sorted_durations[midCeil]) / 2;

            const fetchValues = groupedRequests.map(
                (r) => r.phaseCounts?.fetch || 0
            );
            const primaryScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.primaryScan || 0
            );
            const indexScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.indexScan || 0
            );
            const avg_fetch =
                fetchValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_primaryScan =
                primaryScanValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_indexScan =
                indexScanValues.reduce((sum, v) => sum + v, 0) / total_count;

            // Calculate resultCount and resultSize
            const resultCountValues = groupedRequests.map(
                (r) => r.resultCount || 0
            );
            const resultSizeValues = groupedRequests.map(
                (r) => r.resultSize || 0
            );
            const avg_resultCount =
                resultCountValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_resultSize =
                resultSizeValues.reduce((sum, v) => sum + v, 0) / total_count;

            // Compute user_query_counts as an object: { user: count }
            const uniqueUsers = [...new Set(users_agg)];
            const user_query_counts = {};
            uniqueUsers.forEach((user) => {
                user_query_counts[user] = users_agg.filter((v) => v === user).length;
            });

            // Calculate status counts
            const status_counts = {
                completed: 0,
                fatal: 0,
                cancelled: 0,
                other: 0
            };

            groupedRequests.forEach((r) => {
                const state = r.state ? r.state.toLowerCase() : 'completed';
                if (state === 'completed') {
                    status_counts.completed++;
                } else if (state === 'fatal') {
                    status_counts.fatal++;
                } else if (state === 'cancelled') {
                    status_counts.cancelled++;
                } else {
                    status_counts.other++;
                }
            });

            // Build average/min/max phase times (ms) for timeline chart
            function phaseStats(keys) {
                const keysArr = Array.isArray(keys) ? keys : [keys];
                const values = groupedRequests.map(r => {
                    const pt = r.phaseTimes || {};
                    let v = 0;
                    keysArr.forEach((k) => { if (pt && pt[k]) v += parseTime(pt[k]) || 0; });
                    return v;
                });
                const valid = values.filter(v => typeof v === 'number');
                const cnt = valid.length;
                if (cnt === 0) return { avg: 0, min: 0, max: 0 };
                const sum = valid.reduce((a,b)=>a+b,0);
                return { avg: sum/cnt, min: Math.min(...valid), max: Math.max(...valid) };
            }

            const s_authorize = phaseStats('authorize');
            const s_parse = phaseStats('parse');
            const s_plan = phaseStats('plan');
            const s_index = phaseStats(['indexScan','primaryScan','primaryScan.GSI']);
            const s_fetch = phaseStats('fetch');
            const s_join = phaseStats(['hashJoin','nestedLoopJoin']);
            const s_nest = phaseStats('nest');
            const s_unnest = phaseStats('unnest');
            const s_filter = phaseStats('filter');
            const s_group = phaseStats(['group','aggregate']);
            const s_sort = phaseStats('sort');
            const s_limit = phaseStats('limit');
            const s_project = phaseStats('project');
            const s_delete = phaseStats('delete');
            const s_update = phaseStats('update');
            const s_insert = phaseStats('insert');
            const s_stream = phaseStats('stream');

            const avgPhaseTimeline = [
                { id: 'authorize', label: TEXT_CONSTANTS.PHASE_AUTHORIZE || 'authorize', avgMs: s_authorize.avg, minMs: s_authorize.min, maxMs: s_authorize.max },
                { id: 'parse', label: TEXT_CONSTANTS.PHASE_PARSE, avgMs: s_parse.avg, minMs: s_parse.min, maxMs: s_parse.max },
                { id: 'plan', label: TEXT_CONSTANTS.PHASE_PLAN, avgMs: s_plan.avg, minMs: s_plan.min, maxMs: s_plan.max },
                { id: 'indexScan', label: TEXT_CONSTANTS.PHASE_INDEX_SCAN || 'index scan', avgMs: s_index.avg, minMs: s_index.min, maxMs: s_index.max },
                { id: 'fetch', label: TEXT_CONSTANTS.PHASE_FETCH || 'fetch data', avgMs: s_fetch.avg, minMs: s_fetch.min, maxMs: s_fetch.max },
                { id: 'join', label: TEXT_CONSTANTS.PHASE_JOIN || 'JOIN', avgMs: s_join.avg, minMs: s_join.min, maxMs: s_join.max },
                { id: 'nest', label: 'Nest', avgMs: s_nest.avg, minMs: s_nest.min, maxMs: s_nest.max },
                { id: 'unnest', label: 'Unnest', avgMs: s_unnest.avg, minMs: s_unnest.min, maxMs: s_unnest.max },
                { id: 'filter', label: TEXT_CONSTANTS.PHASE_FILTER, avgMs: s_filter.avg, minMs: s_filter.min, maxMs: s_filter.max },
                { id: 'groupAgg', label: TEXT_CONSTANTS.PHASE_GROUP_AGG, avgMs: s_group.avg, minMs: s_group.min, maxMs: s_group.max },
                { id: 'sort', label: TEXT_CONSTANTS.PHASE_SORT, avgMs: s_sort.avg, minMs: s_sort.min, maxMs: s_sort.max },
                { id: 'limit', label: TEXT_CONSTANTS.PHASE_LIMIT || 'limit', avgMs: s_limit.avg, minMs: s_limit.min, maxMs: s_limit.max },
                { id: 'project', label: TEXT_CONSTANTS.PHASE_PROJECT, avgMs: s_project.avg, minMs: s_project.min, maxMs: s_project.max },
                { id: 'delete', label: TEXT_CONSTANTS.PHASE_DELETE || 'DELETE', avgMs: s_delete.avg, minMs: s_delete.min, maxMs: s_delete.max },
                { id: 'update', label: TEXT_CONSTANTS.PHASE_UPDATE || 'UPDATE', avgMs: s_update.avg, minMs: s_update.min, maxMs: s_update.max },
                { id: 'insert', label: TEXT_CONSTANTS.PHASE_INSERT || 'INSERT', avgMs: s_insert.avg, minMs: s_insert.min, maxMs: s_insert.max },
                { id: 'stream', label: TEXT_CONSTANTS.PHASE_STREAM || 'return results', avgMs: s_stream.avg, minMs: s_stream.min, maxMs: s_stream.max },
            ].filter(p => p.avgMs > 0);

            return {
                normalized_statement,
                user_query_counts,
                total_count,
                min_duration_in_seconds: min_duration,
                max_duration_in_seconds: max_duration,
                avg_duration_in_seconds: avg_duration,
                median_duration_in_seconds: median_duration,
                avg_fetch: Math.round(avg_fetch),
                avg_primaryScan: Math.round(avg_primaryScan),
                avg_indexScan: Math.round(avg_indexScan),
                avg_resultCount: Math.round(avg_resultCount),
                avg_resultSize: Math.round(avg_resultSize),
                status_counts,
                // for chart rendering on row click
                avgPhaseTimeline
            };
        }

        // Column Configuration for Analysis (Query Groups) Table
        const ANALYSIS_COLUMNS = [
            {
                id: 'total_count',
                header: 'total count',
                dataField: 'total_count',
                sortable: true,
                sortType: 'numeric',
                getValue: (group) => group.total_count,
                render: (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue)) {
                        if (numValue > 999999) {
                            return "999K+";
                        } else {
                            return numValue.toLocaleString();
                        }
                    }
                    return value;
                }
            },
            {
                id: 'min_duration_in_seconds',
                header: 'min duration (mm:ss.sss)',
                dataField: 'min_duration_in_seconds',
                sortable: true,
                sortType: 'time',
                getValue: (group) => {
                    return isNaN(group.min_duration_in_seconds)
                        ? "N/A"
                        : formatTime(Number(group.min_duration_in_seconds) * 1000);
                },
                render: (value) => value
            },
            {
                id: 'max_duration_in_seconds',
                header: 'max duration (mm:ss.sss)',
                dataField: 'max_duration_in_seconds',
                sortable: true,
                sortType: 'time',
                getValue: (group) => {
                    return isNaN(group.max_duration_in_seconds)
                        ? "N/A"
                        : formatTime(Number(group.max_duration_in_seconds) * 1000);
                },
                render: (value) => value
            },
            {
                id: 'avg_duration_in_seconds',
                header: 'avg duration (mm:ss.sss)',
                dataField: 'avg_duration_in_seconds',
                sortable: true,
                sortType: 'time',
                getValue: (group) => {
                    return isNaN(group.avg_duration_in_seconds)
                        ? "N/A"
                        : formatTime(Number(group.avg_duration_in_seconds) * 1000);
                },
                render: (value) => value
            },
            {
                id: 'median_duration_in_seconds',
                header: 'median duration (mm:ss.sss)',
                dataField: 'median_duration_in_seconds',
                sortable: true,
                sortType: 'time',
                getValue: (group) => {
                    return isNaN(group.median_duration_in_seconds)
                        ? "N/A"
                        : formatTime(Number(group.median_duration_in_seconds) * 1000);
                },
                render: (value) => value
            },
            {
                id: 'avg_resultCount',
                header: 'avg resultCount',
                dataField: 'avg_resultCount',
                sortable: true,
                sortType: 'numeric',
                getValue: (group) => {
                    return isNaN(group.avg_resultCount) ? "N/A" : Number(group.avg_resultCount).toLocaleString();
                },
                render: (value) => value
            },
            {
                id: 'avg_resultSize',
                header: 'avg resultSize',
                dataField: 'avg_resultSize',
                sortable: true,
                sortType: 'numeric',
                getValue: (group) => {
                    return isNaN(group.avg_resultSize) ? "N/A" : Number(group.avg_resultSize).toLocaleString();
                },
                render: (value) => value
            },
            {
                id: 'avg_fetch',
                header: 'avg docsFetch',
                dataField: 'avg_fetch',
                sortable: true,
                sortType: 'numeric',
                getValue: (group) => {
                    return isNaN(group.avg_fetch) ? "N/A" : Number(group.avg_fetch).toLocaleString();
                },
                render: (value) => value
            },
            {
                id: 'avg_primaryScan',
                header: 'avg primaryScan',
                dataField: 'avg_primaryScan',
                sortable: true,
                sortType: 'numeric',
                getValue: (group) => {
                    return isNaN(group.avg_primaryScan) ? "N/A" : Number(group.avg_primaryScan).toLocaleString();
                },
                render: (value, td) => {
                    const cleanValue = String(value).replace(/,/g, '');
                    const originalValue = Number(cleanValue);
                    if (!isNaN(originalValue) && originalValue > 0) {
                        td.classList.add("primary-scan-yes");
                    }
                    return value;
                }
            },
            {
                id: 'avg_indexScan',
                header: 'avg indexScan',
                dataField: 'avg_indexScan',
                sortable: true,
                sortType: 'numeric',
                getValue: (group) => {
                    return isNaN(group.avg_indexScan) ? "N/A" : Number(group.avg_indexScan).toLocaleString();
                },
                render: (value) => value
            },
            {
                id: 'status_counts',
                header: null, // Will be set dynamically from TEXT_CONSTANTS.STATE_FATAL
                dataField: 'status_counts',
                sortable: true,
                sortType: 'numeric',
                getValue: (group) => {
                    const counts = group.status_counts;
                    return counts.fatal;
                },
                render: (value) => {
                    if (value > 0) {
                        return `<span class="fatal-count">${value}</span>`;
                    }
                    return value;
                }
            },
            {
                id: 'normalized_statement',
                header: 'normalized statement',
                dataField: 'normalized_statement',
                width: '300px',
                sortable: true,
                sortType: 'string',
                getValue: (group) => group.normalized_statement || "N/A",
                render: (value, td, rowData, index) => {
                    const statement = value || "";
                    const statementId = `analysis-statement-${index}`;
                    const preparedSample = (rowData && rowData.preparedSample) ? String(rowData.preparedSample) : "";
                    const preparedSnippet = preparedSample 
                        ? `<div style="margin-top:6px; color:#555; font-size:12px;"><strong>${TEXT_CONSTANTS.PREPARED_TEXT || 'Prepared:'}</strong> ${escapeHtml(preparedSample.substring(0, 300))}${preparedSample.length > 300 ? '...' : ''}</div>` 
                        : '';

                    analysisStatementStore[statementId] = statement;

                    if (statement.length > 500) {
                        const truncated = statement.substring(0, 500);
                        return `
                            <div id="${statementId}-truncated">
                                <span>${truncated}...</span>
                                ${preparedSnippet}
                                <br>
                                <button onclick="toggleAnalysisStatement('${statementId}', true)" 
                                        class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                                <button onclick="copyAnalysisStatement('${statementId}', event)" 
                                        class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                            </div>
                            <div id="${statementId}-full" style="display: none;">
                                <span>${statement}</span>
                                ${preparedSnippet}
                                <br>
                                <button onclick="toggleAnalysisStatement('${statementId}', false)" 
                                        class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                                <button onclick="copyAnalysisStatement('${statementId}', event)" 
                                        class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                            </div>
                        `;
                    } else {
                        return `
                            <div>
                                <span>${statement}</span>
                                ${preparedSnippet}
                                <br>
                                <button onclick="copyAnalysisStatement('${statementId}', event)" 
                                        class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                            </div>
                        `;
                    }
                }
            },
            {
                id: 'user_query_counts',
                header: null, // Will be set dynamically from TEXT_CONSTANTS.USER_COUNT
                dataField: 'user_query_counts',
                sortable: true,
                sortType: 'string',
                getValue: (group) => {
                    return Object.entries(group.user_query_counts)
                        .map(([user, count]) => `${user}: (${count})`)
                        .join(", ");
                },
                render: (value) => {
                    // Bold the counts in parentheses
                    return value.replace(/\((\d+)\)/g, "<b>($1)</b>");
                }
            }
        ];

        // Generate analysis table based on SQL++ query logic
        function generateAnalysisTable(requests) {
            const analysisTableHeader = document.getElementById(
                "analysis-table-header"
            );
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableHeader.innerHTML = "";
            analysisTableBody.innerHTML = "";

            // Group requests by normalized_statement
            const groups = {};
            requests.forEach((request) => {
                const stmt = request.statement || request.preparedText;
                if (!stmt) return;
                // Note: System query filtering is now handled globally in parseJSON()
                const normalized = normalizeStatement(stmt);
                if (!groups[normalized]) {
                    groups[normalized] = [];
                }
                groups[normalized].push(request);
            });

            // Calculate stats for each group
            const groupData = Object.keys(groups)
                .map((key) => calculateGroupStats(key, groups[key]))
                .filter((data) => data !== null);
            groupData.sort((a, b) => b.total_count - a.total_count);

            // Initialize phase times chart with the first group (if present)
            if (groupData.length > 0) {
                renderQueryGroupPhaseTimesChart(groupData[0]);
            }

            // Create header row using column config
            const headerRow = document.createElement("tr");
            ANALYSIS_COLUMNS.forEach((colConfig) => {
                const th = document.createElement("th");
                
                // Use header from config, or TEXT_CONSTANTS for special columns
                let displayName = colConfig.header;
                if (colConfig.id === "user_query_counts") {
                    displayName = TEXT_CONSTANTS.USER_COUNT;
                } else if (colConfig.id === "status_counts") {
                    displayName = TEXT_CONSTANTS.STATE_FATAL;
                }
                
                th.textContent = displayName;
                th.style.textAlign = "center";
                
                if (colConfig.sortable) {
                    th.addEventListener("click", () => handleColumnSort(colConfig.id, "analysis"));
                }
                headerRow.appendChild(th);
            });
            analysisTableHeader.appendChild(headerRow);

            // Prepare table data using column config
            const analysisTableData = groupData.map((group) => {
                const rowData = {};
                
                ANALYSIS_COLUMNS.forEach((colConfig) => {
                    let value;
                    if (colConfig.getValue) {
                        value = colConfig.getValue(group);
                    } else if (colConfig.dataField) {
                        value = group[colConfig.dataField] || 'N/A';
                    }
                    rowData[colConfig.id] = value;
                });

                // Add fields for search filtering and prepared sample
                rowData.statement = group.normalized_statement || "";
                // Use first request of this group to derive a prepared statement sample
                try {
                const sampleList = groups && groups[group.normalized_statement];
                if (Array.isArray(sampleList) && sampleList.length > 0) {
                const sampleReq = sampleList[0] || {};
                rowData.preparedSample = isPreparedExecution(sampleReq) ? getPreparedSample(sampleReq) : "";
                } else {
                rowData.preparedSample = "";
                }
                } catch (e) { rowData.preparedSample = ""; }
                rowData.users = Object.keys(group.user_query_counts || {}).join(", ");
                // Attach original group for chart rendering on row click
                rowData.groupRef = group;

                return rowData;
            });

            // Sort by total_count by default
            const sortedData = sortData(analysisTableData, "total_count", "desc");
            analysisData = sortedData;
            filteredAnalysisData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "total_count";
            currentSortDirection = "desc";
            currentTableType = "analysis";

            // Setup search listeners (only once)
            if (
                !document
                    .getElementById("analysis-statement-search")
                    .hasAttribute("data-listeners-added")
            ) {
                setupAnalysisSearchListeners();
                document
                    .getElementById("analysis-statement-search")
                    .setAttribute("data-listeners-added", "true");
            }

            populateAnalysisTable(filteredAnalysisData);
            updateSortArrows("analysis-table-header", "total_count", "desc");
            updateAnalysisSearchResultsInfo(
                filteredAnalysisData.length,
                analysisData.length
            );
        }

        // Populate Analysis table body
        function populateAnalysisTable(data) {
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableBody.innerHTML = "";

            // Clear statement store for new data
            analysisStatementStore = {};

            // Use DocumentFragment for smooth table rendering with batching
            const batchSize = 50; // Process rows in batches for large datasets
            const fragment = document.createDocumentFragment();

            function processBatch(startIndex) {
                const endIndex = Math.min(startIndex + batchSize, data.length);

                for (let index = startIndex; index < endIndex; index++) {
                    const rowData = data[index];
                    const row = document.createElement("tr");

                    ANALYSIS_COLUMNS.forEach((colConfig) => {
                        const td = document.createElement("td");
                        let value = rowData[colConfig.id];

                        // Apply thresholding for extreme values
                        if (typeof value === 'number' && value > 1000000) {
                            value = `${Math.round(value / 1000000)}M+`;
                        }

                        // Apply custom rendering if defined
                        if (colConfig.render) {
                            const rendered = colConfig.render(value, td, rowData, index);
                            if (typeof rendered === 'string') {
                                td.innerHTML = rendered;
                            } else {
                                td.textContent = rendered;
                            }
                        } else {
                            td.textContent = value;
                        }

                        row.appendChild(td);
                    });
                    
                    // On row click, render the per-group phase timeline chart
                    row.addEventListener('click', () => {
                        if (rowData.groupRef) {
                            renderQueryGroupPhaseTimesChart(rowData.groupRef);
                        }
                    });
                    fragment.appendChild(row);
                }

                // Append batch to DOM
                if (endIndex >= data.length) {
                    analysisTableBody.appendChild(fragment);
                    // Auto-populate chart with first row after final batch (Issue #225)
                    if (data.length > 0 && data[0].groupRef) {
                        renderQueryGroupPhaseTimesChart(data[0].groupRef);
                    }
                } else {
                    // Process next batch asynchronously
                    analysisTableBody.appendChild(fragment);
                    setTimeout(() => processBatch(endIndex), 0);
                }
            }

            // Start batch processing if we have data
            if (data.length > 0) {
                processBatch(0);
            }
        }

        // ============================================================
        // PERFORMANCE UTILITIES MODULE (Optimization Step 3)
        // Throttle and debounce functions for performance optimization
        // ============================================================
        const PerformanceUtils = {
            // Throttle: Limits function calls to once per wait period
            // Good for: scroll, resize, mousemove, pan/zoom handlers
            throttle(func, wait) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, wait);
                    }
                };
            },

            // Debounce: Delays function execution until wait period after last call
            // Good for: search input, form validation
            debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }
        };

        // ============================================================
        // CHART TIME UTILITIES MODULE (Optimization Step 2a)
        // Consolidated time-related chart helper functions
        // ============================================================
        const ChartTimeUtils = {
            // Get time grouping setting from dropdown
            getTimeGrouping() {
                const dropdown = document.getElementById('time-grouping-select');
                return dropdown ? dropdown.value : "optimizer";
            },

            // Automatically determine optimal time unit based on data span
            getOptimalTimeUnit(requests) {
                if (!requests || requests.length === 0) return "minute";

                const times = requests
                    .map((r) => getChartDate(r.requestTime))
                    .filter((t) => !isNaN(t));
                if (times.length === 0) return "minute";

                const minTime = Math.min(...times);
                const maxTime = Math.max(...times);
                const timeSpanMs = maxTime - minTime;
                const timeSpanHours = timeSpanMs / (1000 * 60 * 60);
                const timeSpanDays = timeSpanHours / 24;

                // Choose time unit based on span to keep Chart.js happy
                if (timeSpanDays > 365) return "year";
                if (timeSpanDays > 60) return "month";
                if (timeSpanDays > 14) return "week";
                if (timeSpanDays > 2) return "day";
                if (timeSpanHours > 2) return "hour";
                if (timeSpanHours > 0.1) return "minute";
                return "second";
            },

            // Round timestamp based on grouping and optimal unit
            roundTimestamp(timestamp, grouping, requests) {
                // Create cache key for this specific timestamp+grouping combination
                const cacheKey = `${timestamp.getTime()}-${grouping}`;
                if (timestampRoundingCache.has(cacheKey)) {
                    return timestampRoundingCache.get(cacheKey);
                }

                const date = new Date(timestamp);

                // Determine actual unit to use with caching
                let actualUnit;
                if (grouping === "optimizer") {
                    // Cache the optimal unit per request array to avoid repeated analysis
                    if (timeUnitCache.has(requests)) {
                        actualUnit = timeUnitCache.get(requests);
                    } else {
                        actualUnit = this.getOptimalTimeUnit(requests);
                        timeUnitCache.set(requests, actualUnit);
                    }
                } else {
                    // Use exactly what the user selected
                    actualUnit = grouping;
                }

                // Round based on actual unit
                switch (actualUnit) {
                    case "second":
                        date.setMilliseconds(0);
                        break;
                    case "5min":
                        const minutes5 = Math.floor(date.getMinutes() / 5) * 5;
                        date.setMinutes(minutes5, 0, 0);
                        break;
                    case "minute":
                        date.setSeconds(0, 0);
                        break;
                    case "hour":
                        date.setMinutes(0, 0, 0);
                        break;
                    case "day":
                        date.setHours(0, 0, 0, 0);
                        break;
                    case "week":
                        const dayOfWeek = date.getDay();
                        date.setDate(date.getDate() - dayOfWeek);
                        date.setHours(0, 0, 0, 0);
                        break;
                    case "month":
                        date.setDate(1);
                        date.setHours(0, 0, 0, 0);
                        break;
                    case "year":
                        date.setMonth(0, 1);
                        date.setHours(0, 0, 0, 0);
                        break;
                    default:
                        date.setSeconds(0, 0);
                }

                // Cache the result with size limit (Step 9)
                if (timestampRoundingCache.size >= CACHE_LIMITS.timestampRounding) {
                    // Clear oldest 20% when limit reached
                    const keysToDelete = Array.from(timestampRoundingCache.keys())
                        .slice(0, Math.floor(CACHE_LIMITS.timestampRounding * 0.2));
                    keysToDelete.forEach(key => timestampRoundingCache.delete(key));
                }
                timestampRoundingCache.set(cacheKey, date);
                return date;
            },

            // Get all timeline buckets from requests (Issue #148 - ensures charts share same x-axis)
            getTimelineBucketsFromRequests(requests, grouping) {
                const seen = new Set();
                for (const r of requests) {
                    const dt = this.roundTimestamp(getChartDate(r.requestTime), grouping, requests);
                    seen.add(dt.toISOString());
                }
                return Array.from(seen)
                    .map(s => new Date(s))
                    .sort((a, b) => a - b);
            }
        };

        // Backward compatibility - keep original function names as aliases
        const getTimeGrouping = () => ChartTimeUtils.getTimeGrouping();
        const getOptimalTimeUnit = (requests) => ChartTimeUtils.getOptimalTimeUnit(requests);
        const roundTimestamp = (timestamp, grouping, requests) => ChartTimeUtils.roundTimestamp(timestamp, grouping, requests);
        const getTimelineBucketsFromRequests = (requests, grouping) => ChartTimeUtils.getTimelineBucketsFromRequests(requests, grouping);

        // ============================================================
        // THROTTLED FUNCTION WRAPPERS (Optimization Step 3)
        // Created after PerformanceUtils is defined
        // ============================================================
        // Throttled version of syncChartZoom for onPan/onZoom handlers
        // Reduces calls from ~60/sec to ~10/sec during pan/zoom operations
        const syncChartZoomThrottled = PerformanceUtils.throttle(syncChartZoom, 100);

// Render horizontal bar chart for Query Groups using avgPhaseTimeline (with specific row ordering)
function renderQueryGroupPhaseTimesChart(group) {
            try {
                const titleEl = document.getElementById('query-group-phase-times-title');
                const subtitleEl = document.getElementById('query-group-phase-times-subtitle');
                const canvas = document.getElementById('query-group-phase-times-chart');
                const noteEl = document.getElementById('query-group-phase-times-note');
                if (!canvas) return;

                if (titleEl) titleEl.textContent = TEXT_CONSTANTS.QUERY_GROUP_PHASE_TIMES_TITLE || 'Phase Times by Query Group (avg)';
                if (subtitleEl && TEXT_CONSTANTS.PHASE_TIMELINE_NOTE) subtitleEl.textContent = TEXT_CONSTANTS.PHASE_TIMELINE_NOTE;
                if (noteEl && TEXT_CONSTANTS.PHASE_TIMELINE_NOTE) noteEl.textContent = TEXT_CONSTANTS.PHASE_TIMELINE_NOTE;

                const ctx = canvas.getContext('2d');
                if (window.queryGroupPhaseTimesChart) {
                    window.queryGroupPhaseTimesChart.destroy();
                }

                const phases = Array.isArray(group.avgPhaseTimeline) ? group.avgPhaseTimeline : [];
                const findStats = (id) => phases.find(p => p.id === id) || { avgMs: 0, minMs: 0, maxMs: 0 };

                // Stats per phase (avg/min/max in ms)
                const authStats    = findStats('authorize');
                const parseStats   = findStats('parse');
                const planStats    = findStats('plan');
                const indexStats   = findStats('indexScan');
                const fetchStats   = findStats('fetch');
                const joinStats    = findStats('join');
                const filterStats  = findStats('filter');
                const nestStats    = findStats('nest');
                const unnestStats  = findStats('unnest');
                const groupStats   = findStats('groupAgg');
                const sortStats    = findStats('sort');
                const limitStats   = findStats('limit');
                const projectStats = findStats('project');
                const deleteStats  = findStats('delete');
                const updateStats  = findStats('update');
                const insertStats  = findStats('insert');
                const streamStats  = findStats('stream');

                // Dynamically build rows (top-down order) and include only if data exists
                const rows = [
                    { key: 'authorize',    label: TEXT_CONSTANTS.PHASE_AUTHORIZE,                         include: !!authStats.avgMs },
                    { key: 'parsePlan',    label: `Parse & Plan`,                                       include: !!parseStats.avgMs || !!planStats.avgMs },
                    { key: 'scanFetch',    label: `Index Scan / Doc Fetch`,                             include: !!indexStats.avgMs || !!fetchStats.avgMs },
                    { key: 'join',         label: TEXT_CONSTANTS.PHASE_JOIN || 'JOIN',                  include: !!joinStats.avgMs },
                    { key: 'nest',         label: 'Nest',                                               include: !!nestStats.avgMs },
                    { key: 'unnest',       label: 'Unnest',                                             include: !!unnestStats.avgMs },
                    { key: 'filter',       label: TEXT_CONSTANTS.PHASE_FILTER,                          include: !!filterStats.avgMs },
                    { key: 'groupAgg',     label: TEXT_CONSTANTS.PHASE_GROUP_AGG,                       include: !!groupStats.avgMs },
                    { key: 'sort',         label: TEXT_CONSTANTS.PHASE_SORT,                            include: !!sortStats.avgMs },
                    { key: 'limit',        label: TEXT_CONSTANTS.PHASE_LIMIT,                           include: !!limitStats.avgMs },
                    { key: 'project',      label: TEXT_CONSTANTS.PHASE_PROJECT,                         include: !!projectStats.avgMs },
                    { key: 'delete',       label: TEXT_CONSTANTS.PHASE_DELETE || 'DELETE',              include: !!deleteStats.avgMs },
                    { key: 'update',       label: TEXT_CONSTANTS.PHASE_UPDATE || 'UPDATE',              include: !!updateStats.avgMs },
                    { key: 'insert',       label: TEXT_CONSTANTS.PHASE_INSERT || 'INSERT',              include: !!insertStats.avgMs },
                    { key: 'stream',       label: TEXT_CONSTANTS.PHASE_STREAM,                          include: !!streamStats.avgMs },
                ];
                const activeRows = rows.filter(r => r.include);
                const labels = activeRows.map(r => r.label);
                const rowIndex = Object.fromEntries(activeRows.map((r, i) => [r.key, i]));

                // Dynamically size chart height based on row count and bar thickness (set parent height for Chart.js sizing)
                try {
                    const barPx = 26; // close to maxBarThickness used elsewhere
                    const rowPadding = 28; // tick + grid spacing
                    const base = 140; // extra space for axes/labels
                    const targetHeight = Math.max(base + labels.length * (barPx + rowPadding), 300);
                    const scaled = Math.max(280, Math.round(targetHeight * 0.75)); // reduce by ~25%
                    const parent = canvas.parentElement; // Chart.js reads parent container size
                    if (parent) parent.style.height = `${scaled}px`;
                    // Also set the canvas as a fallback
                    canvas.style.height = `${scaled}px`;
                } catch (e) { /* no-op */ }

                // Compute sequential offsets. Row 2: parse then plan (in series). Row 3: scan/fetch concurrent.
                let t = 0;
                const authBar    = authStats.avgMs   > 0 ? [t, (t += authStats.avgMs)]      : null;
                const row2Start  = t;
                const parseBar   = parseStats.avgMs  > 0 ? [t, (t += parseStats.avgMs)]     : null;
                const planBar    = planStats.avgMs   > 0 ? [t, (t += planStats.avgMs)]      : null;

                const row3Start  = t; // concurrency start for Index Scan / Fetch
                const scanBar    = indexStats.avgMs  > 0 ? [row3Start, row3Start + indexStats.avgMs] : null;
                // Adjust Doc Fetch to end no earlier than Index Scan if scan is longer.
                let fetchBar = null;
                if (fetchStats.avgMs > 0) {
                    const intrinsicEnd = row3Start + fetchStats.avgMs;
                    const scanEnd = scanBar ? scanBar[1] : intrinsicEnd;
                    const fetchEnd = Math.max(intrinsicEnd, scanEnd);
                    const fetchStart = Math.max(0, fetchEnd - fetchStats.avgMs);
                    fetchBar = [fetchStart, fetchEnd];
                }
                t = Math.max(scanBar ? scanBar[1] : row3Start, fetchBar ? fetchBar[1] : row3Start);

                const joinBar    = joinStats.avgMs   > 0 ? [t, (t += joinStats.avgMs)]      : null;
                // Nest bar placement: same policy as Filter
                // - Preserve the average duration as the bar width.
                // - Align END to later of scan/fetch end or its own intrinsic end.
                // - START = end - avg.
                let nestBar = null;
                if (nestStats.avgMs > 0) {
                    const concurrentStart = row3Start;
                    const scanEnd = scanBar ? scanBar[1] : concurrentStart;
                    const fetchEnd = fetchBar ? fetchBar[1] : concurrentStart;
                    const concurrentEnd = Math.max(scanEnd, fetchEnd);
                    const intrinsicEnd = concurrentStart + nestStats.avgMs;
                    const end = Math.max(concurrentEnd, intrinsicEnd);
                    const start = Math.max(0, end - nestStats.avgMs);
                    nestBar = [start, end];
                }

                // Unnest bar placement: same policy as Filter
                // - Preserve the average duration as the bar width.
                // - Align END to later of scan/fetch end or its own intrinsic end.
                // - START = end - avg.
                let unnestBar = null;
                if (unnestStats.avgMs > 0) {
                    const concurrentStart = row3Start;
                    const scanEnd = scanBar ? scanBar[1] : concurrentStart;
                    const fetchEnd = fetchBar ? fetchBar[1] : concurrentStart;
                    const concurrentEnd = Math.max(scanEnd, fetchEnd);
                    const intrinsicEnd = concurrentStart + unnestStats.avgMs;
                    const end = Math.max(concurrentEnd, intrinsicEnd);
                    const start = Math.max(0, end - unnestStats.avgMs);
                    unnestBar = [start, end];
                }

                // Filter bar placement:
                // - Preserve the average duration as the bar width (visual focus on avg time).
                // - Align the bar END to the later of scan/fetch end or its own intrinsic end.
                // - The START is computed as end - avg (does not need to begin with scan/fetch).
                let filterBar = null;
                if (filterStats.avgMs > 0) {
                    const concurrentStart = row3Start;
                    const scanEnd = scanBar ? scanBar[1] : concurrentStart;
                    const fetchEnd = fetchBar ? fetchBar[1] : concurrentStart;
                    const concurrentEnd = Math.max(scanEnd, fetchEnd);
                    const intrinsicEnd = concurrentStart + filterStats.avgMs;
                    const filterEnd = Math.max(concurrentEnd, intrinsicEnd);
                    const filterStart = Math.max(0, filterEnd - filterStats.avgMs);
                    filterBar = [filterStart, filterEnd];
                }
                const groupBar   = groupStats.avgMs  > 0 ? [t, (t += groupStats.avgMs)]     : null;
                const sortBar    = sortStats.avgMs   > 0 ? [t, (t += sortStats.avgMs)]      : null;
                const limitBar   = limitStats.avgMs  > 0 ? [t, (t += limitStats.avgMs)]     : null;
                // Project must occur after Nest, Unnest and Filter (and sequential phases like Group/Sort/Limit).
                // Start Project at the later of: sequential time 't', Filter end, Nest end, and Unnest end.
                let projectBar = null;
                if (projectStats.avgMs > 0) {
                    const prevEnd = Math.max(
                        t,
                        filterBar ? filterBar[1] : 0,
                        nestBar ? nestBar[1] : 0,
                        unnestBar ? unnestBar[1] : 0
                    );
                    const projectStart = prevEnd;
                    const projectEnd = projectStart + projectStats.avgMs;
                    projectBar = [projectStart, projectEnd];
                }
                const deleteBar  = deleteStats.avgMs > 0 ? [t, (t += deleteStats.avgMs)]     : null;
                const updateBar  = updateStats.avgMs > 0 ? [t, (t += updateStats.avgMs)]     : null;
                const insertBar  = insertStats.avgMs > 0 ? [t, (t += insertStats.avgMs)]     : null;
                // Stream should be the final step: start at the latest end among all other phases
                let streamBar = null;
                if (streamStats.avgMs > 0) {
                const otherEnds = [authBar, parseBar, planBar, scanBar, fetchBar, joinBar, nestBar, unnestBar, filterBar, groupBar, sortBar, limitBar, projectBar, deleteBar, updateBar, insertBar]
                .filter(Boolean)
                .map(b => b[1]);
                const streamStart = otherEnds.length ? Math.max(...otherEnds) : t;
                const streamEnd = streamStart + streamStats.avgMs;
                streamBar = [streamStart, streamEnd];
                }

                // Helper to place a bar on a specific row index
                function mkDataForRow(bar, rowIndex) {
                    return labels.map((_, i) => (i === rowIndex ? bar : null));
                }

                // Build datasets; one dataset per segment. Attach phaseId for tooltip stats.
                const datasets = [];
                if (authBar && rowIndex.authorize !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_AUTHORIZE, phaseId: 'authorize', data: mkDataForRow(authBar, rowIndex.authorize), backgroundColor: 'rgba(102, 126, 234, 0.35)', borderColor: 'rgba(102, 126, 234, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (parseBar && rowIndex.parsePlan !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_PARSE,     phaseId: 'parse',     data: mkDataForRow(parseBar, rowIndex.parsePlan), backgroundColor: 'rgba(66, 133, 244, 0.35)', borderColor: 'rgba(66, 133, 244, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (planBar && rowIndex.parsePlan !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_PLAN,      phaseId: 'plan',      data: mkDataForRow(planBar,  rowIndex.parsePlan), backgroundColor: 'rgba(66, 133, 244, 0.25)', borderColor: 'rgba(66, 133, 244, 0.8)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (scanBar && rowIndex.scanFetch !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_INDEX_SCAN,phaseId: 'indexScan', data: mkDataForRow(scanBar,  rowIndex.scanFetch), backgroundColor: 'rgba(40, 167, 69, 0.35)',  borderColor: 'rgba(40, 167, 69, 0.9)',  borderWidth: 1, borderRadius: 4, barThickness: 10, categoryPercentage: 0.5, barPercentage: 0.5 });
                if (fetchBar && rowIndex.scanFetch !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_FETCH,     phaseId: 'fetch',     data: mkDataForRow(fetchBar, rowIndex.scanFetch), backgroundColor: 'rgba(220, 53, 69, 0.30)',  borderColor: 'rgba(220, 53, 69, 0.9)',  borderWidth: 1, borderRadius: 4, barThickness: 10, categoryPercentage: 0.5, barPercentage: 0.5 });
                if (joinBar && rowIndex.join !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_JOIN || 'JOIN', phaseId: 'join',  data: mkDataForRow(joinBar, rowIndex.join), backgroundColor: 'rgba(255, 159, 64, 0.35)', borderColor: 'rgba(255, 159, 64, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (nestBar && rowIndex.nest !== undefined)
                    datasets.push({ label: 'Nest', phaseId: 'nest', data: mkDataForRow(nestBar,rowIndex.nest), backgroundColor: 'rgba(121, 85, 72, 0.35)',   borderColor: 'rgba(121, 85, 72, 0.9)',   borderWidth: 1, borderRadius: 4, grouped: false });
                if (unnestBar && rowIndex.unnest !== undefined)
                    datasets.push({ label: 'Unnest', phaseId: 'unnest', data: mkDataForRow(unnestBar,rowIndex.unnest), backgroundColor: 'rgba(141, 105, 92, 0.35)',   borderColor: 'rgba(141, 105, 92, 0.9)',   borderWidth: 1, borderRadius: 4, grouped: false });
                if (filterBar && rowIndex.filter !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_FILTER,    phaseId: 'filter',    data: mkDataForRow(filterBar,rowIndex.filter), backgroundColor: 'rgba(255, 193, 7, 0.30)',   borderColor: 'rgba(255, 193, 7, 0.9)',   borderWidth: 1, borderRadius: 4, grouped: false });
                if (groupBar && rowIndex.groupAgg !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_GROUP_AGG, phaseId: 'groupAgg',  data: mkDataForRow(groupBar, rowIndex.groupAgg), backgroundColor: 'rgba(23, 162, 184, 0.30)',  borderColor: 'rgba(23, 162, 184, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (sortBar && rowIndex.sort !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_SORT,      phaseId: 'sort',      data: mkDataForRow(sortBar,  rowIndex.sort), backgroundColor: 'rgba(108, 117, 125, 0.30)', borderColor: 'rgba(108, 117, 125, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (limitBar && rowIndex.limit !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_LIMIT,     phaseId: 'limit',     data: mkDataForRow(limitBar, rowIndex.limit), backgroundColor: 'rgba(153, 102, 255, 0.30)', borderColor: 'rgba(153, 102, 255, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (projectBar && rowIndex.project !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_PROJECT,   phaseId: 'project',   data: mkDataForRow(projectBar,rowIndex.project), backgroundColor: 'rgba(255, 99, 132, 0.25)', borderColor: 'rgba(255, 99, 132, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (deleteBar && rowIndex.delete !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_DELETE || 'DELETE', phaseId: 'delete', data: mkDataForRow(deleteBar, rowIndex.delete), backgroundColor: 'rgba(200, 35, 51, 0.35)', borderColor: 'rgba(200, 35, 51, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (updateBar && rowIndex.update !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_UPDATE || 'UPDATE', phaseId: 'update', data: mkDataForRow(updateBar, rowIndex.update), backgroundColor: 'rgba(0, 150, 136, 0.35)', borderColor: 'rgba(0, 150, 136, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (insertBar && rowIndex.insert !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_INSERT || 'INSERT', phaseId: 'insert', data: mkDataForRow(insertBar, rowIndex.insert), backgroundColor: 'rgba(156, 39, 176, 0.35)', borderColor: 'rgba(156, 39, 176, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (streamBar && rowIndex.stream !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_STREAM,    phaseId: 'stream',    data: mkDataForRow(streamBar,rowIndex.stream), backgroundColor: 'rgba(0, 123, 255, 0.20)',  borderColor: 'rgba(0, 123, 255, 0.8)',  borderWidth: 1, borderRadius: 4, grouped: false });

                // Inline plugin to draw avg time labels at end of each bar
                const valueLabelPlugin = {
                    id: 'queryGroupBarValueLabels',
                    afterDatasetsDraw(chart, args, plgOpts) {
                        const { ctx, chartArea } = chart;
                        ctx.save();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        chart.data.datasets.forEach((ds, di) => {
                            const meta = chart.getDatasetMeta(di);
                            if (!meta || meta.hidden) return;
                            const statsForDs = (phaseId) => findStats(phaseId || '');
                            meta.data.forEach((bar, i) => {
                                const raw = ds.data[i];
                                if (!raw || !Array.isArray(raw)) return;
                                const stats = statsForDs(ds.phaseId);
                                const avgMs = (stats && stats.avgMs) ? stats.avgMs : 0;
                                if (!avgMs) return;
                                const label = formatTime(avgMs);
                                const x = Math.max(bar.x, bar.base) + 6;
                                const y = bar.y;
                                const drawX = Math.min(x, chartArea.right - 4);
                                ctx.fillText(label, drawX, y);
                            });
                        });
                        ctx.restore();
                    }
                };

                window.queryGroupPhaseTimesChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    plugins: [valueLabelPlugin],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        layout: { padding: { bottom: 20, top: 0, left: 0, right: 10 } },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        const val = ctx.raw;
                                        const dur = (Array.isArray(val) ? (val[1] - val[0]) : 0);
                                        const ds = ctx.dataset || {};
                                        const phaseId = ds.phaseId || '';
                                        const stats = findStats(phaseId);
                                        const minStr = stats.minMs ? formatTime(stats.minMs) : '00:00.000';
                                        const avgStr = stats.avgMs ? formatTime(stats.avgMs) : '00:00.000';
                                        const maxStr = stats.maxMs ? formatTime(stats.maxMs) : '00:00.000';
                                        return `${ctx.dataset.label}: ${dur.toFixed(2)} ms (min ${minStr} | avg ${avgStr} | max ${maxStr})`;
                                    }
                                }
                            }
                        },
                        datasets: {
                            bar: {
                                barThickness: 20,
                                maxBarThickness: 26,
                                categoryPercentage: 0.9,
                                barPercentage: 0.9,
                            }
                        },
                        scales: {
                            x: {
                                stacked: false,
                                title: { display: true, text: TEXT_CONSTANTS.AXIS_TIME_MS },
                            },
                            y: {
                                stacked: false,
                                offset: true,
                                title: { display: false }
                            }
                        }
                    }
                });
            } catch (err) {
                Logger.error('Error rendering Query Group Phase Times chart:', err);
            }
        }
        
        // Helper function to get Chart.js time configuration with auto-adjustment
        function getTimeConfig(requestedGrouping, requests) {
            // Use exactly the unit that was requested
            let actualUnit = requestedGrouping;

            // For x-axis display, let Chart.js automatically determine the best format
            // Data is already bucketed by the requested grouping via roundTimestamp()
            // This prevents Chart.js errors when trying to display too many ticks
            return {
                displayFormats: {
                    millisecond: "HH:mm:ss.SSS",
                    second: "HH:mm:ss",
                    minute: "MMM dd HH:mm",
                    hour: "MMM dd HH:mm",
                    day: "MMM dd",
                    week: "MMM dd",
                    month: "MMM yyyy",
                    quarter: "MMM yyyy",
                    year: "yyyy"
                },
                // Don't force a specific unit - let Chart.js adapt based on zoom level
                // Data decimation will handle rendering performance
            };
        }

        // Helper function to get current time config with requests data
        function getCurrentTimeConfig(requests) {
            const grouping = getTimeGrouping();
            let actualUnit;
            if (grouping === "optimizer") {
                actualUnit = getOptimalTimeUnit(requests);
            } else {
                actualUnit = grouping;
            }
            return getTimeConfig(actualUnit, requests);
        }

        // Helper function to update the optimizer label
        function updateOptimizerLabel(requests) {
            const optimizedUnit = getOptimalTimeUnit(requests);
            const dropdown = document.getElementById("time-grouping-select");
            if (dropdown) {
                // Update the first option text to show the actual optimized unit
                const optimizerOption = dropdown.querySelector('option[value="optimizer"]');
                if (optimizerOption) {
                    optimizerOption.textContent = `By Optimizer (${optimizedUnit})`;
                }
            }
        }

        // Array to store all timeline charts for synchronization
        const timelineCharts = [];

        // Custom plugin to draw a vertical line on hover
        const verticalLinePlugin = {
            id: 'verticalLine',
            afterInit(chart) {
                chart.verticalLine = { draw: false, x: 0 };
            },
            afterEvent(chart, args) {
                const { inChartArea, event } = args;
                if (chart.verticalLine) {
                    chart.verticalLine.draw = inChartArea;
                    chart.verticalLine.x = event ? event.x : args.x;
                    // Let Chart.js handle the redraw naturally, don't force it
                }
            },
            afterDatasetsDraw(chart) {
                if (!chart.verticalLine || !chart.verticalLine.draw || !chart.verticalLine.x) return;

                const { ctx, chartArea: { top, bottom } } = chart;
                ctx.save();
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#007bff';
                ctx.setLineDash([5, 5]);
                ctx.moveTo(chart.verticalLine.x, top);
                ctx.lineTo(chart.verticalLine.x, bottom);
                ctx.stroke();
                ctx.restore();
            }
        };

        // Function to sync crosshairs across all timeline charts
        function syncTimelineCharts(sourceEvent, activeChart) {
            if (!activeChart || !activeChart.chartArea) return;

            const chartArea = activeChart.chartArea;
            const inChartArea = sourceEvent.x >= chartArea.left && sourceEvent.x <= chartArea.right &&
                sourceEvent.y >= chartArea.top && sourceEvent.y <= chartArea.bottom;

            // Filter out null/destroyed charts and exclude the active chart
            const validCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart !== activeChart &&  // Exclude active chart to prevent flicker
                    chart.canvas &&
                    chart.canvas.getContext &&
                    chart.scales &&
                    chart.scales.x &&
                    chart.chartArea &&
                    !chart.isDestroyed;
            });

            // Update active chart's crosshair state without redrawing
            if (activeChart.verticalLine) {
                activeChart.verticalLine.draw = inChartArea;
                if (inChartArea) {
                    activeChart.verticalLine.x = sourceEvent.x;
                }
            }

            // Sync other charts
            validCharts.forEach(chart => {
                if (!inChartArea) {
                    if (chart.verticalLine && chart.verticalLine.draw) {
                        chart.verticalLine.draw = false;
                        requestAnimationFrame(() => chart.draw());
                    }
                    return;
                }

                try {
                    const xValue = activeChart.scales.x.getValueForPixel(sourceEvent.x);
                    const targetX = chart.scales.x.getPixelForValue(xValue);

                    if (chart.verticalLine && targetX >= chart.chartArea.left && targetX <= chart.chartArea.right) {
                        const wasDrawn = chart.verticalLine.draw;
                        const oldX = chart.verticalLine.x;

                        chart.verticalLine.draw = true;
                        chart.verticalLine.x = targetX;

                        // Only redraw if position changed significantly or wasn't drawn before
                        if (!wasDrawn || Math.abs(oldX - targetX) > 2) {
                            requestAnimationFrame(() => chart.draw());
                        }
                    }
                } catch (error) {
                    // Silently handle errors
                    if (chart.verticalLine) {
                        chart.verticalLine.draw = false;
                    }
                }
            });

            // Update the timelineCharts array to only contain valid charts (including active chart)
            const allValidCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart.canvas &&
                    chart.canvas.getContext &&
                    chart.scales &&
                    chart.scales.x &&
                    chart.chartArea &&
                    !chart.isDestroyed;
            });

            if (allValidCharts.length !== timelineCharts.length) {
                timelineCharts.length = 0;
                timelineCharts.push(...allValidCharts);
            }
        }

        // Clear crosshairs on all timeline charts
        function clearTimelineCrosshairs() {
            // Filter out null/destroyed charts
            const validCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart.canvas &&
                    chart.canvas.getContext &&
                    !chart.isDestroyed &&
                    chart.verticalLine;
            });

            validCharts.forEach(chart => {
                if (chart.verticalLine && chart.verticalLine.draw) {
                    chart.verticalLine.draw = false;
                    requestAnimationFrame(() => chart.draw());
                }
            });

            // Update the timelineCharts array to only contain valid charts
            if (validCharts.length !== timelineCharts.length) {
                timelineCharts.length = 0;
                timelineCharts.push(...validCharts);
            }
        }

        // Helper function to register a chart for crosshair synchronization
        function registerTimelineChart(chart, ctx) {
            if (!chart || !ctx || !ctx.canvas) return;

            // Add to timeline charts array for synchronization
            timelineCharts.push(chart);

            // Throttle mousemove events to prevent excessive redraws
            let mouseMoveTimeout;
            const mouseMoveHandler = (event) => {
                if (mouseMoveTimeout) return;

                mouseMoveTimeout = setTimeout(() => {
                    mouseMoveTimeout = null;

                    const rect = ctx.canvas.getBoundingClientRect();
                    const canvasEvent = {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    };
                    syncTimelineCharts(canvasEvent, chart);
                }, 8); // Throttle to ~120fps
            };

            // Add mouseleave event listener to clear crosshairs
            const mouseLeaveHandler = () => {
                if (mouseMoveTimeout) {
                    clearTimeout(mouseMoveTimeout);
                    mouseMoveTimeout = null;
                }
                clearTimelineCrosshairs();
            };

            ctx.canvas.addEventListener('mousemove', mouseMoveHandler);
            ctx.canvas.addEventListener('mouseleave', mouseLeaveHandler);

            // Store handlers for cleanup if needed
            chart._crosshairHandlers = {
                mousemove: mouseMoveHandler,
                mouseleave: mouseLeaveHandler
            };
        }

        // [REMOVED] generateOperationsChart - Replaced by Enhanced Database Operations chart

        // ========== Progressive Chart Loading System ==========
        // Queue system for creating charts progressively to avoid UI blocking
        const chartTasks = [];
        let drainingCharts = false;
        let totalCharts = 0;
        let completedCharts = 0;

        // ============================================================
        // CHART QUEUE OPTIMIZATION (Step 4)
        // Enhanced queue with priority and performance tracking
        // ============================================================
        function enqueueChartTask(name, fn, priority = 0) {
            chartTasks.push({ name, fn, priority });
            totalCharts++;
            
            // Sort by priority (higher = sooner)
            chartTasks.sort((a, b) => b.priority - a.priority);
            
            if (!drainingCharts) {
                drainChartQueue();
            }
        }

        function drainChartQueue() {
            if (chartTasks.length === 0) {
                drainingCharts = false;
                Logger.debug(`‚úÖ Chart queue complete: ${completedCharts}/${totalCharts} charts created`);
                return;
            }
            
            drainingCharts = true;
            requestAnimationFrame(() => {
                // Double-check array isn't empty (race condition protection)
                if (chartTasks.length === 0) {
                    drainingCharts = false;
                    return;
                }
                
                const { name, fn } = chartTasks.shift();
                completedCharts++;
                
                const startTime = performance.now();
                try {
                    fn();
                    const duration = (performance.now() - startTime).toFixed(2);
                    Logger.debug(`üìä Chart created [${completedCharts}/${totalCharts}]: ${name} (${duration}ms)`);
                } catch (e) {
                    console.error(`‚ùå Chart creation failed: ${name}`, e);
                }
                
                drainChartQueue();
            });
        }

        // Lazy chart creation with IntersectionObserver and priority
        function lazyCreateChart(canvasId, chartName, createFn, priority = 0) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.warn(`Canvas not found: ${canvasId}`);
                return;
            }
            
            const container = canvas.closest('.chart-container');
            if (!container) {
                // No container, create immediately with given priority
                enqueueChartTask(chartName, () => {
                    createFn();
                    attachHandlersToChart(canvasId);
                }, priority);
                return;
            }
            
            // Use IntersectionObserver for lazy loading
            if ('IntersectionObserver' in window) {
                const observer = new IntersectionObserver((entries) => {
                    if (entries.some(e => e.isIntersecting)) {
                        observer.disconnect();
                        // Visible charts get higher priority (base priority + 10)
                        enqueueChartTask(chartName, () => {
                            createFn();
                            attachHandlersToChart(canvasId);
                        }, priority + 10);
                    }
                }, { 
                    root: null, 
                    rootMargin: '200px', // Start loading 200px before visible
                    threshold: 0.01 
                });
                observer.observe(container);
                
                // Also enqueue with lower priority for background loading
                // This ensures charts load even if user doesn't scroll
                setTimeout(() => {
                    if (observer) {
                        enqueueChartTask(chartName, () => {
                            observer.disconnect();
                            createFn();
                            attachHandlersToChart(canvasId);
                        }, priority);
                    }
                }, 5000); // Background load after 5 seconds
            } else {
                // Fallback: enqueue immediately if IntersectionObserver not supported
                enqueueChartTask(chartName, () => {
                    createFn();
                    attachHandlersToChart(canvasId);
                }, priority);
            }
        }

        // Attach double-click handler and other handlers to a chart after creation
        function attachHandlersToChart(canvasId) {
            // Map canvas IDs to window chart objects
            const chartMap = {
                'filter-chart': window.filterChart,
                'timeline-chart': window.timelineChart,
                'query-types-chart': window.queryTypesChart,
                'duration-buckets-chart': window.durationBucketsChart,
                'memory-chart': window.memoryChart,
                'result-count-chart': window.resultCountChart,
                'result-size-chart': window.resultSizeChart,
                'cpu-time-chart': window.cpuTimeChart,
                'index-scan-throughput-chart': window.indexScanThroughputChart,
                'doc-fetch-throughput-chart': window.docFetchThroughputChart,
                'doc-size-bubble-chart': window.docSizeBubbleChart,
                'exec-vs-kernel-chart': window.execVsKernelChart,
                'exec-vs-serv-chart': window.execVsServChart,
                'exec-vs-elapsed-chart': window.execVsElapsedChart,
                'service-time-analysis-chart': window.serviceTimeAnalysisLineChart,
                'enhanced-operations-chart': window.enhancedOperationsChart,
                'collection-queries-chart': window.collectionQueriesChart,
                'parse-duration-chart': window.parseDurationChart,
                'plan-duration-chart': window.planDurationChart,
            };
            
            const chart = chartMap[canvasId];
            if (chart) {
                // Attach double-click handler
                if (typeof attachDoubleClickHandler === 'function') {
                    attachDoubleClickHandler(chart);
                }
                
                // If a vertical stake is already active, apply it to this newly created chart
                if (verticalStakePosition !== null && chart.options.plugins) {
                    if (!chart.options.plugins.annotation) {
                        chart.options.plugins.annotation = { annotations: {} };
                    }
                    
                    chart.options.plugins.annotation.annotations.verticalStake = {
                        type: 'line',
                        xMin: verticalStakePosition,
                        xMax: verticalStakePosition,
                        borderColor: '#007bff',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: 'Staked',
                            position: 'start',
                            backgroundColor: '#007bff',
                            color: '#fff',
                            font: {
                                size: 10
                            }
                        }
                    };
                    
                    chart.update('none');
                }
            }
        }

        // Reset chart loading counters
        function resetChartLoadingCounters() {
            chartTasks.length = 0;
            drainingCharts = false;
            totalCharts = 0;
            completedCharts = 0;
            Logger.debug('üîÑ Chart queue reset');
        }
        // ========== End Progressive Chart Loading System ==========

        // Generate enhanced operations chart with detailed In/Out tracking
        function generateEnhancedOperationsChart(requests) {
            // Destroy existing chart if it exists
            if (window.enhancedOperationsChart) {
                window.enhancedOperationsChart.destroy();
                window.enhancedOperationsChart = null;
            }

            const canvas = document.getElementById("enhanced-operations-chart");
            if (!canvas) return;
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime || !request.plan) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalIndexIn: 0,
                        totalIndexOut: 0,
                        totalFetchIn: 0,
                        totalFetchOut: 0,
                        indexQueryCount: 0,
                        fetchQueryCount: 0,
                    };
                }

                // Extract detailed operator statistics from plan
                try {
                    const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                    const operators = getOperators(planObj);

                    let hasIndexOps = false;
                    let hasFetchOps = false;

                    operators.forEach((operator) => {
                        const operatorType = operator["#operator"];
                        const stats = operator["#stats"] || {};
                        const itemsIn = stats["#itemsIn"] || 0;
                        const itemsOut = stats["#itemsOut"] || 0;

                        if (operatorType === "IndexScan" || operatorType === "IndexScan3" || 
                            operatorType === "PrimaryScan" || operatorType === "PrimaryScan3") {
                            timeGroups[key].totalIndexIn += itemsIn;
                            timeGroups[key].totalIndexOut += itemsOut;
                            hasIndexOps = true;
                        } else if (operatorType === "Fetch") {
                            timeGroups[key].totalFetchIn += itemsIn;
                            timeGroups[key].totalFetchOut += itemsOut;
                            hasFetchOps = true;
                        }
                    });

                    // Count queries that had these operations
                    if (hasIndexOps) {
                        timeGroups[key].indexQueryCount++;
                    }
                    if (hasFetchOps) {
                        timeGroups[key].fetchQueryCount++;
                    }
                } catch (e) {
                    console.warn("Error parsing plan for enhanced operations chart:", e);
                }
            });

            // Get all timeline buckets to ensure charts share same x-axis (Issue #148)
            const buckets = getTimelineBucketsFromRequests(requests, grouping);
            
            // Map data to all buckets (use default values for missing data points)
            const sortedData = buckets.map(ts => {
                const key = ts.toISOString();
                const group = timeGroups[key];
                if (group) {
                    return group;
                } else {
                    return {
                        timestamp: ts,
                        totalIndexIn: 0,
                        totalIndexOut: 0,
                        totalFetchIn: 0,
                        totalFetchOut: 0,
                        indexQueryCount: 0,
                        fetchQueryCount: 0,
                    };
                }
            });

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const indexInData = sortedData.map((item) => item.totalIndexIn);
            const indexOutData = sortedData.map((item) => item.totalIndexOut);
            const fetchInData = sortedData.map((item) => item.totalFetchIn);
            const fetchOutData = sortedData.map((item) => item.totalFetchOut);
            
            // Calculate averages for line charts
            const avgIndexInData = sortedData.map((item) =>
                item.indexQueryCount > 0 ? item.totalIndexIn / item.indexQueryCount : null
            );
            const avgFetchOutData = sortedData.map((item) =>
                item.fetchQueryCount > 0 ? item.totalFetchOut / item.fetchQueryCount : null
            );

            // Create inefficiency fill data - only when Index In > Document Out
            const inefficiencyFillData = sortedData.map((item, index) => {
                const indexIn = avgIndexInData[index];
                const fetchOut = avgFetchOutData[index];
                
                // Only show fill area when Index In > Document Out (inefficient scanning)
                if (indexIn !== null && fetchOut !== null && indexIn > fetchOut) {
                    return indexIn; // Fill from Document Out up to Index In
                }
                return null; // No fill when efficient or no data
            });

            // Create enhanced operations chart
            window.enhancedOperationsChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Avg Index In per Query (with inefficiency fill)",
                            data: avgIndexInData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.25)", // Transparent Orange for fill
                            borderColor: "rgba(0, 123, 255, 1)", // Blue border
                            borderWidth: 2,
                            // No borderDash - solid line
                            fill: '+1', // Fill to next dataset (Document Out line)
                            yAxisID: "y1",
                            order: 0,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3, // Show points
                            pointHoverRadius: 5,
                        },
                        {
                            label: "Avg Document Out per Query",
                            data: avgFetchOutData,
                            type: "line",
                            backgroundColor: "rgba(40, 167, 69, 0.8)", // Green
                            borderColor: "rgba(40, 167, 69, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5], // Dotted line
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3, // Show points
                            pointHoverRadius: 5,
                        },
                        {
                            label: "Index In",
                            data: indexInData,
                            backgroundColor: "rgba(173, 216, 230, 0.8)", // Light Blue
                            borderColor: "rgba(135, 206, 235, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 1, // First bar (leftmost)
                        },
                        {
                            label: "Index Out",
                            data: indexOutData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2, // Second bar
                        },
                        {
                            label: "Document Fetch In",
                            data: fetchInData,
                            backgroundColor: "rgba(144, 238, 144, 0.8)", // Light Green
                            borderColor: "rgba(124, 252, 124, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 3, // Third bar
                        },
                        {
                            label: "Document Fetch Out",
                            data: fetchOutData,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 4, // Fourth bar (rightmost)
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb',
                            samples: 1000,
                            threshold: 1000
                        },
                        title: {
                            display: true,
                            text: "Detailed Index & Document Operations",
                            font: {
                                size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = Math.round(context.parsed.y).toLocaleString();
                                    
                                    if (label.includes('Avg Index In per Query')) {
                                        return `Avg Index In: ${value}`;
                                    }
                                    if (label.includes('Avg Document Out per Query')) {
                                        return `Avg Doc Out: ${value}`;
                                    }
                                    if (label === 'Index In') {
                                        return `Index In: ${value}`;
                                    }
                                    if (label === 'Index Out') {
                                        return `Index Out: ${value}`;
                                    }
                                    if (label === 'Document Fetch In') {
                                        return `Doc Fetch In: ${value}`;
                                    }
                                    if (label === 'Document Fetch Out') {
                                        return `Doc Fetch Out: ${value}`;
                                    }
                                    return `${label}: ${value}`;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    const totalQueries = Math.max(data.indexQueryCount, data.fetchQueryCount);
                                    return [`Queries: ${totalQueries.toLocaleString()}`];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Operation Count",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg Items per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.enhancedOperationsChart, ctx);
        }

        // Generate filter chart showing filter efficiency (IN vs OUT)
        function generateFilterChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.filterChart) {
                window.filterChart.destroy();
                window.filterChart = null;
            }

            const canvas = document.getElementById("filter-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime || !request.plan) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        filtersEqual: 0,
                        filtersNotEqual: 0,
                        queryCount: 0,
                    };
                }
                
                timeGroups[key].queryCount++;

                // Find all Filter operators in the plan
                const operators = getOperators(request.plan);
                operators.forEach((operator) => {
                    if (operator["#operator"] === "Filter") {
                        const stats = operator["#stats"] || {};
                        const itemsIn = stats["#itemsIn"];
                        const itemsOut = stats["#itemsOut"];

                        if (itemsIn !== undefined && itemsOut !== undefined) {
                            if (itemsIn === itemsOut) {
                                timeGroups[key].filtersEqual += itemsOut;
                            } else {
                                timeGroups[key].filtersNotEqual += itemsOut;
                            }
                        }
                    }
                });
            });

            // Get all timeline buckets to ensure charts share same x-axis (Issue #148)
            const buckets = getTimelineBucketsFromRequests(requests, grouping);
            
            // Map data to all buckets (use default values for missing data points)
            const sortedData = buckets.map(ts => {
                const key = ts.toISOString();
                const group = timeGroups[key];
                if (group) {
                    return group;
                } else {
                    return {
                        timestamp: ts,
                        filtersEqual: 0,
                        filtersNotEqual: 0,
                        queryCount: 0,
                    };
                }
            });

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const filtersEqualData = sortedData.map((item) => item.filtersEqual);
            const filtersNotEqualData = sortedData.map(
                (item) => item.filtersNotEqual
            );
            const percentageData = sortedData.map((item) => {
                const total = item.filtersEqual + item.filtersNotEqual;
                return total > 0 ? (item.filtersNotEqual / total) * 100 : 0;
            });

            // Create new mixed chart with bars and line
            window.filterChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Filters: IN = OUT",
                            data: filtersEqualData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                            order: 2,
                        },
                        {
                            label: "Filters: IN ‚â† OUT",
                            data: filtersNotEqualData,
                            backgroundColor: "#dc3545", // Red
                            borderColor: "#b02a37",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                            order: 3,
                        },
                        {
                            label: "Efficiency %",
                            data: percentageData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            yAxisID: "y1",
                            tension: 0.3,
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb',
                            samples: 1000,
                            threshold: 1000
                        },
                        title: {
                            display: true,
                            text: "Filter Operations: Efficiency Analysis (IN vs OUT)",
                            font: {
                                size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = Math.round(context.parsed.y).toLocaleString();
                                    return `${label}: ${value}`;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [`Queries: ${data.queryCount.toLocaleString()}`];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Filter Count",
                            },
                            beginAtZero: true,
                            stacked: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Efficiency %",
                            },
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.filterChart, ctx);

            // Attach double-click handler for vertical stake feature
            attachDoubleClickHandler(window.filterChart);
        }

        // Generate timeline chart showing kernel time vs execution time performance
        function generateTimelineChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.timelineChart) {
                window.timelineChart.destroy();
                window.timelineChart = null;
            }

            const canvas = document.getElementById("timeline-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        percent0to10: 0,
                        percent10to20: 0,
                        percent20to30: 0,
                        percent30to40: 0,
                        percent40to50: 0,
                        percent50to60: 0,
                        percent60to70: 0,
                        percent70to80: 0,
                        percent80to90: 0,
                        percent90to100: 0,
                        percentOver100: 0,
                    };
                }

                // Use pre-calculated values
                const totalKernTimeMs = request.kernTimeMs || 0;
                const elapsedTimeMs = request.elapsedTimeMs || 0;

                // Calculate percentage of kernTime vs executionTime
                const kernTimePercentage =
                    elapsedTimeMs > 0 ? (totalKernTimeMs / elapsedTimeMs) * 100 : 0;

                // Group by percentage ranges
                if (kernTimePercentage < 10) {
                    timeGroups[key].percent0to10++;
                } else if (kernTimePercentage < 20) {
                    timeGroups[key].percent10to20++;
                } else if (kernTimePercentage < 30) {
                    timeGroups[key].percent20to30++;
                } else if (kernTimePercentage < 40) {
                    timeGroups[key].percent30to40++;
                } else if (kernTimePercentage < 50) {
                    timeGroups[key].percent40to50++;
                } else if (kernTimePercentage < 60) {
                    timeGroups[key].percent50to60++;
                } else if (kernTimePercentage < 70) {
                    timeGroups[key].percent60to70++;
                } else if (kernTimePercentage < 80) {
                    timeGroups[key].percent70to80++;
                } else if (kernTimePercentage < 90) {
                    timeGroups[key].percent80to90++;
                } else if (kernTimePercentage <= 100) {
                    timeGroups[key].percent90to100++;
                } else {
                    timeGroups[key].percentOver100++;
                }
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Set original time range from data
            if (sortedData.length > 0) {
                originalTimeRange.min = sortedData[0].timestamp;
                originalTimeRange.max = sortedData[sortedData.length - 1].timestamp;
                currentTimeRange = { ...originalTimeRange };
                updateTimeRangeDisplay();
            }

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const percent0to10Data = sortedData.map((item) => item.percent0to10);
            const percent10to20Data = sortedData.map((item) => item.percent10to20);
            const percent20to30Data = sortedData.map((item) => item.percent20to30);
            const percent30to40Data = sortedData.map((item) => item.percent30to40);
            const percent40to50Data = sortedData.map((item) => item.percent40to50);
            const percent50to60Data = sortedData.map((item) => item.percent50to60);
            const percent60to70Data = sortedData.map((item) => item.percent60to70);
            const percent70to80Data = sortedData.map((item) => item.percent70to80);
            const percent80to90Data = sortedData.map((item) => item.percent80to90);
            const percent90to100Data = sortedData.map(
                (item) => item.percent90to100
            );
            const percentOver100Data = sortedData.map(
                (item) => item.percentOver100
            );

            // Create new stacked bar chart
            window.timelineChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "0-10%",
                            data: percent0to10Data,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                        },
                        {
                            label: "10-20%",
                            data: percent10to20Data,
                            backgroundColor: "#6cb2eb", // Light blue
                            borderColor: "#3490dc",
                            borderWidth: 1,
                        },
                        {
                            label: "20-30%",
                            data: percent20to30Data,
                            backgroundColor: "#a78bfa", // Light purple
                            borderColor: "#8b5cf6",
                            borderWidth: 1,
                        },
                        {
                            label: "30-40%",
                            data: percent30to40Data,
                            backgroundColor: "#34d399", // Light green
                            borderColor: "#10b981",
                            borderWidth: 1,
                        },
                        {
                            label: "40-50%",
                            data: percent40to50Data,
                            backgroundColor: "#fbbf24", // Yellow
                            borderColor: "#f59e0b",
                            borderWidth: 1,
                        },
                        {
                            label: "50-60%",
                            data: percent50to60Data,
                            backgroundColor: "#fb923c", // Orange
                            borderColor: "#ea580c",
                            borderWidth: 1,
                        },
                        {
                            label: "60-70%",
                            data: percent60to70Data,
                            backgroundColor: "#f472b6", // Pink
                            borderColor: "#ec4899",
                            borderWidth: 1,
                        },
                        {
                            label: "70-80%",
                            data: percent70to80Data,
                            backgroundColor: "#a855f7", // Purple
                            borderColor: "#9333ea",
                            borderWidth: 1,
                        },
                        {
                            label: "80-90%",
                            data: percent80to90Data,
                            backgroundColor: "#ef4444", // Red
                            borderColor: "#dc2626",
                            borderWidth: 1,
                        },
                        {
                            label: "90-100%",
                            data: percent90to100Data,
                            backgroundColor: "#991b1b", // Dark red
                            borderColor: "#7f1d1d",
                            borderWidth: 1,
                        },
                        {
                            label: "100%+",
                            data: percentOver100Data,
                            backgroundColor: "#450a0a", // Very dark red
                            borderColor: "#1c0a0a",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        intersect: false,
                        mode: "index",
                    },
                    elements: {
                        point: {
                            radius: 0, // Hide points for better performance
                            hoverRadius: 4,
                        },
                    },
                    scales: {
                        x: {
                            stacked: true,
                            type: "time",
                            time: {
                                displayFormats: {
                                    minute: "HH:mm",
                                    hour: "MM-DD HH:mm",
                                },
                            },
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                        },
                    },
                    plugins: {
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb',
                            samples: 1000,
                            threshold: 1000
                        },
                        title: {
                            display: true,
                            text: "Query Performance: KernTime % of ExecutionTime",
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range - convert chart scale values to Date objects
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                            stacked: true,
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Query Count",
                            },
                            stacked: true,
                            beginAtZero: true,
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.timelineChart, ctx);

            // Attach double-click handler to timeline chart immediately
            attachDoubleClickHandler(window.timelineChart);

            // Reset chart loading counters for new batch
            resetChartLoadingCounters();

            // Create charts progressively using IntersectionObserver + RAF
            // This prevents UI blocking when loading many charts
            // Handlers (double-click, drag) are attached automatically after each chart creation
            lazyCreateChart('query-types-chart', 'Query Types', () => createQueryTypesChart(requests, grouping));
            lazyCreateChart('duration-buckets-chart', 'Duration Buckets', () => createDurationBucketsChart(requests, grouping));
            lazyCreateChart('memory-chart', 'Memory Usage', () => createMemoryChart(requests, grouping));
            lazyCreateChart('collection-queries-chart', 'Collection Queries', () => createCollectionQueriesChart(requests, grouping));
            lazyCreateChart('parse-duration-chart', 'Parse Duration', () => createParseDurationChart(requests, grouping));
            lazyCreateChart('plan-duration-chart', 'Plan Duration', () => createPlanDurationChart(requests, grouping));
            lazyCreateChart('result-count-chart', 'Result Count', () => createResultCountChart(requests, grouping));
            lazyCreateChart('result-size-chart', 'Result Size', () => createResultSizeChart(requests, grouping));
            lazyCreateChart('cpu-time-chart', 'CPU Time', () => createCpuTimeChart(requests, grouping));
            lazyCreateChart('index-scan-throughput-chart', 'Index Scan Throughput', () => createIndexScanThroughputChart(requests, grouping));
            lazyCreateChart('doc-fetch-throughput-chart', 'Doc Fetch Throughput', () => createDocFetchThroughputChart(requests, grouping));
            lazyCreateChart('doc-size-bubble-chart', 'Doc Size Bubble', () => createDocumentSizeBubbleChart(requests, grouping));
            lazyCreateChart('exec-vs-kernel-chart', 'Exec vs Kernel', () => createExecVsKernelChart(requests, grouping));
            lazyCreateChart('exec-vs-serv-chart', 'Exec vs Serv', () => createExecVsServChart(requests, grouping));
            lazyCreateChart('exec-vs-elapsed-chart', 'Exec vs Elapsed', () => createExecVsElapsedChart(requests, grouping));
            lazyCreateChart('service-time-analysis-chart', 'Service Time Analysis', () => createServiceTimeAnalysisLineChart(requests, grouping));
            lazyCreateChart('enhanced-operations-chart', 'Enhanced Operations', () => generateEnhancedOperationsChart(requests));

            // Initialize drag and drop after a brief delay to let first charts render
            setTimeout(() => setupChartDragAndDrop(), 100);
        }

        // Attach double-click handlers to all timeline charts
        function attachTimelineDoubleClickHandlers() {
            const charts = [
                window.filterChart,
                window.timelineChart,
                window.queryTypesChart,
                window.durationBucketsChart,
                window.memoryChart,
                window.resultCountChart,
                window.resultSizeChart,
                window.cpuTimeChart,
                window.indexScanThroughputChart,
                window.docFetchThroughputChart,
                window.docSizeBubbleChart,
                window.execVsKernelChart,
                window.execVsServChart,
                window.execVsElapsedChart,
                window.serviceTimeAnalysisLineChart,
                window.enhancedOperationsChart,
                window.collectionQueriesChart,
                window.parseDurationChart,
                window.planDurationChart,
            ];

            charts.forEach((chart) => {
                if (chart) {
                    attachDoubleClickHandler(chart);
                }
            });
        }

        // Create Query Types Scatter Plot Chart
        function createQueryTypesChart(requests, grouping) {
            const canvas = document.getElementById("query-types-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.queryTypesChart) {
                window.queryTypesChart.destroy();
            }

            // Group requests by time and statement type
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        statementTypes: {},
                        fatalCount: 0,
                    };
                }

                // Track fatal queries separately
                if (request.state && request.state.toLowerCase() === 'fatal') {
                    timeGroups[key].fatalCount++;
                    if (!timeGroups[key].fatalElapsedTimes) {
                        timeGroups[key].fatalElapsedTimes = [];
                    }
                    // Get duration in milliseconds and convert to seconds
                    const elapsedTimeMs = parseTime(request.elapsedTime);
                    const durationSeconds = elapsedTimeMs / 1000;
                    timeGroups[key].fatalElapsedTimes.push(durationSeconds);
                }

                // Use consistent statement type parsing
                let statementType = request.statementType || deriveStatementType(request.statement || request.preparedText) || "UNKNOWN";

                if (!timeGroups[key].statementTypes[statementType]) {
                    timeGroups[key].statementTypes[statementType] = {
                        count: 0,
                        durations: [],
                    };
                }

                timeGroups[key].statementTypes[statementType].count++;

                // Get duration in seconds
                const elapsedTimeMs = parseTime(request.elapsedTime);
                const durationSeconds = elapsedTimeMs / 1000;
                timeGroups[key].statementTypes[statementType].durations.push(
                    durationSeconds
                );
            });

            // Get all unique statement types
            const allStatementTypes = new Set();
            Object.values(timeGroups).forEach((group) => {
                Object.keys(group.statementTypes).forEach((type) => {
                    allStatementTypes.add(type);
                });
            });

            // Log all statement types found (removed for production)

            // Predefined colors for all statement types found
            const colorMap = {
                SELECT: "#007bff", // Blue
                INSERT: "#28a745", // Green
                UPDATE: "#17c671", // Light green
                DELETE: "#dc3545", // Red
                UPSERT: "#6f42c1", // Purple
                MERGE: "#9c27b0", // Deep purple
                CREATE: "#fd7e14", // Orange
                DROP: "#e83e8c", // Pink
                EXPLAIN: "#20c997", // Teal
                ADVISE: "#17a2b8", // Cyan
                INFER: "#ffc107", // Yellow
                WITH: "#6c757d", // Gray
                PREPARE: "#fd7e14", // Orange-red
                EXECUTE: "#6610f2", // Indigo
                "--": "#343a40", // Dark gray (comments)
                UNKNOWN: "#868e96", // Light gray
            };

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.statementTypes).forEach((typeData) => {
                    minCount = Math.min(minCount, typeData.count);
                    maxCount = Math.max(maxCount, typeData.count);
                });
            });

            // Generate datasets for each statement type with variable circle sizes
            const datasets = Array.from(allStatementTypes).map((statementType) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    if (group.statementTypes[statementType]) {
                        const typeData = group.statementTypes[statementType];
                        // Calculate average duration for this time group and statement type
                        const avgDuration =
                            typeData.durations.reduce((sum, d) => sum + d, 0) /
                            typeData.durations.length;

                        // Calculate circle size based on count (3-15 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (typeData.count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 3 + sizeRatio * 12; // Range from 3 to 15 pixels

                        data.push({
                            x: group.timestamp,
                            y: avgDuration,
                            r: circleSize,
                            count: typeData.count,
                            maxDuration: Math.max(...typeData.durations),
                            minDuration: Math.min(...typeData.durations),
                        });
                    }
                });

                return {
                    label: `${statementType} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 50%)`,
                    borderColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 40%)`,
                    borderWidth: 1,
                };
            });

            // Add fatal queries dataset for right Y-axis
            const fatalData = [];
            let maxFatalCount = 0;

            Object.values(timeGroups).forEach((group) => {
                if (group.fatalCount > 0) {
                    maxFatalCount = Math.max(maxFatalCount, group.fatalCount);
                    // Calculate average elapsed time for fatal queries in this time period
                    const avgElapsedTime = group.fatalElapsedTimes && group.fatalElapsedTimes.length > 0
                        ? group.fatalElapsedTimes.reduce((sum, time) => sum + time, 0) / group.fatalElapsedTimes.length
                        : 0;
                    fatalData.push({
                        x: group.timestamp,
                        y: group.fatalCount,
                        count: group.fatalCount,
                        avgElapsedTime: avgElapsedTime,
                    });
                }
            });

            if (fatalData.length > 0) {
                datasets.push({
                    label: `Fatal Queries (${fatalData.reduce((sum, point) => sum + point.count, 0)} total)`,
                    data: fatalData.map(point => ({
                        x: point.x,
                        y: point.y,
                        count: point.count,
                        avgElapsedTime: point.avgElapsedTime
                    })),
                    type: 'scatter', // Use scatter instead of bubble for different point style
                    backgroundColor: '#FF0000', // Bright red
                    borderColor: '#FF0000', // Red outline to match fatal styling
                    borderWidth: 3,
                    pointRadius: fatalData.map(point => Math.min(20, Math.max(8, point.count * 3))), // Larger and more variable sizing
                    pointStyle: 'crossRot', // X shape instead of circle
                    yAxisID: 'y1', // Use right Y-axis
                    showLine: false, // Don't connect points with lines
                });
            }

            // Create bubble chart
            window.queryTypesChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb',
                            samples: 1000,
                            threshold: 1000
                        },
                        title: {
                            display: true,
                            text: TEXT_CONSTANTS.QUERY_DURATION_CHART_TITLE,
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const datasetLabel = context.dataset.label;
                                    const statementType = datasetLabel.split(" (")[0];

                                    // Handle fatal queries dataset differently
                                    if (statementType === "Fatal Queries") {
                                        return [
                                            `${statementType}`,
                                            `${TEXT_CONSTANTS.FATAL_LABEL} ${dataPoint.count}`,
                                            `${TEXT_CONSTANTS.ELAPSED_LABEL} ${dataPoint.avgElapsedTime.toFixed(3)}s`,
                                        ];
                                    } else {
                                        // Handle regular statement type datasets
                                        return [
                                            `${statementType}`,
                                            `${TEXT_CONSTANTS.COUNT_LABEL} ${dataPoint.count}`,
                                            `${TEXT_CONSTANTS.AVG_LABEL} ${dataPoint.y.toFixed(3)}s`,
                                            `${TEXT_CONSTANTS.MIN_LABEL} ${dataPoint.minDuration.toFixed(3)}s`,
                                            `${TEXT_CONSTANTS.MAX_LABEL} ${dataPoint.maxDuration.toFixed(3)}s`,
                                        ];
                                    }
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Average Duration (seconds)",
                            },
                            beginAtZero: true,
                            position: "left",
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Fatal Query Count",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.queryTypesChart, ctx);

            // Setup 3D button click handler
            const btn3D = document.getElementById('open-3d-query-types-chart-btn');
            if (btn3D) {
                // Show button only if we have data
                btn3D.style.display = (requests && requests.length > 0) ? 'block' : 'none';
                
                // Remove old event listeners (prevents duplicate handlers)
                const newBtn = btn3D.cloneNode(true);
                btn3D.parentNode.replaceChild(newBtn, btn3D);
                
                // Add click handler
                newBtn.addEventListener('click', function() {
                    // Always regenerate 3D data to respect current filters
                    createECharts3DQueryTypes(requests, grouping);
                    // Open fullscreen modal
                    expandECharts3DQueryTypes();
                });
            }
        }

        // Create Duration Buckets Chart
        function createDurationBucketsChart(requests, grouping) {
            const canvas = document.getElementById("duration-buckets-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            Logger.debug(`createDurationBucketsChart called with ${requests.length} requests, grouping: ${grouping}`);

            // Destroy existing chart if it exists
            if (window.durationBucketsChart) {
                window.durationBucketsChart.destroy();
            }

            // Group requests by time and duration buckets
            const timeGroups = {};



            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        durationBuckets: {
                            "0-1s": 0,
                            "1-2s": 0,
                            "2-3s": 0,
                            "3-4s": 0,
                            "4-5s": 0,
                            "5-10s": 0,
                            "10-30s": 0,
                            "30-60s": 0,
                            "60-120s": 0,
                            "120-240s": 0,
                            "240-500s": 0,
                            "500-900s": 0,
                            "900s+": 0,
                        },
                    };
                }

                // Get duration in seconds
                const durationMs = parseTime(request.elapsedTime);
                const durationSeconds = durationMs / 1000;

                // Categorize into duration buckets
                if (durationSeconds < 1) {
                    timeGroups[key].durationBuckets["0-1s"]++;
                } else if (durationSeconds < 2) {
                    timeGroups[key].durationBuckets["1-2s"]++;
                } else if (durationSeconds < 3) {
                    timeGroups[key].durationBuckets["2-3s"]++;
                } else if (durationSeconds < 4) {
                    timeGroups[key].durationBuckets["3-4s"]++;
                } else if (durationSeconds < 5) {
                    timeGroups[key].durationBuckets["4-5s"]++;
                } else if (durationSeconds < 10) {
                    timeGroups[key].durationBuckets["5-10s"]++;
                } else if (durationSeconds < 30) {
                    timeGroups[key].durationBuckets["10-30s"]++;
                } else if (durationSeconds < 60) {
                    timeGroups[key].durationBuckets["30-60s"]++;
                } else if (durationSeconds < 120) {
                    timeGroups[key].durationBuckets["60-120s"]++;
                } else if (durationSeconds < 240) {
                    timeGroups[key].durationBuckets["120-240s"]++;
                } else if (durationSeconds < 500) {
                    timeGroups[key].durationBuckets["240-500s"]++;
                } else if (durationSeconds < 900) {
                    timeGroups[key].durationBuckets["500-900s"]++;
                } else {
                    timeGroups[key].durationBuckets["900s+"]++;
                }
            });

            if (Object.keys(timeGroups).length > 0) {
            }

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.durationBuckets).forEach((count) => {
                    if (count > 0) {
                        minCount = Math.min(minCount, count);
                        maxCount = Math.max(maxCount, count);
                    }
                });
            });

            // Color mapping for duration buckets - progressive darkness
            const bucketColors = {
                "0-1s": "#28a745", // Green - fast
                "1-2s": "#6cb2eb", // Light blue
                "2-3s": "#ffc107", // Yellow
                "3-4s": "#fd7e14", // Orange
                "4-5s": "#dc3545", // Red
                "5-10s": "#6f42c1", // Purple
                "10-30s": "#495057", // Dark gray
                "30-60s": "#343a40", // Darker gray
                "60-120s": "#721c24", // Dark red
                "120-240s": "#5a1a1a", // Darker red
                "240-500s": "#450a0a", // Very dark red
                "500-900s": "#2d0a0a", // Extremely dark red
                "900s+": "#1a0404", // Nearly black red
            };

            // Generate datasets for each duration bucket
            const datasets = Object.keys(bucketColors).map((bucket) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    const count = group.durationBuckets[bucket];
                    if (count > 0) {
                        // Calculate circle size based on count (5-20 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 5 + sizeRatio * 15; // Range from 5 to 20 pixels

                        // Use bucket midpoint for y-axis position
                        let yPosition;
                        switch (bucket) {
                            case "0-1s":
                                yPosition = 0.5;
                                break;
                            case "1-2s":
                                yPosition = 1.5;
                                break;
                            case "2-3s":
                                yPosition = 2.5;
                                break;
                            case "3-4s":
                                yPosition = 3.5;
                                break;
                            case "4-5s":
                                yPosition = 4.5;
                                break;
                            case "5-10s":
                                yPosition = 7.5;
                                break;
                            case "10-30s":
                                yPosition = 20;
                                break;
                            case "30-60s":
                                yPosition = 45;
                                break;
                            case "60-120s":
                                yPosition = 90;
                                break;
                            case "120-240s":
                                yPosition = 180;
                                break;
                            case "240-500s":
                                yPosition = 370;
                                break;
                            case "500-900s":
                                yPosition = 700;
                                break;
                            case "900s+":
                                yPosition = 1200;
                                break;
                        }

                        data.push({
                            x: group.timestamp,
                            y: yPosition,
                            r: circleSize,
                            count: count,
                        });
                    }
                });

                return {
                    label: `${bucket} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor: bucketColors[bucket],
                    borderColor: bucketColors[bucket],
                    borderWidth: 1,
                };
            });

            // Create bubble chart
            window.durationBucketsChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Duration Distrubution By Time Buckets (Bubble Size = Query Count)",
                            font: {
                                size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const bucket = context.dataset.label.split(" (")[0];
                                    return [
                                        `${bucket}`,
                                        `Count: ${dataPoint.count}`,
                                        `${new Date(dataPoint.x).toLocaleString()}`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Duration Range (seconds)",
                            },
                            beginAtZero: true,
                            type: "logarithmic",
                            ticks: {
                                callback: function (value) {
                                    if (value === 0.5) return "0-1s";
                                    if (value === 1.5) return "1-2s";
                                    if (value === 2.5) return "2-3s";
                                    if (value === 3.5) return "3-4s";
                                    if (value === 4.5) return "4-5s";
                                    if (value === 7.5) return "5-10s";
                                    if (value === 20) return "10-30s";
                                    if (value === 45) return "30-60s";
                                    if (value === 90) return "60-120s";
                                    if (value === 180) return "120-240s";
                                    if (value === 370) return "240-500s";
                                    if (value === 700) return "500-900s";
                                    if (value === 1200) return "900s+";
                                    return "";
                                },
                            },
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.durationBucketsChart, ctx);

            // Setup 3D button click handler
            const btn3D = document.getElementById('open-3d-timeline-chart-btn');
            if (btn3D) {
                // Show button only if we have data
                btn3D.style.display = (requests && requests.length > 0) ? 'block' : 'none';
                
                // Remove old event listeners
                const newBtn = btn3D.cloneNode(true);
                btn3D.parentNode.replaceChild(newBtn, btn3D);
                
                // Add click handler
                newBtn.addEventListener('click', function() {
                // Always regenerate 3D data to respect current filters
                createECharts3DCollectionTimeline(requests, grouping);
                // Open fullscreen
                expandECharts3DTimeline();
                });
            }
        }

        // Create Memory Usage Chart
        function createMemoryChart(requests, grouping) {
            const canvas = document.getElementById("memory-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.memoryChart) {
                window.memoryChart.destroy();
            }

            // Group requests by time and sum memory usage
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalMemoryBytes: 0,
                        queryCount: 0,
                    };
                }

                // Use pre-calculated memory value
                const usedMemoryBytes = request.memoryBytes || 0;
                timeGroups[key].totalMemoryBytes += usedMemoryBytes;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array and convert bytes to MB
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map((item) => ({
                    timestamp: item.timestamp,
                    totalMemoryMB: item.totalMemoryBytes / (1024 * 1024), // Convert bytes to MB
                    queryCount: item.queryCount,
                }));

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const memoryData = sortedData.map((item) => item.totalMemoryMB);

            // Calculate average memory per query for line chart
            const avgMemoryData = sortedData.map(
                (item) => item.totalMemoryMB / item.queryCount
            );

            // Create memory usage bar chart with line overlay
            window.memoryChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Memory Usage (MB)",
                            data: memoryData,
                            backgroundColor: "#17a2b8", // Info blue-cyan
                            borderColor: "#138496",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg per Query (MB)",
                            data: avgMemoryData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            yAxisID: "y1",
                            tension: 0.3,
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb',
                            samples: 1000,
                            threshold: 1000
                        },
                        title: {
                            display: true,
                            text: "Total Query Process Memory Usage",
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    if (label.includes('Memory Usage')) {
                                        return `Memory Usage (MB): ${value.toLocaleString('en-US', {minimumFractionDigits: 3, maximumFractionDigits: 3})}`;
                                    }
                                    if (label.includes('Avg per Query')) {
                                        return `Avg per Query (MB): ${value.toLocaleString('en-US', {minimumFractionDigits: 3, maximumFractionDigits: 3})}`;
                                    }
                                    return `${label}: ${value.toLocaleString('en-US', {minimumFractionDigits: 3, maximumFractionDigits: 3})}`;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [`Queries: ${data.queryCount.toLocaleString()}`];
                                }
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Memory Usage (MB)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query (MB)",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.memoryChart, ctx);
        }

        // Plugin to draw horizontal dotted line at 1ms threshold
        const horizontalLinePlugin = {
            id: 'horizontalLine',
            afterDatasetsDraw(chart) {
                const { ctx, chartArea: { left, right }, scales: { y } } = chart;
                
                if (!y) return;
                
                // Get the pixel position for 3.0 on the y-axis
                // This is between "666¬µs-1ms" (2.5) and "1-1.3ms" (3.5)
                const yPosition = y.getPixelForValue(3.0);
                
                // Only draw if the line is within the chart area
                if (yPosition < chart.chartArea.top || yPosition > chart.chartArea.bottom) {
                    return;
                }
                
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.moveTo(left, yPosition);
                ctx.lineTo(right, yPosition);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Add label
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('1ms threshold', right - 5, yPosition - 5);
                
                ctx.restore();
            }
        };

        // Extract bucket.scope.collection from SQL statement
        function extractCollectionsFromSQL(sql) {
            if (!sql) return [];
            
            const collections = new Set();
            
            // Match both quoted and unquoted identifiers
            // Patterns handle: FROM `bucket`.`scope`.`collection`, FROM `bucket`, FROM bucket, etc.
            const patterns = [
                // Quoted three-part: `bucket`.`scope`.`collection`
                /(?:FROM|JOIN)\s+`([^`]+)`\.`([^`]+)`\.`([^`]+)`/gi,
                // Unquoted three-part: bucket.scope.collection
                /(?:FROM|JOIN)\s+([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*)/gi,
                // Quoted single: `bucket`
                /(?:FROM|JOIN)\s+`([^`]+)`(?:\s+(?:AS\s+)?[a-zA-Z_]|\s|,|$|WHERE|GROUP|ORDER|LIMIT|UNNEST|JOIN)/gi,
                // Unquoted single: bucket
                /(?:FROM|JOIN)\s+([a-zA-Z_][a-zA-Z0-9_]*)(?:\s+(?:AS\s+)?[a-zA-Z_]|\s|,|$|WHERE|GROUP|ORDER|LIMIT|UNNEST|JOIN)/gi
            ];
            
            patterns.forEach((pattern, patternIndex) => {
                let match;
                while ((match = pattern.exec(sql)) !== null) {
                    if (match.length === 4) {
                        // Three-part: bucket.scope.collection
                        collections.add(`${match[1]}.${match[2]}.${match[3]}`);
                    } else if (match.length === 2) {
                        // Single part: bucket only - defaults to bucket._default._default
                        collections.add(`${match[1]}._default._default`);
                    }
                }
            });
            
            return Array.from(collections);
        }

        // Create Collection Queries Chart
        function createCollectionQueriesChart(requests, grouping) {
            const canvas = document.getElementById("collection-queries-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            if (window.collectionQueriesChart) {
                window.collectionQueriesChart.destroy();
            }

            if (!requests || requests.length === 0) {
                Logger.debug(TEXT_CONSTANTS.NO_DATA_AVAILABLE || "No data available");
                return;
            }

            // Get all timeline buckets
            const timeBuckets = getTimelineBucketsFromRequests(requests, grouping);
            const timeGroups = {};

            // Initialize time buckets
            timeBuckets.forEach(ts => {
                timeGroups[ts.toISOString()] = {};
            });

            // Count queries per collection per time bucket
            requests.forEach((request) => {
                const sql = request.statement || request.preparedText || "";
                const collections = extractCollectionsFromSQL(sql);
                
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                collections.forEach(collection => {
                    if (!timeGroups[key][collection]) {
                        timeGroups[key][collection] = 0;
                    }
                    timeGroups[key][collection]++;
                });
            });

            // Get all unique collections
            const allCollections = new Set();
            Object.values(timeGroups).forEach(group => {
                Object.keys(group).forEach(collection => allCollections.add(collection));
            });

            // Generate colors for each collection
            const colorPalette = [
                'rgba(75, 192, 192, 1)',
                'rgba(255, 99, 132, 1)',
                'rgba(54, 162, 235, 1)',
                'rgba(255, 206, 86, 1)',
                'rgba(153, 102, 255, 1)',
                'rgba(255, 159, 64, 1)',
                'rgba(199, 199, 199, 1)',
                'rgba(83, 102, 255, 1)',
                'rgba(255, 99, 255, 1)',
                'rgba(99, 255, 132, 1)'
            ];

            // Create datasets for each collection
            const datasets = Array.from(allCollections).map((collection, index) => {
                const data = timeBuckets.map(ts => {
                    const key = ts.toISOString();
                    return timeGroups[key][collection] || null;
                });

                const color = colorPalette[index % colorPalette.length];
                
                // Calculate total for this collection
                const total = data.reduce((sum, val) => sum + (val || 0), 0);

                return {
                    label: collection,
                    data: data,
                    borderColor: color,
                    backgroundColor: color.replace('1)', '0.1)'),
                    borderWidth: 2,
                    fill: false,
                    spanGaps: false,
                    tension: 0.3,
                    total: total  // Store total for legend
                };
            });

            window.collectionQueriesChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: timeBuckets,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Queries per Bucket.Scope.Collection",
                            font: { size: 12 }
                        },
                        subtitle: {
                            display: true,
                            text: "Note: Counts collections in JOINs and WITH (CTEs)",
                            font: { size: 10 }
                        },
                        legend: {
                            display: false  // Disable Chart.js legend, use custom HTML legend
                        },
                        tooltip: {
                            mode: "index",
                            intersect: false,
                            filter: function(tooltipItem) {
                                // Only show tooltip for visible datasets
                                const chart = window.collectionQueriesChart;
                                if (!chart) return true;
                                const meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                                return !meta.hidden;
                            }
                        },
                        zoom: {
                            limits: { x: { min: "original", max: "original" }, y: { min: "original", max: "original" } },
                            pan: {
                                enabled: true,
                                mode: "x",
                                modifierKey: "shift"
                            },
                            zoom: {
                                wheel: {
                                    enabled: false
                                },
                                pinch: {
                                    enabled: true
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time"
                            }
                        },
                        y: {
                            type: "linear",
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "Query Count"
                            }
                        }
                    },
                    interaction: {
                        mode: "nearest",
                        axis: "x",
                        intersect: false
                    }
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for timeline zoom sync
            registerTimelineChart(window.collectionQueriesChart, ctx);

            // Store datasets globally for re-sorting
            window.collectionDatasetsForLegend = datasets;
            
            // Generate custom HTML legend with sort dropdown
            renderCollectionLegend('queries');
        }


        // Create ECharts 3D Collection Timeline Chart (dev feature)
        function createECharts3DCollectionTimeline(requests, grouping) {
            if (!requests || requests.length === 0) {
                Logger.debug(TEXT_CONSTANTS.NO_DATA_AVAILABLE || "No data available");
                return;
            }

            // Duration buckets and their numeric values for Z-axis (in seconds)
            const durationBucketDefinitions = [
                { label: "0-1s", min: 0, max: 1, value: 0 },
                { label: "1-2s", min: 1, max: 2, value: 1 },
                { label: "2-3s", min: 2, max: 3, value: 2 },
                { label: "3-4s", min: 3, max: 4, value: 3 },
                { label: "4-5s", min: 4, max: 5, value: 4 },
                { label: "5-10s", min: 5, max: 10, value: 5 },
                { label: "10-30s", min: 10, max: 30, value: 6 },
                { label: "30-60s", min: 30, max: 60, value: 7 },
                { label: "60-120s", min: 60, max: 120, value: 8 },
                { label: "120-240s", min: 120, max: 240, value: 9 },
                { label: "240-500s", min: 240, max: 500, value: 10 },
                { label: "500-900s", min: 500, max: 900, value: 11 },
                { label: "900s+", min: 900, max: Infinity, value: 12 }
            ];

            // Color palette for duration buckets (matching timeline charts)
            const durationColors = [
                'rgba(76, 175, 80, 0.7)',    // 0-1s: Green
                'rgba(33, 150, 243, 0.7)',   // 1-2s: Blue
                'rgba(255, 193, 7, 0.7)',    // 2-3s: Amber/Yellow
                'rgba(255, 152, 0, 0.7)',    // 3-4s: Orange
                'rgba(244, 67, 54, 0.7)',    // 4-5s: Red
                'rgba(156, 39, 176, 0.7)',   // 5-10s: Purple
                'rgba(96, 125, 139, 0.7)',   // 10-30s: Blue Grey
                'rgba(0, 0, 0, 0.7)',        // 30-60s: Black
                'rgba(121, 85, 72, 0.7)',    // 60-120s: Brown
                'rgba(139, 0, 0, 0.7)',      // 120-240s: Dark Red
                'rgba(75, 0, 130, 0.7)',     // 240-500s: Indigo
                'rgba(0, 0, 0, 0.8)',        // 500-900s: Black
                'rgba(0, 0, 0, 0.9)'         // 900s+: Black
            ];

            // Get duration bucket index from elapsed time in seconds
            function getDurationBucketIndex(durationSeconds) {
                if (durationSeconds < 1) return 0;
                else if (durationSeconds < 2) return 1;
                else if (durationSeconds < 3) return 2;
                else if (durationSeconds < 4) return 3;
                else if (durationSeconds < 5) return 4;
                else if (durationSeconds < 10) return 5;
                else if (durationSeconds < 30) return 6;
                else if (durationSeconds < 60) return 7;
                else if (durationSeconds < 120) return 8;
                else if (durationSeconds < 240) return 9;
                else if (durationSeconds < 500) return 10;
                else if (durationSeconds < 900) return 11;
                else return 12; // 900s+
            }

            // Get all timeline buckets
            const timeBuckets = getTimelineBucketsFromRequests(requests, grouping);
            const timeGroups = {};

            // Initialize time buckets with collection -> duration bucket -> count
            timeBuckets.forEach(ts => {
                timeGroups[ts.toISOString()] = {};
            });

            // Group queries by collection, time bucket, and duration bucket
            requests.forEach((request) => {
                const sql = request.statement || request.preparedText || "";
                const collections = extractCollectionsFromSQL(sql);
                
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                const elapsedMs = request.elapsedTime ? parseTime(request.elapsedTime) : 0;
                const durationSeconds = elapsedMs / 1000;  // Convert ms to seconds
                const durationBucketIdx = getDurationBucketIndex(durationSeconds);

                collections.forEach(collection => {
                    if (!timeGroups[key][collection]) {
                        timeGroups[key][collection] = {};
                    }
                    if (!timeGroups[key][collection][durationBucketIdx]) {
                        timeGroups[key][collection][durationBucketIdx] = 0;
                    }
                    timeGroups[key][collection][durationBucketIdx]++;
                });
            });

            // Get all unique collections and count total queries per collection
            const collectionQueryCounts = {};
            Object.values(timeGroups).forEach(group => {
                Object.entries(group).forEach(([collection, durationBuckets]) => {
                    if (!collectionQueryCounts[collection]) {
                        collectionQueryCounts[collection] = 0;
                    }
                    Object.values(durationBuckets).forEach(count => {
                        collectionQueryCounts[collection] += count;
                    });
                });
            });

            // Sort collections by query count (ascending) - fewest queries in front, most in back
            const allCollections = Object.keys(collectionQueryCounts).sort((a, b) => {
                return collectionQueryCounts[a] - collectionQueryCounts[b];
            });

            // Create a mapping of collection to index for y-axis (sorted by query count)
            const collectionToIndex = {};
            allCollections.forEach((collection, idx) => {
                collectionToIndex[collection] = idx;
            });

            // Build data points for ECharts scatter3D
            const data = [];
            timeBuckets.forEach((ts, timeIndex) => {
                const key = ts.toISOString();
                Object.entries(timeGroups[key]).forEach(([collection, durationBuckets]) => {
                    Object.entries(durationBuckets).forEach(([bucketIdx, count]) => {
                        if (count > 0) {
                            const formattedTime = ts.toLocaleString('en-US', { 
                                month: 'short', 
                                day: 'numeric', 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            });
                            const bucketLabel = durationBucketDefinitions[parseInt(bucketIdx)].label;
                            
                            data.push({
                                value: [timeIndex, collectionToIndex[collection], parseInt(bucketIdx)],
                                itemStyle: { color: durationColors[parseInt(bucketIdx)] },
                                actualCount: count,
                                collection: collection,
                                time: formattedTime,
                                duration: bucketLabel
                            });
                        }
                    });
                });
            });

            // Store data globally for fullscreen
            window.echartsTimelineData = {
                data,
                timeBuckets,
                allCollections,
                durationBucketDefinitions,
                durationColors,
                collectionQueryCounts
            };

            Logger.info(`‚úÖ ECharts 3D Timeline data prepared: ${data.length} data points, ${allCollections.length} collections`);
        }

        // Helper function: Add camera position debug display to 3D charts
        function addCameraDebugDisplay(myChart, fullscreenChartDiv, closeBtn, chartName) {
            const urlParams = new URLSearchParams(window.location.search);
            const debugMode = urlParams.get('debug') === 'true' || urlParams.get('logLevel') === 'debug';
            
            if (!debugMode) return;
            
            // Create debug DIV
            const debugDiv = document.createElement('div');
            debugDiv.id = `camera-debug-${chartName}`;
            debugDiv.style.cssText = 'position: absolute; top: 60px; left: 10px; background: rgba(0,0,0,0.9); color: #00ff00; padding: 12px; font-family: monospace; font-size: 13px; z-index: 10002; border-radius: 4px; border: 2px solid #00ff00; box-shadow: 0 0 10px rgba(0,255,0,0.5);';
            debugDiv.innerHTML = '<strong style="color: #ffff00;">Camera Position:</strong><br/>Alpha: 0.0<br/>Beta: 0.0<br/>Distance: 0.0';
            fullscreenChartDiv.appendChild(debugDiv);
            
            // Continuously poll camera position (updates every 100ms)
            const cameraUpdateInterval = setInterval(function() {
                try {
                    const option = myChart.getOption();
                    if (option && option.grid3D && option.grid3D[0] && option.grid3D[0].viewControl) {
                        const vc = option.grid3D[0].viewControl;
                        debugDiv.innerHTML = `
                            <strong style="color: #ffff00;">Camera Position:</strong><br/>
                            Alpha: ${vc.alpha.toFixed(1)}<br/>
                            Beta: ${vc.beta.toFixed(1)}<br/>
                            Distance: ${vc.distance.toFixed(1)}
                        `;
                    }
                } catch (e) {
                    // Silently fail
                }
            }, 100);
            
            // Clean up interval when modal closes
            const originalCloseHandler = closeBtn.onclick;
            closeBtn.onclick = function() {
                clearInterval(cameraUpdateInterval);
                if (originalCloseHandler) originalCloseHandler.call(this);
            };
        }

        // Expand ECharts 3D Timeline to fullscreen
        function expandECharts3DTimeline() {
            const { data, timeBuckets, allCollections, durationBucketDefinitions, durationColors, collectionQueryCounts } = window.echartsTimelineData;
            if (!data || !allCollections) return;

            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'chart-fullscreen-overlay active';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center;';

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'width: 95%; height: 95%; background: white; border-radius: 8px; padding: 20px; position: relative;';

            // Create close button
            const closeBtn = document.createElement('div');
            closeBtn.className = 'chart-collapse-btn';
            closeBtn.title = 'Collapse chart';
            closeBtn.innerHTML = '‚úï';
            closeBtn.onclick = () => {
                document.body.removeChild(overlay);
                document.body.style.overflow = '';
            };

            // Create fullscreen chart container
            const fullscreenChartDiv = document.createElement('div');
            fullscreenChartDiv.id = 'echarts-3d-timeline-fullscreen';
            fullscreenChartDiv.style.cssText = 'width: calc(100% - 420px); height: 100%;';

            // Create controls and legend container
            const controlsContainer = document.createElement('div');
            controlsContainer.style.cssText = 'position: absolute; top: 50px; right: 20px; width: 400px; background: white; border: 1px solid #444; border-radius: 4px; padding: 10px; max-height: calc(100% - 60px); overflow-y: auto;';

            // Add toggle controls
            const togglesDiv = document.createElement('div');
            togglesDiv.style.cssText = 'margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ddd;';
            togglesDiv.innerHTML = `
                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; font-weight: bold;">
                        <input type="checkbox" id="echarts-timeline-log-scale-toggle" style="margin-right: 8px;">
                        Log Scale Bubble Size
                    </label>
                </div>
            `;
            controlsContainer.appendChild(togglesDiv);

            // Add Duration Range Legend Section
            const durationLegendHeader = document.createElement('div');
            durationLegendHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
            durationLegendHeader.innerHTML = `
                <strong style="font-size: 14px;">Duration Ranges:</strong>
                <div>
                    <button id="echarts-timeline-fs-show-all-durations" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 11px;">Show All</button>
                    <button id="echarts-timeline-fs-hide-all-durations" style="padding: 4px 12px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Hide All</button>
                </div>
            `;
            controlsContainer.appendChild(durationLegendHeader);

            // Calculate counts for each duration range
            const durationRangeCounts = {};
            durationBucketDefinitions.forEach((bin, idx) => {
                durationRangeCounts[bin.label] = data.filter(d => d.value[2] === idx).reduce((sum, d) => sum + d.actualCount, 0);
            });

            const durationVisibilityState = {};

            // Create duration range legend items grid
            const durationItemsGrid = document.createElement('div');
            durationItemsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr; gap: 6px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ddd;';
            durationItemsGrid.id = 'echarts-timeline-duration-legend-items-grid';

            durationBucketDefinitions.forEach((bin, idx) => {
                const count = durationRangeCounts[bin.label];
                durationVisibilityState[idx] = true;
                
                const legendItem = document.createElement('div');
                legendItem.style.cssText = 'display: flex; align-items: center; padding: 5px; cursor: pointer; border-radius: 3px; margin-bottom: 2px; border: 1px solid #e0e0e0;';
                legendItem.dataset.durationIndex = idx;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                
                const colorBox = document.createElement('span');
                colorBox.style.cssText = `display: inline-block; width: 16px; height: 16px; background: ${durationColors[idx]}; margin-right: 8px; border: 1px solid #333; border-radius: 2px;`;
                
                const label = document.createElement('span');
                label.style.cssText = 'font-size: 12px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                label.textContent = `${bin.label} (${count} total)`;
                
                legendItem.appendChild(checkbox);
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                
                legendItem.onclick = (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                    durationVisibilityState[idx] = checkbox.checked;
                    legendItem.style.opacity = checkbox.checked ? '1' : '0.3';
                    updateChart();
                };
                
                durationItemsGrid.appendChild(legendItem);
            });

            controlsContainer.appendChild(durationItemsGrid);

            // Add legend header
            const legendHeader = document.createElement('div');
            legendHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
            legendHeader.innerHTML = `
                <strong style="font-size: 14px;">Collections:</strong>
                <div>
                    <button id="echarts-timeline-fs-show-all" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 11px;">Show All</button>
                    <button id="echarts-timeline-fs-hide-all" style="padding: 4px 12px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Hide All</button>
                </div>
            `;
            controlsContainer.appendChild(legendHeader);

            // Add search input
            const searchContainer = document.createElement('div');
            searchContainer.style.cssText = 'margin-bottom: 10px;';
            searchContainer.innerHTML = `
                <input type="text" id="echarts-timeline-legend-search" placeholder="Search collections..." style="width: 100%; font-size: 11px; padding: 6px 8px; border: 1px solid #dee2e6; border-radius: 3px; box-sizing: border-box;">
            `;
            controlsContainer.appendChild(searchContainer);

            // Create legend items grid
            const itemsGrid = document.createElement('div');
            itemsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr; gap: 6px;';
            itemsGrid.id = 'echarts-timeline-legend-items-grid';
            
            // Sort collections by count (descending) for legend display
            const sortedCollections = [...allCollections].sort((a, b) => {
                return collectionQueryCounts[b] - collectionQueryCounts[a];
            });

            const visibilityState = {};
            sortedCollections.forEach(collection => {
                visibilityState[collection] = true;
            });

            sortedCollections.forEach(collection => {
                const count = collectionQueryCounts[collection];
                const legendItem = document.createElement('div');
                legendItem.style.cssText = 'display: flex; align-items: center; padding: 5px; cursor: pointer; border-radius: 3px; margin-bottom: 2px; border: 1px solid #e0e0e0;';
                legendItem.dataset.collection = collection;
                
                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                
                // Collection name with count
                const label = document.createElement('span');
                label.style.cssText = 'font-size: 12px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                label.textContent = `[${count}] ${collection}`;
                
                legendItem.appendChild(checkbox);
                legendItem.appendChild(label);
                
                // Toggle visibility on click
                legendItem.onclick = (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                    visibilityState[collection] = checkbox.checked;
                    legendItem.style.opacity = checkbox.checked ? '1' : '0.3';
                    updateChart();
                };
                
                itemsGrid.appendChild(legendItem);
            });

            controlsContainer.appendChild(itemsGrid);

            // Assemble modal
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(fullscreenChartDiv);
            modalContent.appendChild(controlsContainer);
            overlay.appendChild(modalContent);
            document.body.appendChild(overlay);
            document.body.style.overflow = 'hidden';
            
            // Sync Y-axis scale from radio buttons to 3D chart checkbox (after DOM insertion)
            const selectedScale = document.querySelector('input[name="yScale"]:checked');
            const logScaleCheckbox = document.getElementById('echarts-timeline-log-scale-toggle');
            Logger.debug('3D Timeline - selectedScale.value:', selectedScale?.value);
            Logger.debug('3D Timeline - logScaleCheckbox:', logScaleCheckbox);
            if (selectedScale && logScaleCheckbox) {
                logScaleCheckbox.checked = selectedScale.value === 'logarithmic';
                Logger.debug('3D Timeline - Set checkbox to:', selectedScale.value === 'logarithmic');
            }

            // Calculate initial bubble sizes
            const allCounts = data.map(d => d.actualCount);
            const maxCount = Math.max(...allCounts);

            function calculateBubbleSizes(useLogScale) {
                return data.map(d => {
                    const durationIdx = d.value[2];
                    if (!visibilityState[d.collection] || !durationVisibilityState[durationIdx]) return null;
                    
                    let size;
                    if (useLogScale) {
                        size = Math.max(5, Math.log10(d.actualCount + 1) * 10);
                    } else {
                        size = Math.max(5, Math.min(30, (d.actualCount / maxCount) * 30));
                    }
                    
                    return {
                        value: d.value,
                        itemStyle: d.itemStyle,
                        actualCount: d.actualCount,
                        collection: d.collection,
                        time: d.time,
                        duration: d.duration,
                        symbolSize: size
                    };
                }).filter(d => d !== null);
            }

            // Initialize fullscreen chart
            const myChart = echarts.init(fullscreenChartDiv);
            
            function updateChart() {
                const useLogScale = document.getElementById('echarts-timeline-log-scale-toggle')?.checked || false;
                const chartData = calculateBubbleSizes(useLogScale);
                
                const option = {
                    title: {
                        text: 'Query Duration Groups by Collection',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        formatter: function(params) {
                            const d = params.data;
                            return `${d.collection}<br/>Time: ${d.time}<br/>Duration: ${d.duration}<br/>Queries: ${d.actualCount}`;
                        }
                    },
                    xAxis3D: {
                        type: 'category',
                        data: timeBuckets.map((ts, idx) => idx),
                        name: 'Request Time',
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            interval: Math.max(0, Math.ceil(timeBuckets.length / 10) - 1),
                            formatter: function(value) {
                                return timeBuckets[value].toLocaleString('en-US', { month: 'short', day: 'numeric' });
                            },
                            fontSize: 10
                        }
                    },
                    yAxis3D: {
                        type: 'category',
                        data: allCollections,
                        name: 'Collection',
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            interval: Math.max(0, Math.ceil(allCollections.length / 10) - 1),
                            fontSize: 10
                        }
                    },
                    zAxis3D: {
                        type: 'category',
                        data: durationBucketDefinitions.map(b => b.label),
                        name: 'Duration Range',
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        }
                    },
                    grid3D: {
                        boxWidth: 250,
                        boxDepth: Math.min(250, allCollections.length * 7),
                        boxHeight: 150,
                        viewControl: {
                            alpha: 22.9,
                            beta: 44.6,
                            distance: 453.0,
                            minDistance: 100,
                            maxDistance: 600
                        },
                        light: {
                            main: {
                                intensity: 1.2,
                                shadow: true
                            },
                            ambient: {
                                intensity: 0.5
                            }
                        }
                    },
                    series: [{
                        type: 'scatter3D',
                        data: chartData,
                        symbolSize: function(dataItem) {
                            return dataItem.symbolSize;
                        },
                        itemStyle: {
                            opacity: 0.85
                        },
                        emphasis: {
                            itemStyle: {
                                opacity: 1
                            }
                        }
                    }]
                };

                myChart.setOption(option);
            }

            // Initial render
            updateChart();

            // Add camera debug display
            addCameraDebugDisplay(myChart, fullscreenChartDiv, closeBtn, 'timeline');

            // Duration Range Show/Hide All handlers
            document.getElementById('echarts-timeline-fs-show-all-durations').addEventListener('click', () => {
                Object.keys(durationVisibilityState).forEach(key => {
                    durationVisibilityState[key] = true;
                    const item = durationItemsGrid.querySelector(`[data-duration-index="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = true;
                        item.style.opacity = '1';
                    }
                });
                updateChart();
            });

            document.getElementById('echarts-timeline-fs-hide-all-durations').addEventListener('click', () => {
                Object.keys(durationVisibilityState).forEach(key => {
                    durationVisibilityState[key] = false;
                    const item = durationItemsGrid.querySelector(`[data-duration-index="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = false;
                        item.style.opacity = '0.3';
                    }
                });
                updateChart();
            });

            // Collection Show All button functionality
            document.getElementById('echarts-timeline-fs-show-all').addEventListener('click', () => {
                sortedCollections.forEach(collection => {
                    visibilityState[collection] = true;
                    const item = itemsGrid.querySelector(`[data-collection="${collection}"]`);
                    if (item) {
                        item.querySelector('input').checked = true;
                        item.style.opacity = '1';
                    }
                });
                updateChart();
            });

            // Hide All button functionality
            document.getElementById('echarts-timeline-fs-hide-all').addEventListener('click', () => {
                sortedCollections.forEach(collection => {
                    visibilityState[collection] = false;
                    const item = itemsGrid.querySelector(`[data-collection="${collection}"]`);
                    if (item) {
                        item.querySelector('input').checked = false;
                        item.style.opacity = '0.3';
                    }
                });
                updateChart();
            });

            // Log Scale checkbox functionality
            document.getElementById('echarts-timeline-log-scale-toggle').addEventListener('change', updateChart);

            // Search input filtering
            document.getElementById('echarts-timeline-legend-search').addEventListener('input', (e) => {
                const searchText = e.target.value.toLowerCase().trim();
                const legendItems = itemsGrid.querySelectorAll('div[data-collection]');
                
                legendItems.forEach(item => {
                    const label = item.querySelector('span');
                    const collectionText = label.textContent.toLowerCase();
                    
                    if (searchText === '' || collectionText.includes(searchText)) {
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });

            // Close on ESC key
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    closeBtn.click();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);

            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeBtn.click();
                }
            });
        }

        // Render collection legend with specified sort order
        function renderCollectionLegend(sortBy = 'queries') {
            const legendContainer = document.getElementById("collection-queries-legend-container");
            if (!legendContainer || !window.collectionDatasetsForLegend) return;
            
            const datasets = window.collectionDatasetsForLegend;
            
            // Create sticky header with show/hide buttons and sort dropdown
            let legendHTML = `
                <div style="position: sticky; top: 0; background-color: #fff; z-index: 10; padding-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #dee2e6;">
                        <div style="font-weight: bold; font-size: 14px; color: #495057;">Collections Legend</div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <input type="text" id="collection-search-input" placeholder="Search collections..." style="font-size: 11px; padding: 3px 8px; border: 1px solid #dee2e6; border-radius: 3px; width: 150px;" oninput="filterCollectionLegend(this.value)">
                            <button onclick="showAllCollections()" style="font-size: 11px; padding: 4px 10px; border: 1px solid #28a745; background: #28a745; color: #fff; border-radius: 3px; cursor: pointer; font-weight: 600; transition: background 0.2s;" onmouseover="this.style.background='#218838'" onmouseout="this.style.background='#28a745'">Show All</button>
                            <button onclick="hideAllCollections()" style="font-size: 11px; padding: 4px 10px; border: 1px solid #dc3545; background: #dc3545; color: #fff; border-radius: 3px; cursor: pointer; font-weight: 600; transition: background 0.2s;" onmouseover="this.style.background='#c82333'" onmouseout="this.style.background='#dc3545'">Hide All</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label for="collection-sort-select" style="font-size: 11px; color: #6c757d; font-weight: 600;">Sort By:</label>
                            <select id="collection-sort-select" onchange="renderCollectionLegend(this.value)" style="font-size: 11px; padding: 3px 6px; border: 1px solid #dee2e6; border-radius: 3px; background: #fff; cursor: pointer;">
                                <option value="queries" ${sortBy === 'queries' ? 'selected' : ''}>Queries</option>
                                <option value="name" ${sortBy === 'name' ? 'selected' : ''}>Name</option>
                                <option value="bucket" ${sortBy === 'bucket' ? 'selected' : ''}>Bucket</option>
                            </select>
                        </div>
                    </div>
                </div>
            `;
            
            // Sort datasets based on selection
            let sortedDatasets = [...datasets];
            if (sortBy === 'queries') {
                // Sort by total queries (descending)
                sortedDatasets.sort((a, b) => b.total - a.total);
            } else if (sortBy === 'name') {
                // Sort alphabetically by collection name
                sortedDatasets.sort((a, b) => a.label.localeCompare(b.label));
            } else if (sortBy === 'bucket') {
                // Sort by bucket.scope.collection
                sortedDatasets.sort((a, b) => {
                    const aParts = a.label.split('.');
                    const bParts = b.label.split('.');
                    
                    // Compare bucket
                    if (aParts[0] !== bParts[0]) return aParts[0].localeCompare(bParts[0]);
                    // Compare scope
                    if (aParts[1] !== bParts[1]) return aParts[1].localeCompare(bParts[1]);
                    // Compare collection
                    return aParts[2].localeCompare(bParts[2]);
                });
            }
            
            legendHTML += '<div style="display: flex; flex-direction: column; gap: 6px;">';
            
            sortedDatasets.forEach((dataset) => {
                // Find original index
                const originalIndex = datasets.indexOf(dataset);
                const color = dataset.borderColor;
                
                // Check if dataset is currently hidden
                const chart = window.collectionQueriesChart;
                const isHidden = chart && chart.getDatasetMeta(originalIndex).hidden;
                const opacity = isHidden ? '0.5' : '1';
                const textDecoration = isHidden ? 'line-through' : 'none';
                
                legendHTML += `
                    <div id="collection-legend-item-${originalIndex}" class="legend-item" data-collection-name="${dataset.label}" style="display: flex; align-items: center; cursor: pointer; padding: 6px 8px; border-radius: 4px; transition: all 0.2s; border: 1px solid transparent; opacity: ${opacity};"
                         onmouseover="this.style.backgroundColor='#f8f9fa'; this.style.borderColor='#dee2e6';"
                         onmouseout="this.style.backgroundColor='transparent'; this.style.borderColor='transparent';"
                         onclick="toggleCollectionDataset(${originalIndex})">
                        <div style="width: 24px; height: 3px; background-color: ${color}; margin-right: 10px; border-radius: 2px; flex-shrink: 0;"></div>
                        <div style="flex: 1; line-height: 1.4;">
                            <div id="collection-legend-label-${originalIndex}" style="font-weight: 600; color: #343a40; font-size: 16px; transition: text-decoration 0.2s; text-decoration: ${textDecoration};">${dataset.label}</div>
                            <div id="collection-legend-count-${originalIndex}" style="color: #6c757d; font-size: 14px; margin-top: 2px; transition: text-decoration 0.2s; text-decoration: ${textDecoration};">${dataset.total} queries</div>
                        </div>
                    </div>
                `;
            });
            
            legendHTML += '</div>';
            legendContainer.innerHTML = legendHTML;
        }

        // Toggle dataset visibility for collection queries chart
        function toggleCollectionDataset(index) {
            const chart = window.collectionQueriesChart;
            if (!chart) return;
            
            const meta = chart.getDatasetMeta(index);
            meta.hidden = !meta.hidden;
            chart.update();
            
            // Update legend item styling
            const legendItem = document.getElementById(`collection-legend-item-${index}`);
            const legendLabel = document.getElementById(`collection-legend-label-${index}`);
            const legendCount = document.getElementById(`collection-legend-count-${index}`);
            
            if (meta.hidden) {
                // Apply strikethrough and reduce opacity
                if (legendLabel) legendLabel.style.textDecoration = 'line-through';
                if (legendCount) legendCount.style.textDecoration = 'line-through';
                if (legendItem) legendItem.style.opacity = '0.5';
            } else {
                // Remove strikethrough and restore opacity
                if (legendLabel) legendLabel.style.textDecoration = 'none';
                if (legendCount) legendCount.style.textDecoration = 'none';
                if (legendItem) legendItem.style.opacity = '1';
            }
        }

        // Show all collection datasets
        function showAllCollections() {
            const chart = window.collectionQueriesChart;
            if (!chart) return;
            
            const datasets = window.collectionDatasetsForLegend;
            if (!datasets) return;
            
            // Show all datasets
            datasets.forEach((dataset, index) => {
                const meta = chart.getDatasetMeta(index);
                meta.hidden = false;
            });
            
            chart.update();
            
            // Get current sort order
            const sortSelect = document.getElementById('collection-sort-select');
            const currentSort = sortSelect ? sortSelect.value : 'queries';
            
            // Re-render legend to update styling
            renderCollectionLegend(currentSort);
        }

        // Hide all collection datasets
        function hideAllCollections() {
            const chart = window.collectionQueriesChart;
            if (!chart) return;
            
            const datasets = window.collectionDatasetsForLegend;
            if (!datasets) return;
            
            // Hide all datasets
            datasets.forEach((dataset, index) => {
                const meta = chart.getDatasetMeta(index);
                meta.hidden = true;
            });
            
            chart.update();
            
            // Get current sort order
            const sortSelect = document.getElementById('collection-sort-select');
            const currentSort = sortSelect ? sortSelect.value : 'queries';
            
            // Re-render legend to update styling
            renderCollectionLegend(currentSort);
        }

        // Filter collection legend by search string
        function filterCollectionLegend(searchText) {
            const legendItems = document.querySelectorAll('#collection-queries-legend-container .legend-item');
            const searchLower = searchText.toLowerCase().trim();
            
            legendItems.forEach(item => {
                const collectionName = item.getAttribute('data-collection-name');
                if (!collectionName) return;
                
                if (searchLower === '' || collectionName.toLowerCase().includes(searchLower)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // ========================================
        // 3D Query Types Chart Functions (Issue #214)
        // ========================================

        // Create ECharts 3D Query Types Data (Scatter3D with Bubbles + Fatal X markers)
        // X-axis: Time, Y-axis: Collection, Z-axis: Avg Duration
        // Color: Statement Type, Size: Query Count
        function createECharts3DQueryTypes(requests, grouping) {
            if (!requests || requests.length === 0) {
                Logger.debug(TEXT_CONSTANTS.NO_DATA_AVAILABLE || "No data available");
                return;
            }

            // Statement type colors (matching 2D chart)
            const colorMap = {
                SELECT: "#007bff", // Blue
                INSERT: "#28a745", // Green
                UPDATE: "#17c671", // Light green
                DELETE: "#dc3545", // Red
                UPSERT: "#6f42c1", // Purple
                MERGE: "#9c27b0", // Deep purple
                CREATE: "#fd7e14", // Orange
                DROP: "#e83e8c", // Pink
                EXPLAIN: "#20c997", // Teal
                ADVISE: "#17a2b8", // Cyan
                INFER: "#ffc107", // Yellow
                WITH: "#6c757d", // Gray
                PREPARE: "#fd7e14", // Orange-red
                EXECUTE: "#6610f2", // Indigo
                "--": "#343a40", // Dark gray (comments)
                UNKNOWN: "#868e96", // Light gray
            };

            // Get all timeline buckets
            const timeBuckets = getTimelineBucketsFromRequests(requests, grouping);
            
            // Data structure: timeGroups[timeKey][collection][statementType] = { count, durations }
            const timeGroups = {};
            const fatalQueriesData = {}; // Separate tracking for fatal queries

            // Initialize time buckets
            timeBuckets.forEach(ts => {
                timeGroups[ts.toISOString()] = {};
                fatalQueriesData[ts.toISOString()] = {}; // collection -> { count, durations }
            });

            // Group queries by time, collection, and statement type
            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) return;

                const sql = request.statement || request.preparedText || "";
                const collections = extractCollectionsFromSQL(sql);
                const statementType = request.statementType || deriveStatementType(sql) || "UNKNOWN";
                const elapsedMs = parseTime(request.elapsedTime);
                const durationSeconds = elapsedMs / 1000;
                const isFatal = request.state && request.state.toLowerCase() === 'fatal';

                // If no collections found, use "UNKNOWN_COLLECTION" to ensure all queries are counted
                const collectionsToProcess = collections.length > 0 ? collections : ["UNKNOWN_COLLECTION"];

                collectionsToProcess.forEach(collection => {
                    // Track fatal queries separately
                    if (isFatal) {
                        if (!fatalQueriesData[key][collection]) {
                            fatalQueriesData[key][collection] = {
                                count: 0,
                                durations: []
                            };
                        }
                        fatalQueriesData[key][collection].count++;
                        fatalQueriesData[key][collection].durations.push(durationSeconds);
                    }

                    // Track regular statement types
                    if (!timeGroups[key][collection]) {
                        timeGroups[key][collection] = {};
                    }
                    if (!timeGroups[key][collection][statementType]) {
                        timeGroups[key][collection][statementType] = {
                            count: 0,
                            durations: []
                        };
                    }
                    timeGroups[key][collection][statementType].count++;
                    timeGroups[key][collection][statementType].durations.push(durationSeconds);
                });
            });

            // Get all unique statement types
            const allStatementTypes = new Set();
            Object.values(timeGroups).forEach(timeGroup => {
                Object.values(timeGroup).forEach(collectionData => {
                    Object.keys(collectionData).forEach(type => {
                        allStatementTypes.add(type);
                    });
                });
            });

            // Get all unique collections
            const allCollections = new Set();
            Object.values(timeGroups).forEach(timeGroup => {
                Object.keys(timeGroup).forEach(collection => {
                    allCollections.add(collection);
                });
            });

            // Add collections from fatal queries
            Object.values(fatalQueriesData).forEach(fatalTimeData => {
                Object.keys(fatalTimeData).forEach(collection => {
                    allCollections.add(collection);
                });
            });

            // Count totals for sorting
            const statementTypeCounts = {};
            const collectionCounts = {};

            Object.values(timeGroups).forEach(timeGroup => {
                Object.entries(timeGroup).forEach(([collection, statementTypes]) => {
                    if (!collectionCounts[collection]) {
                        collectionCounts[collection] = 0;
                    }
                    Object.entries(statementTypes).forEach(([statementType, data]) => {
                        if (!statementTypeCounts[statementType]) {
                            statementTypeCounts[statementType] = 0;
                        }
                        statementTypeCounts[statementType] += data.count;
                        collectionCounts[collection] += data.count;
                    });
                });
            });

            // Sort by count (ascending - smallest in front)
            const sortedStatementTypes = Array.from(allStatementTypes).sort((a, b) => {
                return (statementTypeCounts[a] || 0) - (statementTypeCounts[b] || 0);
            });

            const sortedCollections = Array.from(allCollections).sort((a, b) => {
                return (collectionCounts[a] || 0) - (collectionCounts[b] || 0);
            });

            // Create index mappings
            const collectionToIndex = {};
            sortedCollections.forEach((collection, idx) => {
                collectionToIndex[collection] = idx;
            });

            // Build bubble data points (for statement types by collection)
            const bubbleData = [];
            timeBuckets.forEach((ts, timeIndex) => {
                const key = ts.toISOString();
                const formattedTime = ts.toLocaleString('en-US', { 
                    month: 'short', 
                    day: 'numeric', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });

                Object.entries(timeGroups[key]).forEach(([collection, statementTypes]) => {
                    Object.entries(statementTypes).forEach(([statementType, data]) => {
                        if (data.count > 0) {
                            const avgDuration = data.durations.reduce((sum, d) => sum + d, 0) / data.durations.length;

                            bubbleData.push({
                                value: [timeIndex, collectionToIndex[collection], avgDuration],
                                itemStyle: { color: colorMap[statementType] || '#868e96' },
                                actualCount: data.count,
                                statementType: statementType,
                                collection: collection,
                                time: formattedTime,
                                avgDuration: avgDuration,
                                maxDuration: Math.max(...data.durations),
                                minDuration: Math.min(...data.durations)
                            });
                        }
                    });
                });
            });

            // Build fatal query data points (X markers)
            const fatalData = [];
            timeBuckets.forEach((ts, timeIndex) => {
                const key = ts.toISOString();
                const formattedTime = ts.toLocaleString('en-US', { 
                    month: 'short', 
                    day: 'numeric', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });

                Object.entries(fatalQueriesData[key]).forEach(([collection, data]) => {
                    if (data.count > 0) {
                        const avgDuration = data.durations.reduce((sum, d) => sum + d, 0) / data.durations.length;
                        
                        fatalData.push({
                            value: [timeIndex, collectionToIndex[collection], avgDuration],
                            itemStyle: { color: '#FF0000' },
                            actualCount: data.count,
                            statementType: 'Fatal Query',
                            collection: collection,
                            time: formattedTime,
                            avgDuration: avgDuration,
                            maxDuration: Math.max(...data.durations),
                            minDuration: Math.min(...data.durations)
                        });
                    }
                });
            });

            // Store data globally for fullscreen
            window.echartsQueryTypesData = {
                bubbleData,
                fatalData,
                timeBuckets,
                sortedStatementTypes,
                sortedCollections,
                colorMap,
                statementTypeCounts,
                collectionCounts
            };

            Logger.info(`‚úÖ ECharts 3D Query Types data prepared: ${bubbleData.length} bubbles, ${fatalData.length} fatal markers, ${sortedStatementTypes.length} statement types, ${sortedCollections.length} collections`);
        }

        // Expand ECharts 3D Query Types to Fullscreen Modal
        function expandECharts3DQueryTypes() {
            const { bubbleData, fatalData, timeBuckets, sortedStatementTypes, sortedCollections, colorMap, statementTypeCounts, collectionCounts } = window.echartsQueryTypesData;
            if (!bubbleData || !sortedCollections) return;
        
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'chart-fullscreen-overlay active';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center;';
        
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'width: 95%; height: 95%; background: white; border-radius: 8px; padding: 20px; position: relative;';
        
            // Create close button
            const closeBtn = document.createElement('div');
            closeBtn.className = 'chart-collapse-btn';
            closeBtn.title = 'Collapse chart';
            closeBtn.innerHTML = '‚úï';
            closeBtn.onclick = () => {
                document.body.removeChild(overlay);
                document.body.style.overflow = '';
            };
        
            // Create fullscreen chart container
            const fullscreenChartDiv = document.createElement('div');
            fullscreenChartDiv.id = 'echarts-3d-query-types-fullscreen';
            fullscreenChartDiv.style.cssText = 'width: calc(100% - 420px); height: 100%;';
        
            // Create controls and legend container
            const controlsContainer = document.createElement('div');
            controlsContainer.style.cssText = 'position: absolute; top: 50px; right: 20px; width: 400px; background: white; border: 1px solid #444; border-radius: 4px; padding: 10px; max-height: calc(100% - 60px); overflow-y: auto;';
        
            // Add Log Scale toggle
            const togglesDiv = document.createElement('div');
            togglesDiv.style.cssText = 'margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ddd;';
            togglesDiv.innerHTML = `
                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; font-weight: bold;">
                        <input type="checkbox" id="echarts-query-types-log-scale-toggle" style="margin-right: 8px;">
                        Log Scale Z-Axis (Avg Duration)
                    </label>
                </div>
            `;
            controlsContainer.appendChild(togglesDiv);
            
            // Add Statement Type Legend Section (from 2D chart)
            const statementTypeLegendHeader = document.createElement('div');
            statementTypeLegendHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
            statementTypeLegendHeader.innerHTML = `
                <strong style="font-size: 14px;">Statement Types:</strong>
                <div>
                    <button id="echarts-query-types-fs-show-all-statements" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 11px;">Show All</button>
                    <button id="echarts-query-types-fs-hide-all-statements" style="padding: 4px 12px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Hide All</button>
                </div>
            `;
            controlsContainer.appendChild(statementTypeLegendHeader);
        
            const statementTypeVisibilityState = {};
        
            // Create statement type legend items grid
            const statementTypeItemsGrid = document.createElement('div');
            statementTypeItemsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr; gap: 6px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ddd;';
            statementTypeItemsGrid.id = 'echarts-query-types-statement-legend-items-grid';
        
            // Add Fatal Queries first (if any) - Special styling to stand out
            const totalFatalCount = fatalData.reduce((sum, d) => sum + d.actualCount, 0);
            if (totalFatalCount > 0) {
                statementTypeVisibilityState['FATAL_QUERIES'] = true;
                
                const fatalLegendItem = document.createElement('div');
                fatalLegendItem.style.cssText = 'display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 4px; margin-bottom: 8px; border: 3px solid #FF0000; background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%); box-shadow: 0 2px 8px rgba(255, 0, 0, 0.3);';
                fatalLegendItem.dataset.statementType = 'FATAL_QUERIES';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer; width: 16px; height: 16px;';
                
                const colorBox = document.createElement('span');
                colorBox.style.cssText = `display: inline-block; width: 18px; height: 18px; background: #FF0000; margin-right: 8px; border: 2px solid #8B0000; border-radius: 2px; box-shadow: 0 0 4px rgba(255, 0, 0, 0.5);`;
                
                const label = document.createElement('span');
                label.style.cssText = 'font-size: 13px; flex: 1; font-weight: bold; color: #C62828; text-shadow: 0 1px 2px rgba(0,0,0,0.1);';
                label.innerHTML = `‚ö†Ô∏è Fatal Queries (${totalFatalCount} total)`;
                
                fatalLegendItem.appendChild(checkbox);
                fatalLegendItem.appendChild(colorBox);
                fatalLegendItem.appendChild(label);
                
                fatalLegendItem.onclick = (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                    statementTypeVisibilityState['FATAL_QUERIES'] = checkbox.checked;
                    fatalLegendItem.style.opacity = checkbox.checked ? '1' : '0.3';
                    updateChart();
                };
                
                statementTypeItemsGrid.appendChild(fatalLegendItem);
            }
        
            // Sort statement types by count (descending) for legend display
            const displayStatementTypes = [...sortedStatementTypes].sort((a, b) => {
                return (statementTypeCounts[b] || 0) - (statementTypeCounts[a] || 0);
            });
        
            displayStatementTypes.forEach(statementType => {
                statementTypeVisibilityState[statementType] = true;
                
                const count = statementTypeCounts[statementType];
                const legendItem = document.createElement('div');
                legendItem.style.cssText = 'display: flex; align-items: center; padding: 5px; cursor: pointer; border-radius: 3px; margin-bottom: 2px; border: 1px solid #e0e0e0;';
                legendItem.dataset.statementType = statementType;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                
                const colorBox = document.createElement('span');
                colorBox.style.cssText = `display: inline-block; width: 16px; height: 16px; background: ${colorMap[statementType] || '#868e96'}; margin-right: 8px; border: 1px solid #333; border-radius: 2px;`;
                
                const label = document.createElement('span');
                label.style.cssText = 'font-size: 12px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                label.textContent = `${statementType} (${count} total)`;
                
                legendItem.appendChild(checkbox);
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                
                legendItem.onclick = (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                    statementTypeVisibilityState[statementType] = checkbox.checked;
                    legendItem.style.opacity = checkbox.checked ? '1' : '0.3';
                    updateChart();
                };
                
                statementTypeItemsGrid.appendChild(legendItem);
            });
        
            controlsContainer.appendChild(statementTypeItemsGrid);
        
            // Add legend header with Show/Hide All buttons
            const legendHeader = document.createElement('div');
            legendHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
            legendHeader.innerHTML = `
                <strong style="font-size: 14px;">Collections:</strong>
                <div>
                    <button id="echarts-query-types-fs-show-all" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 11px;">Show All</button>
                    <button id="echarts-query-types-fs-hide-all" style="padding: 4px 12px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Hide All</button>
                </div>
            `;
            controlsContainer.appendChild(legendHeader);
        
            // Add search input
            const searchContainer = document.createElement('div');
            searchContainer.style.cssText = 'margin-bottom: 10px;';
            searchContainer.innerHTML = `
                <input type="text" id="echarts-query-types-legend-search" placeholder="Search collections..." style="width: 100%; font-size: 11px; padding: 6px 8px; border: 1px solid #dee2e6; border-radius: 3px; box-sizing: border-box;">
            `;
            controlsContainer.appendChild(searchContainer);
        
            // Create legend items grid
            const itemsGrid = document.createElement('div');
            itemsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr; gap: 6px;';
            itemsGrid.id = 'echarts-query-types-legend-items-grid';
        
            const visibilityState = {};
        
            // Sort collections by count (descending) for legend display
            const displayCollections = [...sortedCollections].sort((a, b) => {
                return (collectionCounts[b] || 0) - (collectionCounts[a] || 0);
            });
        
            displayCollections.forEach(collection => {
                visibilityState[collection] = true;
                
                const count = collectionCounts[collection];
                const legendItem = document.createElement('div');
                legendItem.style.cssText = 'display: flex; align-items: center; padding: 5px; cursor: pointer; border-radius: 3px; margin-bottom: 2px; border: 1px solid #e0e0e0;';
                legendItem.dataset.collection = collection;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                
                const label = document.createElement('span');
                label.style.cssText = 'font-size: 12px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                label.textContent = `[${count}] ${collection}`;
                
                legendItem.appendChild(checkbox);
                legendItem.appendChild(label);
                
                legendItem.onclick = (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                    visibilityState[collection] = checkbox.checked;
                    legendItem.style.opacity = checkbox.checked ? '1' : '0.3';
                    updateChart();
                };
                
                itemsGrid.appendChild(legendItem);
            });
        
            controlsContainer.appendChild(itemsGrid);
        
            // Assemble modal
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(fullscreenChartDiv);
            modalContent.appendChild(controlsContainer);
            overlay.appendChild(modalContent);
            document.body.appendChild(overlay);
            document.body.style.overflow = 'hidden';
            
            // Sync Y-axis scale from radio buttons to 3D chart checkbox (after DOM insertion)
            const selectedScale = document.querySelector('input[name="yScale"]:checked');
            const logScaleCheckbox = document.getElementById('echarts-query-types-log-scale-toggle');
            if (selectedScale && logScaleCheckbox) {
                logScaleCheckbox.checked = selectedScale.value === 'logarithmic';
                Logger.debug('3D Query Types - Set checkbox to:', selectedScale.value === 'logarithmic');
            }
        
            // Initialize ECharts
            const myChart = echarts.init(fullscreenChartDiv);
        
            // Calculate bubble sizes (fixed size based on count, not affected by Z-axis scale)
            function calculateBubbleSizes() {
                const allCounts = bubbleData
                    .filter(d => visibilityState[d.collection] && statementTypeVisibilityState[d.statementType])
                    .map(d => d.actualCount);
                const maxCount = Math.max(...allCounts, 1);
                
                return bubbleData
                    .filter(d => visibilityState[d.collection] && statementTypeVisibilityState[d.statementType])
                    .map(d => {
                        // Fixed bubble size based on count
                        const size = Math.max(5, Math.min(30, (d.actualCount / maxCount) * 30));
                        return {
                            value: d.value,
                            itemStyle: d.itemStyle,
                            actualCount: d.actualCount,
                            statementType: d.statementType,
                            collection: d.collection,
                            time: d.time,
                            avgDuration: d.avgDuration,
                            maxDuration: d.maxDuration,
                            minDuration: d.minDuration,
                            symbolSize: size
                        };
                    });
            }
        
            function updateChart() {
                const useLogScale = document.getElementById('echarts-query-types-log-scale-toggle')?.checked || false; // Default to false
                const chartData = calculateBubbleSizes();
        
                // Build series array
                const series = [];
        
                // Regular bubbles (grouped by statement type for coloring)
                const bubbleSeriesData = chartData.map(d => ({
                    value: d.value,
                    itemStyle: d.itemStyle,
                    actualCount: d.actualCount,
                    statementType: d.statementType,
                    collection: d.collection,
                    time: d.time,
                    avgDuration: d.avgDuration,
                    maxDuration: d.maxDuration,
                    minDuration: d.minDuration,
                    symbolSize: d.symbolSize
                }));
        
                if (bubbleSeriesData.length > 0) {
                    series.push({
                        type: 'scatter3D',
                        data: bubbleSeriesData,
                        symbol: 'circle',
                        symbolSize: function(dataItem) {
                            return dataItem.symbolSize;
                        },
                        itemStyle: {
                            opacity: 0.85
                        },
                        emphasis: {
                            itemStyle: {
                                opacity: 1
                            }
                        }
                    });
                }
        
                // Fatal queries (diamonds)
                if (statementTypeVisibilityState['FATAL_QUERIES'] && fatalData && fatalData.length > 0) {
                const fatalSeriesData = fatalData
                .filter(d => visibilityState[d.collection])
                .map(d => {
                            // Fixed fatal marker size based on count
                            const size = Math.max(15, Math.min(40, d.actualCount * 8));
                            return {
                                value: d.value,
                                itemStyle: { color: '#FF0000' },
                                actualCount: d.actualCount,
                                statementType: d.statementType,
                                collection: d.collection,
                                time: d.time,
                                avgDuration: d.avgDuration,
                                maxDuration: d.maxDuration,
                                minDuration: d.minDuration,
                                symbolSize: size
                            };
                        });
        
                    if (fatalSeriesData.length > 0) {
                        series.push({
                            type: 'scatter3D',
                            data: fatalSeriesData,
                            symbol: 'diamond',
                            symbolSize: function(dataItem) {
                                return dataItem.symbolSize;
                            },
                            itemStyle: {
                                opacity: 1,
                                color: '#FF0000'
                            },
                            emphasis: {
                                itemStyle: {
                                    opacity: 1,
                                    color: '#FF3333'
                                }
                            }
                        });
                    }
                }
        
                const option = {
                    title: {
                        text: 'Query Duration By Statement Type By Collection',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        formatter: function(params) {
                            const d = params.data;
                            return `<strong>${d.statementType}</strong><br/>Collection: ${d.collection}<br/>Time: ${d.time}<br/>Avg Duration: ${d.avgDuration.toFixed(3)}s<br/>Count: ${d.actualCount}<br/>Min: ${d.minDuration.toFixed(3)}s<br/>Max: ${d.maxDuration.toFixed(3)}s`;
                        }
                    },
                    grid3D: {
                        boxWidth: 200,
                        boxHeight: Math.min(300, sortedCollections.length * 20),
                        boxDepth: 200,
                        viewControl: {
                            alpha: 9,
                            beta: 44.4,
                            distance: 589.1,
                            minDistance: 100,
                            maxDistance: 600
                        },
                        light: {
                            main: {
                                intensity: 1.2,
                                shadow: true
                            },
                            ambient: {
                                intensity: 0.5
                            }
                        }
                    },
                    xAxis3D: {
                        type: 'value',
                        name: 'Time',
                        min: 0,
                        max: timeBuckets.length - 1,
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            interval: Math.max(0, Math.ceil(timeBuckets.length / 10) - 1),
                            formatter: function(value) {
                                const idx = Math.round(value);
                                if (idx >= 0 && idx < timeBuckets.length) {
                                    return timeBuckets[idx].toLocaleString('en-US', { month: 'short', day: 'numeric' });
                                }
                                return '';
                            },
                            fontSize: 10
                        }
                    },
                    yAxis3D: {
                        type: 'value',
                        name: 'Collection',
                        min: 0,
                        max: sortedCollections.length - 1,
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            interval: Math.max(0, Math.ceil(sortedCollections.length / 10) - 1),
                            formatter: function(value) {
                                const idx = Math.round(value);
                                if (idx >= 0 && idx < sortedCollections.length) {
                                    const collection = sortedCollections[idx];
                                    return collection.length > 15 ? collection.substring(0, 15) + '...' : collection;
                                }
                                return '';
                            },
                            fontSize: 10
                        }
                    },
                    zAxis3D: {
                        type: useLogScale ? 'log' : 'value',
                        name: 'Avg Duration (s)',
                        min: useLogScale ? 0.001 : 0,
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            formatter: function(value) {
                                return value.toFixed(3) + 's';
                            }
                        }
                    },
                    series: series
                };
        
                myChart.setOption(option, true);
            }
        
            // Initial render
            updateChart();

            // Add camera debug display
            addCameraDebugDisplay(myChart, fullscreenChartDiv, closeBtn, 'query-types');
        
            // Log scale toggle handler
            document.getElementById('echarts-query-types-log-scale-toggle').addEventListener('change', updateChart);
        
            // Statement Type Show/Hide All handlers
            document.getElementById('echarts-query-types-fs-show-all-statements').addEventListener('click', () => {
                Object.keys(statementTypeVisibilityState).forEach(key => {
                    statementTypeVisibilityState[key] = true;
                    const item = statementTypeItemsGrid.querySelector(`[data-statement-type="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = true;
                        item.style.opacity = '1';
                    }
                });
                updateChart();
            });
        
            document.getElementById('echarts-query-types-fs-hide-all-statements').addEventListener('click', () => {
                Object.keys(statementTypeVisibilityState).forEach(key => {
                    statementTypeVisibilityState[key] = false;
                    const item = statementTypeItemsGrid.querySelector(`[data-statement-type="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = false;
                        item.style.opacity = '0.3';
                    }
                });
                updateChart();
            });
        
            // Collection Show/Hide All handlers
            document.getElementById('echarts-query-types-fs-show-all').addEventListener('click', () => {
                Object.keys(visibilityState).forEach(key => {
                    visibilityState[key] = true;
                    const item = itemsGrid.querySelector(`[data-collection="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = true;
                        item.style.opacity = '1';
                    }
                });
                updateChart();
            });
        
            document.getElementById('echarts-query-types-fs-hide-all').addEventListener('click', () => {
                Object.keys(visibilityState).forEach(key => {
                    visibilityState[key] = false;
                    const item = itemsGrid.querySelector(`[data-collection="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = false;
                        item.style.opacity = '0.3';
                    }
                });
                updateChart();
            });
        
            // Search handler
            const searchInput = document.getElementById('echarts-query-types-legend-search');
            searchInput.addEventListener('input', function() {
                const searchLower = this.value.toLowerCase();
                itemsGrid.querySelectorAll('[data-collection]').forEach(item => {
                    const collection = item.dataset.collection;
                    if (!collection) return;
                    
                    if (searchLower === '' || collection.toLowerCase().includes(searchLower)) {
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });
        }
        // Create Parse Duration Distribution Chart
        function createParseDurationChart(requests, grouping) {
            const canvas = document.getElementById("parse-duration-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            if (window.parseDurationChart) {
                window.parseDurationChart.destroy();
            }

            // Get all timeline buckets to ensure charts share same x-axis (universal alignment)
            const timeBuckets = getTimelineBucketsFromRequests(requests, grouping);
            
            const timeGroups = {};
            const buckets = ["1-333¬µs", "333-666¬µs", "666¬µs-1ms", "1-1.3ms", "1.3-1.6ms", "1.6-2ms", "2-10ms", "10-100ms", "100-500ms", "500ms+"];
            const bucketColors = {
                "1-333¬µs": "rgba(144, 238, 144, 0.7)",      // Light green
                "333-666¬µs": "rgba(255, 223, 0, 0.7)",      // Yellow
                "666¬µs-1ms": "rgba(255, 165, 0, 0.7)",      // Orange
                "1-1.3ms": "rgba(255, 140, 0, 0.7)",        // Dark orange
                "1.3-1.6ms": "rgba(255, 99, 71, 0.7)",      // Tomato
                "1.6-2ms": "rgba(255, 69, 0, 0.7)",         // Orange red
                "2-10ms": "rgba(220, 20, 60, 0.7)",         // Crimson
                "10-100ms": "rgba(178, 34, 34, 0.7)",       // Firebrick
                "100-500ms": "rgba(139, 0, 0, 0.7)",        // Dark red
                "500ms+": "rgba(0, 0, 0, 0.8)"              // Black
            };

            // Initialize all time buckets with zero counts
            timeBuckets.forEach(ts => {
                const key = ts.toISOString();
                timeGroups[key] = { timestamp: ts };
                buckets.forEach(b => timeGroups[key][b] = 0);
            });

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                const parseDurationMs = request.phaseTimes?.parse ? parseTime(request.phaseTimes.parse) : 0;
                
                if (parseDurationMs > 0.001 && parseDurationMs <= 0.333) timeGroups[key]["1-333¬µs"]++;
                else if (parseDurationMs > 0.333 && parseDurationMs <= 0.666) timeGroups[key]["333-666¬µs"]++;
                else if (parseDurationMs > 0.666 && parseDurationMs <= 1.0) timeGroups[key]["666¬µs-1ms"]++;
                else if (parseDurationMs > 1.0 && parseDurationMs <= 1.3) timeGroups[key]["1-1.3ms"]++;
                else if (parseDurationMs > 1.3 && parseDurationMs <= 1.6) timeGroups[key]["1.3-1.6ms"]++;
                else if (parseDurationMs > 1.6 && parseDurationMs <= 2.0) timeGroups[key]["1.6-2ms"]++;
                else if (parseDurationMs > 2.0 && parseDurationMs <= 10.0) timeGroups[key]["2-10ms"]++;
                else if (parseDurationMs > 10.0 && parseDurationMs <= 100.0) timeGroups[key]["10-100ms"]++;
                else if (parseDurationMs > 100.0 && parseDurationMs <= 500.0) timeGroups[key]["100-500ms"]++;
                else if (parseDurationMs > 500.0) timeGroups[key]["500ms+"]++;
            });

            const sortedGroups = timeBuckets.map(ts => timeGroups[ts.toISOString()]);

            const datasets = buckets.map((bucket) => {
                const data = [];
                const maxCount = Math.max(...sortedGroups.map(g => g[bucket] || 0));
                const minRadius = 3;
                const maxRadius = 15;

                sortedGroups.forEach((group) => {
                    const count = group[bucket] || 0;
                    if (count > 0) {
                        const circleSize = minRadius + ((count / (maxCount || 1)) * (maxRadius - minRadius));
                        
                        let yPosition = 0;
                        switch(bucket) {
                            case "1-333¬µs": yPosition = 0.5; break;
                            case "333-666¬µs": yPosition = 1.5; break;
                            case "666¬µs-1ms": yPosition = 2.5; break;
                            case "1-1.3ms": yPosition = 3.5; break;
                            case "1.3-1.6ms": yPosition = 4.5; break;
                            case "1.6-2ms": yPosition = 5.5; break;
                            case "2-10ms": yPosition = 6.5; break;
                            case "10-100ms": yPosition = 7.5; break;
                            case "100-500ms": yPosition = 8.5; break;
                            case "500ms+": yPosition = 9.5; break;
                        }

                        data.push({
                            x: group.timestamp,
                            y: yPosition,
                            r: circleSize,
                            count: count
                        });
                    }
                });

                return {
                    label: `${bucket} (${data.reduce((sum, point) => sum + point.count, 0)} total)`,
                    data: data,
                    backgroundColor: bucketColors[bucket],
                    borderColor: bucketColors[bucket],
                    borderWidth: 1
                };
            });

            window.parseDurationChart = new Chart(ctx, {
                type: "bubble",
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { 
                            display: true, 
                            text: "Parse Duration Distribution by Time Buckets (Bubble Size = Query Count)",
                            font: {
                                size: 12
                            }
                        },
                        subtitle: {
                            display: true,
                            text: "(Note: Prepared statements skip parse/plan phases)",
                            font: {
                                size: 10
                            }
                        },
                        legend: { display: true, position: "top" },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const bucket = context.dataset.label.split(" (")[0];
                                    return [
                                        `${bucket}`,
                                        `Count: ${dataPoint.count}`,
                                        `${new Date(dataPoint.x).toLocaleString()}`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: { x: { min: "original", max: "original" }, y: { min: "original", max: "original" } },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                }
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: { display: true, text: "Request Time" }
                        },
                        y: {
                            title: { display: true, text: "Duration Range" },
                            beginAtZero: true,
                            ticks: {
                                callback: function (value) {
                                    if (value === 0.5) return "1-333¬µs";
                                    if (value === 1.5) return "333-666¬µs";
                                    if (value === 2.5) return "666¬µs-1ms";
                                    if (value === 3.5) return "1-1.3ms";
                                    if (value === 4.5) return "1.3-1.6ms";
                                    if (value === 5.5) return "1.6-2ms";
                                    if (value === 6.5) return "2-10ms";
                                    if (value === 7.5) return "10-100ms";
                                    if (value === 8.5) return "100-500ms";
                                    if (value === 9.5) return "500ms+";
                                    return "";
                                }
                            }
                        }
                    },
                    interaction: { mode: "point", intersect: false }
                },
                plugins: [verticalLinePlugin, horizontalLinePlugin]
            });

            registerTimelineChart(window.parseDurationChart, ctx);
        }

        // Create Plan Duration Distribution Chart
        function createPlanDurationChart(requests, grouping) {
            const canvas = document.getElementById("plan-duration-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            if (window.planDurationChart) {
                window.planDurationChart.destroy();
            }

            // Get all timeline buckets to ensure charts share same x-axis (universal alignment)
            const timeBuckets = getTimelineBucketsFromRequests(requests, grouping);
            
            const timeGroups = {};
            const buckets = ["1-333¬µs", "333-666¬µs", "666¬µs-1ms", "1-1.3ms", "1.3-1.6ms", "1.6-2ms", "2-10ms", "10-100ms", "100-500ms", "500ms+"];
            const bucketColors = {
                "1-333¬µs": "rgba(144, 238, 144, 0.7)",      // Light green
                "333-666¬µs": "rgba(255, 223, 0, 0.7)",      // Yellow
                "666¬µs-1ms": "rgba(255, 165, 0, 0.7)",      // Orange
                "1-1.3ms": "rgba(255, 140, 0, 0.7)",        // Dark orange
                "1.3-1.6ms": "rgba(255, 99, 71, 0.7)",      // Tomato
                "1.6-2ms": "rgba(255, 69, 0, 0.7)",         // Orange red
                "2-10ms": "rgba(220, 20, 60, 0.7)",         // Crimson
                "10-100ms": "rgba(178, 34, 34, 0.7)",       // Firebrick
                "100-500ms": "rgba(139, 0, 0, 0.7)",        // Dark red
                "500ms+": "rgba(0, 0, 0, 0.8)"              // Black
            };

            // Initialize all time buckets with zero counts
            timeBuckets.forEach(ts => {
                const key = ts.toISOString();
                timeGroups[key] = { timestamp: ts };
                buckets.forEach(b => timeGroups[key][b] = 0);
            });

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                const planDurationMs = request.phaseTimes?.plan ? parseTime(request.phaseTimes.plan) : 0;
                
                if (planDurationMs > 0.001 && planDurationMs <= 0.333) timeGroups[key]["1-333¬µs"]++;
                else if (planDurationMs > 0.333 && planDurationMs <= 0.666) timeGroups[key]["333-666¬µs"]++;
                else if (planDurationMs > 0.666 && planDurationMs <= 1.0) timeGroups[key]["666¬µs-1ms"]++;
                else if (planDurationMs > 1.0 && planDurationMs <= 1.3) timeGroups[key]["1-1.3ms"]++;
                else if (planDurationMs > 1.3 && planDurationMs <= 1.6) timeGroups[key]["1.3-1.6ms"]++;
                else if (planDurationMs > 1.6 && planDurationMs <= 2.0) timeGroups[key]["1.6-2ms"]++;
                else if (planDurationMs > 2.0 && planDurationMs <= 10.0) timeGroups[key]["2-10ms"]++;
                else if (planDurationMs > 10.0 && planDurationMs <= 100.0) timeGroups[key]["10-100ms"]++;
                else if (planDurationMs > 100.0 && planDurationMs <= 500.0) timeGroups[key]["100-500ms"]++;
                else if (planDurationMs > 500.0) timeGroups[key]["500ms+"]++;
            });

            const sortedGroups = timeBuckets.map(ts => timeGroups[ts.toISOString()]);

            const datasets = buckets.map((bucket) => {
                const data = [];
                const maxCount = Math.max(...sortedGroups.map(g => g[bucket] || 0));
                const minRadius = 3;
                const maxRadius = 15;

                sortedGroups.forEach((group) => {
                    const count = group[bucket] || 0;
                    if (count > 0) {
                        const circleSize = minRadius + ((count / (maxCount || 1)) * (maxRadius - minRadius));
                        
                        let yPosition = 0;
                        switch(bucket) {
                            case "1-333¬µs": yPosition = 0.5; break;
                            case "333-666¬µs": yPosition = 1.5; break;
                            case "666¬µs-1ms": yPosition = 2.5; break;
                            case "1-1.3ms": yPosition = 3.5; break;
                            case "1.3-1.6ms": yPosition = 4.5; break;
                            case "1.6-2ms": yPosition = 5.5; break;
                            case "2-10ms": yPosition = 6.5; break;
                            case "10-100ms": yPosition = 7.5; break;
                            case "100-500ms": yPosition = 8.5; break;
                            case "500ms+": yPosition = 9.5; break;
                        }

                        data.push({
                            x: group.timestamp,
                            y: yPosition,
                            r: circleSize,
                            count: count
                        });
                    }
                });

                return {
                    label: `${bucket} (${data.reduce((sum, point) => sum + point.count, 0)} total)`,
                    data: data,
                    backgroundColor: bucketColors[bucket],
                    borderColor: bucketColors[bucket],
                    borderWidth: 1
                };
            });

            window.planDurationChart = new Chart(ctx, {
                type: "bubble",
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { 
                            display: true, 
                            text: "Plan Duration Distribution by Time Buckets",
                            font: {
                                size: 12
                            }
                        },
                        subtitle: {
                            display: true,
                            text: "(Note: Prepared statements skip parse/plan phases)",
                            font: {
                                size: 10
                            }
                        },
                        legend: { display: true, position: "top" },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const bucket = context.dataset.label.split(" (")[0];
                                    return [
                                        `${bucket}`,
                                        `Count: ${dataPoint.count}`,
                                        `${new Date(dataPoint.x).toLocaleString()}`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: { x: { min: "original", max: "original" }, y: { min: "original", max: "original" } },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                }
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: { display: true, text: "Request Time" }
                        },
                        y: {
                            title: { display: true, text: "Duration Range" },
                            beginAtZero: true,
                            ticks: {
                                callback: function (value) {
                                    if (value === 0.5) return "1-333¬µs";
                                    if (value === 1.5) return "333-666¬µs";
                                    if (value === 2.5) return "666¬µs-1ms";
                                    if (value === 3.5) return "1-1.3ms";
                                    if (value === 4.5) return "1.3-1.6ms";
                                    if (value === 5.5) return "1.6-2ms";
                                    if (value === 6.5) return "2-10ms";
                                    if (value === 7.5) return "10-100ms";
                                    if (value === 8.5) return "100-500ms";
                                    if (value === 9.5) return "500ms+";
                                    return "";
                                }
                            }
                        }
                    },
                    interaction: { mode: "point", intersect: false }
                },
                plugins: [verticalLinePlugin, horizontalLinePlugin]
            });

            registerTimelineChart(window.planDurationChart, ctx);
        }

        // Create Result Count Chart (light green bar + orange line for resultCount/query)
        function createResultCountChart(requests, grouping) {
            const canvas = document.getElementById("result-count-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.resultCountChart) {
                window.resultCountChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalResultCount: 0,
                        queryCount: 0,
                    };
                }

                const resultCount = request.resultCount || 0;
                timeGroups[key].totalResultCount += resultCount;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const resultCountData = sortedData.map((item) => item.totalResultCount);
            const avgResultCountData = sortedData.map((item) =>
                item.queryCount > 0 ? item.totalResultCount / item.queryCount : 0
            );

            window.resultCountChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Total Result Count",
                            data: resultCountData,
                            backgroundColor: "rgba(144, 238, 144, 0.8)", // Light green
                            borderColor: "rgba(144, 238, 144, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Result Count per Query",
                            data: avgResultCountData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            yAxisID: "y1",
                            order: 1,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Result Count Analysis: Total vs Average per Query",
                            font: {
                                size: 12
                            }
                        },
                        legend: {
                            display: true,
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = Math.round(context.parsed.y).toLocaleString();
                                    return `${label}: ${value}`;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [`Queries: ${data.queryCount.toLocaleString()}`];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Total Result Count",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.resultCountChart, ctx);
        }

        // Create Result Size Chart (dark green bar + orange line for resultSize/query)
        function createResultSizeChart(requests, grouping) {
            const canvas = document.getElementById("result-size-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.resultSizeChart) {
                window.resultSizeChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalResultSize: 0,
                        queryCount: 0,
                    };
                }

                const resultSize = request.resultSize || 0;
                timeGroups[key].totalResultSize += resultSize;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data (convert bytes to MB)
            const labels = sortedData.map((item) => item.timestamp);
            const resultSizeData = sortedData.map((item) => item.totalResultSize / (1024 * 1024));
            const avgResultSizeData = sortedData.map((item) =>
                item.queryCount > 0 ? (item.totalResultSize / item.queryCount) / (1024 * 1024) : 0
            );

            window.resultSizeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Total Result Size (MB)",
                            data: resultSizeData,
                            backgroundColor: "rgba(0, 100, 0, 0.8)", // Dark green
                            borderColor: "rgba(0, 100, 0, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Result Size per Query (MB)",
                            data: avgResultSizeData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            yAxisID: "y1",
                            order: 1,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Result Size Analysis: Total vs Average per Query",
                            font: {
                                size: 12
                            }
                        },
                        legend: {
                            display: true,
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    return `${label}: ${value.toLocaleString('en-US', {minimumFractionDigits: 3, maximumFractionDigits: 3})}`;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [`Queries: ${data.queryCount.toLocaleString()}`];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Total Result Size (MB)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query (MB)",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.resultSizeChart, ctx);
        }

        // Create ECharts 3D Avg Doc Size Data
        function createECharts3DAvgDocSize(requests, grouping) {
            if (!requests || requests.length === 0) {
                Logger.debug(TEXT_CONSTANTS.NO_DATA_AVAILABLE || "No data available");
                return;
            }

            // Define result size buckets (in bytes) - MUST match 2D chart exactly
            const resultSizeBucketDefinitions = [
                { label: "0 bytes", min: 0, max: 0, value: 0, color: "rgba(128, 128, 128, 0.7)" },                   // Gray
                { label: "1-10 bytes", min: 1, max: 10, value: 1, color: "rgba(255, 0, 255, 0.7)" },                 // Magenta
                { label: "10-100 bytes", min: 10, max: 100, value: 2, color: "rgba(128, 0, 255, 0.7)" },             // Purple
                { label: "100-1K bytes", min: 100, max: 1000, value: 3, color: "rgba(0, 0, 200, 0.7)" },             // Dark Blue
                { label: "1K-10K bytes", min: 1000, max: 10000, value: 4, color: "rgba(0, 200, 255, 0.7)" },         // Cyan
                { label: "10K-100K bytes", min: 10000, max: 100000, value: 5, color: "rgba(0, 180, 0, 0.7)" },       // Green
                { label: "100K-1MB", min: 100000, max: 1000000, value: 6, color: "rgba(150, 200, 0, 0.7)" },         // Yellow-Green
                { label: "1MB-5MB", min: 1000000, max: 5000000, value: 7, color: "rgba(255, 220, 0, 0.7)" },         // Bright Yellow
                { label: "5MB-10MB", min: 5000000, max: 10000000, value: 8, color: "rgba(255, 150, 0, 0.7)" },       // Orange
                { label: "10MB-15MB", min: 10000000, max: 15000000, value: 9, color: "rgba(255, 80, 0, 0.7)" },      // Red-Orange
                { label: "15MB-20MB", min: 15000000, max: 20000000, value: 10, color: "rgba(220, 0, 0, 0.7)" }       // Red
            ];

            // Extract colors array
            const resultSizeColors = resultSizeBucketDefinitions.map(b => b.color);

            // Get result size bucket index from avg doc size in bytes
            function getResultSizeBucketIndex(avgDocSizeBytes) {
                if (avgDocSizeBytes === 0) return 0;
                else if (avgDocSizeBytes < 10) return 1;
                else if (avgDocSizeBytes < 100) return 2;
                else if (avgDocSizeBytes < 1000) return 3;
                else if (avgDocSizeBytes < 10000) return 4;
                else if (avgDocSizeBytes < 100000) return 5;
                else if (avgDocSizeBytes < 1000000) return 6;
                else if (avgDocSizeBytes < 5000000) return 7;
                else if (avgDocSizeBytes < 10000000) return 8;
                else if (avgDocSizeBytes < 15000000) return 9;
                else return 10; // 15MB-20MB
            }

            // Get all timeline buckets
            const timeBuckets = getTimelineBucketsFromRequests(requests, grouping);
            const timeGroups = {};

            // Initialize time buckets with collection -> size bucket -> count
            timeBuckets.forEach(ts => {
                timeGroups[ts.toISOString()] = {};
            });

            // Group queries by collection, time bucket, and result size bucket
            requests.forEach((request) => {
                const sql = request.statement || request.preparedText || "";
                const collections = extractCollectionsFromSQL(sql);
                
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                // Calculate average document size in bytes (same as 2D chart)
                const resultCount = request.resultCount || 0;
                const resultSize = request.resultSize || 0;
                
                if (resultCount === 0 || resultSize === 0) return;
                
                const avgDocSize = resultSize / resultCount;
                const sizeBucketIdx = getResultSizeBucketIndex(avgDocSize);

                collections.forEach(collection => {
                    if (!timeGroups[key][collection]) {
                        timeGroups[key][collection] = {};
                    }
                    if (!timeGroups[key][collection][sizeBucketIdx]) {
                        timeGroups[key][collection][sizeBucketIdx] = 0;
                    }
                    timeGroups[key][collection][sizeBucketIdx]++;
                });
            });

            // Get all unique collections and count total queries per collection
            const collectionQueryCounts = {};
            Object.values(timeGroups).forEach(group => {
                Object.entries(group).forEach(([collection, sizeBuckets]) => {
                    if (!collectionQueryCounts[collection]) {
                        collectionQueryCounts[collection] = 0;
                    }
                    Object.values(sizeBuckets).forEach(count => {
                        collectionQueryCounts[collection] += count;
                    });
                });
            });

            // Sort collections by query count (ascending) - fewest queries in front, most in back
            const allCollections = Object.keys(collectionQueryCounts).sort((a, b) => {
                return collectionQueryCounts[a] - collectionQueryCounts[b];
            });

            // Create a mapping of collection to index for y-axis (sorted by query count)
            const collectionToIndex = {};
            allCollections.forEach((collection, idx) => {
                collectionToIndex[collection] = idx;
            });

            // Build data points for ECharts scatter3D
            const data = [];
            timeBuckets.forEach((ts, timeIndex) => {
                const key = ts.toISOString();
                Object.entries(timeGroups[key]).forEach(([collection, sizeBuckets]) => {
                    Object.entries(sizeBuckets).forEach(([bucketIdx, count]) => {
                        if (count > 0) {
                            const formattedTime = ts.toLocaleString('en-US', { 
                                month: 'short', 
                                day: 'numeric', 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            });
                            const bucketLabel = resultSizeBucketDefinitions[parseInt(bucketIdx)].label;
                            
                            data.push({
                                value: [timeIndex, collectionToIndex[collection], parseInt(bucketIdx)],
                                itemStyle: { color: resultSizeColors[parseInt(bucketIdx)] },
                                actualCount: count,
                                collection: collection,
                                time: formattedTime,
                                sizeRange: bucketLabel
                            });
                        }
                    });
                });
            });

            // Store data globally for fullscreen
            window.echartsAvgDocSizeData = {
                data,
                timeBuckets,
                allCollections,
                resultSizeBucketDefinitions,
                resultSizeColors,
                collectionQueryCounts
            };

            Logger.info(`‚úÖ ECharts 3D Avg Doc Size data prepared: ${data.length} data points, ${allCollections.length} collections`);
        }

        // Expand ECharts 3D Avg Doc Size to fullscreen
        function expandECharts3DAvgDocSize() {
            const { data, timeBuckets, allCollections, resultSizeBucketDefinitions, resultSizeColors, collectionQueryCounts } = window.echartsAvgDocSizeData;
            if (!data || !allCollections) return;

            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'chart-fullscreen-overlay active';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center;';

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'width: 95%; height: 95%; background: white; border-radius: 8px; padding: 20px; position: relative;';

            // Create close button
            const closeBtn = document.createElement('div');
            closeBtn.className = 'chart-collapse-btn';
            closeBtn.title = 'Collapse chart';
            closeBtn.innerHTML = '‚úï';
            closeBtn.onclick = () => {
                document.body.removeChild(overlay);
                document.body.style.overflow = '';
            };

            // Create fullscreen chart container
            const fullscreenChartDiv = document.createElement('div');
            fullscreenChartDiv.id = 'echarts-3d-avg-doc-size-fullscreen';
            fullscreenChartDiv.style.cssText = 'width: calc(100% - 420px); height: 100%;';

            // Create controls and legend container
            const controlsContainer = document.createElement('div');
            controlsContainer.style.cssText = 'position: absolute; top: 50px; right: 20px; width: 400px; background: white; border: 1px solid #444; border-radius: 4px; padding: 10px; max-height: calc(100% - 60px); overflow-y: auto;';

            // Add toggle controls
            const togglesDiv = document.createElement('div');
            togglesDiv.style.cssText = 'margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ddd;';
            togglesDiv.innerHTML = `
                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; font-weight: bold;">
                        <input type="checkbox" id="echarts-avg-doc-size-log-scale-toggle" style="margin-right: 8px;">
                        Log Scale Z-Axis (Avg Doc Size)
                    </label>
                </div>
            `;
            controlsContainer.appendChild(togglesDiv);

            // Add Document Size Range Legend Section
            const sizeLegendHeader = document.createElement('div');
            sizeLegendHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
            sizeLegendHeader.innerHTML = `
                <strong style="font-size: 14px;">Document Sizes:</strong>
                <div>
                    <button id="echarts-avg-doc-size-fs-show-all-sizes" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 11px;">Show All</button>
                    <button id="echarts-avg-doc-size-fs-hide-all-sizes" style="padding: 4px 12px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Hide All</button>
                </div>
            `;
            controlsContainer.appendChild(sizeLegendHeader);

            // Calculate counts for each size range
            const sizeRangeCounts = {};
            resultSizeBucketDefinitions.forEach((bin, idx) => {
                sizeRangeCounts[bin.label] = data.filter(d => d.value[2] === idx).reduce((sum, d) => sum + d.actualCount, 0);
            });

            const sizeVisibilityState = {};

            // Create size range legend items grid
            const sizeItemsGrid = document.createElement('div');
            sizeItemsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr; gap: 6px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ddd;';
            sizeItemsGrid.id = 'echarts-avg-doc-size-size-legend-items-grid';

            resultSizeBucketDefinitions.forEach((bin, idx) => {
                const count = sizeRangeCounts[bin.label];
                sizeVisibilityState[idx] = true;
                
                const legendItem = document.createElement('div');
                legendItem.style.cssText = 'display: flex; align-items: center; padding: 5px; cursor: pointer; border-radius: 3px; margin-bottom: 2px; border: 1px solid #e0e0e0;';
                legendItem.dataset.sizeIndex = idx;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                
                const colorBox = document.createElement('span');
                colorBox.style.cssText = `display: inline-block; width: 16px; height: 16px; background: ${resultSizeColors[idx]}; margin-right: 8px; border: 1px solid #333; border-radius: 2px;`;
                
                const label = document.createElement('span');
                label.style.cssText = 'font-size: 12px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                label.textContent = `${bin.label} (${count} total)`;
                
                legendItem.appendChild(checkbox);
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                
                legendItem.onclick = (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                    sizeVisibilityState[idx] = checkbox.checked;
                    legendItem.style.opacity = checkbox.checked ? '1' : '0.3';
                    updateChart();
                };
                
                sizeItemsGrid.appendChild(legendItem);
            });

            controlsContainer.appendChild(sizeItemsGrid);

            // Add legend header
            const legendHeader = document.createElement('div');
            legendHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
            legendHeader.innerHTML = `
                <strong style="font-size: 14px;">Collections:</strong>
                <div>
                    <button id="echarts-avg-doc-size-fs-show-all" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 11px;">Show All</button>
                    <button id="echarts-avg-doc-size-fs-hide-all" style="padding: 4px 12px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Hide All</button>
                </div>
            `;
            controlsContainer.appendChild(legendHeader);

            // Add search input
            const searchContainer = document.createElement('div');
            searchContainer.style.cssText = 'margin-bottom: 10px;';
            searchContainer.innerHTML = `
                <input type="text" id="echarts-avg-doc-size-legend-search" placeholder="Search collections..." style="width: 100%; font-size: 11px; padding: 6px 8px; border: 1px solid #dee2e6; border-radius: 3px; box-sizing: border-box;">
            `;
            controlsContainer.appendChild(searchContainer);

            // Create legend items grid
            const itemsGrid = document.createElement('div');
            itemsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr; gap: 6px;';
            itemsGrid.id = 'echarts-avg-doc-size-legend-items-grid';
            
            // Sort collections by count (descending) for legend display
            const sortedCollections = [...allCollections].sort((a, b) => {
                return collectionQueryCounts[b] - collectionQueryCounts[a];
            });

            const visibilityState = {};
            sortedCollections.forEach(collection => {
                visibilityState[collection] = true;
            });

            sortedCollections.forEach(collection => {
                const count = collectionQueryCounts[collection];
                const legendItem = document.createElement('div');
                legendItem.style.cssText = 'display: flex; align-items: center; padding: 5px; cursor: pointer; border-radius: 3px; margin-bottom: 2px; border: 1px solid #e0e0e0;';
                legendItem.dataset.collection = collection;
                
                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 8px; cursor: pointer;';
                
                // Collection name with count
                const label = document.createElement('span');
                label.style.cssText = 'font-size: 12px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
                label.textContent = `[${count}] ${collection}`;
                
                legendItem.appendChild(checkbox);
                legendItem.appendChild(label);
                
                // Toggle visibility on click
                legendItem.onclick = (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                    visibilityState[collection] = checkbox.checked;
                    legendItem.style.opacity = checkbox.checked ? '1' : '0.3';
                    updateChart();
                };
                
                itemsGrid.appendChild(legendItem);
            });

            controlsContainer.appendChild(itemsGrid);

            // Assemble modal
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(fullscreenChartDiv);
            modalContent.appendChild(controlsContainer);
            overlay.appendChild(modalContent);
            document.body.appendChild(overlay);
            document.body.style.overflow = 'hidden';
            
            // Sync Y-axis scale from radio buttons to 3D chart checkbox (after DOM insertion)
            const selectedScale = document.querySelector('input[name="yScale"]:checked');
            const logScaleCheckbox = document.getElementById('echarts-avg-doc-size-log-scale-toggle');
            if (selectedScale && logScaleCheckbox) {
                logScaleCheckbox.checked = selectedScale.value === 'logarithmic';
                Logger.debug('3D Avg Doc Size - Set checkbox to:', selectedScale.value === 'logarithmic');
            }

            // Calculate bubble sizes using same method as 2D chart
            function calculateBubbleSize(count) {
                if (count === 0) return 0;
                // Logarithmic scale: log10(count + 1) * 8 (same as 2D chart)
                return Math.log10(count + 1) * 8;
            }

            function prepareChartData(useLogScale) {
                return data.map(d => {
                    const sizeIdx = d.value[2];
                    if (!visibilityState[d.collection] || !sizeVisibilityState[sizeIdx]) return null;
                    
                    // Use same bubble sizing as 2D chart
                    const bubbleSize = calculateBubbleSize(d.actualCount);
                    
                    // For log scale, map bucket index to log10 scale
                    let zValue = d.value[2]; // Original bucket index
                    if (useLogScale) {
                        // Convert bucket index to actual bytes value for log scale
                        const bucketDef = resultSizeBucketDefinitions[d.value[2]];
                        const avgBytes = bucketDef.max === 0 ? 0 : (bucketDef.min + Math.min(bucketDef.max, 20000000)) / 2; // Use midpoint
                        zValue = avgBytes === 0 ? 0 : Math.log10(avgBytes);
                    }
                    
                    return {
                        value: [d.value[0], d.value[1], zValue],
                        itemStyle: d.itemStyle,
                        actualCount: d.actualCount,
                        collection: d.collection,
                        time: d.time,
                        sizeRange: d.sizeRange,
                        symbolSize: bubbleSize
                    };
                }).filter(d => d !== null);
            }

            // Initialize fullscreen chart
            const myChart = echarts.init(fullscreenChartDiv);
            
            function updateChart() {
                const useLogScale = document.getElementById('echarts-avg-doc-size-log-scale-toggle')?.checked || false;
                const chartData = prepareChartData(useLogScale);
                
                const option = {
                    title: {
                        text: "Query's Avg Returned Document Size By Collection",
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        formatter: function(params) {
                            const d = params.data;
                            return `${d.collection}<br/>Time: ${d.time}<br/>Size Range: ${d.sizeRange}<br/>Queries: ${d.actualCount}`;
                        }
                    },
                    xAxis3D: {
                        type: 'category',
                        data: timeBuckets.map((ts, idx) => idx),
                        name: 'Request Time',
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            interval: Math.max(0, Math.ceil(timeBuckets.length / 10) - 1),
                            formatter: function(value) {
                                return timeBuckets[value].toLocaleString('en-US', { month: 'short', day: 'numeric' });
                            },
                            fontSize: 10
                        }
                    },
                    yAxis3D: {
                        type: 'category',
                        data: allCollections,
                        name: 'Collection',
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            interval: Math.max(0, Math.ceil(allCollections.length / 10) - 1),
                            fontSize: 10
                        }
                    },
                    zAxis3D: {
                        type: useLogScale ? 'value' : 'category',
                        data: useLogScale ? null : resultSizeBucketDefinitions.map(b => b.label),
                        name: useLogScale ? 'Avg Doc Size (bytes) - Log Scale' : 'Avg Doc Size Range',
                        nameTextStyle: {
                            fontSize: 14,
                            fontWeight: 'bold'
                        },
                        min: useLogScale ? 0 : undefined,
                        axisLabel: {
                            formatter: useLogScale ? function(value) {
                                // Convert log value back to bytes for display
                                const bytes = Math.pow(10, value);
                                if (bytes < 1000) return bytes.toFixed(0);
                                else if (bytes < 1000000) return (bytes/1000).toFixed(0) + 'K';
                                else return (bytes/1000000).toFixed(0) + 'M';
                            } : undefined
                        }
                    },
                    grid3D: {
                        boxWidth: 250,
                        boxDepth: Math.min(250, allCollections.length * 7),
                        boxHeight: 150,
                        viewControl: {
                            alpha: 22.9,
                            beta: 44.6,
                            distance: 453.0,
                            minDistance: 100,
                            maxDistance: 600
                        },
                        light: {
                            main: {
                                intensity: 1.2,
                                shadow: true
                            },
                            ambient: {
                                intensity: 0.5
                            }
                        }
                    },
                    series: [{
                        type: 'scatter3D',
                        data: chartData,
                        symbolSize: function(dataItem) {
                            return dataItem.symbolSize;
                        },
                        itemStyle: {
                            opacity: 0.85
                        },
                        emphasis: {
                            itemStyle: {
                                opacity: 1
                            }
                        }
                    }]
                };

                myChart.setOption(option);
            }

            // Initial render
            updateChart();

            // Add camera debug display
            addCameraDebugDisplay(myChart, fullscreenChartDiv, closeBtn, 'avg-doc-size');

            // Document Size Range Show/Hide All handlers
            document.getElementById('echarts-avg-doc-size-fs-show-all-sizes').addEventListener('click', () => {
                Object.keys(sizeVisibilityState).forEach(key => {
                    sizeVisibilityState[key] = true;
                    const item = sizeItemsGrid.querySelector(`[data-size-index="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = true;
                        item.style.opacity = '1';
                    }
                });
                updateChart();
            });

            document.getElementById('echarts-avg-doc-size-fs-hide-all-sizes').addEventListener('click', () => {
                Object.keys(sizeVisibilityState).forEach(key => {
                    sizeVisibilityState[key] = false;
                    const item = sizeItemsGrid.querySelector(`[data-size-index="${key}"]`);
                    if (item) {
                        item.querySelector('input').checked = false;
                        item.style.opacity = '0.3';
                    }
                });
                updateChart();
            });

            // Collection Show All button functionality
            document.getElementById('echarts-avg-doc-size-fs-show-all').addEventListener('click', () => {
                sortedCollections.forEach(collection => {
                    visibilityState[collection] = true;
                    const item = itemsGrid.querySelector(`[data-collection="${CSS.escape(collection)}"]`);
                    if (item) {
                        item.querySelector('input').checked = true;
                        item.style.opacity = '1';
                    }
                });
                updateChart();
            });

            // Hide All button functionality
            document.getElementById('echarts-avg-doc-size-fs-hide-all').addEventListener('click', () => {
                sortedCollections.forEach(collection => {
                    visibilityState[collection] = false;
                    const item = itemsGrid.querySelector(`[data-collection="${CSS.escape(collection)}"]`);
                    if (item) {
                        item.querySelector('input').checked = false;
                        item.style.opacity = '0.3';
                    }
                });
                updateChart();
            });

            // Log Scale checkbox functionality
            document.getElementById('echarts-avg-doc-size-log-scale-toggle').addEventListener('change', updateChart);

            // Search input filtering
            document.getElementById('echarts-avg-doc-size-legend-search').addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                sortedCollections.forEach(collection => {
                    const item = itemsGrid.querySelector(`[data-collection="${CSS.escape(collection)}"]`);
                    if (item) {
                        const matches = collection.toLowerCase().includes(searchTerm);
                        item.style.display = matches ? 'flex' : 'none';
                    }
                });
            });

            // Window resize handler
            window.addEventListener('resize', () => myChart.resize());
        }

        // Create CPU/Kernel/Elapsed Time Analysis Chart
        function createCpuTimeChart(requests, grouping) {
            const canvas = document.getElementById("cpu-time-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.cpuTimeChart) {
                window.cpuTimeChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        cpuTimeSum: 0,
                        elapsedTimeSum: 0,
                        kernTimeSum: 0,
                        queryCount: 0,
                    };
                }

                // Parse time values - handle both string and number formats
                const cpuTimeMs = parseTime(request.cpuTime) || 0;
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;

                timeGroups[key].cpuTimeSum += cpuTimeMs;
                timeGroups[key].elapsedTimeSum += elapsedTimeMs;
                timeGroups[key].kernTimeSum += kernTimeMs;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array and calculate averages
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgCpuTime: item.queryCount > 0 ? item.cpuTimeSum / item.queryCount : 0,
                    avgElapsedTime: item.queryCount > 0 ? item.elapsedTimeSum / item.queryCount : 0,
                    avgKernTime: item.queryCount > 0 ? item.kernTimeSum / item.queryCount : 0,
                }));

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const avgCpuTimeData = sortedData.map((item) => item.avgCpuTime);
            const avgKernTimeData = sortedData.map((item) => item.avgKernTime);
            const avgElapsedTimeData = sortedData.map((item) => item.avgElapsedTime);

            // Calculate percentage data for line graphs
            const cpuKernPercentData = sortedData.map((item) => {
                return item.avgKernTime > 0 ? (item.avgCpuTime / item.avgKernTime) * 100 : 0;
            });

            const cpuElapsedPercentData = sortedData.map((item) => {
                return item.avgElapsedTime > 0 ? (item.avgCpuTime / item.avgElapsedTime) * 100 : 0;
            });

            window.cpuTimeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "CPU as % of Elapsed (dotted)",
                            data: cpuElapsedPercentData,
                            type: "line",
                            backgroundColor: "rgba(0, 128, 128, 0.8)", // Dark Teal
                            borderColor: "rgba(0, 128, 128, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5], // Dotted line
                            fill: false,
                            spanGaps: false,
                            yAxisID: "y1",
                            order: 5,
                            tension: 0.3,
                        },
                        {
                            label: "CPU as % of Kernel",
                            data: cpuKernPercentData,
                            type: "line",
                            backgroundColor: "rgba(139, 0, 0, 0.8)", // Dark Red
                            borderColor: "rgba(139, 0, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            yAxisID: "y1",
                            order: 4,
                            tension: 0.3,
                        },
                        {
                            label: "Avg Elapsed Time (ms)",
                            data: avgElapsedTimeData,
                            backgroundColor: "rgba(75, 192, 192, 0.8)", // Teal
                            borderColor: "rgba(75, 192, 192, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 3,
                        },
                        {
                            label: "Avg Kernel Time (ms)",
                            data: avgKernTimeData,
                            backgroundColor: "rgba(255, 99, 132, 0.8)", // Red
                            borderColor: "rgba(255, 99, 132, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg CPU Time (ms)",
                            data: avgCpuTimeData,
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "CPU/Kernel/Elapsed Time Analysis",
                            font: {
                            size: 12
                            }
                        },
                        legend: {
                            display: true,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    
                                    if (label.includes('Avg CPU Time')) {
                                        return `Avg CPU (ms): ${Math.round(value).toLocaleString()}`;
                                    }
                                    if (label.includes('Avg Kernel Time')) {
                                        return `Avg Kernel (ms): ${Math.round(value).toLocaleString()}`;
                                    }
                                    if (label.includes('Avg Elapsed Time')) {
                                        return `Avg Elapsed (ms): ${Math.round(value).toLocaleString()}`;
                                    }
                                    if (label.includes('CPU as % of Kernel')) {
                                        return `CPU % of Kernel: ${Math.round(value).toLocaleString()}%`;
                                    }
                                    if (label.includes('CPU as % of Elapsed')) {
                                        return `CPU % of Elapsed: ${Math.round(value).toLocaleString()}%`;
                                    }
                                    return `${label}: ${Math.round(value).toLocaleString()}`;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [
                                        `Queries: ${data.queryCount.toLocaleString()}`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Time (ms)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Percentage (%)",
                            },
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 100, // Always show 0-100% range, scale higher if needed
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.cpuTimeChart, ctx);
        }

        // Create Index Scan Throughput Chart with Average Count on 2nd Y-axis
        function createIndexScanThroughputChart(requests, grouping) {
            const canvas = document.getElementById("index-scan-throughput-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.indexScanThroughputChart) {
                window.indexScanThroughputChart.destroy();
            }

            // Group requests by time and collect throughput data (records/ms) for Index Scan operations
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        scanThroughputs: [],   // records/ms
                        scanItemCounts: [],    // item counts for average
                    };
                }

                // Extract servTime and item counts from plan operators
                if (request.plan) {
                    try {
                        const plan = typeof request.plan === 'string' ? JSON.parse(request.plan) : request.plan;
                        
                        // Recursive function to find Index Scan operators
                        const extractOperatorThroughput = (node) => {
                            if (!node) return;
                            
                            const operator = node['#operator'] || node.operator;
                            const stats = node['#stats'] || node.stats || {};
                            const servTime = stats.servTime;
                            const itemsIn = stats['#itemsIn'] || stats.itemsIn || 0;
                            
                            // Check for Index Scan operators - use itemsIn / servTime
                            if ((operator && (operator.includes('Scan') || operator.includes('scan'))) && servTime) {
                                const servTimeMs = parseTime(servTime);
                                if (!isNaN(servTimeMs) && servTimeMs > 0 && itemsIn > 0) {
                                    const throughput = itemsIn / servTimeMs; // records per ms
                                    timeGroups[key].scanThroughputs.push(throughput);
                                    timeGroups[key].scanItemCounts.push(itemsIn); // Track item count
                                }
                            }
                            
                            // Recursively search child nodes
                            if (node['~child']) extractOperatorThroughput(node['~child']);
                            if (node['~children']) {
                                node['~children'].forEach(child => extractOperatorThroughput(child));
                            }
                        };
                        
                        extractOperatorThroughput(plan);
                    } catch (e) {
                        // Skip parsing errors
                    }
                }
            });

            // Get all timeline buckets to ensure charts share same x-axis (Issue #148)
            const buckets = getTimelineBucketsFromRequests(requests, grouping);
            
            // Calculate percentiles and averages for each time bucket
            const sortedData = buckets.map(ts => {
                const key = ts.toISOString();
                const group = timeGroups[key] || { scanThroughputs: [], scanItemCounts: [], timestamp: ts };
                
                // Sort arrays for percentile calculation
                const scanSorted = [...group.scanThroughputs].sort((a, b) => a - b);
                
                // Calculate percentiles (90th = top 10%, 50th = median, 10th = bottom 10%)
                const getPercentile = (arr, percentile) => {
                    if (arr.length === 0) return null;
                    const index = Math.ceil((percentile / 100) * arr.length) - 1;
                    return arr[Math.max(0, index)];
                };
                
                // Calculate average item count
                const avgItemCount = group.scanItemCounts.length > 0
                    ? group.scanItemCounts.reduce((sum, val) => sum + val, 0) / group.scanItemCounts.length
                    : null;
                
                return {
                    timestamp: ts,
                    // Index Scan percentiles (throughput in records/ms)
                    scanP90: getPercentile(scanSorted, 90),
                    scanP50: getPercentile(scanSorted, 50),
                    scanP10: getPercentile(scanSorted, 10),
                    scanCount: scanSorted.length,
                    avgItemCount: avgItemCount,
                };
            });

            if (sortedData.length === 0) {
                Logger.debug("No index scan throughput data found for chart");
                return;
            }

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);

            window.indexScanThroughputChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        // Index Scan throughput datasets (orange/yellow shades) - itemsIn/servTime
                        {
                            label: "Scan Throughput - top 10%",
                            data: sortedData.map((item) => item.scanP90),
                            borderColor: "rgba(255, 140, 0, 1)", // Dark orange
                            backgroundColor: "rgba(255, 140, 0, 0.1)",
                            borderWidth: 3,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            yAxisID: 'y',
                            hidden: true,
                        },
                        {
                            label: "Scan Throughput - middle",
                            data: sortedData.map((item) => item.scanP50),
                            borderColor: "rgba(255, 193, 7, 1)", // Medium orange/yellow
                            backgroundColor: "rgba(255, 193, 7, 0.1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            yAxisID: 'y',
                        },
                        {
                            label: "Scan Throughput - bottom 10%",
                            data: sortedData.map((item) => item.scanP10),
                            borderColor: "rgba(204, 102, 0, 1)", // Dark orange
                            backgroundColor: "rgba(204, 102, 0, 0.1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            yAxisID: 'y',
                            hidden: true,
                        },
                        // Average records scanned per query (2nd y-axis)
                        {
                            label: "Avg Records Scanned per Query",
                            data: sortedData.map((item) => item.avgItemCount),
                            borderColor: "rgba(0, 128, 0, 1)", // Dark Green
                            backgroundColor: "rgba(0, 128, 0, 0.1)",
                            borderWidth: 2,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3],
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointStyle: 'rect',
                            yAxisID: 'y1', // Second y-axis
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Index Scan Throughput (records/ms) & Avg Records Scanned per Query",
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    if (label.includes('Avg Records Scanned')) {
                                        return `Avg / Query: ${Math.round(value).toLocaleString()} records`;
                                    }
                                    if (label.includes('top 10%')) {
                                        return `top 10%: ${Math.round(value).toLocaleString()}/ms`;
                                    }
                                    if (label.includes('middle')) {
                                        return `middle: ${Math.round(value).toLocaleString()}/ms`;
                                    }
                                    if (label.includes('bottom 10%')) {
                                        return `bottom 10%: ${Math.round(value).toLocaleString()}/ms`;
                                    }
                                    return value !== null ? `${label}: ${Math.round(value).toLocaleString()}/ms` : label;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [`Queries: ${data.scanCount.toLocaleString()}`];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Throughput (records/ms)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg Records Scanned per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [
                    verticalLinePlugin,
                    {
                        id: 'indexScanThresholdLine',
                        afterDatasetsDraw(chart) {
                            const { ctx, chartArea: { left, right }, scales: { y } } = chart;
                            
                            if (!y) return;
                            
                            // Draw threshold line at 50 records/ms
                            const yPosition = y.getPixelForValue(50);
                            
                            // Only draw if the line is within the chart area
                            if (yPosition < chart.chartArea.top || yPosition > chart.chartArea.bottom) {
                                return;
                            }
                            
                            ctx.save();
                            ctx.beginPath();
                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.moveTo(left, yPosition);
                            ctx.lineTo(right, yPosition);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Add label
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                            ctx.font = 'bold 11px Arial';
                            ctx.textAlign = 'right';
                            ctx.fillText('50/ms threshold', right - 5, yPosition - 5);
                            
                            ctx.restore();
                        }
                    }
                ]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.indexScanThroughputChart, ctx);
        }

        // Create Doc Fetch Throughput Chart with Average Count on 2nd Y-axis
        function createDocFetchThroughputChart(requests, grouping) {
            const canvas = document.getElementById("doc-fetch-throughput-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.docFetchThroughputChart) {
                window.docFetchThroughputChart.destroy();
            }

            // Group requests by time and collect throughput data (records/ms) for Doc Fetch operations
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        fetchThroughputs: [],   // records/ms
                        fetchItemCounts: [],    // item counts for average
                    };
                }

                // Extract servTime and item counts from plan operators
                if (request.plan) {
                    try {
                        const plan = typeof request.plan === 'string' ? JSON.parse(request.plan) : request.plan;
                        
                        // Recursive function to find Fetch operators
                        const extractOperatorThroughput = (node) => {
                            if (!node) return;
                            
                            const operator = node['#operator'] || node.operator;
                            const stats = node['#stats'] || node.stats || {};
                            const servTime = stats.servTime;
                            const itemsOut = stats['#itemsOut'] || stats.itemsOut || 0;
                            
                            // Check for Fetch operator - use itemsOut / servTime
                            if (operator === 'Fetch' && servTime) {
                                const servTimeMs = parseTime(servTime);
                                if (!isNaN(servTimeMs) && servTimeMs > 0 && itemsOut > 0) {
                                    const throughput = itemsOut / servTimeMs; // records per ms
                                    timeGroups[key].fetchThroughputs.push(throughput);
                                    timeGroups[key].fetchItemCounts.push(itemsOut); // Track item count
                                }
                            }
                            
                            // Recursively search child nodes
                            if (node['~child']) extractOperatorThroughput(node['~child']);
                            if (node['~children']) {
                                node['~children'].forEach(child => extractOperatorThroughput(child));
                            }
                        };
                        
                        extractOperatorThroughput(plan);
                    } catch (e) {
                        // Skip parsing errors
                    }
                }
            });

            // Get all timeline buckets to ensure charts share same x-axis (Issue #148)
            const buckets = getTimelineBucketsFromRequests(requests, grouping);
            
            // Calculate percentiles and averages for each time bucket
            const sortedData = buckets.map(ts => {
                const key = ts.toISOString();
                const group = timeGroups[key] || { fetchThroughputs: [], fetchItemCounts: [], timestamp: ts };
                
                // Sort arrays for percentile calculation
                const fetchSorted = [...group.fetchThroughputs].sort((a, b) => a - b);
                
                // Calculate percentiles (90th = top 10%, 50th = median, 10th = bottom 10%)
                const getPercentile = (arr, percentile) => {
                    if (arr.length === 0) return null;
                    const index = Math.ceil((percentile / 100) * arr.length) - 1;
                    return arr[Math.max(0, index)];
                };
                
                // Calculate average item count
                const avgItemCount = group.fetchItemCounts.length > 0
                    ? group.fetchItemCounts.reduce((sum, val) => sum + val, 0) / group.fetchItemCounts.length
                    : null;
                
                return {
                    timestamp: ts,
                    // Doc Fetch percentiles (throughput in records/ms)
                    fetchP90: getPercentile(fetchSorted, 90),
                    fetchP50: getPercentile(fetchSorted, 50),
                    fetchP10: getPercentile(fetchSorted, 10),
                    fetchCount: fetchSorted.length,
                    avgItemCount: avgItemCount,
                };
            });

            if (sortedData.length === 0) {
                Logger.debug("No doc fetch throughput data found for chart");
                return;
            }

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);

            window.docFetchThroughputChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        // Doc Fetch throughput datasets (purple shades) - itemsOut/servTime
                        {
                            label: "Fetch Throughput - top 10%",
                            data: sortedData.map((item) => item.fetchP90),
                            borderColor: "rgba(128, 0, 128, 1)", // Dark purple
                            backgroundColor: "rgba(128, 0, 128, 0.1)",
                            borderWidth: 3,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            yAxisID: 'y',
                            hidden: true,
                        },
                        {
                            label: "Fetch Throughput - middle",
                            data: sortedData.map((item) => item.fetchP50),
                            borderColor: "rgba(153, 102, 255, 1)", // Medium purple
                            backgroundColor: "rgba(153, 102, 255, 0.1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            yAxisID: 'y',
                        },
                        {
                            label: "Fetch Throughput - bottom 10%",
                            data: sortedData.map((item) => item.fetchP10),
                            borderColor: "rgba(102, 51, 153, 1)", // Medium-dark purple
                            backgroundColor: "rgba(102, 51, 153, 0.1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            yAxisID: 'y',
                            hidden: true,
                        },
                        // Average documents fetched per query (2nd y-axis)
                        {
                            label: "Avg Docs Fetched per Query",
                            data: sortedData.map((item) => item.avgItemCount),
                            borderColor: "rgba(0, 128, 0, 1)", // Dark Green
                            backgroundColor: "rgba(0, 128, 0, 0.1)",
                            borderWidth: 2,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3],
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointStyle: 'rect',
                            yAxisID: 'y1', // Second y-axis
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Doc Fetch Throughput (records/ms) & Avg Docs Fetched per Query",
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    if (label.includes('Avg Docs Fetched')) {
                                        return `Avg / Query: ${Math.round(value).toLocaleString()} docs`;
                                    }
                                    if (label.includes('top 10%')) {
                                        return `top 10%: ${Math.round(value).toLocaleString()}/ms`;
                                    }
                                    if (label.includes('middle')) {
                                        return `middle: ${Math.round(value).toLocaleString()}/ms`;
                                    }
                                    if (label.includes('bottom 10%')) {
                                        return `bottom 10%: ${Math.round(value).toLocaleString()}/ms`;
                                    }
                                    return value !== null ? `${label}: ${Math.round(value).toLocaleString()}/ms` : label;
                                },
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [`Queries: ${data.fetchCount.toLocaleString()}`];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Throughput (records/ms)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg Docs Fetched per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [
                    verticalLinePlugin,
                    {
                        id: 'docFetchThresholdLine',
                        afterDatasetsDraw(chart) {
                            const { ctx, chartArea: { left, right }, scales: { y } } = chart;
                            
                            if (!y) return;
                            
                            // Draw threshold line at 5 records/ms
                            const yPosition = y.getPixelForValue(5);
                            
                            // Only draw if the line is within the chart area
                            if (yPosition < chart.chartArea.top || yPosition > chart.chartArea.bottom) {
                                return;
                            }
                            
                            ctx.save();
                            ctx.beginPath();
                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.moveTo(left, yPosition);
                            ctx.lineTo(right, yPosition);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Add label
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                            ctx.font = 'bold 11px Arial';
                            ctx.textAlign = 'right';
                            ctx.fillText('5/ms threshold', right - 5, yPosition - 5);
                            
                            ctx.restore();
                        }
                    }
                ]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.docFetchThroughputChart, ctx);
        }

        // ===== 3D Service Time Analysis Chart (Issue #217) =====
        // Create 3D ribbon chart showing Service Time metrics by collection over time
        function createECharts3DServiceTime(requests, grouping) {
            if (!requests || requests.length === 0) {
                Logger.debug(TEXT_CONSTANTS.NO_DATA_AVAILABLE || "No data available");
                return;
            }

            Logger.info("Creating 3D Service Time data...");

            // Get all timeline buckets for consistent x-axis
            const timeBuckets = getTimelineBucketsFromRequests(requests, grouping);
            
            // Initialize data structures
            const collectionData = {}; // collection -> timeKey -> metrics

            // Process each request
            requests.forEach((request) => {
                const sql = request.statement || request.preparedText || "";
                const collections = extractCollectionsFromSQL(sql);
                
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                // Extract elapsed and kernel time
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                
                // Initialize auth/index/fetch service times
                let authServTimeMs = 0;
                let indexServTimeMs = 0;
                let fetchServTimeMs = 0;

                // Extract service times from operators
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const servTime = parseTime(stats.servTime) || 0;

                            if (servTime > 0) {
                                switch (operatorType) {
                                    case "Authorize":
                                        authServTimeMs += servTime;
                                        break;
                                    case "IndexScan3":
                                    case "PrimaryScan":
                                    case "PrimaryScan3":
                                        indexServTimeMs += servTime;
                                        break;
                                    case "Fetch":
                                        fetchServTimeMs += servTime;
                                        break;
                                }
                            }
                        });
                    } catch (e) {
                        Logger.debug("Error parsing plan for service time 3D:", e);
                    }
                }

                collections.forEach(collection => {
                    if (!collectionData[collection]) {
                        collectionData[collection] = {};
                    }
                    if (!collectionData[collection][key]) {
                        collectionData[collection][key] = {
                            elapsedSum: 0,
                            kernSum: 0,
                            authSum: 0,
                            indexSum: 0,
                            fetchSum: 0,
                            count: 0
                        };
                    }
                    
                    collectionData[collection][key].elapsedSum += elapsedTimeMs;
                    collectionData[collection][key].kernSum += kernTimeMs;
                    collectionData[collection][key].authSum += authServTimeMs;
                    collectionData[collection][key].indexSum += indexServTimeMs;
                    collectionData[collection][key].fetchSum += fetchServTimeMs;
                    collectionData[collection][key].count++;
                });
            });

            // Sort collections by total query count
            const collectionCounts = {};
            Object.keys(collectionData).forEach(collection => {
                collectionCounts[collection] = Object.values(collectionData[collection])
                    .reduce((sum, bucket) => sum + bucket.count, 0);
            });

            const sortedCollections = Object.keys(collectionData).sort((a, b) => {
                return collectionCounts[b] - collectionCounts[a];
            });

            // Prepare series data for each metric (5 ribbons)
            const metricsConfig = [
                { name: "Avg Elapsed Time", key: "elapsedSum", color: "rgba(75, 192, 192, 0.8)" },
                { name: "Avg Kernel Time", key: "kernSum", color: "rgba(255, 0, 0, 0.8)" },
                { name: "Authorize ServTime", key: "authSum", color: "rgba(54, 162, 235, 0.8)" },
                { name: "IndexScan ServTime", key: "indexSum", color: "rgba(255, 206, 86, 0.8)" },
                { name: "Fetch ServTime", key: "fetchSum", color: "rgba(153, 102, 255, 0.8)" }
            ];

            const seriesData = metricsConfig.map(metric => {
                const lineData = [];
                
                sortedCollections.forEach((collection, collIdx) => {
                    timeBuckets.forEach((timestamp) => {
                        const key = timestamp.toISOString();
                        const bucket = collectionData[collection][key];
                        
                        if (bucket && bucket.count > 0) {
                            const avgValue = bucket[metric.key] / bucket.count;
                            lineData.push({
                                value: [timestamp.getTime(), collIdx, avgValue],
                                collection: collection,
                                time: timestamp.toISOString().substring(0, 19).replace('T', ' '),
                                actualValue: avgValue,
                                count: bucket.count
                            });
                        }
                    });
                });

                return {
                    name: metric.name,
                    data: lineData,
                    color: metric.color
                };
            });

            // Store data globally
            window.echartsServiceTimeData = {
                collections: sortedCollections,
                timeBuckets: timeBuckets,
                seriesData: seriesData,
                collectionCounts: collectionCounts
            };

            Logger.info(`‚úÖ 3D Service Time data created: ${sortedCollections.length} collections, ${timeBuckets.length} time buckets`);
        }

        // Expand 3D Service Time modal
        function expandECharts3DServiceTime() {
            const data = window.echartsServiceTimeData;
            if (!data) {
                Logger.warn("No 3D Service Time data available");
                return;
            }

            Logger.info("Opening 3D Service Time modal...");

            // Create fullscreen modal
            const fullscreenChartDiv = document.createElement('div');
            fullscreenChartDiv.id = 'echarts-3d-service-time-fullscreen';
            fullscreenChartDiv.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 20000; display: flex; align-items: center; justify-content: center;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'width: 95%; height: 90%; background: white; border-radius: 8px; padding: 20px; position: relative;';
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï';
            closeBtn.style.cssText = 'position: absolute; top: 10px; right: 10px; width: 32px; height: 32px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold; z-index: 20001;';
            closeBtn.addEventListener('click', function() {
                document.body.removeChild(fullscreenChartDiv);
            });

            // Title
            const title = document.createElement('h2');
            title.textContent = 'Service Time Analysis By Collection (3D Ribbons)';
            title.style.cssText = 'margin: 0 0 10px 0; font-size: 18px;';

            // Controls container
            const controlsDiv = document.createElement('div');
            controlsDiv.style.cssText = 'display: flex; gap: 20px; align-items: center; margin-bottom: 10px; flex-wrap: wrap;';

            // Log scale toggle
            const logScaleDiv = document.createElement('div');
            logScaleDiv.innerHTML = `
                <input type="checkbox" id="echarts-service-time-log-scale-toggle" style="margin-right: 8px;">
                <label for="echarts-service-time-log-scale-toggle" style="font-size: 14px; cursor: pointer;">Log Scale Z-Axis (Time ms)</label>
            `;
            controlsDiv.appendChild(logScaleDiv);

            // Main content layout (chart + legend side by side)
            const contentLayout = document.createElement('div');
            contentLayout.style.cssText = 'display: flex; gap: 15px; height: calc(100% - 80px);';

            // Chart container (left side)
            const chartDiv = document.createElement('div');
            chartDiv.id = 'echarts-3d-service-time-chart';
            chartDiv.style.cssText = 'flex: 1; min-width: 0;';

            // Legend container (right side)
            const legendDiv = document.createElement('div');
            legendDiv.style.cssText = 'width: 280px; padding: 10px; background: #f8f9fa; border-radius: 4px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px;';
            
            // Metrics legend section (top)
            const metricsLegendDiv = document.createElement('div');
            metricsLegendDiv.innerHTML = `
                <div style="margin-bottom: 8px;">
                    <strong style="font-size: 14px;">Metrics (5 Planes)</strong>
                </div>
                <div id="service-time-metrics-items" style="display: flex; flex-direction: column; gap: 6px;"></div>
            `;
            
            // Collections legend section (bottom)
            const collectionsLegendDiv = document.createElement('div');
            collectionsLegendDiv.innerHTML = `
                <div style="margin-bottom: 8px;">
                    <strong style="font-size: 14px;">Collections (${data.collections.length})</strong>
                </div>
                <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                    <input type="text" id="service-time-legend-search" placeholder="Search..." style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 11px;">
                    <button id="service-time-show-all" style="padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">All</button>
                    <button id="service-time-hide-all" style="padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">None</button>
                </div>
                <div id="service-time-legend-items" style="display: flex; flex-wrap: wrap; gap: 6px; max-height: 300px; overflow-y: auto;"></div>
            `;
            
            legendDiv.appendChild(metricsLegendDiv);
            legendDiv.appendChild(collectionsLegendDiv);

            // Assemble layout
            contentLayout.appendChild(chartDiv);
            contentLayout.appendChild(legendDiv);

            // Assemble modal
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(title);
            modalContent.appendChild(controlsDiv);
            modalContent.appendChild(contentLayout);
            fullscreenChartDiv.appendChild(modalContent);
            document.body.appendChild(fullscreenChartDiv);

            // Populate metrics legend (top section)
            const metricsItemsDiv = document.getElementById('service-time-metrics-items');
            const metricsConfig = [
                { name: "Avg Elapsed Time", color: "rgba(75, 192, 192, 0.8)" },
                { name: "Avg Kernel Time", color: "rgba(255, 0, 0, 0.8)" },
                { name: "Authorize ServTime", color: "rgba(54, 162, 235, 0.8)" },
                { name: "IndexScan ServTime", color: "rgba(255, 206, 86, 0.8)" },
                { name: "Fetch ServTime", color: "rgba(153, 102, 255, 0.8)" }
            ];
            
            metricsConfig.forEach(metric => {
                const metricItem = document.createElement('label');
                metricItem.style.cssText = 'display: flex; align-items: center; padding: 4px 8px; background: white; border: 1px solid #dee2e6; border-radius: 3px; cursor: pointer; font-size: 12px;';
                metricItem.dataset.metric = metric.name;
                metricItem.innerHTML = `
                    <input type="checkbox" checked data-metric="${metric.name}" style="margin-right: 8px;">
                    <span style="width: 12px; height: 12px; background: ${metric.color}; display: inline-block; margin-right: 6px; border-radius: 2px;"></span>
                    <span>${metric.name}</span>
                `;
                metricsItemsDiv.appendChild(metricItem);
            });

            // Populate collections legend (bottom section)
            const legendItemsDiv = document.getElementById('service-time-legend-items');
            const displayCollections = [...data.collections].sort((a, b) => {
                return (data.collectionCounts[b] || 0) - (data.collectionCounts[a] || 0);
            });

            displayCollections.forEach(collection => {
                const count = data.collectionCounts[collection] || 0;
                const legendItem = document.createElement('label');
                legendItem.style.cssText = 'display: flex; align-items: center; padding: 4px 8px; background: white; border: 1px solid #dee2e6; border-radius: 3px; cursor: pointer; font-size: 12px;';
                legendItem.dataset.collection = collection;
                legendItem.innerHTML = `
                    <input type="checkbox" checked data-collection="${collection}" style="margin-right: 6px;">
                    <span>[${count}] ${collection}</span>
                `;
                legendItemsDiv.appendChild(legendItem);
            });

            // Initialize ECharts
            const myChart = echarts.init(chartDiv);
            
            // Render function
            function renderChart() {
                const useLogScale = document.getElementById('echarts-service-time-log-scale-toggle').checked;
                
                // Get visible metrics
                const visibleMetrics = new Set();
                document.querySelectorAll('#service-time-metrics-items input[type="checkbox"]:checked').forEach(cb => {
                    visibleMetrics.add(cb.dataset.metric);
                });
                
                // Get visible collections
                const visibleCollections = new Set();
                document.querySelectorAll('#service-time-legend-items input[type="checkbox"]:checked').forEach(cb => {
                    visibleCollections.add(cb.dataset.collection);
                });

                // Create stacked 3D bars showing component time breakdown
                const filteredSeries = [];
                
                // Component order (bottom to top): Auth, IndexScan, Fetch, Kernel
                // Each creates a separate bar3D series with stack offsets
                const componentLayers = [
                    { name: 'Authorize ServTime', dataKey: 'authSum', color: 'rgba(54, 162, 235, 0.85)', base: 0 },
                    { name: 'IndexScan ServTime', dataKey: 'indexSum', color: 'rgba(255, 206, 86, 0.85)', base: 1 },
                    { name: 'Fetch ServTime', dataKey: 'fetchSum', color: 'rgba(153, 102, 255, 0.85)', base: 2 },
                    { name: 'Avg Kernel Time', dataKey: 'kernSum', color: 'rgba(255, 0, 0, 0.85)', base: 3 }
                ];
                
                // Build stacked bar data: need to track cumulative height for each bar
                const barDataByLayer = componentLayers.map(() => []);
                const heightTracker = {}; // Track cumulative height per [time, collection]
                
                // Collect all data points with all component values
                const allPoints = [];
                data.timeBuckets.forEach((timestamp) => {
                    data.collections.forEach((collection, collIdx) => {
                        if (!visibleCollections.has(collection)) return;
                        
                        const timeKey = timestamp.toISOString();
                        const timeMs = timestamp.getTime();
                        
                        // Aggregate all metrics for this time+collection
                        const point = {
                            time: timeMs,
                            collIdx: collIdx,
                            authSum: 0,
                            indexSum: 0,
                            fetchSum: 0,
                            kernSum: 0,
                            elapsedSum: 0,
                            count: 0
                        };
                        
                        // Gather data from each metric's data
                        data.seriesData.forEach(metric => {
                            const metricPoint = metric.data.find(p => 
                                p.value[0] === timeMs && p.collection === collection
                            );
                            if (metricPoint) {
                                if (metric.name === 'Avg Elapsed Time') point.elapsedSum += metricPoint.actualValue;
                                if (metric.name === 'Avg Kernel Time') point.kernSum += metricPoint.actualValue;
                                if (metric.name === 'Authorize ServTime') point.authSum += metricPoint.actualValue;
                                if (metric.name === 'IndexScan ServTime') point.indexSum += metricPoint.actualValue;
                                if (metric.name === 'Fetch ServTime') point.fetchSum += metricPoint.actualValue;
                                point.count = Math.max(point.count, metricPoint.count);
                            }
                        });
                        
                        if (point.count > 0) {
                            allPoints.push(point);
                        }
                    });
                });
                
                // Create stacked layers
                componentLayers.forEach((layer, layerIdx) => {
                    // Skip if metric is not visible
                    if (!visibleMetrics.has(layer.name)) return;
                    
                    const layerData = allPoints.map(point => {
                        const key = `${point.time}_${point.collIdx}`;
                        
                        // Calculate cumulative base height (sum of all previous layers)
                        let baseHeight = 0;
                        for (let i = 0; i < layerIdx; i++) {
                            const prevLayer = componentLayers[i];
                            if (visibleMetrics.has(prevLayer.name)) {
                                baseHeight += point[prevLayer.dataKey] || 0;
                            }
                        }
                        
                        const segmentHeight = point[layer.dataKey] || 0;
                        
                        // Store in heightTracker
                        if (!heightTracker[key]) heightTracker[key] = 0;
                        heightTracker[key] += segmentHeight;
                        
                        // Return [x, y, z, value] where z is the segment height, and we'll use stack
                        return {
                            value: [point.time, point.collIdx, baseHeight + segmentHeight],
                            baseHeight: baseHeight,
                            segmentHeight: segmentHeight,
                            itemStyle: {
                                color: layer.color
                            }
                        };
                    }).filter(d => d.segmentHeight > 0);
                    
                    if (layerData.length === 0) return;
                    
                    filteredSeries.push({
                        type: 'bar3D',
                        name: layer.name,
                        data: layerData,
                        shading: 'color',
                        stack: 'total',
                        itemStyle: {
                            opacity: 0.85
                        },
                        emphasis: {
                            itemStyle: {
                                opacity: 1.0
                            }
                        }
                    });
                });

                const option = {
                    tooltip: {
                        formatter: function(params) {
                            const d = params.data;
                            if (!d.value) return '';
                            const timestamp = new Date(d.value[0]);
                            const timeStr = timestamp.toISOString().substring(0, 19).replace('T', ' ');
                            const collectionIdx = d.value[1];
                            const collection = data.collections[collectionIdx];
                            const timeValue = d.value[2];
                            return `<strong>${params.seriesName}</strong><br/>Collection: ${collection}<br/>Time: ${timeStr}<br/>Value: ${timeValue.toFixed(2)} ms`;
                        }
                    },
                    grid3D: {
                        boxWidth: 200,
                        boxHeight: Math.min(200, data.collections.length * 15),
                        boxDepth: 200,
                        axisPointer: {
                            show: true,
                            lineStyle: { color: '#ffaa00', width: 2 }
                        },
                        viewControl: {
                            alpha: 25,
                            beta: 45,
                            distance: 280,
                            minDistance: 100,
                            maxDistance: 500
                        }
                    },
                    // Bar sizing for stacked bars
                    barSize: [15, 15],
                    xAxis3D: {
                        type: 'time',
                        name: 'Request Time'
                    },
                    yAxis3D: {
                        type: 'category',
                        name: 'Collection',
                        data: data.collections
                    },
                    zAxis3D: {
                        type: useLogScale ? 'log' : 'value',
                        name: 'Time (ms)',
                        min: useLogScale ? 0.001 : 0
                    },
                    series: filteredSeries
                };

                myChart.setOption(option, true);
            }

            // Event listeners
            document.getElementById('echarts-service-time-log-scale-toggle').addEventListener('change', renderChart);
            document.getElementById('service-time-show-all').addEventListener('click', function() {
                document.querySelectorAll('#service-time-legend-items input[type="checkbox"]').forEach(cb => cb.checked = true);
                renderChart();
            });
            document.getElementById('service-time-hide-all').addEventListener('click', function() {
                document.querySelectorAll('#service-time-legend-items input[type="checkbox"]').forEach(cb => cb.checked = false);
                renderChart();
            });
            document.getElementById('service-time-legend-search').addEventListener('input', function(e) {
                const query = e.target.value.toLowerCase();
                document.querySelectorAll('#service-time-legend-items label').forEach(label => {
                    const collection = label.dataset.collection.toLowerCase();
                    label.style.display = collection.includes(query) ? 'flex' : 'none';
                });
            });
            legendItemsDiv.addEventListener('change', renderChart);
            metricsItemsDiv.addEventListener('change', renderChart);

            // Debug mode camera display
            const urlParams = new URLSearchParams(window.location.search);
            const debugMode = urlParams.get('debug') === 'true' || urlParams.get('logLevel') === 'debug';
            
            if (debugMode) {
                const debugDiv = document.createElement('div');
                debugDiv.id = 'camera-debug-service-time';
                debugDiv.style.cssText = 'position: absolute; top: 60px; left: 10px; background: rgba(0,0,0,0.9); color: #00ff00; padding: 12px; font-family: monospace; font-size: 13px; z-index: 10002; border-radius: 4px; border: 2px solid #00ff00; box-shadow: 0 0 10px rgba(0,255,0,0.5);';
                debugDiv.innerHTML = '<strong style="color: #ffff00;">Camera Position:</strong><br/>Alpha: 25.0<br/>Beta: 45.0<br/>Distance: 280.0';
                modalContent.appendChild(debugDiv);
                
                const cameraUpdateInterval = setInterval(function() {
                    try {
                        const option = myChart.getOption();
                        if (option && option.grid3D && option.grid3D[0] && option.grid3D[0].viewControl) {
                            const vc = option.grid3D[0].viewControl;
                            debugDiv.innerHTML = `
                                <strong style="color: #ffff00;">Camera Position:</strong><br/>
                                Alpha: ${vc.alpha.toFixed(1)}<br/>
                                Beta: ${vc.beta.toFixed(1)}<br/>
                                Distance: ${vc.distance.toFixed(1)}
                            `;
                        }
                    } catch (e) {
                        // Silently fail
                    }
                }, 100);
                
                closeBtn.addEventListener('click', function() {
                    clearInterval(cameraUpdateInterval);
                }, { once: true });
            }

            // Initial render
            renderChart();
            
            Logger.info("‚úÖ 3D Service Time modal opened");
        }

        function createDocumentSizeBubbleChart(requests, grouping) {
            const canvas = document.getElementById("doc-size-bubble-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            if (window.docSizeBubbleChart) {
                window.docSizeBubbleChart.destroy();
            }

            // Store requests and grouping for checkbox toggle
            window.docSizeBubbleChartData = { requests, grouping };

            const sizeRanges = [
                { label: "0 bytes", min: 0, max: 0, color: "rgba(128, 128, 128, 0.7)" },                   // Gray
                { label: "1-10 bytes", min: 1, max: 10, color: "rgba(255, 0, 255, 0.7)" },                // Magenta
                { label: "10-100 bytes", min: 10, max: 100, color: "rgba(128, 0, 255, 0.7)" },            // Purple
                { label: "100-1K bytes", min: 100, max: 1000, color: "rgba(0, 0, 200, 0.7)" },            // Dark Blue
                { label: "1K-10K bytes", min: 1000, max: 10000, color: "rgba(0, 200, 255, 0.7)" },        // Cyan
                { label: "10K-100K bytes", min: 10000, max: 100000, color: "rgba(0, 180, 0, 0.7)" },      // Green
                { label: "100K-1MB", min: 100000, max: 1000000, color: "rgba(150, 200, 0, 0.7)" },        // Yellow-Green
                { label: "1MB-5MB", min: 1000000, max: 5000000, color: "rgba(255, 220, 0, 0.7)" },        // Bright Yellow
                { label: "5MB-10MB", min: 5000000, max: 10000000, color: "rgba(255, 150, 0, 0.7)" },      // Orange
                { label: "10MB-15MB", min: 10000000, max: 15000000, color: "rgba(255, 80, 0, 0.7)" },     // Red-Orange
                { label: "15MB-20MB", min: 15000000, max: 20000000, color: "rgba(220, 0, 0, 0.7)" },      // Red
            ];

            const timeGroups = {};

            requests.forEach((request) => {
                const resultCount = request.resultCount || 0;
                const resultSize = request.resultSize || 0;

                if (resultCount === 0 || resultSize === 0) return;

                const avgDocSize = resultSize / resultCount;

                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        sizeRangeCounts: {},
                    };
                    sizeRanges.forEach(range => {
                        timeGroups[key].sizeRangeCounts[range.label] = 0;
                    });
                }

                for (const range of sizeRanges) {
                    if (avgDocSize >= range.min && avgDocSize < range.max) {
                        timeGroups[key].sizeRangeCounts[range.label]++;
                        break;
                    }
                    if (range.max === Infinity && avgDocSize >= range.min) {
                        timeGroups[key].sizeRangeCounts[range.label]++;
                        break;
                    }
                }
            });

            // Get all timeline buckets to ensure charts share same x-axis (Issue #148)
            const buckets = getTimelineBucketsFromRequests(requests, grouping);
            
            // Map data to all buckets (use default values for missing data points)
            const sortedTimeGroups = buckets.map(ts => {
                const key = ts.toISOString();
                const group = timeGroups[key];
                if (group) {
                    return group;
                } else {
                    const emptyGroup = {
                        timestamp: ts,
                        sizeRangeCounts: {},
                    };
                    sizeRanges.forEach(range => {
                        emptyGroup.sizeRangeCounts[range.label] = 0;
                    });
                    return emptyGroup;
                }
            });

            if (sortedTimeGroups.length === 0) {
                Logger.debug("No document size data for bubble chart");
                return;
            }

            // Function to calculate bubble radius using logarithmic scale
            const calculateBubbleRadius = (count) => {
                if (count === 0) return 0;
                // Logarithmic scale: log10(count + 1) * 8
                return Math.log10(count + 1) * 8;
            };

            const datasets = sizeRanges.map(range => {
                const data = sortedTimeGroups.map(group => ({
                    x: group.timestamp,
                    y: group.sizeRangeCounts[range.label],
                    r: calculateBubbleRadius(group.sizeRangeCounts[range.label]),
                }));
                
                // Calculate total count for this size range
                const totalCount = data.reduce((sum, point) => sum + point.y, 0);
                
                return {
                    label: `${range.label} (${totalCount} total)`,
                    data: data,
                    backgroundColor: range.color,
                    borderColor: range.color.replace('0.6', '1'),
                    borderWidth: 1,
                };
            });

            window.docSizeBubbleChart = new Chart(ctx, {
                type: "bubble",
                data: { datasets },
                plugins: [verticalLinePlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Query's Avg Returned Document Size (Bubble Size = Query Count)",
                            font: { size: 12 },
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || "";
                                    const count = context.parsed.y;
                                    return `${label}: ${count} queries`;
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "Query Count",
                            },
                        },
                    },
                },
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.docSizeBubbleChart, ctx);

            // Setup 3D button click handler
            const btn3D = document.getElementById('open-3d-avg-doc-size-chart-btn');
            if (btn3D) {
                // Show button only if we have data
                btn3D.style.display = (requests && requests.length > 0) ? 'block' : 'none';
                
                // Remove old event listeners (prevents duplicate handlers)
                const newBtn = btn3D.cloneNode(true);
                btn3D.parentNode.replaceChild(newBtn, btn3D);
                
                // Add click handler
                newBtn.addEventListener('click', function() {
                    // Always regenerate 3D data to respect current filters
                    createECharts3DAvgDocSize(requests, grouping);
                    // Open fullscreen modal
                    expandECharts3DAvgDocSize();
                });
            }
        }

        // Create Execution Analysis Chart (ExecTime vs ServTime/KernTime percentages)
        function createExecVsKernelChart(requests, grouping) {
            const canvas = document.getElementById("exec-vs-kernel-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.execVsKernelChart) {
                window.execVsKernelChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        authorizeData: [],
                        parseData: [],
                        planData: [],
                        indexScanData: [],
                        fetchData: [],
                        filterData: [],
                        streamData: [],
                        kernTimeData: [],
                        elapsedTimeData: [],
                        queryCount: 0,
                    };
                }

                timeGroups[key].queryCount++;

                // Extract data from phaseTimes and plan operators
                if (request.phaseTimes) {
                    const parseTimeMs = parseTime(request.phaseTimes.parse) || 0;
                    const planTimeMs = parseTime(request.phaseTimes.plan) || 0;
                    timeGroups[key].parseData.push(parseTimeMs);
                    timeGroups[key].planData.push(planTimeMs);
                }

                // Extract kernel time from plan
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                timeGroups[key].kernTimeData.push(kernTimeMs);

                // Extract elapsed time for ratio calculation
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                timeGroups[key].elapsedTimeData.push(elapsedTimeMs);

                // Extract operator-specific data from plan
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const execTime = parseTime(stats.execTime) || 0;

                            switch (operatorType) {
                                case "Authorize":
                                    timeGroups[key].authorizeData.push({ execTime });
                                    break;
                                case "IndexScan3":
                                case "PrimaryScan":
                                case "PrimaryScan3":
                                    timeGroups[key].indexScanData.push({ execTime });
                                    break;
                                case "Fetch":
                                    timeGroups[key].fetchData.push({ execTime });
                                    break;
                                case "Filter":
                                    timeGroups[key].filterData.push({ execTime });
                                    break;
                                case "Stream":
                                    timeGroups[key].streamData.push({ execTime });
                                    break;
                            }
                        });
                    } catch (e) {
                        console.warn("Error parsing plan for exec analysis:", e);
                    }
                }
            });

            // Convert to sorted array and calculate percentages vs kernel time
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgAuthorizeExecTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length : 0,
                    avgParseTime: item.parseData.length > 0 ? 
                        item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length : 0,
                    avgPlanTime: item.planData.length > 0 ? 
                        item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length : 0,
                    avgIndexScanExecTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length : 0,
                    avgFetchExecTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length : 0,
                    avgFilterExecTime: item.filterData.length > 0 ? 
                        item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length : 0,
                    avgStreamExecTime: item.streamData.length > 0 ? 
                        item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length : 0,
                    avgKernTime: item.kernTimeData.length > 0 ? 
                        item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0,
                }));

            const authorizeVsKernPercentData = sortedData.map((item) => {
                if (item.authorizeData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgAuthorizeExecTime = item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgAuthorizeExecTime / avgKernTime) * 100 : 0;
            });

            const parseVsKernPercentData = sortedData.map((item) => {
                if (item.parseData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgParseTime = item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgParseTime / avgKernTime) * 100 : 0;
            });

            const planVsKernPercentData = sortedData.map((item) => {
                if (item.planData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgPlanTime = item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgPlanTime / avgKernTime) * 100 : 0;
            });

            const indexScanVsKernPercentData = sortedData.map((item) => {
                if (item.indexScanData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgIndexScanExecTime = item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgIndexScanExecTime / avgKernTime) * 100 : 0;
            });

            const fetchVsKernPercentData = sortedData.map((item) => {
                if (item.fetchData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgFetchExecTime = item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgFetchExecTime / avgKernTime) * 100 : 0;
            });

            const filterVsKernPercentData = sortedData.map((item) => {
                if (item.filterData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgFilterExecTime = item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgFilterExecTime / avgKernTime) * 100 : 0;
            });

            const streamVsKernPercentData = sortedData.map((item) => {
                if (item.streamData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgStreamExecTime = item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgStreamExecTime / avgKernTime) * 100 : 0;
            });

            // Calculate KernTime vs ElapsedTime percentage for new red dotted line
            const kernVsElapsedPercentData = sortedData.map((item) => {
                const avgKernTime = item.kernTimeData.length > 0 ? 
                    item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0;
                const avgElapsedTime = item.elapsedTimeData.length > 0 ? 
                    item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0;
                return avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
            });

            const labels = sortedData.map((item) => item.timestamp);

            window.execVsKernelChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Authorize: ExecTime vs Kernel Time (%)",
                            data: authorizeVsKernPercentData,
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue (matches ServTime chart)
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Parse vs Kernel Time (%)",
                            data: parseVsKernPercentData,
                            backgroundColor: "rgba(255, 99, 132, 0.8)", // Red
                            borderColor: "rgba(255, 99, 132, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Plan vs Kernel Time (%)",
                            data: planVsKernPercentData,
                            backgroundColor: "rgba(75, 192, 192, 0.8)", // Teal
                            borderColor: "rgba(75, 192, 192, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "IndexScan: ExecTime vs Kernel Time (%)",
                            data: indexScanVsKernPercentData,
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow (matches ServTime chart)
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Fetch: ExecTime vs Kernel Time (%)",
                            data: fetchVsKernPercentData,
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple (matches ServTime chart)
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Filter vs Kernel Time (%)",
                            data: filterVsKernPercentData,
                            backgroundColor: "rgba(255, 159, 64, 0.8)", // Orange
                            borderColor: "rgba(255, 159, 64, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Stream vs Kernel Time (%)",
                            data: streamVsKernPercentData,
                            backgroundColor: "rgba(201, 203, 207, 0.8)", // Gray
                            borderColor: "rgba(201, 203, 207, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Kernel vs Elapsed Time (%)",
                            data: kernVsElapsedPercentData,
                            backgroundColor: "rgba(255, 0, 0, 0.8)", // Bright Red
                            borderColor: "rgba(255, 0, 0, 1)",
                            borderWidth: 3,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3], // Custom dash pattern
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 0, // No points
                            pointHoverRadius: 0, // No hover points
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "ExecTime vs Highest Kernel Time (%) By Query Steps",
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value === null || value === undefined) return null;
                                    // Extract just the operator name from various label formats
                                    let operatorName = context.dataset.label;
                                    if (operatorName.includes(':')) {
                                        operatorName = operatorName.split(':')[0];
                                    } else if (operatorName.includes(' vs ')) {
                                        operatorName = operatorName.split(' vs ')[0];
                                    }
                                    return `  ${operatorName}: ${value.toFixed(2)}%`;
                                },
                                afterBody: function(tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    const avgElapsedTime = data.elapsedTimeData.length > 0 ? 
                                        data.elapsedTimeData.reduce((sum, d) => sum + d, 0) / data.elapsedTimeData.length : 0;
                                    const kernElapsedRatio = avgElapsedTime > 0 ? (data.avgKernTime / avgElapsedTime) * 100 : 0;
                                    return [
                                        '',
                                        `Kernel vs Elapsed: ${kernElapsedRatio.toFixed(1)}%`,
                                        `Queries: ${data.queryCount}`,
                                        `Kernel Time: ${data.avgKernTime.toFixed(1)}ms`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: { display: true, text: "Percentage (%)" },
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 100,
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.execVsKernelChart, ctx);
        }

        // Create ExecTime vs ServTime Chart (operators with servTime)
        function createExecVsServChart(requests, grouping) {
            const canvas = document.getElementById("exec-vs-serv-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.execVsServChart) {
                window.execVsServChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        authorizeData: [],
                        indexScanData: [],
                        fetchData: [],
                        kernTimeData: [],
                        elapsedTimeData: [],
                        queryCount: 0,
                    };
                }

                timeGroups[key].queryCount++;

                // Extract kernel and elapsed time for ratio calculation
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                timeGroups[key].kernTimeData.push(kernTimeMs);
                timeGroups[key].elapsedTimeData.push(elapsedTimeMs);

                // Extract operator-specific data from plan
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const execTime = parseTime(stats.execTime) || 0;
                            const servTime = parseTime(stats.servTime) || 0;

                            switch (operatorType) {
                                case "Authorize":
                                    timeGroups[key].authorizeData.push({ execTime, servTime });
                                    break;
                                case "IndexScan3":
                                case "PrimaryScan":
                                case "PrimaryScan3":
                                    timeGroups[key].indexScanData.push({ execTime, servTime });
                                    break;
                                case "Fetch":
                                    timeGroups[key].fetchData.push({ execTime, servTime });
                                    break;
                            }
                        });
                    } catch (e) {
                        console.warn("Error parsing plan for exec vs serv analysis:", e);
                    }
                }
            });

            // Convert to sorted array and calculate percentages vs servTime
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgAuthorizeExecTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length : 0,
                    avgAuthorizeServTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.servTime, 0) / item.authorizeData.length : 0,
                    avgIndexScanExecTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length : 0,
                    avgIndexScanServTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.servTime, 0) / item.indexScanData.length : 0,
                    avgFetchExecTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length : 0,
                    avgFetchServTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.servTime, 0) / item.fetchData.length : 0,
                }));

            const authorizePercentData = sortedData.map((item) => {
                if (item.authorizeData.length === 0) return 0;
                const avgExecTime = item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length;
                const avgServTime = item.authorizeData.reduce((sum, d) => sum + d.servTime, 0) / item.authorizeData.length;
                return avgServTime > 0 ? (avgExecTime / avgServTime) * 100 : 0;
            });

            const indexScanPercentData = sortedData.map((item) => {
                if (item.indexScanData.length === 0) return 0;
                const avgExecTime = item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length;
                const avgServTime = item.indexScanData.reduce((sum, d) => sum + d.servTime, 0) / item.indexScanData.length;
                return avgServTime > 0 ? (avgExecTime / avgServTime) * 100 : 0;
            });

            const fetchPercentData = sortedData.map((item) => {
                if (item.fetchData.length === 0) return 0;
                const avgExecTime = item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length;
                const avgServTime = item.fetchData.reduce((sum, d) => sum + d.servTime, 0) / item.fetchData.length;
                return avgServTime > 0 ? (avgExecTime / avgServTime) * 100 : 0;
            });

            // Calculate KernTime vs ElapsedTime percentage for new red dotted line
            const kernVsElapsedPercentData = sortedData.map((item) => {
                const avgKernTime = item.kernTimeData.length > 0 ? 
                    item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0;
                const avgElapsedTime = item.elapsedTimeData.length > 0 ? 
                    item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0;
                return avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
            });

            const labels = sortedData.map((item) => item.timestamp);

            window.execVsServChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                    {
                    label: "Authorize: ExecTime vs ServTime (%)",
                    data: authorizePercentData,
                    backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue
                    borderColor: "rgba(54, 162, 235, 1)",
                    borderWidth: 2,
                    fill: false,
                    spanGaps: false,
                    tension: 0.3,
                        yAxisID: 'y',
                        hidden: true
                    },
                    {
                    label: "IndexScan: ExecTime vs ServTime (%)",
                    data: indexScanPercentData,
                    backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow
                    borderColor: "rgba(255, 206, 86, 1)",
                    borderWidth: 2,
                    fill: false,
                    spanGaps: false,
                        tension: 0.3,
                        yAxisID: 'y',
                        hidden: true
                    },
                    {
                    label: "Fetch: ExecTime vs ServTime (%)",
                    data: fetchPercentData,
                    backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple
                    borderColor: "rgba(153, 102, 255, 1)",
                    borderWidth: 2,
                        fill: false,
                        spanGaps: false,
                            tension: 0.3,
                            yAxisID: 'y',
                            hidden: true
                        },
                        {
                            label: "Authorize: Avg ServTime (ms)",
                            data: sortedData.map(item => item.avgAuthorizeServTime),
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            yAxisID: 'y1'
                        },
                        {
                            label: "IndexScan: Avg ServTime (ms)",
                            data: sortedData.map(item => item.avgIndexScanServTime),
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            yAxisID: 'y1'
                        },
                        {
                            label: "Fetch: Avg ServTime (ms)",
                            data: sortedData.map(item => item.avgFetchServTime),
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            yAxisID: 'y1'
                        },
                        {
                            label: "Kernel vs Elapsed Time (%)",
                            data: kernVsElapsedPercentData,
                            backgroundColor: "rgba(255, 0, 0, 0.8)", // Bright Red
                            borderColor: "rgba(255, 0, 0, 1)",
                            borderWidth: 3,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3], // Custom dash pattern
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 0, // No points
                            pointHoverRadius: 0, // No hover points
                            yAxisID: 'y'
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "ExecTime vs ServTime (%) by Services in Query Execution",
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                const value = context.parsed.y;
                                if (value === null || value === undefined) return null;
                                    
                                    // Only show labels for percentage datasets, skip service time datasets
                                if (context.dataset.label.includes('Avg ServTime')) return null;
                                
                                const dataIndex = context.dataIndex;
                                const data = sortedData[dataIndex];
                                
                                // Extract just the operator name from various label formats
                                let operatorName = context.dataset.label;
                                if (operatorName.includes(':')) {
                                    operatorName = operatorName.split(':')[0];
                                } else if (operatorName.includes(' vs ')) {
                                operatorName = operatorName.split(' vs ')[0];
                                }
                                
                                    // Get the corresponding service time for this operator
                                    let servTime = 0;
                                    if (operatorName === 'Authorize') {
                                    servTime = data.avgAuthorizeServTime;
                                    } else if (operatorName === 'IndexScan') {
                                    servTime = data.avgIndexScanServTime;
                                    } else if (operatorName === 'Fetch') {
                                    servTime = data.avgFetchServTime;
                                    }
                                    
                                    return `  ${operatorName}: ${Math.round(value)}% | ${Math.round(servTime)}ms`;
                                    },
                                    afterBody: function(tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    const avgKernTime = data.kernTimeData.length > 0 ? 
                                    data.kernTimeData.reduce((sum, d) => sum + d, 0) / data.kernTimeData.length : 0;
                                    const avgElapsedTime = data.elapsedTimeData.length > 0 ? 
                                    data.elapsedTimeData.reduce((sum, d) => sum + d, 0) / data.elapsedTimeData.length : 0;
                                    const kernElapsedRatio = avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
                                    return [
                                    '',
                                    `Kernel vs Elapsed: ${Math.round(kernElapsedRatio)}%`,
                                    `Queries: ${data.queryCount}`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                    x: {
                    type: "time",
                    time: getCurrentTimeConfig(requests),
                    title: { display: true, text: "Request Time" },
                    },
                    y: {
                    type: "linear",
                    position: "left",
                    title: { display: true, text: "Percentage (%)" },
                    beginAtZero: true,
                    suggestedMin: 0,
                    suggestedMax: 100,
                    },
                        y1: {
                             type: "linear",
                             position: "right",
                             title: { display: true, text: "Avg ServTime (ms)" },
                             beginAtZero: true,
                             grid: {
                                 drawOnChartArea: false,
                             },
                         },
                     },
                    interaction: { mode: "index", intersect: false },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.execVsServChart, ctx);
        }

        // Create Service Time Analysis Line Chart (5 lines: ElapsedTime, KernTime, Auth, Index, Fetch service times)
        function createServiceTimeAnalysisLineChart(requests, grouping) {
            const canvas = document.getElementById("service-time-analysis-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.serviceTimeAnalysisLineChart) {
                window.serviceTimeAnalysisLineChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        elapsedTimeSum: 0,
                        kernTimeSum: 0,
                        authServTimeSum: 0,
                        authServTimeCount: 0,
                        indexServTimeSum: 0,
                        indexServTimeCount: 0,
                        fetchServTimeSum: 0,
                        fetchServTimeCount: 0,
                        queryCount: 0,
                    };
                }

                timeGroups[key].queryCount++;

                // Extract elapsed and kernel time
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                timeGroups[key].elapsedTimeSum += elapsedTimeMs;
                timeGroups[key].kernTimeSum += kernTimeMs;

                // Extract service times from operators
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const servTime = parseTime(stats.servTime) || 0;

                            if (servTime > 0) {
                                switch (operatorType) {
                                    case "Authorize":
                                        timeGroups[key].authServTimeSum += servTime;
                                        timeGroups[key].authServTimeCount++;
                                        break;
                                    case "IndexScan3":
                                    case "PrimaryScan":
                                    case "PrimaryScan3":
                                        timeGroups[key].indexServTimeSum += servTime;
                                        timeGroups[key].indexServTimeCount++;
                                        break;
                                    case "Fetch":
                                        timeGroups[key].fetchServTimeSum += servTime;
                                        timeGroups[key].fetchServTimeCount++;
                                        break;
                                }
                            }
                        });
                    } catch (e) {
                        console.warn("Error parsing plan for service time analysis:", e);
                    }
                }
            });

            // Convert to sorted array and calculate averages per query
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    timestamp: item.timestamp,
                    avgElapsedTime: item.queryCount > 0 ? item.elapsedTimeSum / item.queryCount : null,
                    avgKernTime: item.queryCount > 0 ? item.kernTimeSum / item.queryCount : null,
                    avgAuthServTime: item.queryCount > 0 ? item.authServTimeSum / item.queryCount : null,
                    avgIndexServTime: item.queryCount > 0 ? item.indexServTimeSum / item.queryCount : null,
                    avgFetchServTime: item.queryCount > 0 ? item.fetchServTimeSum / item.queryCount : null,
                }));

            const labels = sortedData.map((item) => item.timestamp);
            const elapsedTimeData = sortedData.map((item) => item.avgElapsedTime);
            const kernTimeData = sortedData.map((item) => item.avgKernTime);
            const authServTimeData = sortedData.map((item) => item.avgAuthServTime);
            const indexServTimeData = sortedData.map((item) => item.avgIndexServTime);
            const fetchServTimeData = sortedData.map((item) => item.avgFetchServTime);

            window.serviceTimeAnalysisLineChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Avg Elapsed Time (ms)",
                            data: elapsedTimeData,
                            backgroundColor: "rgba(75, 192, 192, 0.2)", // Teal with low opacity for fill
                            borderColor: "rgba(75, 192, 192, 1)",
                            borderWidth: 2,
                            fill: true,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Avg Kernel Time (ms)",
                            data: kernTimeData,
                            backgroundColor: "rgba(255, 0, 0, 0.8)", // Bright Red
                            borderColor: "rgba(255, 0, 0, 1)",
                            borderWidth: 3,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3], // Same dotted pattern
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                        },
                        {
                            label: "Authorize: Avg ServTime (ms)",
                            data: authServTimeData,
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "IndexScan: Avg ServTime (ms)",
                            data: indexServTimeData,
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow/Orange
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Fetch: Avg ServTime (ms)",
                            data: fetchServTimeData,
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Service Time Analysis: ElapsedTime, KernTime & Service Times",
                            font: {
                                size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            mode: "index",
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value === null || value === undefined) return null;
                                    
                                    // Shorten labels
                                    let label = context.dataset.label;
                                    if (label.includes("Elapsed")) label = "Elapsed (ms)";
                                    else if (label.includes("Kernel")) label = "Kernel (ms)";
                                    else if (label.includes("Authorize")) label = "Authorize (ms)";
                                    else if (label.includes("IndexScan")) label = "Index (ms)";
                                    else if (label.includes("Fetch")) label = "Fetch (ms)";
                                    
                                    // Format with thousand separators (whole numbers only)
                                    const formattedValue = Math.round(value).toLocaleString('en-US');
                                    return `  ${label}: ${formattedValue}`;
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: { display: true, text: "Request Time" },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: { display: true, text: "Time (ms)" },
                            beginAtZero: true,
                        },
                    },
                    interaction: { mode: "index", intersect: false },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.serviceTimeAnalysisLineChart, ctx);

            // Setup 3D button click handler (Issue #217) - Only show with ?dev=true
            const urlParams = new URLSearchParams(window.location.search);
            const devMode = urlParams.get('dev') === 'true';
            
            if (devMode) {
                const btn3D = document.getElementById('open-3d-service-time-btn');
                if (btn3D) {
                    // Show button only if we have data
                    btn3D.style.display = (requests && requests.length > 0) ? 'block' : 'none';
                    
                    // Remove old event listeners (prevents duplicate handlers)
                    const newBtn = btn3D.cloneNode(true);
                    btn3D.parentNode.replaceChild(newBtn, btn3D);
                    
                    // Add click handler
                    newBtn.addEventListener('click', function() {
                        // Always regenerate 3D data to respect current filters
                        createECharts3DServiceTime(requests, grouping);
                        // Open fullscreen modal
                        expandECharts3DServiceTime();
                    });
                }
            }
        }

        // Setup chart drag and drop functionality
        function setupChartDragAndDrop() {
            // Chart mapping for swapping - all charts
            const chartMapping = {
                'elapsed-time': () => window.elapsedTimeChart,
                'primary-scan': () => window.primaryScanChart,
                'query-pattern': () => window.queryPatternChart,
                'duration-buckets': () => window.durationBucketsChart,
                'query-types': () => window.queryTypesChart,
                'operations': () => window.operationsChart,
                'filter': () => window.filterChart,
                'result-count': () => window.resultCountChart,
                'result-size': () => window.resultSizeChart,
                'timeline': () => window.timelineChart,
                'memory': () => window.memoryChart,
                'exec-vs-kernel': () => window.execVsKernelChart,
                'exec-vs-serv': () => window.execVsServChart,
                'cpu-time': () => window.cpuTimeChart,
                'exec-vs-elapsed': () => window.execVsElapsedChart,
                'service-time-analysis': () => window.serviceTimeAnalysisLineChart,
                'enhanced-operations': () => window.enhancedOperationsChart
            };

            // Make charts draggable (excluding dashboard charts)
            $('.draggable-chart').not('[data-position^="dashboard"]').draggable({
                handle: '.chart-drag-handle',
                revert: 'invalid',
                helper: 'clone',
                opacity: 0.7,
                zIndex: 1000,
                start: function(event, ui) {
                    $(this).addClass('ui-draggable-dragging');
                },
                stop: function(event, ui) {
                    $(this).removeClass('ui-draggable-dragging');
                }
            });

            // Make charts droppable
            $('.draggable-chart').droppable({
                accept: '.draggable-chart',
                hoverClass: 'chart-drop-zone',
                drop: function(event, ui) {
                    const draggedChart = ui.draggable;
                    const targetChart = $(this);
                    
                    // Don't drop on itself
                    if (draggedChart[0] === targetChart[0]) return;

                    // Get chart IDs
                    const draggedId = draggedChart.data('chart-id');
                    const targetId = targetChart.data('chart-id');

                    // Swap positions
                    const draggedPosition = draggedChart.data('position');
                    const targetPosition = targetChart.data('position');

                    // Update data attributes
                    draggedChart.data('position', targetPosition);
                    targetChart.data('position', draggedPosition);

                    // Swap canvas IDs to maintain chart references
                    const draggedCanvas = draggedChart.find('canvas');
                    const targetCanvas = targetChart.find('canvas');
                    
                    const tempId = 'temp-canvas-id';
                    const draggedCanvasId = draggedCanvas.attr('id');
                    const targetCanvasId = targetCanvas.attr('id');
                    
                    draggedCanvas.attr('id', tempId);
                    targetCanvas.attr('id', draggedCanvasId);
                    draggedCanvas.attr('id', targetCanvasId);

                    // Swap the DOM elements
                    const draggedParent = draggedChart.parent();
                    const targetParent = targetChart.parent();
                    
                    // Use jQuery to swap elements
                    const temp = $('<div>');
                    draggedChart.before(temp);
                    targetChart.before(draggedChart);
                    temp.before(targetChart);
                    temp.remove();

                    // Refresh chart sizes after DOM manipulation
                    setTimeout(() => {
                        Object.values(chartMapping).forEach(getChart => {
                            const chart = getChart();
                            if (chart && chart.resize) {
                                chart.resize();
                            }
                        });
                    }, 100);
                }
            });
        }

        // Create ExecTime vs Elapsed Time Chart (copy of ExecVsKernel but vs elapsed time)
        function createExecVsElapsedChart(requests, grouping) {
            const canvas = document.getElementById("exec-vs-elapsed-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.execVsElapsedChart) {
                window.execVsElapsedChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = getChartDate(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        authorizeData: [],
                        parseData: [],
                        planData: [],
                        indexScanData: [],
                        fetchData: [],
                        filterData: [],
                        streamData: [],
                        kernTimeData: [],
                        elapsedTimeData: [],
                        queryCount: 0,
                    };
                }

                timeGroups[key].queryCount++;

                // Extract data from phaseTimes
                if (request.phaseTimes) {
                    const parseTimeMs = parseTime(request.phaseTimes.parse) || 0;
                    const planTimeMs = parseTime(request.phaseTimes.plan) || 0;
                    timeGroups[key].parseData.push(parseTimeMs);
                    timeGroups[key].planData.push(planTimeMs);
                }

                // Extract kernel and elapsed time
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                timeGroups[key].kernTimeData.push(kernTimeMs);
                timeGroups[key].elapsedTimeData.push(elapsedTimeMs);

                // Extract operator-specific data from plan
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const execTime = parseTime(stats.execTime) || 0;

                            switch (operatorType) {
                                case "Authorize":
                                    timeGroups[key].authorizeData.push({ execTime });
                                    break;
                                case "IndexScan3":
                                case "PrimaryScan":
                                case "PrimaryScan3":
                                    timeGroups[key].indexScanData.push({ execTime });
                                    break;
                                case "Fetch":
                                    timeGroups[key].fetchData.push({ execTime });
                                    break;
                                case "Filter":
                                    timeGroups[key].filterData.push({ execTime });
                                    break;
                                case "Stream":
                                    timeGroups[key].streamData.push({ execTime });
                                    break;
                            }
                        });
                    } catch (e) {
                        console.warn("Error parsing plan for exec vs elapsed analysis:", e);
                    }
                }
            });

            // Convert to sorted array and calculate percentages vs elapsed time
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgAuthorizeExecTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length : 0,
                    avgParseTime: item.parseData.length > 0 ? 
                        item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length : 0,
                    avgPlanTime: item.planData.length > 0 ? 
                        item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length : 0,
                    avgIndexScanExecTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length : 0,
                    avgFetchExecTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length : 0,
                    avgFilterExecTime: item.filterData.length > 0 ? 
                        item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length : 0,
                    avgStreamExecTime: item.streamData.length > 0 ? 
                        item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length : 0,
                    avgElapsedTime: item.elapsedTimeData.length > 0 ? 
                        item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0,
                }));

            const authorizeVsElapsedPercentData = sortedData.map((item) => {
                if (item.authorizeData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgAuthorizeExecTime = item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgAuthorizeExecTime / avgElapsedTime) * 100 : 0;
            });

            const parseVsElapsedPercentData = sortedData.map((item) => {
                if (item.parseData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgParseTime = item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgParseTime / avgElapsedTime) * 100 : 0;
            });

            const planVsElapsedPercentData = sortedData.map((item) => {
                if (item.planData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgPlanTime = item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgPlanTime / avgElapsedTime) * 100 : 0;
            });

            const indexScanVsElapsedPercentData = sortedData.map((item) => {
                if (item.indexScanData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgIndexScanExecTime = item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgIndexScanExecTime / avgElapsedTime) * 100 : 0;
            });

            const fetchVsElapsedPercentData = sortedData.map((item) => {
                if (item.fetchData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgFetchExecTime = item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgFetchExecTime / avgElapsedTime) * 100 : 0;
            });

            const filterVsElapsedPercentData = sortedData.map((item) => {
                if (item.filterData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgFilterExecTime = item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgFilterExecTime / avgElapsedTime) * 100 : 0;
            });

            const streamVsElapsedPercentData = sortedData.map((item) => {
                if (item.streamData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgStreamExecTime = item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgStreamExecTime / avgElapsedTime) * 100 : 0;
            });

            // Calculate KernTime vs ElapsedTime percentage for new red dotted line
            const kernVsElapsedPercentData = sortedData.map((item) => {
                const avgKernTime = item.kernTimeData.length > 0 ? 
                    item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0;
                const avgElapsedTime = item.elapsedTimeData.length > 0 ? 
                    item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0;
                return avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
            });

            const labels = sortedData.map((item) => item.timestamp);

            window.execVsElapsedChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Authorize: ExecTime vs Elapsed Time (%)",
                            data: authorizeVsElapsedPercentData,
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue (matches others)
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Parse vs Elapsed Time (%)",
                            data: parseVsElapsedPercentData,
                            backgroundColor: "rgba(255, 99, 132, 0.8)", // Red
                            borderColor: "rgba(255, 99, 132, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Plan vs Elapsed Time (%)",
                            data: planVsElapsedPercentData,
                            backgroundColor: "rgba(75, 192, 192, 0.8)", // Teal
                            borderColor: "rgba(75, 192, 192, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "IndexScan: ExecTime vs Elapsed Time (%)",
                            data: indexScanVsElapsedPercentData,
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow (matches others)
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Fetch: ExecTime vs Elapsed Time (%)",
                            data: fetchVsElapsedPercentData,
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple (matches others)
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Filter vs Elapsed Time (%)",
                            data: filterVsElapsedPercentData,
                            backgroundColor: "rgba(255, 159, 64, 0.8)", // Orange
                            borderColor: "rgba(255, 159, 64, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Stream vs Elapsed Time (%)",
                            data: streamVsElapsedPercentData,
                            backgroundColor: "rgba(201, 203, 207, 0.8)", // Gray
                            borderColor: "rgba(201, 203, 207, 1)",
                            borderWidth: 2,
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                        },
                        {
                            label: "Kernel vs Elapsed Time (%)",
                            data: kernVsElapsedPercentData,
                            backgroundColor: "rgba(255, 0, 0, 0.8)", // Bright Red
                            borderColor: "rgba(255, 0, 0, 1)",
                            borderWidth: 3,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3], // Custom dash pattern
                            fill: false,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 0, // No points
                            pointHoverRadius: 0, // No hover points
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "ExecTime vs Elapsed Time (%) By Query Steps",
                            font: {
size: 12
                            }
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value === null || value === undefined) return null;
                                    // Extract just the operator name from various label formats
                                    let operatorName = context.dataset.label;
                                    if (operatorName.includes(':')) {
                                        operatorName = operatorName.split(':')[0];
                                    } else if (operatorName.includes(' vs ')) {
                                        operatorName = operatorName.split(' vs ')[0];
                                    }
                                    return `  ${operatorName}: ${value.toFixed(2)}%`;
                                },
                                afterBody: function(tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    const avgKernTime = data.kernTimeData.length > 0 ? 
                                        data.kernTimeData.reduce((sum, d) => sum + d, 0) / data.kernTimeData.length : 0;
                                    const kernElapsedRatio = data.avgElapsedTime > 0 ? (avgKernTime / data.avgElapsedTime) * 100 : 0;
                                    return [
                                        '',
                                        `Kernel vs Elapsed: ${kernElapsedRatio.toFixed(1)}%`,
                                        `Queries: ${data.queryCount}`,
                                        `Elapsed Time: ${data.avgElapsedTime.toFixed(1)}ms`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoomThrottled(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: { display: true, text: "Request Time" },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: { display: true, text: "Percentage (%)" },
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 100,
                        },
                    },
                    interaction: { mode: "index", intersect: false },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.execVsElapsedChart, ctx);
        }

        // Reset timeline chart zoom
        function resetTimelineZoom() {
            if (window.timelineChart) {
                window.timelineChart.resetZoom();
            }
            if (window.filterChart) {
                window.filterChart.resetZoom();
            }
            if (window.queryTypesChart) {
                window.queryTypesChart.resetZoom();
            }
            if (window.durationBucketsChart) {
                window.durationBucketsChart.resetZoom();
            }
            if (window.memoryChart) {
                window.memoryChart.resetZoom();
            }
            if (window.resultCountChart) {
                window.resultCountChart.resetZoom();
            }
            if (window.resultSizeChart) {
                window.resultSizeChart.resetZoom();
            }
            if (window.cpuTimeChart) {
            window.cpuTimeChart.resetZoom();
            }
        if (window.indexScanThroughputChart) {
          window.indexScanThroughputChart.resetZoom();
        }
        if (window.docFetchThroughputChart) {
          window.docFetchThroughputChart.resetZoom();
        }
        if (window.docSizeBubbleChart) {
          window.docSizeBubbleChart.resetZoom();
        }
        if (window.execVsKernelChart) {
          window.execVsKernelChart.resetZoom();
        }
        if (window.execVsServChart) {
          window.execVsServChart.resetZoom();
        }
        if (window.execVsElapsedChart) {
          window.execVsElapsedChart.resetZoom();
        }
        if (window.enhancedOperationsChart) {
          window.enhancedOperationsChart.resetZoom();
        }
        if (window.collectionQueriesChart) {
          window.collectionQueriesChart.resetZoom();
        }
        if (window.parseDurationChart) {
          window.parseDurationChart.resetZoom();
        }
        if (window.planDurationChart) {
          window.planDurationChart.resetZoom();
        }
        if (window.serviceTimeAnalysisLineChart) {
          window.serviceTimeAnalysisLineChart.resetZoom();
        }

            // Reset to original time range
            currentTimeRange = { ...originalTimeRange };
            updateTimeRangeDisplay();
        }

        // Format date to datetime-local format
        function formatDateForInput(date) {
            if (!date) return "";
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            const hours = String(d.getHours()).padStart(2, "0");
            const minutes = String(d.getMinutes()).padStart(2, "0");
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Update the time range display
        function updateTimeRangeDisplay() {
            // Function kept for compatibility but display removed
        }

        // Use current time range in the date pickers
        function useCurrentTimeRange() {
            // Get current x-axis range from 2D timeline charts
            // Priority: durationBucketsChart (first 2D chart) > queryTypesChart > timelineChart (fallback)
            const chart = 
                (window.durationBucketsChart && window.durationBucketsChart.scales?.x && window.durationBucketsChart) ||
                (window.queryTypesChart && window.queryTypesChart.scales?.x && window.queryTypesChart) ||
                (window.timelineChart && window.timelineChart.scales?.x && window.timelineChart) ||
                null;

            if (chart) {
                const xScale = chart.scales.x;
                const currentMin = new Date(xScale.min);
                const currentMax = new Date(xScale.max);

                const startValue = formatDateForInput(currentMin);
                const endValue = formatDateForInput(currentMax);

                const startInput = document.getElementById("start-date");
                const endInput = document.getElementById("end-date");
                startInput.value = startValue;
                endInput.value = endValue;

                // Auto-show Data/Filter section so user can see the updated date range
                showInputSection();

                // Always show the filter reminder banner after updating the pickers
                // Consistent with setTimeRange and manual input changes
                showFilterReminder();
            }
        }

        // Change Y-axis scale for both charts
        function changeYAxisScale() {
            const selectedScale = document.querySelector(
                'input[name="yScale"]:checked'
            ).value;
            const scaleType =
                selectedScale === "logarithmic" ? "logarithmic" : "linear";

            // Update filter chart Y-axis scale (both y and y1)
            if (window.filterChart) {
                window.filterChart.options.scales.y.type = scaleType;
                window.filterChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.filterChart.options.scales.y.beginAtZero = false;
                    window.filterChart.options.scales.y.min = 1; // Avoid log(0)
                    window.filterChart.options.scales.y1.beginAtZero = false;
                    window.filterChart.options.scales.y1.min = 0.001; // Efficiency % can be very small
                } else {
                    window.filterChart.options.scales.y.beginAtZero = true;
                    window.filterChart.options.scales.y1.beginAtZero = true;
                    delete window.filterChart.options.scales.y.min;
                    delete window.filterChart.options.scales.y1.min;
                }
                window.filterChart.update();
            }

            // Update timeline chart Y-axis scale
            if (window.timelineChart) {
                window.timelineChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.timelineChart.options.scales.y.beginAtZero = false;
                    window.timelineChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.timelineChart.options.scales.y.beginAtZero = true;
                    delete window.timelineChart.options.scales.y.min;
                }
                window.timelineChart.update();
            }

            // Update query types chart Y-axis scale
            if (window.queryTypesChart) {
                window.queryTypesChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.queryTypesChart.options.scales.y.beginAtZero = false;
                    window.queryTypesChart.options.scales.y.min = 0.001; // Avoid log(0) for very small durations
                } else {
                    window.queryTypesChart.options.scales.y.beginAtZero = true;
                    delete window.queryTypesChart.options.scales.y.min;
                }
                window.queryTypesChart.update();
            }

            // Update memory chart Y-axis scale (both y and y1)
            if (window.memoryChart) {
                window.memoryChart.options.scales.y.type = scaleType;
                window.memoryChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.memoryChart.options.scales.y.beginAtZero = false;
                    window.memoryChart.options.scales.y.min = 0.001; // Avoid log(0) for small memory values
                    window.memoryChart.options.scales.y1.beginAtZero = false;
                    window.memoryChart.options.scales.y1.min = 0.001; // Avoid log(0) for service time
                } else {
                    window.memoryChart.options.scales.y.beginAtZero = true;
                    window.memoryChart.options.scales.y1.beginAtZero = true;
                    delete window.memoryChart.options.scales.y.min;
                    delete window.memoryChart.options.scales.y1.min;
                }
                window.memoryChart.update();
            }



            // Update result count chart Y-axis scale (both y and y1)
            if (window.resultCountChart) {
                window.resultCountChart.options.scales.y.type = scaleType;
                window.resultCountChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.resultCountChart.options.scales.y.beginAtZero = false;
                    window.resultCountChart.options.scales.y.min = 1; // Avoid log(0)
                    window.resultCountChart.options.scales.y1.beginAtZero = false;
                    window.resultCountChart.options.scales.y1.min = 1; // Avoid log(0)
                } else {
                    window.resultCountChart.options.scales.y.beginAtZero = true;
                    window.resultCountChart.options.scales.y1.beginAtZero = true;
                    delete window.resultCountChart.options.scales.y.min;
                    delete window.resultCountChart.options.scales.y1.min;
                }
                window.resultCountChart.update();
            }

            // Update result size chart Y-axis scale (both y and y1)
            if (window.resultSizeChart) {
                window.resultSizeChart.options.scales.y.type = scaleType;
                window.resultSizeChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.resultSizeChart.options.scales.y.beginAtZero = false;
                    window.resultSizeChart.options.scales.y.min = 0.001; // Avoid log(0) for small sizes
                    window.resultSizeChart.options.scales.y1.beginAtZero = false;
                    window.resultSizeChart.options.scales.y1.min = 0.001; // Avoid log(0) for small sizes
                } else {
                    window.resultSizeChart.options.scales.y.beginAtZero = true;
                    window.resultSizeChart.options.scales.y1.beginAtZero = true;
                    delete window.resultSizeChart.options.scales.y.min;
                    delete window.resultSizeChart.options.scales.y1.min;
                }
                window.resultSizeChart.update();
            }

            // Update CPU time chart Y-axis scale
            if (window.cpuTimeChart) {
                window.cpuTimeChart.options.scales.y.type = scaleType;
                window.cpuTimeChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.cpuTimeChart.options.scales.y.beginAtZero = false;
                    window.cpuTimeChart.options.scales.y.min = 0.001; // Avoid log(0) for small times
                    window.cpuTimeChart.options.scales.y1.beginAtZero = false;
                    window.cpuTimeChart.options.scales.y1.min = 0.001; // Avoid log(0) for percentages
                } else {
                    window.cpuTimeChart.options.scales.y.beginAtZero = true;
                    window.cpuTimeChart.options.scales.y1.beginAtZero = true;
                    delete window.cpuTimeChart.options.scales.y.min;
                    delete window.cpuTimeChart.options.scales.y1.min;
                }
                window.cpuTimeChart.update();
            }

            // Update index scan throughput chart Y-axis scale (both y and y1)
            if (window.indexScanThroughputChart) {
                window.indexScanThroughputChart.options.scales.y.type = scaleType;
                window.indexScanThroughputChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.indexScanThroughputChart.options.scales.y.beginAtZero = false;
                    window.indexScanThroughputChart.options.scales.y.min = 0.001;
                    window.indexScanThroughputChart.options.scales.y1.beginAtZero = false;
                    window.indexScanThroughputChart.options.scales.y1.min = 1; // Avg record count
                } else {
                    window.indexScanThroughputChart.options.scales.y.beginAtZero = true;
                    window.indexScanThroughputChart.options.scales.y1.beginAtZero = true;
                    delete window.indexScanThroughputChart.options.scales.y.min;
                    delete window.indexScanThroughputChart.options.scales.y1.min;
                }
                window.indexScanThroughputChart.update();
            }

            // Update doc fetch throughput chart Y-axis scale (both y and y1)
            if (window.docFetchThroughputChart) {
                window.docFetchThroughputChart.options.scales.y.type = scaleType;
                window.docFetchThroughputChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.docFetchThroughputChart.options.scales.y.beginAtZero = false;
                    window.docFetchThroughputChart.options.scales.y.min = 0.001;
                    window.docFetchThroughputChart.options.scales.y1.beginAtZero = false;
                    window.docFetchThroughputChart.options.scales.y1.min = 1; // Avg docs fetched
                } else {
                    window.docFetchThroughputChart.options.scales.y.beginAtZero = true;
                    window.docFetchThroughputChart.options.scales.y1.beginAtZero = true;
                    delete window.docFetchThroughputChart.options.scales.y.min;
                    delete window.docFetchThroughputChart.options.scales.y1.min;
                }
                window.docFetchThroughputChart.update();
            }

            // Update document size bubble chart Y-axis scale
            if (window.docSizeBubbleChart) {
                window.docSizeBubbleChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.docSizeBubbleChart.options.scales.y.beginAtZero = false;
                    window.docSizeBubbleChart.options.scales.y.min = 1;
                } else {
                    window.docSizeBubbleChart.options.scales.y.beginAtZero = true;
                    delete window.docSizeBubbleChart.options.scales.y.min;
                }
                window.docSizeBubbleChart.update();
            }

            // Update execution vs kernel chart Y-axis scale
            if (window.execVsKernelChart) {
                window.execVsKernelChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.execVsKernelChart.options.scales.y.beginAtZero = false;
                    window.execVsKernelChart.options.scales.y.min = 0.001; // Avoid log(0) for small percentages
                } else {
                    window.execVsKernelChart.options.scales.y.beginAtZero = true;
                    delete window.execVsKernelChart.options.scales.y.min;
                }
                window.execVsKernelChart.update();
            }

            // Update execution vs service chart Y-axis scale (both y and y1)
            if (window.execVsServChart) {
                window.execVsServChart.options.scales.y.type = scaleType;
                window.execVsServChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.execVsServChart.options.scales.y.beginAtZero = false;
                    window.execVsServChart.options.scales.y.min = 0.001; // Avoid log(0) for small percentages
                    window.execVsServChart.options.scales.y1.beginAtZero = false;
                    window.execVsServChart.options.scales.y1.min = 0.001; // Avoid log(0) for servTime
                } else {
                    window.execVsServChart.options.scales.y.beginAtZero = true;
                    window.execVsServChart.options.scales.y1.beginAtZero = true;
                    delete window.execVsServChart.options.scales.y.min;
                    delete window.execVsServChart.options.scales.y1.min;
                }
                window.execVsServChart.update();
            }

            // Update execution vs elapsed chart Y-axis scale
            if (window.execVsElapsedChart) {
                window.execVsElapsedChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.execVsElapsedChart.options.scales.y.beginAtZero = false;
                    window.execVsElapsedChart.options.scales.y.min = 0.001; // Avoid log(0) for small percentages
                } else {
                    window.execVsElapsedChart.options.scales.y.beginAtZero = true;
                    delete window.execVsElapsedChart.options.scales.y.min;
                }
                window.execVsElapsedChart.update();
            }

            // Update enhanced operations chart Y-axis scale (both y and y1)
            if (window.enhancedOperationsChart) {
                window.enhancedOperationsChart.options.scales.y.type = scaleType;
                window.enhancedOperationsChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.enhancedOperationsChart.options.scales.y.beginAtZero = false;
                    window.enhancedOperationsChart.options.scales.y.min = 1; // Avoid log(0)
                    window.enhancedOperationsChart.options.scales.y1.beginAtZero = false;
                    window.enhancedOperationsChart.options.scales.y1.min = 1; // Avoid log(0)
                } else {
                    window.enhancedOperationsChart.options.scales.y.beginAtZero = true;
                    window.enhancedOperationsChart.options.scales.y1.beginAtZero = true;
                    delete window.enhancedOperationsChart.options.scales.y.min;
                    delete window.enhancedOperationsChart.options.scales.y1.min;
                }
                window.enhancedOperationsChart.update();
            }

            // Update collection queries chart Y-axis scale
            if (window.collectionQueriesChart) {
                window.collectionQueriesChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.collectionQueriesChart.options.scales.y.beginAtZero = false;
                    window.collectionQueriesChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.collectionQueriesChart.options.scales.y.beginAtZero = true;
                    delete window.collectionQueriesChart.options.scales.y.min;
                }
                window.collectionQueriesChart.update();
            }

            // Update service time analysis line chart Y-axis scale
            if (window.serviceTimeAnalysisLineChart) {
                window.serviceTimeAnalysisLineChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.serviceTimeAnalysisLineChart.options.scales.y.beginAtZero = false;
                    window.serviceTimeAnalysisLineChart.options.scales.y.min = 0.001; // Avoid log(0) for small times
                } else {
                    window.serviceTimeAnalysisLineChart.options.scales.y.beginAtZero = true;
                    delete window.serviceTimeAnalysisLineChart.options.scales.y.min;
                }
                window.serviceTimeAnalysisLineChart.update();
            }

            // Note: parseDurationChart and planDurationChart use fixed y-axis positions
            // and do not respond to the scale toggle, similar to durationBucketsChart

        }

        // Flag to prevent lazy tab loading during time grouping changes
        let isChangingTimeGrouping = false;
        
        // Change time grouping for all charts
        function changeTimeGrouping() {
            Logger.trace(`üîç changeTimeGrouping() called`);
            
            // Set flag to prevent lazy tab loading
            isChangingTimeGrouping = true;
            
            // Use the currently filtered data from the last parse
            let requests = [];
            
            // First try to use window.currentFilteredRequests (already filtered)
            if (window.currentFilteredRequests && window.currentFilteredRequests.length > 0) {
                requests = window.currentFilteredRequests;
                Logger.debug(`Time grouping change: Using current filtered data: ${requests.length} requests`);
            } else if (originalRequests.length > 0) {
                // Fallback: re-apply filters to original data
                const startDateInput = document.getElementById("start-date");
                const endDateInput = document.getElementById("end-date");
                const startDate = startDateInput.value
                    ? new Date(startDateInput.value)
                    : null;
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : null;
                
                Logger.debug(`Time grouping change: Original requests: ${originalRequests.length}, Date range: ${startDate} to ${endDate}`);
                
                requests = filterRequestsByDateRange(
                    originalRequests,
                    startDate,
                    endDate
                );
                
                Logger.debug(`After date filtering: ${requests.length} requests`);

                // Apply SQL filter and system query exclusion
                requests = filterSystemQueries(requests);
                
                Logger.debug(`After SQL/system filtering: ${requests.length} requests`);
            } else {
                // Fallback to parsing JSON if no original data
                const jsonInput = document.getElementById("json-input").value;
                if (!jsonInput.trim()) return;

                try {
                    const data = JSON.parse(jsonInput);
                    if (Array.isArray(data)) {
                        requests = data.map((item) => ({
                            ...item.completed_requests,
                            plan: item.plan
                                ? typeof item.plan === "string"
                                    ? JSON.parse(item.plan)
                                    : item.plan
                                : null,
                        }));
                    }

                    // Apply SQL filter and system query exclusion to parsed data
                    requests = filterSystemQueries(requests);
                } catch (e) {
                    console.error("Error parsing JSON for time grouping change:", e);
                    return;
                }
            }

            try {
                // Update the optimizer label to show current optimization
                updateOptimizerLabel(requests);

                // Clear any pending chart tasks from previous lazy loading
                resetChartLoadingCounters();

                // Destroy only Timeline tab charts before regenerating
                destroyTimelineCharts();

                // Regenerate all charts with new time grouping
                generateFilterChart(requests);
                generateTimelineChart(requests);
                
                // Clear flag after async chart creation completes
                setTimeout(() => {
                    isChangingTimeGrouping = false;
                    Logger.trace(`üîç Time grouping change complete - flag cleared`);
                }, 1000);
            } catch (e) {
                console.error("Error regenerating charts:", e);
                isChangingTimeGrouping = false;
            }
        }

        // Global data stores now imported from data-layer.js via window
        // Access via: window.originalRequests, window.statementStore, window.analysisStatementStore

        // Parse Couchbase datetime to JavaScript Date
        function parseCouchbaseDateTime(dateTimeStr) {
            if (!dateTimeStr) return null;
            // Handle various Couchbase datetime formats
            const isoString = dateTimeStr.replace(" ", "T");
            return new Date(isoString);
        }

        // Convert requestTime string to Date in selected timezone for chart display
        function getChartDate(requestTime) {
            if (!requestTime) return null;
            const date = parseCouchbaseDateTime(requestTime);
            if (!date || isNaN(date.getTime())) return null;
            
            Logger.trace(`[getChartDate] Input: ${requestTime}, Parsed: ${date.toISOString()}, currentTimezone=${currentTimezone}`);
            
            // If no timezone selected or UTC, return as-is
            if (!currentTimezone || currentTimezone === "UTC") {
                Logger.trace(`[getChartDate] Returning UTC: ${date.toISOString()}`);
                return date;
            }
            
            // Convert to selected timezone for display
            const converted = convertToTimezone(date, currentTimezone);
            Logger.trace(`[getChartDate] Converted to ${currentTimezone}: ${converted ? converted.toISOString() : 'null'}`);
            return converted;
        }

        // Convert Date to specified timezone and return Date object
        function convertToTimezone(date, timezone) {
            if (!date || isNaN(date.getTime())) return null;
            
            // If timezone is UTC or not specified, return original date
            if (!timezone || timezone === "UTC") {
                return date;
            }
            
            try {
                // Convert to target timezone string, then parse back to Date
                const options = {
                    timeZone: timezone,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                };
                
                const formatter = new Intl.DateTimeFormat('en-US', options);
                const parts = formatter.formatToParts(date);
                
                const getValue = (type) => parts.find(p => p.type === type)?.value;
                const year = getValue('year');
                const month = getValue('month');
                const day = getValue('day');
                const hour = getValue('hour');
                const minute = getValue('minute');
                const second = getValue('second');
                
                // Create new date in local time zone with the converted values
                return new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
            } catch (e) {
                console.error("Error converting timezone:", e);
                return date; // Return original date on error
            }
        }

        // Convert Date to datetime-local input format in selected timezone
        // Update the timezone label next to date pickers
        function updateDatePickerTimezoneLabel() {
            const label = document.getElementById("date-picker-timezone-label");
            if (label) {
                const tz = currentTimezone || "UTC";
                // Get abbreviated timezone name (e.g., "PST", "EDT", "UTC")
                try {
                    const formatter = new Intl.DateTimeFormat('en-US', {
                        timeZone: tz,
                        timeZoneName: 'short'
                    });
                    const parts = formatter.formatToParts(new Date());
                    const tzAbbr = parts.find(part => part.type === 'timeZoneName')?.value || tz;
                    label.textContent = `(${tzAbbr})`;
                } catch (e) {
                    // Fallback to full timezone name if abbreviation fails
                    label.textContent = `(${tz})`;
                }
            }
        }
        
        function toDateTimeLocal(date, timezone) {
            if (!date || isNaN(date.getTime())) return "";
            
            // Use currentTimezone if timezone not specified, default to UTC if still undefined
            const tz = timezone || currentTimezone || "UTC";
            
            try {
                // Convert to target timezone (or return original if UTC)
                const convertedDate = convertToTimezone(date, tz);
                if (!convertedDate || isNaN(convertedDate.getTime())) {
                    // Fallback to original date if conversion fails
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, "0");
                    const day = String(date.getDate()).padStart(2, "0");
                    const hours = String(date.getHours()).padStart(2, "0");
                    const minutes = String(date.getMinutes()).padStart(2, "0");
                    const seconds = String(date.getSeconds()).padStart(2, "0");
                    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
                }
                
                const year = convertedDate.getFullYear();
                const month = String(convertedDate.getMonth() + 1).padStart(2, "0");
                const day = String(convertedDate.getDate()).padStart(2, "0");
                const hours = String(convertedDate.getHours()).padStart(2, "0");
                const minutes = String(convertedDate.getMinutes()).padStart(2, "0");
                const seconds = String(convertedDate.getSeconds()).padStart(2, "0");
                return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
            } catch (e) {
                console.error("Error in toDateTimeLocal:", e);
                // Fallback to simple formatting without timezone conversion
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, "0");
                const day = String(date.getDate()).padStart(2, "0");
                const hours = String(date.getHours()).padStart(2, "0");
                const minutes = String(date.getMinutes()).padStart(2, "0");
                const seconds = String(date.getSeconds()).padStart(2, "0");
                return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
            }
        }

        // Filter requests by date range
        function filterRequestsByDateRange(requests, startDate, endDate) {
            if (!startDate && !endDate) return requests;

            return requests.filter((request) => {
                const requestDate = parseCouchbaseDateTime(request.requestTime);
                if (!requestDate) return true; // Include requests with invalid dates

                if (startDate && requestDate < startDate) return false;
                if (endDate && requestDate > endDate) return false;
                return true;
            });
        }

        // Calculate timespan string from requests
        function calculateTimespan(requests) {
            if (!requests || requests.length === 0) return "";
            
            const times = requests
                .map(r => new Date(r.requestTime))
                .filter(d => !isNaN(d.getTime()));
            
            if (times.length === 0) return "";
            
            const minTime = Math.min(...times.map(d => d.getTime()));
            const maxTime = Math.max(...times.map(d => d.getTime()));
            const spanMs = maxTime - minTime;
            
            if (spanMs === 0) return "over 0 seconds";
            
            const seconds = Math.floor(spanMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            const weeks = Math.floor(days / 7);
            const months = Math.floor(days / 30);
            
            if (months > 0) return `over ${months} ${months === 1 ? 'month' : 'months'}`;
            if (weeks > 0) return `over ${weeks} ${weeks === 1 ? 'week' : 'weeks'}`;
            if (days > 0) return `over ${days} ${days === 1 ? 'day' : 'days'}`;
            if (hours > 0) return `over ${hours} ${hours === 1 ? 'hour' : 'hours'}`;
            if (minutes > 0) return `over ${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`;
            return `over ${seconds} ${seconds === 1 ? 'second' : 'seconds'}`;
        }

        // Update filter info display
        function updateFilterInfo(originalCount, filteredCount, requests = null) {
            const filterInfo = document.getElementById("filter-info");
            const queriesBadge = document.getElementById("queries-fixed-badge");
            const timespan = requests ? calculateTimespan(requests) : "";
            const timespanText = timespan ? `, ${timespan}` : "";
            
            if (originalCount === filteredCount) {
                const html = `Showing all <strong>${originalCount}</strong> queries${timespanText}`;
                if (filterInfo) filterInfo.innerHTML = html;
                if (queriesBadge) queriesBadge.innerHTML = html;
            } else {
                const html = `Showing <strong>${filteredCount}</strong> of <strong>${originalCount}</strong> queries${timespanText}`;
                if (filterInfo) filterInfo.innerHTML = html;
                if (queriesBadge) queriesBadge.innerHTML = html;
            }
        }

        // Generate Dashboard Charts
        function generateDashboardCharts(requests) {
            Logger.trace(`üîç generateDashboardCharts() called from:`, new Error().stack);
            Logger.debug(`[generateDashboardCharts] Called with ${requests.length} requests, currentTimezone=${currentTimezone}`);
            
            generatePrimaryScanChart(requests);
            generateStateChart(requests);
            generateStatementTypeChart(requests);
            generateScanConsistencyChart(requests);
            generateElapsedTimeChart(requests);
            generateQueryPatternChart(requests);
            generateUserCountTable(requests);
            generateIndexCountTable(requests);
            
            Logger.debug(`[generateDashboardCharts] About to call updateInsights`);
            updateInsights(requests);
            Logger.debug(`[generateDashboardCharts] Completed updateInsights`);
            
            // Build Index/Query Flow data in background for AI analyzer
            Logger.debug(`[generateDashboardCharts] Building flow data for AI`);
            if (typeof processIndexQueryData === 'function') {
                processIndexQueryData(requests);
            }
        }

        // Check if a query uses primary index by analyzing the plan (optimized with cache)
        function usesPrimaryIndex(request) {
            if (!request.plan) return false;

            // Check if we have cached metadata first
            if (request._planMetadata) {
                return request._planMetadata.usesPrimary;
            }

            try {
                const planObj =
                    typeof request.plan === "string"
                        ? JSON.parse(request.plan)
                        : request.plan;

                // Check plan cache
                if (planStatsCache.has(planObj)) {
                    return planStatsCache.get(planObj).usesPrimary;
                }

                return checkOperatorForPrimary(planObj);
            } catch (e) {
                return false;
            }
        }

        // Determine the index type used: 'Primary', 'Sequential Scan', or 'GSI'
        function getIndexType(request) {
            if (!request.plan) return 'GSI';

            try {
                const planObj =
                    typeof request.plan === "string"
                        ? JSON.parse(request.plan)
                        : request.plan;
                return checkOperatorForIndexType(planObj);
            } catch (e) {
                return 'GSI';
            }
        }

        // Recursively check operators to determine index type
        function checkOperatorForIndexType(operator) {
            if (!operator) return 'GSI';

            // Check for sequential scan first (most specific)
            if (operator.using === "sequentialscan") {
                return 'Sequential Scan';
            }

            // Check for primary index indicators
            if (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                (operator.spans && operator.spans.length === 0)
            ) {
                return 'Primary';
            }

            // Recursively check child operators
            if (operator["~child"]) {
                const childType = checkOperatorForIndexType(operator["~child"]);
                if (childType !== 'GSI') return childType;
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                for (const child of operator["~children"]) {
                    const childType = checkOperatorForIndexType(child);
                    if (childType !== 'GSI') return childType;
                }
            }
            if (operator.input) {
                const inputType = checkOperatorForIndexType(operator.input);
                if (inputType !== 'GSI') return inputType;
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                for (const input of operator.inputs) {
                    const inputType = checkOperatorForIndexType(input);
                    if (inputType !== 'GSI') return inputType;
                }
            }
            if (operator.left) {
                const leftType = checkOperatorForIndexType(operator.left);
                if (leftType !== 'GSI') return leftType;
            }
            if (operator.right) {
                const rightType = checkOperatorForIndexType(operator.right);
                if (rightType !== 'GSI') return rightType;
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                const firstType = checkOperatorForIndexType(operator.first);
                if (firstType !== 'GSI') return firstType;
            }
            if (operator.second) {
                const secondType = checkOperatorForIndexType(operator.second);
                if (secondType !== 'GSI') return secondType;
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                for (const scan of operator.scans) {
                    const scanType = checkOperatorForIndexType(scan);
                    if (scanType !== 'GSI') return scanType;
                }
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                const scanType = checkOperatorForIndexType(operator.scan);
                if (scanType !== 'GSI') return scanType;
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                for (const subquery of operator["~subqueries"]) {
                    if (subquery.executionTimings) {
                        const subType = checkOperatorForIndexType(subquery.executionTimings);
                        if (subType !== 'GSI') return subType;
                    }
                }
            }

            return 'GSI';
        }

        // Recursively check operators for primary index usage
        function checkOperatorForPrimary(operator) {
            if (!operator) return false;

            // Check for primary index indicators
            if (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                operator.using === "sequentialscan" ||
                (operator.spans && operator.spans.length === 0)
            ) {
                return true;
            }

            // Recursively check child operators
            if (operator["~child"] && checkOperatorForPrimary(operator["~child"]))
                return true;
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                for (const child of operator["~children"]) {
                    if (checkOperatorForPrimary(child)) return true;
                }
            }
            if (operator.input && checkOperatorForPrimary(operator.input))
                return true;
            if (operator.inputs && Array.isArray(operator.inputs)) {
                for (const input of operator.inputs) {
                    if (checkOperatorForPrimary(input)) return true;
                }
            }
            if (operator.left && checkOperatorForPrimary(operator.left))
                return true;
            if (operator.right && checkOperatorForPrimary(operator.right))
                return true;
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first && checkOperatorForPrimary(operator.first))
                return true;
            if (operator.second && checkOperatorForPrimary(operator.second))
                return true;
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                for (const scan of operator.scans) {
                    if (checkOperatorForPrimary(scan)) return true;
                }
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan && checkOperatorForPrimary(operator.scan))
                return true;
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                for (const subquery of operator["~subqueries"]) {
                    if (
                        subquery.executionTimings &&
                        checkOperatorForPrimary(subquery.executionTimings)
                    )
                        return true;
                }
            }

            return false;
        }

        // Primary Scan Used Donut Chart
        function generatePrimaryScanChart(requests) {
            const scanCounts = { 'Primary': 0, 'Sequential Scan': 0, 'GSI': 0 };

            requests.forEach((request) => {
                const indexType = getIndexType(request);
                scanCounts[indexType]++;
            });

            const total = scanCounts['Primary'] + scanCounts['Sequential Scan'] + scanCounts['GSI'];

            // Show/hide warning div based on whether primary scans are detected
            const warningDiv = document.getElementById("primary-scan-warning");
            if (scanCounts['Primary'] > 0) {
                warningDiv.style.display = "flex";
            } else {
                warningDiv.style.display = "none";
            }

            const ctx = document
                .getElementById("primary-scan-chart")
                .getContext("2d");
            if (window.primaryScanChart) {
                window.primaryScanChart.destroy();
            }

            window.primaryScanChart = new Chart(ctx, {
                type: "doughnut",
                data: {
                    labels: ["Primary", "Sequential Scan", "GSI"],
                    datasets: [
                        {
                            data: [scanCounts['Primary'], scanCounts['Sequential Scan'], scanCounts['GSI']],
                            backgroundColor: ["#dc3545", "#fd7e14", "#f8f9fa"],
                            borderColor: ["#dc3545", "#fd7e14", "#dee2e6"],
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: "60%",
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const d = chart.data;
                                    return d.labels.map((label, index) => ({
                                        text: label + " (" + (typeof d.datasets[0].data[index] === 'number' ? d.datasets[0].data[index].toLocaleString() : d.datasets[0].data[index]) + ")",
                                        fillStyle: d.datasets[0].backgroundColor[index],
                                        strokeStyle: d.datasets[0].borderColor ? d.datasets[0].borderColor[index] : d.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                        datalabels: {
                            display: true,
                            color: function (context) {
                                // White text for Primary (red) and Sequential Scan (orange), dark text for GSI (light gray)
                                return context.dataIndex <= 1 ? "white" : "#6c757d";
                            },
                            font: {
                                weight: "bold",
                                size: 14,
                            },
                            formatter: function (value, context) {
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return percent + "%";
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Query State Pie Chart
        function drawPieLabelsWithLeaders(chart, total, options) {
    const ctx = chart.ctx;
    const dataset = chart.data.datasets[0];
    const meta = chart.getDatasetMeta(0);
    const opts = Object.assign({
        insideThreshold: 10,
        font: 'bold 14px Arial',
        textColor: '#111', // outside label color
        leaderLineLength: 12,
        labelPadding: 4,
        percentDecimals: 1,
        insideTextColor: null, // string or (index, bgColor) => string
    }, options || {});

    function parseRGB(colorStr) {
        if (!colorStr || typeof colorStr !== 'string') return null;
        if (colorStr[0] === '#') {
            let r, g, b;
            if (colorStr.length === 4) {
                r = parseInt(colorStr[1] + colorStr[1], 16);
                g = parseInt(colorStr[2] + colorStr[2], 16);
                b = parseInt(colorStr[3] + colorStr[3], 16);
                return { r, g, b };
            }
            if (colorStr.length === 7) {
                r = parseInt(colorStr.slice(1, 3), 16);
                g = parseInt(colorStr.slice(3, 5), 16);
                b = parseInt(colorStr.slice(5, 7), 16);
                return { r, g, b };
            }
            return null;
        }
        const m = colorStr.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
        if (m) return { r: +m[1], g: +m[2], b: +m[3] };
        return null;
    }

    function getContrastText(bgColor, fallback) {
        const rgb = parseRGB(bgColor);
        if (!rgb) return fallback || '#fff';
        const brightness = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b; // 0..255
        return brightness > 180 ? '#111' : '#fff';
    }

    ctx.save();
    ctx.font = opts.font;

    dataset.data.forEach((value, index) => {
        if (!value || total <= 0) return;
        const percent = (value / total) * 100;
        const metaEntry = meta.data[index];
        if (!metaEntry || typeof metaEntry.getProps !== 'function') return;

        const p = metaEntry.getProps(['x','y','startAngle','endAngle','outerRadius','innerRadius'], true);
        const angle = (p.startAngle + p.endAngle) / 2;
        const midRadius = (p.innerRadius + p.outerRadius) / 2;
        const label = percent.toFixed(opts.percentDecimals) + '%';

        // Resolve slice color for contrast and leader stroke
        const bgColor = Array.isArray(dataset.backgroundColor)
            ? dataset.backgroundColor[index]
            : dataset.backgroundColor;

        if (percent >= opts.insideThreshold) {
            const x = p.x + Math.cos(angle) * midRadius;
            const y = p.y + Math.sin(angle) * midRadius;
            const insideColor = typeof opts.insideTextColor === 'function'
                ? opts.insideTextColor(index, bgColor)
                : (opts.insideTextColor || getContrastText(bgColor, '#fff'));
            ctx.fillStyle = insideColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        } else {
            const r = p.outerRadius;
            const x0 = p.x + Math.cos(angle) * r;
            const y0 = p.y + Math.sin(angle) * r;
            const x1 = p.x + Math.cos(angle) * (r + opts.leaderLineLength);
            const y1 = p.y + Math.sin(angle) * (r + opts.leaderLineLength);
            const alignRight = Math.cos(angle) >= 0;
            const x2 = x1 + (alignRight ? 16 : -16);
            const y2 = y1;

            const strokeStyle = bgColor || '#666';
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.fillStyle = opts.textColor;
            ctx.textAlign = alignRight ? 'left' : 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x2 + (alignRight ? opts.labelPadding : -opts.labelPadding), y2);
        }
    });

    ctx.restore();
}

function generateStateChart(requests) {
            const stateCounts = {};

            requests.forEach((request) => {
                const state = request.state || "Unknown";
                stateCounts[state] = (stateCounts[state] || 0) + 1;
            });

            const total = Object.values(stateCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(stateCounts);
            const data = Object.values(stateCounts);

            // Semantic colors based on query state
            const colors = labels.map(state => {
                const lowerState = state.toLowerCase();
                switch (lowerState) {
                    case "completed":
                    case "success":
                        return "#28a745"; // Green - success
                    case "fatal":
                    case "errors":
                        return "#dc3545"; // Red - error
                    case "timeout":
                        return "#fd7e14"; // Orange - timeout
                    case "stopped":
                    case "cancelled":
                        return "#6c757d"; // Gray - stopped/cancelled
                    case "running":
                        return "#007bff"; // Blue - in progress
                    default:
                        return "#6f42c1"; // Purple - unknown/other
                }
            });

            const ctx = document.getElementById("state-chart").getContext("2d");
            if (window.stateChart) {
                window.stateChart.destroy();
            }

            window.stateChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label + " (" + (typeof data.datasets[0].data[index] === 'number' ? data.datasets[0].data[index].toLocaleString() : data.datasets[0].data[index]) + ")",
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Derive statement type from SQL statement text
        function deriveStatementType(statement) {
            if (!statement || typeof statement !== "string") {
                return "UNKNOWN";
            }

            // Decode any HTML entities and strip any HTML-like tags (e.g., <ud>...)</ud>)
            try {
                const tmp = document.createElement('div');
                tmp.innerHTML = statement;
                statement = (tmp.textContent || tmp.innerText || "");
            } catch (e) { /* no-op */ }
            // Remove any residual tags and collapse whitespace
            const cleaned = statement.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');

            const trimmed = cleaned.trim().toUpperCase();
            if (!trimmed) {
                return "UNKNOWN";
            }

            // Handle common multi-word statement types first
            if (trimmed.startsWith("CREATE INDEX")) return "CREATE_INDEX";
            if (trimmed.startsWith("DROP INDEX")) return "DROP_INDEX";
            if (trimmed.startsWith("ALTER INDEX")) return "ALTER_INDEX";
            if (trimmed.startsWith("BUILD INDEX")) return "BUILD_INDEX";

            // Get first word for other statement types
            const firstWord = trimmed.split(/\s+/)[0];
            return firstWord;
        }

        // Statement Type Pie Chart
        function generateStatementTypeChart(requests) {
            const typeCounts = {};

            requests.forEach((request) => {
                // First try the statementType field, then derive from statement or preparedText
                const type = request.statementType || deriveStatementType(request.statement || request.preparedText) || "UNKNOWN";
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            });

            const total = Object.values(typeCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(typeCounts);
            const data = Object.values(typeCounts);
            const colors = [
                "#ff6384",
                "#36a2eb",
                "#ffce56",
                "#4bc0c0",
                "#9966ff",
                "#ff9f40",
                "#c9cbcf",
                "#4bc0c0",
            ];

            const ctx = document
                .getElementById("statement-type-chart")
                .getContext("2d");
            if (window.statementTypeChart) {
                window.statementTypeChart.destroy();
            }

            window.statementTypeChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label + " (" + (typeof data.datasets[0].data[index] === 'number' ? data.datasets[0].data[index].toLocaleString() : data.datasets[0].data[index]) + ")",
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Scan Consistency Pie Chart
        function generateScanConsistencyChart(requests) {
            const consistencyCounts = {};

            requests.forEach((request) => {
                const consistency = request.scanConsistency || "unbounded";
                consistencyCounts[consistency] = (consistencyCounts[consistency] || 0) + 1;
            });

            const total = Object.values(consistencyCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(consistencyCounts);
            const data = Object.values(consistencyCounts);

            // Specific colors for scan consistency types
            const colors = labels.map(consistency => {
                const lowerConsistency = consistency.toLowerCase();
                switch (lowerConsistency) {
                    case "unbounded":
                        return "#007bff"; // Blue
                    case "scan_plus":
                        return "#28a745"; // Green
                    case "request_plus":
                        return "#fd7e14"; // Orange
                    default:
                        return "#6c757d"; // Gray for unknown
                }
            });

            const ctx = document
                .getElementById("scan-consistency-chart")
                .getContext("2d");
            if (window.scanConsistencyChart) {
                window.scanConsistencyChart.destroy();
            }

            window.scanConsistencyChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors,
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label + " (" + (typeof data.datasets[0].data[index] === 'number' ? data.datasets[0].data[index].toLocaleString() : data.datasets[0].data[index]) + ")",
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Elapsed Time Distribution Bar Chart
        function drawBarValueLabels(chart, options) {
    const ctx = chart.ctx;
    const dataset = chart.data.datasets[0];
    const meta = chart.getDatasetMeta(0);
    const opts = Object.assign({
        font: 'bold 14px Arial',
        color: '#111',
        yOffset: 4,
        formatter: (v) => (typeof v === 'number' ? v.toLocaleString() : v),
    }, options || {});

    if (!dataset || !meta) return;

    ctx.save();
    ctx.font = opts.font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = opts.color;

    meta.data.forEach((barEl, i) => {
        if (!barEl) return;
        const v = dataset.data[i];
        if (v == null || v === 0) return;
        const p = typeof barEl.getProps === 'function'
            ? barEl.getProps(['x','y','base'], true)
            : { x: barEl.x, y: barEl.y, base: barEl.base };
        const x = p.x;
        const y = Math.min(p.y, p.base) - opts.yOffset; // place above the bar
        const text = opts.formatter(v);
        ctx.fillText(text, x, y);
    });

    ctx.restore();
}

function generateElapsedTimeChart(requests) {
            const timeBuckets = {
                "0-1s": 0,
                "1-2s": 0,
                "2-5s": 0,
                "5-10s": 0,
                "10-20s": 0,
                "20-40s": 0,
                "40-60s": 0,
                "60-90s": 0,
                "90s-5m": 0,
                "5-15m": 0,
                "15-30m": 0,
                "30-60m": 0,
                ">60m": 0,
            };

            requests.forEach((request) => {
                const elapsed = (request.elapsedTimeMs || 0) / 1000; // Convert ms to seconds

                if (elapsed <= 1) timeBuckets["0-1s"]++;
                else if (elapsed <= 2) timeBuckets["1-2s"]++;
                else if (elapsed <= 5) timeBuckets["2-5s"]++;
                else if (elapsed <= 10) timeBuckets["5-10s"]++;
                else if (elapsed <= 20) timeBuckets["10-20s"]++;
                else if (elapsed <= 40) timeBuckets["20-40s"]++;
                else if (elapsed <= 60) timeBuckets["40-60s"]++;
                else if (elapsed <= 90) timeBuckets["60-90s"]++;
                else if (elapsed <= 300) timeBuckets["90s-5m"]++;
                else if (elapsed <= 900) timeBuckets["5-15m"]++;
                else if (elapsed <= 1800) timeBuckets["15-30m"]++;
                else if (elapsed <= 3600) timeBuckets["30-60m"]++;
                else timeBuckets[">60m"]++;
            });

            const ctx = document
                .getElementById("elapsed-time-chart")
                .getContext("2d");
            if (window.elapsedTimeChart) {
                window.elapsedTimeChart.destroy();
            }

            window.elapsedTimeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(timeBuckets),
                    datasets: [
                        {
                            label: "Query Count",
                            data: Object.values(timeBuckets),
                            backgroundColor: "#36a2eb",
                            borderColor: "#36a2eb",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: { top: 16 }
                    },
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grace: '15%',
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Elapsed Time Range",
                            },
                        },
                    },
                },
                    plugins: [
                            {
                                       afterDatasetsDraw: function (chart) {
                                    drawBarValueLabels(chart, { font: 'bold 14px Arial' });
                        },
                    },
                ],
            });
        }
 
        // Helper: Detect query patterns for a single request (Issue #202 - single source of truth)
        function detectQueryPatterns(request) {
            const statement = request.statement || request.preparedText || "";
            const upperStatement = statement.toUpperCase();
            const detectedPatterns = [];

            // No WHERE: if this is an EXECUTE, check the preparedText (actual statement) for WHERE/filters
            const stmtForFilter = (upperStatement.startsWith("EXECUTE") && request.preparedText)
                ? request.preparedText
                : statement;
            if (!hasFilteringMechanism(stmtForFilter)) {
                detectedPatterns.push("No WHERE");
            }

            // GROUP BY
            if (upperStatement.includes(" GROUP BY ")) {
                detectedPatterns.push("GROUP BY");
            }

            // ORDER BY
            if (upperStatement.includes(" ORDER BY ")) {
                detectedPatterns.push("ORDER BY");
            }

            // USE INDEX
            if (upperStatement.includes("USE INDEX")) {
                detectedPatterns.push("USE INDEX");
            }

            // USE KEYS
            if (upperStatement.includes("USE KEYS")) {
                detectedPatterns.push("USE KEYS");
            }

            // JOIN
            if (upperStatement.includes(" JOIN ")) {
                detectedPatterns.push("JOIN");
            }

            // NEST
            if (upperStatement.includes(" NEST ")) {
                detectedPatterns.push("NEST");
            }

            // UNNEST
            if (upperStatement.includes(" UNNEST ")) {
                detectedPatterns.push("UNNEST");
            }

            // OFFSET
            if (upperStatement.includes(" OFFSET ")) {
                detectedPatterns.push("OFFSET");
            }

            // SEARCH
            if (upperStatement.includes(" SEARCH(")) {
                detectedPatterns.push("SEARCH");
            }

            // WITH (ensure it's a SQL clause, not a backticked field name)
            if ((upperStatement.startsWith("WITH ") || upperStatement.includes(" WITH ")) && !upperStatement.includes("`WITH`")) {
                detectedPatterns.push("WITH");
            }

            // LET
            if (upperStatement.includes(" LET ")) {
                detectedPatterns.push("LET");
            }

            // ARRAY QUERY - detects array query patterns with ANY/EVERY operators per Couchbase docs:
            // 1. ANY + IN/WITHIN + SATISFIES + END pattern
            // 2. EVERY + IN/WITHIN + SATISFIES + END pattern
            // 3. ANY AND EVERY + IN/WITHIN + SATISFIES + END pattern
            // Note: UNNEST is counted separately above
            const hasAnySatisfies = (
                upperStatement.includes(" ANY ") &&
                upperStatement.includes(" SATISFIES ") &&
                (upperStatement.includes(" END ") || upperStatement.endsWith(" END"))
            );
            const hasEverySatisfies = (
                upperStatement.includes(" EVERY ") &&
                !upperStatement.includes("ANY AND EVERY") &&
                upperStatement.includes(" SATISFIES ") &&
                (upperStatement.includes(" END ") || upperStatement.endsWith(" END"))
            );
            const hasAnyAndEvery = (
                upperStatement.includes("ANY AND EVERY") &&
                upperStatement.includes(" SATISFIES ") &&
                (upperStatement.includes(" END ") || upperStatement.endsWith(" END"))
            );
            
            if (hasAnySatisfies || hasEverySatisfies || hasAnyAndEvery) {
                detectedPatterns.push("ARRAY QUERY");
            }

            // SELECT * (matches SELECT * FROM or SELECT *, field FROM, but not qualified wildcards like c.*)
            const selectStarMatch = upperStatement.match(/SELECT\s+\*[\s,]/);
            if (selectStarMatch) {
                detectedPatterns.push("SELECT *");
            }

            // LIKE (ensure it's an operator, not a backticked field name)
            if (upperStatement.includes(" LIKE ") && !upperStatement.includes("`LIKE`")) {
                detectedPatterns.push("LIKE");
            }

            // COUNT
            if (upperStatement.includes(" COUNT(")) {
                detectedPatterns.push("COUNT");
            }

            // DISTINCT
            if (upperStatement.includes(" DISTINCT ")) {
                detectedPatterns.push("DISTINCT");
            }

            // REGEX
            if (upperStatement.includes("REGEXP_") || /REGEX\s*\(/i.test(statement)) {
                detectedPatterns.push("REGEX");
            }

            // EXECUTE
            if (upperStatement.startsWith("EXECUTE")) {
                detectedPatterns.push("EXECUTE");
            }

            // LIMIT
            if (upperStatement.includes(" LIMIT ")) {
                detectedPatterns.push("LIMIT");
            }

            // UNION
            if (upperStatement.includes(" UNION ")) {
                detectedPatterns.push("UNION");
            }

            return detectedPatterns;
        }
 
        // Generate Query Pattern Chart
        function generateQueryPatternChart(requests) {
            const patternCounts = {
                // Far left
                WITH: 0,
                EXECUTE: 0,
                "SELECT *": 0,
                COUNT: 0,
                DISTINCT: 0,
                // Left-center
                "USE INDEX": 0,
                "USE KEYS": 0,
                LET: 0,
                // Center
                "No WHERE": 0,
                // Center-right  
                JOIN: 0,
                NEST: 0,
                UNNEST: 0,
                SEARCH: 0,
                "ARRAY QUERY": 0,
                LIKE: 0,
                REGEX: 0,
                // Far right
                "GROUP BY": 0,
                "ORDER BY": 0,
                LIMIT: 0,
                OFFSET: 0,
                UNION: 0,
            };

            requests.forEach((request) => {
                const patterns = detectQueryPatterns(request);
                patterns.forEach(pattern => {
                    if (patternCounts.hasOwnProperty(pattern)) {
                        patternCounts[pattern]++;
                    }
                });
            });

            const ctx = document
                .getElementById("query-pattern-chart")
                .getContext("2d");
            if (window.queryPatternChart) {
                window.queryPatternChart.destroy();
            }

            // Generate colors based on pattern names
            const colors = Object.keys(patternCounts).map((pattern) => {
                if (pattern === "SELECT *") {
                    return "#dc3545"; // Red
                } else if (
                    pattern === "LIKE" ||
                    pattern === "No WHERE" ||
                    pattern === "REGEX"
                ) {
                    return "#fd7e14"; // Orange
                } else {
                    return "#28a745"; // Green
                }
            });

            window.queryPatternChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(patternCounts),
                    datasets: [
                        {
                            label: "Query Count",
                            data: Object.values(patternCounts),
                            backgroundColor: colors,
                            borderColor: colors,
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: { top: 16 }
                    },
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grace: '15%',
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Query Pattern Features",
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                            },
                        },
                    },
                },
                    plugins: [
                            {
                                       afterDatasetsDraw: function (chart) {
                                    drawBarValueLabels(chart, { font: 'bold 14px Arial' });
                        },
                    },
                ],
            });

            // Setup 3D button click handler
            const btn3D = document.getElementById('open-3d-pattern-chart-btn');
            if (btn3D) {
                // Show button only if we have data
                btn3D.style.display = requests && requests.length > 0 ? 'block' : 'none';
                
                // Remove old event listeners
                const newBtn = btn3D.cloneNode(true);
                btn3D.parentNode.replaceChild(newBtn, btn3D);
                
                // Add click handler
                newBtn.addEventListener('click', function() {
                    // Always regenerate data to ensure it's fresh
                    generateECharts3DBar(requests);
                    // Small delay to ensure data is set
                    setTimeout(() => {
                        if (window.echartsData) {
                            expandEChartsChart();
                        } else {
                            Logger.error('Failed to generate ECharts data');
                        }
                    }, 50);
                });
            }
        }

        // Generate 3D Pattern-Collection Surface Chart (Dev Feature)
        // Generate ECharts 3D Bar Chart (Dev Feature)
        function generateECharts3DBar(requests) {
            if (!requests || requests.length === 0) {
                Logger.debug(TEXT_CONSTANTS.NO_DATA_AVAILABLE || "No data available");
                return;
            }

            // Reuse pattern detection logic
            const patterns = [
                'WITH', 'EXECUTE', 'SELECT *', 'COUNT', 'DISTINCT',
                'USE INDEX', 'USE KEYS', 'LET',
                'No WHERE',
                'JOIN', 'NEST', 'UNNEST', 'SEARCH', 'ARRAY QUERY', 'LIKE', 'REGEX',
                'GROUP BY', 'ORDER BY', 'LIMIT', 'OFFSET', 'UNION'
            ];

            // Build pattern-collection matrix
            const collectionPatternCounts = {}; // { collection: { pattern: count } }

            requests.forEach((request) => {
                // For EXECUTE statements, use preparedText (contains actual SQL), otherwise use statement
                const sql = request.statement || request.preparedText || "";
                
                // Extract collections from SQL
                const collections = extractCollectionsFromSQL(sql);
                
                // Detect patterns using shared helper function (Issue #202)
                const detectedPatterns = detectQueryPatterns(request);

                // Count patterns per collection
                collections.forEach(collection => {
                    if (!collectionPatternCounts[collection]) {
                        collectionPatternCounts[collection] = {};
                        patterns.forEach(p => collectionPatternCounts[collection][p] = 0);
                    }
                    
                    detectedPatterns.forEach(pattern => {
                        if (patterns.includes(pattern)) {
                            collectionPatternCounts[collection][pattern]++;
                        }
                    });
                });
            });

            // Get all unique collections sorted by total pattern count
            const collections = Object.keys(collectionPatternCounts).sort((a, b) => {
                const aTotal = Object.values(collectionPatternCounts[a]).reduce((sum, v) => sum + v, 0);
                const bTotal = Object.values(collectionPatternCounts[b]).reduce((sum, v) => sum + v, 0);
                return aTotal - bTotal; // Ascending
            });

            if (collections.length === 0) {
                Logger.info('No collection data available for ECharts 3D bar chart');
                return;
            }

            // Build data array for ECharts: [[patternIdx, collectionIdx, count, actualCount, color], ...]
            const data = [];
            const maxCount = Math.max(...Object.values(collectionPatternCounts).flatMap(obj => Object.values(obj)));

            // Helper function to get color based on count (Red=highest, Blue=lowest)
            function getColorForCount(count, max) {
                const intensity = count / max;
                // Red ‚Üí Orange ‚Üí Yellow ‚Üí Green ‚Üí Cyan ‚Üí Blue
                if (intensity > 0.83) return '#dc143c'; // Crimson red (highest)
                if (intensity > 0.67) return '#ff4500'; // Orange-red
                if (intensity > 0.50) return '#ffa500'; // Orange
                if (intensity > 0.33) return '#ffd700'; // Gold
                if (intensity > 0.17) return '#32cd32'; // Lime green
                return '#1e90ff'; // Dodger blue (lowest)
            }

            collections.forEach((collection, cIdx) => {
                patterns.forEach((pattern, pIdx) => {
                    const count = collectionPatternCounts[collection][pattern] || 0;
                    if (count > 0) {
                        // Use log scale: log10(count + 1)
                        const logCount = Math.log10(count + 1);
                        const color = getColorForCount(count, maxCount);
                        data.push([pIdx, cIdx, logCount, count, color]); // Store log, raw count, and color
                    }
                });
            });

            // Store data globally for fullscreen mode
            window.echartsData = {
                collections,
                patterns,
                collectionPatternCounts,
                data,
                maxCount
            };

            Logger.info(`‚úÖ ECharts 3D Bar data prepared: ${collections.length} collections x ${patterns.length} patterns (${data.length} bars)`);
        }

        // Expand ECharts 3D Bar Chart to fullscreen
        function expandEChartsChart() {
            const option = {
                title: {
                    text: 'Query Pattern By Collection',
                    left: 'center',
                    top: 10,
                    textStyle: {
                        fontSize: 16,
                        fontWeight: 'bold'
                    }
                },
                tooltip: {
                    formatter: function(params) {
                        const pIdx = params.value[0];
                        const cIdx = params.value[1];
                        const logCount = params.value[2];
                        const actualCount = params.data.actualCount;
                        return `${patterns[pIdx]}<br/>${collections[cIdx]}<br/>Log Count: ${logCount.toFixed(2)}<br/>Actual Count: ${actualCount}`;
                    }
                },
                xAxis3D: {
                    type: 'category',
                    data: patterns,
                    name: 'Query Pattern',
                    nameTextStyle: {
                        fontSize: 14,
                        fontWeight: 'bold'
                    },
                    axisLabel: {
                        interval: 0,
                        rotate: 45,
                        fontSize: 10
                    }
                },
                yAxis3D: {
                    type: 'category',
                    data: collections,
                    name: 'Collection',
                    nameTextStyle: {
                        fontSize: 14,
                        fontWeight: 'bold'
                    },
                    axisLabel: {
                        interval: Math.max(0, Math.ceil(collections.length / 10) - 1),
                        fontSize: 10
                    }
                },
                zAxis3D: {
                    type: 'value',
                    name: 'Usage Count (log‚ÇÅ‚ÇÄ)',
                    nameTextStyle: {
                        fontSize: 14,
                        fontWeight: 'bold'
                    }
                },
                grid3D: {
                    boxWidth: 200,
                    boxDepth: Math.min(200, collections.length * 5),
                    boxHeight: 100,
                    viewControl: {
                        alpha: 19.3,
                        beta: 41.1,
                        distance: 362.6,
                        minDistance: 100,
                        maxDistance: 500
                    },
                    light: {
                        main: {
                            intensity: 1.2,
                            shadow: true
                        },
                        ambient: {
                            intensity: 0.3
                        }
                    }
                },
                series: [{
                    type: 'bar3D',
                    data: data.map(d => ({
                        value: [d[0], d[1], d[2]],
                        itemStyle: { color: d[4] },
                        actualCount: d[3]
                    })),
                    shading: 'lambert',
                    label: {
                        show: false
                    },
                    itemStyle: {
                        opacity: 0.95
                    },
                    emphasis: {
                        label: {
                            show: false
                        },
                        itemStyle: {
                            opacity: 1,
                            color: '#900'
                        }
                    }
                }]
            };

            myChart.setOption(option);

            Logger.info(`‚úÖ ECharts 3D Bar created: ${collections.length} collections x ${patterns.length} patterns (${data.length} bars)`);
        }

        // Expand ECharts 3D Bar Chart to fullscreen
        function expandEChartsChart() {
            const { collections, patterns, collectionPatternCounts, data, maxCount } = window.echartsData;
            if (!collections || !patterns) return;

            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'chart-fullscreen-overlay active';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center;';

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'width: 95%; height: 95%; background: white; border-radius: 8px; padding: 20px; position: relative;';

            // Create close button
            const closeBtn = document.createElement('div');
            closeBtn.className = 'chart-collapse-btn';
            closeBtn.title = 'Collapse chart';
            closeBtn.innerHTML = '‚úï';
            closeBtn.onclick = () => {
                document.body.removeChild(overlay);
                document.body.style.overflow = '';
            };

            // Create fullscreen chart container
            const fullscreenChartDiv = document.createElement('div');
            fullscreenChartDiv.id = 'echarts-fullscreen';
            fullscreenChartDiv.style.cssText = 'width: calc(100% - 420px); height: 100%;';

            // Create controls and legend container
            const controlsContainer = document.createElement('div');
            controlsContainer.style.cssText = 'position: absolute; top: 50px; right: 20px; width: 400px; background: white; border: 1px solid #444; border-radius: 4px; padding: 10px; max-height: calc(100% - 60px); overflow-y: auto;';

            // Add toggle controls
            const togglesDiv = document.createElement('div');
            togglesDiv.style.cssText = 'margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ddd;';
            togglesDiv.innerHTML = `
                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; font-weight: bold;">
                        <input type="checkbox" id="echarts-log-scale-toggle" checked style="margin-right: 8px;">
                        Log Scale (log‚ÇÅ‚ÇÄ)
                    </label>
                </div>
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; font-weight: bold;">
                        <input type="checkbox" id="echarts-aggregation-toggle" style="margin-right: 8px;">
                        Aggregation Mode
                    </label>
                    <div style="font-size: 10px; color: #666; margin-left: 24px; margin-top: 2px;">Sum all collections per pattern</div>
                </div>
            `;
            controlsContainer.appendChild(togglesDiv);

            // Add legend header
            const legendHeader = document.createElement('div');
            legendHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
            legendHeader.innerHTML = `
                <strong style="font-size: 14px;">Collections:</strong>
                <div>
                    <button id="echarts-fs-show-all" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 11px;">Show All</button>
                    <button id="echarts-fs-hide-all" style="padding: 4px 12px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Hide All</button>
                </div>
            `;
            controlsContainer.appendChild(legendHeader);

            // Add search input
            const searchContainer = document.createElement('div');
            searchContainer.style.cssText = 'margin-bottom: 10px;';
            searchContainer.innerHTML = `
                <input type="text" id="echarts-legend-search" placeholder="Search collections..." style="width: 100%; font-size: 11px; padding: 6px 8px; border: 1px solid #dee2e6; border-radius: 3px; box-sizing: border-box;">
            `;
            controlsContainer.appendChild(searchContainer);

            // Create legend items grid
            const itemsGrid = document.createElement('div');
            itemsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr; gap: 6px;';
            itemsGrid.id = 'echarts-legend-items-grid';
            controlsContainer.appendChild(itemsGrid);

            // Assemble modal
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(fullscreenChartDiv);
            modalContent.appendChild(controlsContainer);
            overlay.appendChild(modalContent);
            document.body.appendChild(overlay);
            document.body.style.overflow = 'hidden';

            // State management
            let useLogScale = true;
            let useAggregation = false;
            let visibleCollections = new Set(collections.map((_, idx) => idx));

            // Initialize chart
            const fullscreenChart = echarts.init(fullscreenChartDiv);

            // Helper function to get color
            function getColorForCount(count, max) {
                const intensity = count / max;
                if (intensity > 0.83) return '#dc143c';
                if (intensity > 0.67) return '#ff4500';
                if (intensity > 0.50) return '#ffa500';
                if (intensity > 0.33) return '#ffd700';
                if (intensity > 0.17) return '#32cd32';
                return '#1e90ff';
            }

            // Render chart
            function renderChart() {
                let chartData;
                let zAxisTitle;

                if (useAggregation) {
                    // Aggregate: sum all collections per pattern
                    chartData = [];
                    patterns.forEach((pattern, pIdx) => {
                        let totalCount = 0;
                        
                        // Sum across all visible collections for this pattern
                        collections.forEach((collection, cIdx) => {
                            if (!visibleCollections.has(cIdx)) return;
                            totalCount += collectionPatternCounts[collection][pattern] || 0;
                        });
                        
                        if (totalCount > 0) {
                            const value = useLogScale ? Math.log10(totalCount + 1) : totalCount;
                            const color = getColorForCount(totalCount, maxCount);
                            
                            chartData.push({
                                value: [pIdx, 0, value],
                                itemStyle: { color },
                                actualCount: totalCount,
                                patternName: pattern
                            });
                        }
                    });
                    zAxisTitle = useLogScale ? 'Total Count (log‚ÇÅ‚ÇÄ)' : 'Total Count';
                } else {
                    // Individual bars
                    chartData = data
                        .filter(d => visibleCollections.has(d[1]))
                        .map(d => {
                            const value = useLogScale ? d[2] : d[3];
                            return {
                                value: [d[0], d[1], value],
                                itemStyle: { color: d[4] },
                                actualCount: d[3]
                            };
                        });
                    zAxisTitle = useLogScale ? 'Usage Count (log‚ÇÅ‚ÇÄ)' : 'Usage Count';
                }

                const option = {
                    title: {
                        text: 'Query Pattern By Collection',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        formatter: function(params) {
                            if (useAggregation) {
                                const patternName = params.data.patternName;
                                const actualCount = params.data.actualCount;
                                if (useLogScale) {
                                    const displayValue = Math.log10(actualCount + 1).toFixed(2);
                                    return `${patternName}<br/>Log Count: ${displayValue}<br/>Actual: ${actualCount}`;
                                } else {
                                    return `${patternName}<br/>Count: ${actualCount}`;
                                }
                            } else {
                                const pIdx = params.value[0];
                                const cIdx = params.value[1];
                                const actualCount = params.data.actualCount;
                                if (useLogScale) {
                                    const displayValue = Math.log10(actualCount + 1).toFixed(2);
                                    return `${patterns[pIdx]}<br/>${collections[cIdx]}<br/>Log Count: ${displayValue}<br/>Actual: ${actualCount}`;
                                } else {
                                    return `${patterns[pIdx]}<br/>${collections[cIdx]}<br/>Count: ${actualCount}`;
                                }
                            }
                        }
                    },
                    xAxis3D: {
                        type: 'category',
                        data: patterns,
                        name: 'Query Pattern',
                        nameTextStyle: { fontSize: 14, fontWeight: 'bold' },
                        axisLabel: { interval: 0, rotate: 45, fontSize: 10 }
                    },
                    yAxis3D: {
                        type: 'category',
                        data: useAggregation ? ['Total'] : collections,
                        name: useAggregation ? '' : 'Collection',
                        nameTextStyle: { fontSize: 14, fontWeight: 'bold' },
                        axisLabel: { interval: Math.max(0, Math.ceil(collections.length / 10) - 1), fontSize: 10 }
                    },
                    zAxis3D: {
                        type: 'value',
                        name: zAxisTitle,
                        nameTextStyle: { fontSize: 14, fontWeight: 'bold' }
                    },
                    grid3D: {
                        boxWidth: 200,
                        boxDepth: useAggregation ? 50 : Math.min(200, collections.length * 5),
                        boxHeight: 120,
                        viewControl: {
                            alpha: 19.3,
                            beta: 41.1,
                            distance: 362.6,
                            minDistance: 100,
                            maxDistance: 500
                        },
                        light: {
                            main: { intensity: 1.2, shadow: true },
                            ambient: { intensity: 0.3 }
                        }
                    },
                    series: [{
                        type: 'bar3D',
                        data: chartData,
                        shading: 'lambert',
                        label: { show: false },
                        itemStyle: { opacity: 0.95 },
                        emphasis: {
                            label: { show: false },
                            itemStyle: { 
                                opacity: 1,
                                color: '#900'
                            }
                        }
                    }]
                };

                fullscreenChart.setOption(option, true);
            }

            // Populate legend
            function updateLegend() {
                itemsGrid.innerHTML = '';
                
                // Create array of collections with their counts and original index
                const collectionsWithCounts = collections.map((collection, cIdx) => ({
                    collection,
                    cIdx,
                    totalCount: Object.values(collectionPatternCounts[collection]).reduce((sum, v) => sum + v, 0)
                }))
                .filter(item => item.totalCount > 0); // Only show collections with data
                
                // Sort by count descending (highest to lowest)
                collectionsWithCounts.sort((a, b) => b.totalCount - a.totalCount);
                
                // Create legend items in sorted order
                collectionsWithCounts.forEach(({ collection, cIdx, totalCount }) => {
                    const item = document.createElement('div');
                    item.dataset.collectionIndex = cIdx;
                    item.style.cssText = 'display: flex; align-items: center; padding: 6px; background: white; border: 1px solid #ccc; border-radius: 3px; cursor: pointer; font-size: 11px;';
                    if (!visibleCollections.has(cIdx)) item.style.opacity = '0.5';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = visibleCollections.has(cIdx);
                    checkbox.style.marginRight = '8px';
                    
                    const label = document.createElement('span');
                    label.textContent = `(${totalCount}) ${collection}`;
                    label.style.flex = '1';
                    
                    item.appendChild(checkbox);
                    item.appendChild(label);
                    
                    const toggleVis = () => {
                        if (visibleCollections.has(cIdx)) {
                            visibleCollections.delete(cIdx);
                            checkbox.checked = false;
                            item.style.opacity = '0.5';
                        } else {
                            visibleCollections.add(cIdx);
                            checkbox.checked = true;
                            item.style.opacity = '1';
                        }
                        renderChart();
                    };
                    
                    item.addEventListener('click', (e) => {
                        if (e.target !== checkbox) toggleVis();
                    });
                    checkbox.addEventListener('change', toggleVis);
                    
                    itemsGrid.appendChild(item);
                });
            }

            // Event listeners
            document.getElementById('echarts-log-scale-toggle').addEventListener('change', (e) => {
                useLogScale = e.target.checked;
                renderChart();
            });

            document.getElementById('echarts-aggregation-toggle').addEventListener('change', (e) => {
                useAggregation = e.target.checked;
                renderChart();
            });

            document.getElementById('echarts-fs-show-all').addEventListener('click', () => {
                visibleCollections = new Set(collections.map((_, idx) => idx));
                updateLegend();
                renderChart();
            });

            document.getElementById('echarts-fs-hide-all').addEventListener('click', () => {
                visibleCollections.clear();
                updateLegend();
                renderChart();
            });

            // Search input filtering
            document.getElementById('echarts-legend-search').addEventListener('input', (e) => {
                const searchText = e.target.value.toLowerCase().trim();
                const legendItems = itemsGrid.querySelectorAll('div[data-collection-index]');
                
                legendItems.forEach(item => {
                    const label = item.querySelector('span');
                    const collectionText = label.textContent.toLowerCase();
                    
                    if (searchText === '' || collectionText.includes(searchText)) {
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });

            // ESC key to close
            document.addEventListener('keydown', function escHandler(e) {
                if (e.key === 'Escape') {
                    closeBtn.click();
                    document.removeEventListener('keydown', escHandler);
                }
            });

            // Initial render
            updateLegend();
            renderChart();

            // Add camera debug display
            addCameraDebugDisplay(fullscreenChart, fullscreenChartDiv, closeBtn, 'pattern-collection');
        }
  
        // Generate User Count Table
        // Helper function to get user list with counts (sorted by count descending)
        function getUserListWithCounts(requests) {
            const userCounts = {};

            requests.forEach((request) => {
                const user = request.users || "Unknown";
                userCounts[user] = (userCounts[user] || 0) + 1;
            });

            const sortedUsers = Object.entries(userCounts).sort(
                ([, a], [, b]) => b - a
            );

            return sortedUsers;
        }

        // Initialize jQuery UI autocomplete for username search inputs
        function initializeUsernameAutocomplete(requests) {
            const sortedUsers = getUserListWithCounts(requests);
            
            // Format data for autocomplete: "username (count)" sorted alphabetically by username
            const autocompleteData = sortedUsers
                .map(([user, count]) => ({
                    label: `${user} (${count})`,
                    value: user
                }))
                .sort((a, b) => a.value.localeCompare(b.value));

            // Destroy existing autocomplete instances before reinitializing
            const analysisUsernameInput = $("#analysis-username-search");
            const everyQueryUsernameInput = $("#username-search");
            
            if (analysisUsernameInput.hasClass("ui-autocomplete-input")) {
                analysisUsernameInput.autocomplete("destroy");
            }
            if (everyQueryUsernameInput.hasClass("ui-autocomplete-input")) {
                everyQueryUsernameInput.autocomplete("destroy");
            }

            // Track if we just selected an item to prevent double trigger
            let justSelected = false;

            // Initialize autocomplete for Analysis tab username search
            analysisUsernameInput.autocomplete({
                source: autocompleteData,
                minLength: 0,
                select: function(event, ui) {
                    justSelected = true;
                    $(this).val(ui.item.value);
                    // Trigger native input event to fire the debounced search
                    this.dispatchEvent(new Event('input', { bubbles: true }));
                    // Reset flag after a short delay
                    setTimeout(() => { justSelected = false; }, 100);
                    return false;
                }
            }).focus(function() {
                if (!justSelected) {
                    $(this).autocomplete("search", $(this).val());
                }
            });

            // Initialize autocomplete for Every Query tab username search
            everyQueryUsernameInput.autocomplete({
                source: autocompleteData,
                minLength: 0,
                select: function(event, ui) {
                    justSelected = true;
                    $(this).val(ui.item.value);
                    // Trigger native input event to fire the debounced search
                    this.dispatchEvent(new Event('input', { bubbles: true }));
                    // Reset flag after a short delay
                    setTimeout(() => { justSelected = false; }, 100);
                    return false;
                }
            }).focus(function() {
                if (!justSelected) {
                    $(this).autocomplete("search", $(this).val());
                }
            });
        }

        function generateUserCountTable(requests) {
            const sortedUsers = getUserListWithCounts(requests);

            const tbody = document.getElementById("user-count-body");
            tbody.innerHTML = "";

            // Use DocumentFragment for smooth rendering with caps
            const fragment = document.createDocumentFragment();
            const maxDisplayUsers = 500; // Cap for performance
            const usersToShow = sortedUsers.slice(0, maxDisplayUsers);

            usersToShow.forEach(([user, count]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";

                // Apply count thresholding
                const displayCount = count > 99999 ? "99K+" : count;

                row.innerHTML = `
              <td class="padding-8 text-align-center" style="font-weight: bold;">${displayCount}</td>
              <td class="padding-8" style="word-break: break-word;">
                ${user}
                <button onclick="copyToClipboard('${user.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="margin-left: 8px;">
                  Copy
                </button>
              </td>
            `;
                fragment.appendChild(row);
            });

            tbody.appendChild(fragment);

            // Add notice if users were capped
            if (sortedUsers.length > maxDisplayUsers) {
                const noticeRow = document.createElement("tr");
                noticeRow.innerHTML = `<td colspan="2" style="text-align: center; color: #666; font-style: italic; padding: 10px;">${TEXT_CONSTANTS.SHOWING_TOP} ${maxDisplayUsers} ${TEXT_CONSTANTS.OF_TOTAL} ${sortedUsers.length} ${TEXT_CONSTANTS.USERS}</td>`;
                tbody.appendChild(noticeRow);
            }
        }

        // Parse FROM clause to extract bucket.scope.collection
        // Enhanced to support all DML statements based on official Couchbase N1QL documentation:
        // - MERGE INTO target_keyspace USING source_keyspace
        // - UPDATE target_keyspace USE KEYS ... SET ...
        // - UPSERT INTO target_keyspace (KEY, VALUE) ...
        // - INSERT INTO target_keyspace (KEY, VALUE) ...
        // - DELETE FROM target_keyspace
        function parseFromClause(statement) {
            if (!statement) return "_default._default._default";

            try {
                // Remove comments and normalize whitespace
                let cleanStatement = statement
                    .replace(/--.*$/gm, "") // Remove line comments
                    .replace(/\/\*[\s\S]*?\*\//g, "") // Remove block comments
                    .replace(/\s+/g, " ") // Normalize whitespace
                    .trim();
                
                // If statement becomes empty after cleaning, return default
                if (!cleanStatement) {
                    console.warn("Empty statement after comment removal:", statement?.substring(0, 100));
                    return "_default._default._default";
                }

                // Handle PREPARE statements:
                // Pattern 1: PREPARE name FROM actual_statement
                // Pattern 2: PREPARE actual_statement (no name)
                if (cleanStatement.match(/^PREPARE\s+/i)) {
                    // Try pattern with name: PREPARE name FROM statement
                    const namedPrepareMatch = cleanStatement.match(/^PREPARE\s+[a-zA-Z0-9_-]+\s+FROM\s+(.+)$/i);
                    if (namedPrepareMatch) {
                        cleanStatement = namedPrepareMatch[1].trim();
                    } else {
                        // Simple pattern: PREPARE statement (just strip PREPARE keyword)
                        cleanStatement = cleanStatement.replace(/^PREPARE\s+/i, '').trim();
                    }
                }

                let target = null;
                let hasBackticks = false;
                
                // Define all DML/DQL statement keywords that precede the target keyspace
                // MERGE INTO, UPSERT INTO, INSERT INTO, UPDATE, DELETE FROM, FROM
                const statementKeyword = '(?:MERGE\\s+INTO|UPSERT\\s+INTO|INSERT\\s+INTO|UPDATE|DELETE\\s+FROM|FROM)';
                
                // Check for subqueries: FROM ( SELECT ... ) or INSERT INTO x (KEY, VALUE) (SELECT ...)
                const subqueryCheck = cleanStatement.match(new RegExp(statementKeyword + '\\s*\\(', 'i'));
                if (subqueryCheck) {
                    // Find all keyspace references that are NOT followed by (
                    const allTargets = [];
                    const regex = new RegExp(statementKeyword + '\\s+([^\\s(][^\\s]*)', 'gi');
                    let match;
                    while ((match = regex.exec(cleanStatement)) !== null) {
                        const possibleTarget = match[1].trim();
                        if (!possibleTarget.startsWith('(')) {
                            allTargets.push(possibleTarget);
                        }
                    }
                    if (allTargets.length > 0) {
                        target = allTargets[0].replace(/`/g, '');
                        hasBackticks = allTargets[0].includes('`');
                    }
                }
                
                // If not subquery or couldn't extract, try normal patterns
                if (!target) {
                    // Pattern 1: Mixed backticks - bucket.`scope`.`collection` (bucket not backticked)
                    const mixedBacktickMatch = cleanStatement.match(new RegExp(statementKeyword + '\\s+([a-zA-Z0-9_-]+)\\.`([^`]+)`\\.`([^`]+)`', 'i'));
                    if (mixedBacktickMatch) {
                        target = `${mixedBacktickMatch[1]}.${mixedBacktickMatch[2]}.${mixedBacktickMatch[3]}`;
                        hasBackticks = true;
                    } else {
                        // Pattern 2: Fully backticked - `bucket`.`scope`.`collection`
                        const fullBacktickMatch = cleanStatement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`\\.`([^`]+)`\\.`([^`]+)`', 'i'));
                        if (fullBacktickMatch) {
                            target = `${fullBacktickMatch[1]}.${fullBacktickMatch[2]}.${fullBacktickMatch[3]}`;
                            hasBackticks = true;
                        } else {
                            // Pattern 3: Two-part backticked - `bucket`.`scope`
                            const twoPartBacktickMatch = cleanStatement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`\\.`([^`]+)`', 'i'));
                            if (twoPartBacktickMatch) {
                                target = `${twoPartBacktickMatch[1]}.${twoPartBacktickMatch[2]}`;
                                hasBackticks = true;
                            } else {
                                // Pattern 4: Single backticked - `bucket.scope.collection` or `bucket`
                                const singleBacktickMatch = cleanStatement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`', 'i'));
                                if (singleBacktickMatch) {
                                    target = singleBacktickMatch[1].trim();
                                    hasBackticks = true;
                                } else {
                                    // Pattern 5: No backticks - bucket.scope.collection or bucket
                                    // Must account for optional aliases: UPDATE hotel h, MERGE INTO airport t
                                    // Syntax: keyspace-ref ( AS? alias )?
                                    // Stop keywords cover SELECT, DML, and JOIN/WHERE clauses:
                                    // - WHERE, JOIN, LET, NEST, UNNEST, GROUP, ORDER, LIMIT (SELECT clauses)
                                    // - USE KEYS (UPDATE with specific keys)
                                    // - USING (MERGE source clause)
                                    // - SET (UPDATE assignments)
                                    // - VALUES (INSERT/UPSERT values)
                                    // - KEY (INSERT/UPSERT key specification)
                                    // - ON (JOIN/MERGE conditions)
                                    // - AS (aliases)
                                    // - RETURNING (DML output)
                                    // - WHEN (MERGE conditions)
                                    const stopKeywords = '(?:WHERE|JOIN|USE\\s+(?:KEYS|INDEX)|USING|LET|NEST|UNNEST|GROUP|ORDER|LIMIT|ON|AS|SET|VALUES|KEY|RETURNING|WHEN)';
                                    // Optional alias pattern: (?:\s+(?:AS\s+)?[a-zA-Z0-9_-]+)?
                                    // This allows: keyspace, keyspace AS alias, or keyspace alias
                                    const multiPartMatch = cleanStatement.match(new RegExp(statementKeyword + '\\s+([a-zA-Z0-9_-]+(?:\\.[a-zA-Z0-9_-]+)*)(?:\\s+(?:AS\\s+)?[a-zA-Z0-9_-]+)?(?:\\s+' + stopKeywords + '|;|\\s*$|\\s*\\()', 'i'));
                                    if (multiPartMatch) {
                                        target = multiPartMatch[1].trim();
                                    }
                                }
                            }
                        }
                    }
                }
                
                // If no valid target found, return default
                if (!target) {
                    Logger.debug("[parseFromClause] No target found in cleaned statement:", cleanStatement.substring(0, 200));
                    return "_default._default._default";
                }
                
                // Split by dots and filter out empty parts
                const parts = target.split(".").filter(p => p.length > 0);
                
                // Validate that parts look like real bucket/scope/collection names
                const isValid = parts.every(p => /^[a-zA-Z0-9_-]+$/.test(p));
                if (!isValid) return "_default._default._default";

                // Parse based on number of parts
                if (parts.length === 1) {
                    // Single word bucket name (with or without backticks)
                    return `${parts[0]}._default._default`;
                } else if (parts.length === 2) {
                    // bucket.scope format
                    return `${parts[0]}.${parts[1]}._default`;
                } else if (parts.length >= 3) {
                    // bucket.scope.collection format
                    return `${parts[0]}.${parts[1]}.${parts[2]}`;
                }

                return "_default._default._default";
            } catch (error) {
                console.warn("Error parsing FROM clause:", error, statement);
                return "_default._default._default";
            }
        }

        // Hash utilities now imported from base.js (window.DebugRedactor)
        // Shorthand functions for backward compatibility
        function hashName(name) { return window.DebugRedactor.hash(name); }
        function hashBSC(bsc) { return window.DebugRedactor.redactBSC(bsc); }
        function hashCompositeKey(key) { return window.DebugRedactor.redactCompositeKey(key); }
        function hashQuery(query) { return window.DebugRedactor.redactQuery(query); }

        // Generate Index Count Table
        function generateIndexCountTable(requests) {
            const indexData = {};

            requests.forEach((request) => {
                const bucketScopeCollection = parseFromClause(request.statement || request.preparedText);

                // Debug problematic parsing
                if (
                    bucketScopeCollection.includes("SELECT") ||
                    bucketScopeCollection.includes("(")
                ) {
                    console.warn("Potentially incorrect bucket parsing:", {
                        statement: (request.statement || request.preparedText)?.substring(0, 100) + "...",
                        parsed: bucketScopeCollection,
                    });
                    // Use default for obviously wrong parsing
                    const correctedBSC = "_default._default._default";

                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, correctedBSC);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                } else {
                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, bucketScopeCollection);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                }
            });

            const sortedIndexes = Object.entries(indexData).sort(
                ([, a], [, b]) => b.count - a.count
            );
            
            // Debug: Log Dashboard indexes for JOIN queries
            Logger.debug(`[DASHBOARD DEBUG] Total indexes found in Dashboard table: ${sortedIndexes.length}`);
            const joinIndexes = sortedIndexes.filter(([key, data]) => {
                // Check if any request using this index is a JOIN
                return requests.some(req => {
                    const stmt = req.statement || req.preparedText || '';
                    return stmt.toUpperCase().includes('JOIN');
                });
            });
            Logger.debug(`[DASHBOARD DEBUG] Indexes from JOIN queries (first 10):`, 
                joinIndexes.slice(0, 10).map(([key, data]) => `${hashCompositeKey(key)} (count: ${data.count})`));

            const tbody = document.getElementById("index-count-body");
            tbody.innerHTML = "";

            // Use DocumentFragment for smooth rendering with caps
            const fragment = document.createDocumentFragment();
            const maxDisplayIndexes = 200; // Cap for performance
            const indexesToShow = sortedIndexes.slice(0, maxDisplayIndexes);

            indexesToShow.forEach(([compositeKey, data]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";

                // Apply count thresholding
                const displayCount = data.count > 99999 ? "99K+" : data.count;
                
                // Extract index name from composite key or use indexName property
                const indexName = data.indexName || compositeKey.split('::')[0];

                row.innerHTML = `
              <td class="padding-8 text-align-center" style="font-weight: bold;">${displayCount}</td>
              <td class="padding-8" style="word-break: break-word;">
                ${indexName}
                <button onclick="copyToClipboard('${indexName.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="margin-left: 8px;">
                  Copy
                </button>
              </td>
              <td class="padding-8 font-size-12" style="word-break: break-word; font-family: monospace;">
                ${data.bucketScopeCollection}
              </td>
            `;
                fragment.appendChild(row);
            });

            tbody.appendChild(fragment);

            // Add notice if indexes were capped
            if (sortedIndexes.length > maxDisplayIndexes) {
                const noticeRow = document.createElement("tr");
                noticeRow.innerHTML = `<td colspan="3" style="text-align: center; color: #666; font-style: italic; padding: 10px;">${TEXT_CONSTANTS.SHOWING_TOP} ${maxDisplayIndexes} ${TEXT_CONSTANTS.OF_TOTAL} ${sortedIndexes.length} ${TEXT_CONSTANTS.INDEXES}</td>`;
                tbody.appendChild(noticeRow);
            }
        }

        // Recursively extract index names from plan operators with improved error handling
        function extractIndexNames(
            operator,
            indexData,
            bucketScopeCollection,
            depth = 0
        ) {
            if (!operator || !indexData) return;

            // Prevent infinite recursion
            if (depth > 50) {
                console.warn("Maximum recursion depth reached in extractIndexNames");
                return;
            }

            try {
                // Helper function to add index to data using composite key
                function addIndexToData(indexName) {
                    let resolvedName = indexName;

                    // If this is #primary, try to resolve to actual primary index name
                    if (indexName === "#primary") {
                        const actualPrimary = resolvePrimaryIndexName(
                            bucketScopeCollection || "unknown.unknown.unknown"
                        );
                        if (actualPrimary && actualPrimary !== "#primary") {
                            resolvedName = actualPrimary;
                        }
                    }

                    // Use composite key: indexName::bucket.scope.collection
                    const compositeKey = `${resolvedName}::${bucketScopeCollection || "unknown.unknown.unknown"}`;
                    
                    if (!indexData[compositeKey]) {
                        indexData[compositeKey] = {
                            indexName: resolvedName,
                            count: 0,
                            bucketScopeCollection: bucketScopeCollection || "unknown",
                        };
                    }
                    indexData[compositeKey].count++;
                }

                // Check for index name in various operator properties
                if (operator.index && typeof operator.index === "string") {
                    addIndexToData(operator.index);
                }
                if (operator.indexName && typeof operator.indexName === "string") {
                    addIndexToData(operator.indexName);
                }

                // Check for primary scan operators (align with usesPrimaryIndex logic)
                if (
                    operator["#operator"] === "PrimaryScan" ||
                    operator["#operator"] === "PrimaryScan3" ||
                    operator.index === "#primary" ||
                    operator.using === "sequentialscan" ||
                    (operator.spans &&
                        Array.isArray(operator.spans) &&
                        operator.spans.length === 0)
                ) {
                    // Only add #primary if we don't already have the actual index name
                    if (!operator.index || operator.index === "#primary") {
                        addIndexToData("#primary");
                    }
                    // If operator.index exists and is not #primary, it was already added above
                }

                // Recursively check child operators
                if (operator["~child"]) {
                    extractIndexNames(
                        operator["~child"],
                        indexData,
                        bucketScopeCollection,
                        depth + 1
                    );
                }
                if (operator["~children"] && Array.isArray(operator["~children"])) {
                    operator["~children"].forEach((child) =>
                        extractIndexNames(
                            child,
                            indexData,
                            bucketScopeCollection,
                            depth + 1
                        )
                    );
                }
            } catch (e) {
                console.warn("Error in extractIndexNames:", e);
            }
            if (operator.input) {
                extractIndexNames(operator.input, indexData, bucketScopeCollection);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexNames(input, indexData, bucketScopeCollection)
                );
            }
            if (operator.left) {
                extractIndexNames(operator.left, indexData, bucketScopeCollection);
            }
            if (operator.right) {
                extractIndexNames(operator.right, indexData, bucketScopeCollection);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexNames(operator.first, indexData, bucketScopeCollection);
            }
            if (operator.second) {
                extractIndexNames(operator.second, indexData, bucketScopeCollection);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexNames(scan, indexData, bucketScopeCollection)
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexNames(operator.scan, indexData, bucketScopeCollection);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexNames(
                            subquery.executionTimings,
                            indexData,
                            bucketScopeCollection
                        );
                    }
                });
            }
        }

        // Update Insights tab with live data
        function updateInsights(requests) {
            Logger.debug(`[updateInsights] Called with ${requests.length} requests, currentTimezone=${currentTimezone}`);
            
            // Reset metrics tracking
            window.inefficientScanMetrics = [];

            // Count queries with no WHERE clauses
            let noWhereCount = 0;
            let slowUseKeysCount = 0;
            let slowUseKeysTotalTime = 0;
            let largeResultsCount = 0;
            let largeResultsTotalMB = 0;
            let inefficientLikeCount = 0;
            let selectStarCount = 0;
            let inefficientIndexScansCount = 0;
            let paginationOverfetchCount = 0;
            let paginationOverfetchTotalScanned = 0;
            let highMemoryCount = 0;
            let highMemoryTotalGB = 0;
            let highKernelTimeQueriesCount = 0;
            let totalCoreKernelRatio = 0;
            let largePayloadStreamingCount = 0;
            let largePayloadTotalResultSize = 0;
            let largePayloadTotalStreamRatio = 0;
            let approachingTimeoutCount = 0;
            let actualTimeoutCount = 0;
            let slowParsePlanCount = 0;
            let slowParsePlanTotalParseTime = 0;
            let slowParsePlanTotalPlanTime = 0;
            
            // JOIN operations metrics
            let joinQueriesCount = 0;
            let joinQueriesWithIssuesCount = 0;
            let joinPhaseTotalTime = 0;

            // Concurrent Conflicts metrics
            let concurrentConflictsCount = 0;
            let concurrentConflictsSamples = [];
            const flagCounts = {
                A: { count: 0, name: 'Query Service Warning', queries: [] },
                B: { count: 0, name: 'Query Service Critical', queries: [] },
                C: { count: 0, name: 'Data Service Warning', queries: [] },
                D: { count: 0, name: 'Data Service Critical', queries: [] },
                E: { count: 0, name: 'Index Service Warning', queries: [] },
                F: { count: 0, name: 'Index Service Critical', queries: [] },
                G: { count: 0, name: 'CPU Contention', queries: [] },
                H: { count: 0, name: 'System-Wide Pressure', queries: [] }
            };
            const servicesUnderPressure = {
                'Query Service': 0,
                'Data Service': 0,
                'Index Service': 0,
                'CPU/OS': 0
            };

            // Sample queries arrays for insights
            let complexJoinOperationsSamples = [];
            let missingWhereClausesSamples = [];
            let slowUseKeyQueriesSamples = [];
            let largeResultSetQueriesSamples = [];
            let inefficientLikeOperationsSamples = [];
            let selectStarUsageSamples = [];
            let highMemoryUsageSamples = [];
            let highKernelTimeQueriesSamples = [];
            let largePayloadStreamingSamples = [];
            let actualTimeoutsSamples = [];
            let approachingTimeoutsSamples = [];
            let paginationOverfetchSamples = [];
            let slowParsePlanSamples = [];

            // Configurable threshold for kernel time detection
            const KERNEL_TIME_THRESHOLD_PERCENT = 20;
            const STREAM_KERNEL_THRESHOLD_PERCENT = 10;

            // Concurrent Conflicts thresholds (Service Pressure Detection)
            const CONCURRENT_CONFLICT_THRESHOLDS = {
                // Query Service (Parse + Plan) pressure
                PARSE_PLAN_WARNING_MS: 1,
                PARSE_PLAN_CRITICAL_MS: 10,
                
                // Data Service (Fetch) pressure - per-document timing
                FETCH_PER_DOC_WARNING_MS: 5,
                FETCH_PER_DOC_CRITICAL_MS: 10,
                MIN_FETCH_COUNT_FOR_ANALYSIS: 10,
                
                // Index Service pressure - throughput analysis
                INDEX_SCAN_WARNING_RATE: 5000,
                INDEX_SCAN_CRITICAL_RATE: 1000,
                MIN_INDEX_SCAN_FOR_ANALYSIS: 100,
                
                // CPU contention (Kernel time)
                KERNEL_TIME_WARNING_RATIO: 0.30,
                KERNEL_TIME_CRITICAL_RATIO: 0.50,
                
                // Multi-service pressure indicator
                MIN_SERVICES_UNDER_PRESSURE: 2,
                
                // Reporting
                TOP_AFFECTED_QUERIES: 10
            };

            requests.forEach((request) => {
                const statement = (request.statement || request.preparedText || "").toUpperCase();
                const elapsedTime = parseTime(request.elapsedTime);
                const elapsedTimeSeconds = elapsedTime / 1000; // Convert to seconds
                const state = (request.state || "").toLowerCase();

                // Count timeout-prone queries
                // Approaching timeout: 1 minute (60s) to 1m15s (75s) AND state is "completed"
                if (elapsedTimeSeconds >= 60 && elapsedTimeSeconds <= 75 && state === "completed") {
                    approachingTimeoutCount++;
                    if (approachingTimeoutsSamples.length < 5 && 
                        !approachingTimeoutsSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        approachingTimeoutsSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement,
                            elapsedTime: request.elapsedTime
                        });
                    }
                }
                
                // Actual timeout: 1m14s (74s) to 1m16s (76s) AND state is "fatal"  
                if (elapsedTimeSeconds >= 74 && elapsedTimeSeconds <= 76 && state === "fatal") {
                    actualTimeoutCount++;
                    if (actualTimeoutsSamples.length < 5 && 
                        !actualTimeoutsSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        actualTimeoutsSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement,
                            elapsedTime: request.elapsedTime
                        });
                    }
                }

                // Count missing WHERE clauses
                // Use consolidated function to check for filtering mechanisms (WHERE or USE KEYS)
                // If this is EXECUTE, evaluate WHERE on preparedText (actual statement) when present
                // Skip EXECUTE statements without preparedText (they reference prepared statements we can't analyze)
                const isExecuteStmt = (request.statement || '').toUpperCase().startsWith('EXECUTE');
                const stmtForWhere = (isExecuteStmt && request.preparedText)
                    ? request.preparedText
                    : (request.statement || request.preparedText);
                
                // Only check for missing WHERE if not an EXECUTE without preparedText
                if (!(isExecuteStmt && !request.preparedText) && !hasFilteringMechanism(stmtForWhere)) {
                    noWhereCount++;
                    if (missingWhereClausesSamples.length < 5 && 
                        !missingWhereClausesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        missingWhereClausesSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Count slow USE KEYS queries (> 1 second)
                if (statement.includes("USE KEYS")) {
                    const elapsedTime = parseTime(request.elapsedTime);
                    if (elapsedTime > 1000) { // 1 second = 1000ms
                        slowUseKeysCount++;
                        slowUseKeysTotalTime += elapsedTime;
                        if (slowUseKeyQueriesSamples.length < 5 && 
                            !slowUseKeyQueriesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                            slowUseKeyQueriesSamples.push({
                                requestTime: request.requestTime,
                                statement: request.preparedText || request.statement
                            });
                        }
                    }
                }

                // Count large result size queries (> 5MB)
                const resultSize = request.resultSize || 0;
                const resultSizeMB = resultSize / (1024 * 1024); // Convert bytes to MB
                if (resultSizeMB > 5) {
                    largeResultsCount++;
                    largeResultsTotalMB += resultSizeMB;
                    if (largeResultSetQueriesSamples.length < 5 && 
                        !largeResultSetQueriesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        largeResultSetQueriesSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Count inefficient LIKE operations with leading wildcards
                if (statement.toUpperCase().includes(" LIKE ")) {
                    // Look for patterns like LIKE '%text' or LIKE "%text"
                    const likeMatches = statement.match(/ LIKE\s+['"]%[^'"]*['"]?/gi);
                    if (likeMatches && likeMatches.length > 0) {
                        inefficientLikeCount++;
                        if (inefficientLikeOperationsSamples.length < 5 && 
                            !inefficientLikeOperationsSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                            inefficientLikeOperationsSamples.push({
                                requestTime: request.requestTime,
                                statement: request.preparedText || request.statement
                            });
                        }
                    }
                }

                // Count SELECT * usage (matches SELECT * FROM or SELECT *, field FROM, not qualified wildcards like c.*)
                const selectStarMatch = statement.match(/SELECT\s+\*[\s,]/i);
                if (selectStarMatch) {
                    selectStarCount++;
                    if (selectStarUsageSamples.length < 5 &&
                        !selectStarUsageSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        selectStarUsageSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Count high memory usage queries (>= 1GB)
                const usedMemory = request.usedMemory || 0;
                const usedMemoryGB = usedMemory / (1024 * 1024 * 1024); // Convert bytes to GB
                if (usedMemoryGB >= 1) {
                    highMemoryCount++;
                    highMemoryTotalGB += usedMemoryGB;
                    if (highMemoryUsageSamples.length < 5 && 
                        !highMemoryUsageSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        highMemoryUsageSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Analyze core execTime vs kernel time (two-stage check)
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const elapsedTimeMs = parseTime(request.elapsedTime);

                        // Stage 1: Check if kernTime is at least 50% of elapsedTime
                        const kernTimeAnalysis = calculateTotalKernTime(request.plan);
                        const kernToElapsedRatio = elapsedTimeMs > 0 ? (kernTimeAnalysis / elapsedTimeMs) * 100 : 0;

                        if (kernToElapsedRatio >= 50) {
                            // Stage 2: Analyze core execTime vs kernel time ratio
                            const coreKernelAnalysis = analyzeCoreExecToKernelRatio(planObj);

                            // If core execTime is 50%+ of kernel time, flag as high kernel time
                            if (coreKernelAnalysis.coreToKernelRatio >= 50) {
                                highKernelTimeQueriesCount++;
                                totalCoreKernelRatio += coreKernelAnalysis.coreToKernelRatio;
                                if (highKernelTimeQueriesSamples.length < 5 && 
                                    !highKernelTimeQueriesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                                    highKernelTimeQueriesSamples.push({
                                        requestTime: request.requestTime,
                                        statement: request.preparedText || request.statement
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Error parsing plan for kernel time analysis:", e);
                    }
                }
                
                // Detect JOIN operations (Beta - full flag detection A-H)
                const hasJoin = /\b(INNER\s+JOIN|LEFT\s+(OUTER\s+)?JOIN|RIGHT\s+(OUTER\s+)?JOIN|CROSS\s+JOIN|JOIN\b)/i.test(statement);
                if (hasJoin) {
                    joinQueriesCount++;
                    
                    // Get JOIN phase metrics
                    const joinPhaseTime = request.phaseTimes?.join || 0;
                    const joinPhaseTimeMs = parseTime(joinPhaseTime);
                    if (joinPhaseTimeMs > 0) {
                        joinPhaseTotalTime += joinPhaseTimeMs;
                    }
                    
                    const elapsedTimeMs = parseTime(request.elapsedTime);
                    const primaryScanCount = request.phaseCounts?.primaryScan || 0;
                    const joinCount = request.phaseCounts?.join || 0;
                    const indexScanCount = request.phaseCounts?.indexScan || 0;
                    const fetchCount = request.phaseCounts?.fetch || 0;
                    const unnestCount = request.phaseCounts?.unnest || 0;
                    const resultCount = request.resultCount || 0;
                    
                    // Calculate input docs (before JOIN)
                    const inputDocs = indexScanCount + fetchCount + primaryScanCount;
                    const explosionRatio = inputDocs > 0 ? resultCount / inputDocs : 0;
                    
                    // Count JOIN keywords in statement
                    const joinKeywordCount = (statement.match(/\bJOIN\b/gi) || []).length;
                    
                    // Calculate JOIN time ratio
                    const joinTimeRatio = elapsedTimeMs > 0 ? joinPhaseTimeMs / elapsedTimeMs : 0;
                    
                    // Detect complexity flags (A-H)
                    const flags = [];
                    const flagDetails = {};
                    
                    // FLAG A: Primary Scan in JOIN (Critical)
                    if (primaryScanCount > 0) {
                        flags.push('A');
                        flagDetails.A = `Primary Scan (${primaryScanCount.toLocaleString()} docs)`;
                    }
                    
                    // FLAG B: Cartesian Product (Critical)
                    if (/\bCROSS\s+JOIN\b/i.test(statement)) {
                        flags.push('B');
                        flagDetails.B = `CROSS JOIN detected`;
                    }
                    
                    // FLAG C: Data Explosion 2x-10x (High)
                    if (explosionRatio >= 2.0 && explosionRatio < 10.0) {
                        flags.push('C');
                        flagDetails.C = `${explosionRatio.toFixed(1)}x explosion (${inputDocs} ‚Üí ${resultCount})`;
                    }
                    
                    // FLAG D: Severe Data Explosion 10x+ (Critical)
                    if (explosionRatio >= 10.0) {
                        flags.push('D');
                        flagDetails.D = `${explosionRatio.toFixed(1)}x explosion (${inputDocs} ‚Üí ${resultCount})`;
                    }
                    
                    // FLAG E: Slow JOIN Phase ‚â•2s (High)
                    if (joinPhaseTimeMs >= 2000) {
                        flags.push('E');
                        flagDetails.E = `JOIN took ${(joinPhaseTimeMs / 1000).toFixed(2)}s`;
                    }
                    
                    // FLAG F: High Document Processing ‚â•100K (High)
                    if (joinCount >= 100000) {
                        flags.push('F');
                        flagDetails.F = `${joinCount.toLocaleString()} docs processed`;
                    }
                    
                    // FLAG G: Multiple JOINs ‚â•4 (Medium)
                    if (joinKeywordCount >= 4) {
                        flags.push('G');
                        flagDetails.G = `${joinKeywordCount} JOIN operations`;
                    }
                    
                    // FLAG H: JOIN Time Dominant ‚â•30% (High)
                    if (joinTimeRatio >= 0.30) {
                        flags.push('H');
                        flagDetails.H = `JOIN is ${(joinTimeRatio * 100).toFixed(1)}% of query time`;
                    }
                    
                    // If any flags detected, this is a complex JOIN
                    if (flags.length > 0) {
                        joinQueriesWithIssuesCount++;
                    }
                    
                    // Add to sample queries (up to 5 unique) - collect ALL JOIN queries regardless of flags
                    if (complexJoinOperationsSamples.length < 5 &&
                        !complexJoinOperationsSamples.some(s => s.statement === request.statement)) {
                        complexJoinOperationsSamples.push({
                            requestTime: request.requestTime,
                            statement: request.statement,  // Use original statement, not preparedText
                            flags: flags,
                            flagDetails: flagDetails,
                            joinTime: joinPhaseTimeMs
                        });
                    }
                }

                // Detect Concurrent Query Conflicts (Service Pressure Analysis)
                const conflictFlags = [];
                const conflictFlagDetails = {};
                const requestServicesUnderPressure = new Set();
                
                // Step 1: Detect Query Service Pressure (Parse + Plan Time)
                const parseTimeMs = parseTime(request.phaseTimes?.parse || '0');
                const planTimeMs = parseTime(request.phaseTimes?.plan || '0');
                const parsePlanTime = parseTimeMs + planTimeMs;
                
                if (parsePlanTime >= CONCURRENT_CONFLICT_THRESHOLDS.PARSE_PLAN_CRITICAL_MS) {
                    conflictFlags.push('B');
                    conflictFlagDetails.B = `Parse+Plan took ${parsePlanTime.toFixed(2)}ms (critically slow, should be <1ms)`;
                    requestServicesUnderPressure.add('Query Service');
                } else if (parsePlanTime >= CONCURRENT_CONFLICT_THRESHOLDS.PARSE_PLAN_WARNING_MS) {
                    conflictFlags.push('A');
                    conflictFlagDetails.A = `Parse+Plan took ${parsePlanTime.toFixed(2)}ms (should be <1ms)`;
                    requestServicesUnderPressure.add('Query Service');
                }
                
                // Step 2: Detect Data Service Pressure (Fetch Time per Document)
                const fetchTimeMs = parseTime(request.phaseTimes?.fetch || '0');
                const fetchCount = request.phaseCounts?.fetch || 0;
                
                if (fetchCount >= CONCURRENT_CONFLICT_THRESHOLDS.MIN_FETCH_COUNT_FOR_ANALYSIS) {
                    const fetchPerDoc = fetchTimeMs / fetchCount;
                    
                    if (fetchPerDoc >= CONCURRENT_CONFLICT_THRESHOLDS.FETCH_PER_DOC_CRITICAL_MS) {
                        conflictFlags.push('D');
                        conflictFlagDetails.D = `Fetch ${fetchPerDoc.toFixed(2)}ms per doc (${fetchTimeMs}ms for ${fetchCount} docs) - critically slow`;
                        requestServicesUnderPressure.add('Data Service');
                    } else if (fetchPerDoc >= CONCURRENT_CONFLICT_THRESHOLDS.FETCH_PER_DOC_WARNING_MS) {
                        conflictFlags.push('C');
                        conflictFlagDetails.C = `Fetch ${fetchPerDoc.toFixed(2)}ms per doc (${fetchTimeMs}ms for ${fetchCount} docs)`;
                        requestServicesUnderPressure.add('Data Service');
                    }
                }
                
                // Step 3: Detect Index Service Pressure (Scan Throughput)
                const indexScanTimeMs = parseTime(request.phaseTimes?.indexScan || '0');
                const indexScanCount = request.phaseCounts?.indexScan || 0;
                
                if (indexScanCount >= CONCURRENT_CONFLICT_THRESHOLDS.MIN_INDEX_SCAN_FOR_ANALYSIS && indexScanTimeMs > 0) {
                    const recordsPerSecond = (indexScanCount / indexScanTimeMs) * 1000;
                    
                    if (recordsPerSecond <= CONCURRENT_CONFLICT_THRESHOLDS.INDEX_SCAN_CRITICAL_RATE) {
                        conflictFlags.push('F');
                        conflictFlagDetails.F = `Index scan ${Math.round(recordsPerSecond).toLocaleString()} records/sec (${indexScanCount.toLocaleString()} in ${indexScanTimeMs}ms) - critically slow`;
                        requestServicesUnderPressure.add('Index Service');
                    } else if (recordsPerSecond <= CONCURRENT_CONFLICT_THRESHOLDS.INDEX_SCAN_WARNING_RATE) {
                        conflictFlags.push('E');
                        conflictFlagDetails.E = `Index scan ${Math.round(recordsPerSecond).toLocaleString()} records/sec (${indexScanCount.toLocaleString()} in ${indexScanTimeMs}ms)`;
                        requestServicesUnderPressure.add('Index Service');
                    }
                }
                
                // Step 4: Detect CPU Contention (Kernel Time)
                const kernTimeMs = parseTime(request.phaseTimes?.kernTime || '0');
                const conflictElapsedTimeMs = parseTime(request.elapsedTime);
                
                if (conflictElapsedTimeMs > 0 && kernTimeMs > 0) {
                    const kernelRatio = kernTimeMs / conflictElapsedTimeMs;
                    
                    if (kernelRatio >= CONCURRENT_CONFLICT_THRESHOLDS.KERNEL_TIME_WARNING_RATIO) {
                        conflictFlags.push('G');
                        conflictFlagDetails.G = `Kernel time ${(kernelRatio * 100).toFixed(1)}% (${kernTimeMs}ms / ${conflictElapsedTimeMs}ms)`;
                        requestServicesUnderPressure.add('CPU/OS');
                    }
                }
                
                // Step 5: Flag System-Wide Pressure (Multiple services affected)
                if (requestServicesUnderPressure.size >= CONCURRENT_CONFLICT_THRESHOLDS.MIN_SERVICES_UNDER_PRESSURE) {
                    conflictFlags.push('H');
                    conflictFlagDetails.H = `${requestServicesUnderPressure.size} services under pressure: ${Array.from(requestServicesUnderPressure).join(', ')}`;
                }
                
                // If any flags detected, count as concurrent conflict
                if (conflictFlags.length > 0) {
                    concurrentConflictsCount++;
                    
                    // Update flag counts
                    conflictFlags.forEach(flag => {
                        flagCounts[flag].count++;
                        if (flagCounts[flag].queries.length < 10) {
                            flagCounts[flag].queries.push(request);
                        }
                    });
                    
                    // Update service pressure counts
                    requestServicesUnderPressure.forEach(service => {
                        servicesUnderPressure[service]++;
                    });
                    
                    // Add to sample queries (up to 10)
                    if (concurrentConflictsSamples.length < CONCURRENT_CONFLICT_THRESHOLDS.TOP_AFFECTED_QUERIES) {
                        concurrentConflictsSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement,
                            flags: conflictFlags,
                            flagDetails: conflictFlagDetails,
                            parsePlanTime: parsePlanTime,
                            fetchPerDoc: fetchCount >= CONCURRENT_CONFLICT_THRESHOLDS.MIN_FETCH_COUNT_FOR_ANALYSIS ? fetchTimeMs / fetchCount : null,
                            indexScanRate: (indexScanCount >= CONCURRENT_CONFLICT_THRESHOLDS.MIN_INDEX_SCAN_FOR_ANALYSIS && indexScanTimeMs > 0) ? (indexScanCount / indexScanTimeMs) * 1000 : null,
                            kernelPercent: conflictElapsedTimeMs > 0 && kernTimeMs > 0 ? (kernTimeMs / conflictElapsedTimeMs) * 100 : null
                        });
                    }
                }

                // Check for slow parse/plan times (> 1ms)
                if (request.phaseTimes) {
                    const parseTimeMs = parseTime(request.phaseTimes.parse || '0');
                    const planTimeMs = parseTime(request.phaseTimes.plan || '0');
                    
                    if (parseTimeMs > 1 || planTimeMs > 1) {
                        slowParsePlanCount++;
                        slowParsePlanTotalParseTime += parseTimeMs;
                        slowParsePlanTotalPlanTime += planTimeMs;
                        if (slowParsePlanSamples.length < 5 && 
                            !slowParsePlanSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                            slowParsePlanSamples.push({
                                requestTime: request.requestTime,
                                statement: request.preparedText || request.statement
                            });
                        }
                    }
                }

                // Analyze large payload streaming
                const payloadSize = request.resultSize || 0;
                const payloadSizeMB = payloadSize / (1024 * 1024); // Convert to MB

                if (payloadSizeMB >= 1) { // Result size >= 1MB
                    if (request.plan) {
                        try {
                            const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                            const elapsedTimeMs = parseTime(request.elapsedTime);
                            const streamAnalysis = analyzeStreamToElapsedRatio(planObj, elapsedTimeMs, STREAM_KERNEL_THRESHOLD_PERCENT);

                            if (streamAnalysis.qualifies) {
                                largePayloadStreamingCount++;
                                largePayloadTotalResultSize += payloadSizeMB;
                                largePayloadTotalStreamRatio += streamAnalysis.streamRatio;
                                if (largePayloadStreamingSamples.length < 5 && 
                                    !largePayloadStreamingSamples.some(s => s.statement === (request.statement || request.preparedText))) {
                                    largePayloadStreamingSamples.push({
                                        requestTime: request.requestTime,
                                        statement: request.preparedText || request.statement
                                    });
                                }
                            }
                        } catch (e) {
                            console.error("Error analyzing large payload streaming:", e);
                        }
                    }
                }

                // Count inefficient index scans
                // Exclude mutation statements (MERGE, DELETE, INSERT, UPDATE, UPSERT) which may return [] on success
                const stmtType = (request.statementType || deriveStatementType(request.statement || request.preparedText) || '').toUpperCase();
                const isMutationStatement = stmtType === 'MERGE' || stmtType === 'DELETE' || stmtType === 'INSERT' || stmtType === 'UPDATE' || stmtType === 'UPSERT';
                // Check if query has aggregate functions (exclude them)
                const hasAggregates = /\b(COUNT|AVG|MIN|MAX|SUM)\s*\(/i.test(statement);

                if (!isMutationStatement && !hasAggregates) {
                    const resultCount = request.resultCount || 0;
                    const phaseCounts = request.phaseCounts || {};

                    // Check various types of index scans
                    let totalScanned = 0;
                    if (phaseCounts.primaryScan) totalScanned += phaseCounts.primaryScan;
                    if (phaseCounts.indexScan) totalScanned += phaseCounts.indexScan;
                    if (phaseCounts['primaryScan.GSI']) totalScanned += phaseCounts['primaryScan.GSI'];
                    if (phaseCounts['indexScan.GSI']) totalScanned += phaseCounts['indexScan.GSI'];

                    // Check if scanned >= 50,000 and efficiency < 10%
                    if (totalScanned >= 50000) {
                        const efficiency = totalScanned > 0 ? (resultCount / totalScanned) * 100 : 0;
                        if (efficiency < 10) {
                            inefficientIndexScansCount++;
                            // Track metrics for average calculation
                            if (!window.inefficientScanMetrics) window.inefficientScanMetrics = [];
                            window.inefficientScanMetrics.push({
                                scanned: totalScanned,
                                resultCount: resultCount,
                                selectivity: efficiency
                            });
                        }
                    }
                }

                // Detect pagination index over-scan for ORDER BY + LIMIT + OFFSET
                const hasOrderBy = statement.includes(" ORDER BY ");
                const hasLimit = statement.includes(" LIMIT ");
                const hasOffset = statement.includes(" OFFSET ");
                if (hasOrderBy && hasLimit && hasOffset) {
                    const pc = request.phaseCounts || {};
                    const primaryCount = Math.max(pc.primaryScan || 0, pc['primaryScan.GSI'] || 0);
                    const indexCount = Math.max(pc.indexScan || 0, pc['indexScan.GSI'] || 0);
                    const scanned = Math.max(primaryCount, indexCount);
                    if (scanned >= 10000) {
                        paginationOverfetchCount++;
                        paginationOverfetchTotalScanned += scanned;
                        if (paginationOverfetchSamples.length < 5 &&
                            !paginationOverfetchSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                            paginationOverfetchSamples.push({
                                requestTime: request.requestTime,
                                statement: request.preparedText || request.statement
                            });
                        }
                    }
                }
            });

            const totalQueries = requests.length;
            const noWherePercent = totalQueries > 0 ? ((noWhereCount / totalQueries) * 100).toFixed(1) : 0;

            // Update the missing WHERE clauses insight
            const missingWhereCountElement = document.getElementById("missing-where-count");
            const missingWherePercentElement = document.getElementById("missing-where-percent");

            if (missingWhereCountElement && missingWherePercentElement) {
                missingWhereCountElement.textContent = `${noWhereCount} queries`;
                missingWherePercentElement.textContent = `${noWherePercent}%`;

                // Only highlight if there are issues
                if (noWhereCount > 0) {
                    missingWhereCountElement.className = "highlight-number";
                    missingWherePercentElement.className = "highlight-number";
                } else {
                    missingWhereCountElement.className = "";
                    missingWherePercentElement.className = "";
                }
            }

            // Update the slow USE KEYS queries insight
            const slowUseKeysCountElement = document.getElementById("slow-use-keys-count");
            const avgUseKeysTimeElement = document.getElementById("avg-use-keys-time");

            if (slowUseKeysCount > 0) {
                const avgUseKeysTime = slowUseKeysTotalTime / slowUseKeysCount;

                if (slowUseKeysCountElement) {
                    slowUseKeysCountElement.textContent = `${slowUseKeysCount} USE KEY queries`;
                    slowUseKeysCountElement.className = "highlight-number";
                }
                if (avgUseKeysTimeElement) {
                    avgUseKeysTimeElement.textContent = formatTime(avgUseKeysTime);
                    avgUseKeysTimeElement.className = "highlight-number";
                }
                const slowUseKeysPercentElement = document.getElementById("slow-use-keys-percent");
                if (slowUseKeysPercentElement) {
                    const slowUseKeysPercent = totalQueries > 0 ? ((slowUseKeysCount / totalQueries) * 100).toFixed(1) : 0;
                    slowUseKeysPercentElement.textContent = `${slowUseKeysPercent}%`;
                    slowUseKeysPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (slowUseKeysCountElement) {
                    slowUseKeysCountElement.textContent = "0 USE KEY queries";
                    slowUseKeysCountElement.className = "";
                }
                if (avgUseKeysTimeElement) {
                    avgUseKeysTimeElement.textContent = "0ms";
                    avgUseKeysTimeElement.className = "";
                }
                const slowUseKeysPercentElement = document.getElementById("slow-use-keys-percent");
                if (slowUseKeysPercentElement) {
                    slowUseKeysPercentElement.textContent = "0%";
                    slowUseKeysPercentElement.className = "";
                }
            }

            // Update the large result sets insight
            const largeResultsCountElement = document.getElementById("large-results-count");
            const avgLargeResultSizeElement = document.getElementById("avg-large-result-size");

            if (largeResultsCount > 0) {
                const avgLargeResultSize = (largeResultsTotalMB / largeResultsCount).toFixed(1);

                if (largeResultsCountElement) {
                    largeResultsCountElement.textContent = `${largeResultsCount} queries`;
                    largeResultsCountElement.className = "highlight-number";
                }
                if (avgLargeResultSizeElement) {
                    avgLargeResultSizeElement.textContent = `${avgLargeResultSize}MB`;
                    avgLargeResultSizeElement.className = "highlight-number";
                }
                const largeResultsPercentElement = document.getElementById("large-results-percent");
                if (largeResultsPercentElement) {
                    const largeResultsPercent = totalQueries > 0 ? ((largeResultsCount / totalQueries) * 100).toFixed(1) : 0;
                    largeResultsPercentElement.textContent = `${largeResultsPercent}%`;
                    largeResultsPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (largeResultsCountElement) {
                    largeResultsCountElement.textContent = "0 queries";
                    largeResultsCountElement.className = "";
                }
                if (avgLargeResultSizeElement) {
                    avgLargeResultSizeElement.textContent = "0MB";
                    avgLargeResultSizeElement.className = "";
                }
                const largeResultsPercentElement = document.getElementById("large-results-percent");
                if (largeResultsPercentElement) {
                    largeResultsPercentElement.textContent = "0%";
                    largeResultsPercentElement.className = "";
                }
            }

            // Update the large payload streaming insight
            const largePayloadCountElement = document.getElementById("large-payload-count");
            const avgPayloadSizeElement = document.getElementById("avg-payload-size");
            const avgStreamRatioElement = document.getElementById("avg-stream-ratio");

            if (largePayloadStreamingCount > 0) {
                const avgPayloadSize = (largePayloadTotalResultSize / largePayloadStreamingCount).toFixed(1);
                const avgStreamRatio = (largePayloadTotalStreamRatio / largePayloadStreamingCount).toFixed(1);

                if (largePayloadCountElement) {
                    largePayloadCountElement.textContent = `${largePayloadStreamingCount} queries`;
                    largePayloadCountElement.className = "highlight-number";
                }
                if (avgPayloadSizeElement) {
                    avgPayloadSizeElement.textContent = `${avgPayloadSize}MB`;
                    avgPayloadSizeElement.className = "highlight-number";
                }
                if (avgStreamRatioElement) {
                    avgStreamRatioElement.textContent = `${avgStreamRatio}%`;
                    avgStreamRatioElement.className = "highlight-number";
                }
                const largePayloadPercentElement = document.getElementById("large-payload-percent");
                if (largePayloadPercentElement) {
                    const largePayloadPercent = totalQueries > 0 ? ((largePayloadStreamingCount / totalQueries) * 100).toFixed(1) : 0;
                    largePayloadPercentElement.textContent = `${largePayloadPercent}%`;
                    largePayloadPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (largePayloadCountElement) {
                    largePayloadCountElement.textContent = "0 queries";
                    largePayloadCountElement.className = "";
                }
                if (avgPayloadSizeElement) {
                    avgPayloadSizeElement.textContent = "0MB";
                    avgPayloadSizeElement.className = "";
                }
                if (avgStreamRatioElement) {
                    avgStreamRatioElement.textContent = "0%";
                    avgStreamRatioElement.className = "";
                }
                const largePayloadPercentElement = document.getElementById("large-payload-percent");
                if (largePayloadPercentElement) {
                    largePayloadPercentElement.textContent = "0%";
                    largePayloadPercentElement.className = "";
                }
            }

            // Update the inefficient LIKE operations insight
            const inefficientLikeCountElement = document.getElementById("inefficient-like-count");

            if (inefficientLikeCountElement) {
                inefficientLikeCountElement.textContent = `${inefficientLikeCount} queries`;
                inefficientLikeCountElement.className = inefficientLikeCount > 0 ? "highlight-number" : "";
                const inefficientLikePercentElement = document.getElementById("inefficient-like-percent");
                if (inefficientLikePercentElement) {
                    const inefficientLikePercent = totalQueries > 0 ? ((inefficientLikeCount / totalQueries) * 100).toFixed(1) : 0;
                    inefficientLikePercentElement.textContent = `${inefficientLikePercent}%`;
                    inefficientLikePercentElement.className = inefficientLikeCount > 0 ? "highlight-number" : "";
                }
            }

            // Update the SELECT * usage insight
            const selectStarCountElement = document.getElementById("select-star-count");
            if (selectStarCountElement) {
                selectStarCountElement.textContent = `${selectStarCount} queries`;
                selectStarCountElement.className = selectStarCount > 0 ? "highlight-number" : "";
                const selectStarPercentElement = document.getElementById("select-star-percent");
                if (selectStarPercentElement) {
                    const selectStarPercent = totalQueries > 0 ? ((selectStarCount / totalQueries) * 100).toFixed(1) : 0;
                    selectStarPercentElement.textContent = `${selectStarPercent}%`;
                    selectStarPercentElement.className = selectStarCount > 0 ? "highlight-number" : "";
                }
            }
            
            // Update the Complex JOIN Operations insight (Beta - basic version)
            const complexJoinCountElement = document.getElementById("complex-join-count");
            const complexJoinPercentElement = document.getElementById("complex-join-percent");
            const complexJoinFlaggedCountElement = document.getElementById("complex-join-flagged-count");
            const complexJoinFlaggedPercentElement = document.getElementById("complex-join-flagged-percent");
            const complexJoinAvgTimeElement = document.getElementById("complex-join-avg-time");
            
            if (joinQueriesCount > 0) {
                const joinPercent = totalQueries > 0 ? ((joinQueriesCount / totalQueries) * 100).toFixed(1) : 0;
                const flaggedPercent = joinQueriesCount > 0 ? ((joinQueriesWithIssuesCount / joinQueriesCount) * 100).toFixed(1) : 0;
                const avgJoinTime = joinQueriesCount > 0 ? (joinPhaseTotalTime / joinQueriesCount / 1000).toFixed(2) : 0;
                
                if (complexJoinCountElement) {
                    complexJoinCountElement.textContent = `${joinQueriesCount} queries`;
                    complexJoinCountElement.className = "highlight-number";
                }
                if (complexJoinPercentElement) {
                    complexJoinPercentElement.textContent = `${joinPercent}%`;
                    complexJoinPercentElement.className = "highlight-number";
                }
                if (complexJoinFlaggedCountElement) {
                    complexJoinFlaggedCountElement.textContent = `${joinQueriesWithIssuesCount}`;
                    complexJoinFlaggedCountElement.className = joinQueriesWithIssuesCount > 0 ? "highlight-number" : "";
                }
                if (complexJoinFlaggedPercentElement) {
                    complexJoinFlaggedPercentElement.textContent = `${flaggedPercent}%`;
                    complexJoinFlaggedPercentElement.className = joinQueriesWithIssuesCount > 0 ? "highlight-number" : "";
                }
                if (complexJoinAvgTimeElement) {
                    complexJoinAvgTimeElement.textContent = `${avgJoinTime}s`;
                    complexJoinAvgTimeElement.className = "highlight-number";
                }
                
                // Activate the insight item if there are JOIN queries with issues
                const complexJoinInsightItem = document.querySelector('#complex-join-operations-content').closest('.insight-item');
                const complexJoinTitle = complexJoinInsightItem?.querySelector('.insight-title');
                const complexJoinContent = document.getElementById('complex-join-operations-content');
                
                if (complexJoinInsightItem && joinQueriesWithIssuesCount > 0) {
                    complexJoinInsightItem.classList.add('active');
                    // Auto-expand the content when there are issues
                    if (complexJoinTitle) complexJoinTitle.classList.remove('collapsed');
                    if (complexJoinContent) complexJoinContent.classList.remove('collapsed');
                } else if (complexJoinInsightItem) {
                    complexJoinInsightItem.classList.remove('active');
                    // Keep collapsed when no data
                    if (complexJoinTitle) complexJoinTitle.classList.add('collapsed');
                    if (complexJoinContent) complexJoinContent.classList.add('collapsed');
                }
            } else {
                // Reset to defaults
                if (complexJoinCountElement) {
                    complexJoinCountElement.textContent = "0 queries";
                    complexJoinCountElement.className = "";
                }
                if (complexJoinPercentElement) {
                    complexJoinPercentElement.textContent = "0%";
                    complexJoinPercentElement.className = "";
                }
                if (complexJoinFlaggedCountElement) {
                    complexJoinFlaggedCountElement.textContent = "0";
                    complexJoinFlaggedCountElement.className = "";
                }
                if (complexJoinFlaggedPercentElement) {
                    complexJoinFlaggedPercentElement.textContent = "0%";
                    complexJoinFlaggedPercentElement.className = "";
                }
                if (complexJoinAvgTimeElement) {
                    complexJoinAvgTimeElement.textContent = "0s";
                    complexJoinAvgTimeElement.className = "";
                }
                
                // Deactivate the insight item
                const complexJoinInsightItem = document.querySelector('#complex-join-operations-content').closest('.insight-item');
                const complexJoinTitle = complexJoinInsightItem?.querySelector('.insight-title');
                const complexJoinContent = document.getElementById('complex-join-operations-content');
                
                if (complexJoinInsightItem) {
                    complexJoinInsightItem.classList.remove('active');
                    // Keep collapsed when no data
                    if (complexJoinTitle) complexJoinTitle.classList.add('collapsed');
                    if (complexJoinContent) complexJoinContent.classList.add('collapsed');
                }
            }

            // Update the Concurrent Query Conflicts insight (Beta)
            const concurrentConflictsCountElement = document.getElementById("concurrent-conflicts-count");
            const concurrentConflictsPercentElement = document.getElementById("concurrent-conflicts-percent");
            
            if (concurrentConflictsCount > 0) {
                const conflictsPercent = totalQueries > 0 ? ((concurrentConflictsCount / totalQueries) * 100).toFixed(1) : 0;
                
                if (concurrentConflictsCountElement) {
                    concurrentConflictsCountElement.textContent = `${concurrentConflictsCount} queries`;
                    concurrentConflictsCountElement.className = "highlight-number";
                }
                if (concurrentConflictsPercentElement) {
                    concurrentConflictsPercentElement.textContent = `${conflictsPercent}%`;
                    concurrentConflictsPercentElement.className = "highlight-number";
                }
                
                // Show service pressure summary
                const summaryDiv = document.getElementById("concurrent-conflicts-summary");
                const summaryText = document.getElementById("concurrent-conflicts-services-summary");
                if (summaryDiv && summaryText) {
                    const servicePressureSummary = Object.entries(servicesUnderPressure)
                        .filter(([, count]) => count > 0)
                        .map(([service, count]) => `‚Ä¢ ${service}: ${count} queries affected`)
                        .join('<br>');
                    
                    summaryText.innerHTML = servicePressureSummary;
                    summaryDiv.style.display = 'block';
                }
                
                // Activate the insight item if there are conflicts
                const concurrentConflictsInsightItem = document.querySelector('#concurrent-query-conflicts-content').closest('.insight-item');
                const concurrentConflictsTitle = concurrentConflictsInsightItem?.querySelector('.insight-title');
                const concurrentConflictsContent = document.getElementById('concurrent-query-conflicts-content');
                
                if (concurrentConflictsInsightItem) {
                    concurrentConflictsInsightItem.classList.add('active');
                    // Auto-expand the content when there are conflicts
                    if (concurrentConflictsTitle) concurrentConflictsTitle.classList.remove('collapsed');
                    if (concurrentConflictsContent) concurrentConflictsContent.classList.remove('collapsed');
                }
            } else {
                // Reset to defaults
                if (concurrentConflictsCountElement) {
                    concurrentConflictsCountElement.textContent = "0 queries";
                    concurrentConflictsCountElement.className = "";
                }
                if (concurrentConflictsPercentElement) {
                    concurrentConflictsPercentElement.textContent = "0%";
                    concurrentConflictsPercentElement.className = "";
                }
                
                // Hide service pressure summary
                const summaryDiv = document.getElementById("concurrent-conflicts-summary");
                if (summaryDiv) {
                    summaryDiv.style.display = 'none';
                }
                
                // Deactivate the insight item
                const concurrentConflictsInsightItem = document.querySelector('#concurrent-query-conflicts-content').closest('.insight-item');
                const concurrentConflictsTitle = concurrentConflictsInsightItem?.querySelector('.insight-title');
                const concurrentConflictsContent = document.getElementById('concurrent-query-conflicts-content');
                
                if (concurrentConflictsInsightItem) {
                    concurrentConflictsInsightItem.classList.remove('active');
                    // Keep collapsed when no data
                    if (concurrentConflictsTitle) concurrentConflictsTitle.classList.add('collapsed');
                    if (concurrentConflictsContent) concurrentConflictsContent.classList.add('collapsed');
                }
            }

            // Update the high memory usage insight
            const highMemoryCountElement = document.getElementById("high-memory-count");
            const avgMemoryUsageElement = document.getElementById("avg-memory-usage");

            if (highMemoryCount > 0) {
                const avgMemoryGB = (highMemoryTotalGB / highMemoryCount).toFixed(1);

                if (highMemoryCountElement) {
                    highMemoryCountElement.textContent = `${highMemoryCount} queries`;
                    highMemoryCountElement.className = "highlight-number";
                }
                if (avgMemoryUsageElement) {
                    avgMemoryUsageElement.textContent = `${avgMemoryGB}GB`;
                    avgMemoryUsageElement.className = "highlight-number";
                }
                const highMemoryPercentElement = document.getElementById("high-memory-percent");
                if (highMemoryPercentElement) {
                    const highMemoryPercent = totalQueries > 0 ? ((highMemoryCount / totalQueries) * 100).toFixed(1) : 0;
                    highMemoryPercentElement.textContent = `${highMemoryPercent}%`;
                    highMemoryPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (highMemoryCountElement) {
                    highMemoryCountElement.textContent = "0 queries";
                    highMemoryCountElement.className = "";
                }
                if (avgMemoryUsageElement) {
                    avgMemoryUsageElement.textContent = "0GB";
                    avgMemoryUsageElement.className = "";
                }
                const highMemoryPercentElement = document.getElementById("high-memory-percent");
                if (highMemoryPercentElement) {
                    highMemoryPercentElement.textContent = "0%";
                    highMemoryPercentElement.className = "";
                }
            }

            // Update the high kernel time insight
            const highKernelTimeQueriesCountElement = document.getElementById("high-kernel-time-queries-count");
            const avgCoreKernelRatioElement = document.getElementById("avg-core-kernel-ratio");

            if (highKernelTimeQueriesCount > 0) {
                const avgCoreKernelRatio = (totalCoreKernelRatio / highKernelTimeQueriesCount).toFixed(1);

                if (highKernelTimeQueriesCountElement) {
                    highKernelTimeQueriesCountElement.textContent = `${highKernelTimeQueriesCount} queries`;
                    highKernelTimeQueriesCountElement.className = "highlight-number";
                }
                if (avgCoreKernelRatioElement) {
                    avgCoreKernelRatioElement.textContent = `${avgCoreKernelRatio}%`;
                    avgCoreKernelRatioElement.className = "highlight-number";
                }
                const highKernelTimePercentElement = document.getElementById("high-kernel-time-queries-percent");
                if (highKernelTimePercentElement) {
                    const highKernelPercent = totalQueries > 0 ? ((highKernelTimeQueriesCount / totalQueries) * 100).toFixed(1) : 0;
                    highKernelTimePercentElement.textContent = `${highKernelPercent}%`;
                    highKernelTimePercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (highKernelTimeQueriesCountElement) {
                    highKernelTimeQueriesCountElement.textContent = "0 queries";
                    highKernelTimeQueriesCountElement.className = "";
                }
                if (avgCoreKernelRatioElement) {
                    avgCoreKernelRatioElement.textContent = "0%";
                    avgCoreKernelRatioElement.className = "";
                }
                const highKernelTimePercentElement = document.getElementById("high-kernel-time-queries-percent");
                if (highKernelTimePercentElement) {
                    highKernelTimePercentElement.textContent = "0%";
                    highKernelTimePercentElement.className = "";
                }
            }

            // Update the inefficient index scans insight
            const inefficientIndexScansCountElement = document.getElementById("inefficient-index-scans-count");
            const avgScanCountElement = document.getElementById("avg-scan-count");
            const avgResultCountElement = document.getElementById("avg-result-count");
            const avgSelectivityElement = document.getElementById("avg-selectivity");

            // Update pagination over-scan insight
            const paginationOverfetchCountElement = document.getElementById("pagination-overfetch-count");
            const paginationOverfetchAvgElement = document.getElementById("pagination-overfetch-avg-items");
            if (paginationOverfetchCountElement) {
                paginationOverfetchCountElement.textContent = `${paginationOverfetchCount} queries`;
                paginationOverfetchCountElement.className = paginationOverfetchCount > 0 ? "highlight-number" : "";
                const paginationOverfetchPercentElement = document.getElementById("pagination-overfetch-percent");
                if (paginationOverfetchPercentElement) {
                    const paginationOverfetchPercent = totalQueries > 0 ? ((paginationOverfetchCount / totalQueries) * 100).toFixed(1) : 0;
                    paginationOverfetchPercentElement.textContent = `${paginationOverfetchPercent}%`;
                    paginationOverfetchPercentElement.className = paginationOverfetchCount > 0 ? "highlight-number" : "";
                }
            }
            if (paginationOverfetchAvgElement) {
                const avgScanned = paginationOverfetchCount > 0 ? Math.round(paginationOverfetchTotalScanned / paginationOverfetchCount) : 0;
                paginationOverfetchAvgElement.textContent = avgScanned.toLocaleString();
                paginationOverfetchAvgElement.className = paginationOverfetchCount > 0 ? "highlight-number" : "";
            }

            if (inefficientIndexScansCountElement) {
                inefficientIndexScansCountElement.textContent = `${inefficientIndexScansCount} queries`;
                inefficientIndexScansCountElement.className = inefficientIndexScansCount > 0 ? "highlight-number" : "";
                const inefficientIndexScansPercentElement = document.getElementById("inefficient-index-scans-percent");
                if (inefficientIndexScansPercentElement) {
                    const inefficientIndexScansPercent = totalQueries > 0 ? ((inefficientIndexScansCount / totalQueries) * 100).toFixed(1) : 0;
                    inefficientIndexScansPercentElement.textContent = `${inefficientIndexScansPercent}%`;
                    inefficientIndexScansPercentElement.className = inefficientIndexScansCount > 0 ? "highlight-number" : "";
                }
            }

            // Calculate and display averages
            if (window.inefficientScanMetrics && window.inefficientScanMetrics.length > 0) {
                const totalScanned = window.inefficientScanMetrics.reduce((sum, metric) => sum + metric.scanned, 0);
                const totalResults = window.inefficientScanMetrics.reduce((sum, metric) => sum + metric.resultCount, 0);
                const totalSelectivity = window.inefficientScanMetrics.reduce((sum, metric) => sum + metric.selectivity, 0);

                const avgScanned = Math.round(totalScanned / window.inefficientScanMetrics.length);
                const avgResults = Math.round(totalResults / window.inefficientScanMetrics.length);
                const avgSelectivity = (totalSelectivity / window.inefficientScanMetrics.length).toFixed(2);

                if (avgScanCountElement) {
                    avgScanCountElement.textContent = avgScanned.toLocaleString();
                    avgScanCountElement.className = "highlight-number";
                }
                if (avgResultCountElement) {
                    avgResultCountElement.textContent = avgResults.toLocaleString();
                    avgResultCountElement.className = "highlight-number";
                }
                if (avgSelectivityElement) {
                    avgSelectivityElement.textContent = `${avgSelectivity}%`;
                    avgSelectivityElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults when no inefficient queries
                if (avgScanCountElement) {
                    avgScanCountElement.textContent = "0";
                    avgScanCountElement.className = "";
                }
                if (avgResultCountElement) {
                    avgResultCountElement.textContent = "0";
                    avgResultCountElement.className = "";
                }
                if (avgSelectivityElement) {
                    avgSelectivityElement.textContent = "0%";
                    avgSelectivityElement.className = "";
                }
            }

            // Update the timeout-prone queries insight
            const timeoutProneContent = document.getElementById("timeout-prone-queries-content");
            if (timeoutProneContent) {
                const approachingHighlight = approachingTimeoutCount > 0 ? "highlight-number" : "";
                const actualHighlight = actualTimeoutCount > 0 ? "highlight-number" : "";
                const approachingTimeoutPercent = totalQueries > 0 ? ((approachingTimeoutCount / totalQueries) * 100).toFixed(1) : 0;
                const actualTimeoutPercent = totalQueries > 0 ? ((actualTimeoutCount / totalQueries) * 100).toFixed(1) : 0;
                
                timeoutProneContent.innerHTML = `
                    <p class=\"insight-description\">
                        <span id=\"approaching-timeout-count\" class=\"${approachingHighlight}\">${approachingTimeoutCount} queries</span> (<span id=\"approaching-timeout-percent\" class=\"${approachingHighlight}\">${approachingTimeoutPercent}%</span>) are consistently approaching timeout
                        thresholds, with <span id=\"actual-timeout-count\" class=\"${actualHighlight}\">${actualTimeoutCount} queries</span> (<span id=\"actual-timeout-percent\" class=\"${actualHighlight}\">${actualTimeoutPercent}%</span>) actually timing out
                        in the analyzed period. <em>(Default query timeout: 75 seconds / 1m15s)</em>
                    </p>

                    <button id=\"toggle-timeout-prone-queries-sample-queries-btn\" onclick=\"toggleTimeoutQueriesTable()\" class=\"btn-standard\" style=\"margin-top: 10px;\">
                        <span id=\"timeout-prone-queries-sample-queries-btn-text\">Show Sample Queries</span>
                    </button>
                    <div id=\"timeout-prone-queries-sample-queries-container\" style=\"display: none; margin-top: 10px;\">
                        <table class=\"sample-queries-table\">
                            <thead>
                                <tr>
                                    <th>Request Date</th>
                                    <th>Statement (unique)</th>
                                    <th>Elapsed Time</th>
                                </tr>
                            </thead>
                            <tbody id=\"timeout-prone-queries-sample-queries-tbody\">
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // Reset metrics for next parse
            window.inefficientScanMetrics = [];

            // Update slow index scan times insight
            updateSlowIndexScanTimes(requests);

            // Update slow parse/plan times insight
            const slowParsePlanCountElement = document.getElementById("slow-parse-plan-count");
            const slowParsePlanPercentElement = document.getElementById("slow-parse-plan-percent");
            const avgParseTimeElement = document.getElementById("avg-parse-time");
            const avgPlanTimeElement = document.getElementById("avg-plan-time");
            
            if (slowParsePlanCountElement) {
                slowParsePlanCountElement.textContent = `${slowParsePlanCount} queries`;
                slowParsePlanCountElement.className = slowParsePlanCount > 0 ? "highlight-number" : "";
            }
            if (slowParsePlanPercentElement) {
                const slowParsePlanPercent = totalQueries > 0 ? ((slowParsePlanCount / totalQueries) * 100).toFixed(1) : 0;
                slowParsePlanPercentElement.textContent = `${slowParsePlanPercent}%`;
                slowParsePlanPercentElement.className = slowParsePlanCount > 0 ? "highlight-number" : "";
            }
            if (avgParseTimeElement) {
                const avgParseTime = slowParsePlanCount > 0 ? (slowParsePlanTotalParseTime / slowParsePlanCount).toFixed(3) : 0;
                avgParseTimeElement.textContent = `${avgParseTime}ms`;
                avgParseTimeElement.className = slowParsePlanCount > 0 ? "highlight-number" : "";
            }
            if (avgPlanTimeElement) {
                const avgPlanTime = slowParsePlanCount > 0 ? (slowParsePlanTotalPlanTime / slowParsePlanCount).toFixed(3) : 0;
                avgPlanTimeElement.textContent = `${avgPlanTime}ms`;
                avgPlanTimeElement.className = slowParsePlanCount > 0 ? "highlight-number" : "";
            }

            // Update sample queries for each insight
            Logger.debug(`[updateInsights] About to update insight sample queries, sampleQueries.length=${sampleQueries.length}`);
            
            updateInsightSampleQueries('missing-where-clauses', missingWhereClausesSamples);
            updateInsightSampleQueries('slow-use-key-queries', slowUseKeyQueriesSamples);
            updateInsightSampleQueries('large-result-set-queries', largeResultSetQueriesSamples);
            updateInsightSampleQueries('inefficient-like-operations', inefficientLikeOperationsSamples);
            updateInsightSampleQueries('select-star-usage', selectStarUsageSamples);
            updateInsightSampleQueries('pagination-index-overfetch', paginationOverfetchSamples);
            updateInsightSampleQueries('high-memory-usage', highMemoryUsageSamples);
            updateInsightSampleQueries('high-kernel-time-queries', highKernelTimeQueriesSamples);
            updateInsightSampleQueries('large-payload-streaming', largePayloadStreamingSamples);
            updateInsightSampleQueries('slow-parse-plan-times', slowParsePlanSamples);
            updateJoinSampleQueries(complexJoinOperationsSamples); // Custom function with flags column
            updateConcurrentConflictsSampleQueries(concurrentConflictsSamples, flagCounts); // Custom function with service pressure flags

            // Special handling for timeout queries (3-column table with 10 entries)
            updateTimeoutQueriesTable(actualTimeoutsSamples, approachingTimeoutsSamples);

            // Update navigation counts and accordion states
            updateInsightNavigation();
        }

        // Analyze core execTime vs kernel time ratio
        function analyzeCoreExecToKernelRatio(operator) {
            if (!operator) return { coreToKernelRatio: 0 };

            let totalExecTime = 0;
            let streamExecTime = 0;
            let highestKernelTime = 0;

            function sumExecAndKernelTimes(op) {
                if (!op) return;

                if (op["#stats"]) {
                    const stats = op["#stats"];

                    // Sum all execTime
                    if (stats["execTime"]) {
                        const execTime = parseTime(stats["execTime"]);
                        if (!isNaN(execTime)) {
                            totalExecTime += execTime;

                            // Track stream execTime separately
                            if (op["#operator"] === "Stream") {
                                streamExecTime += execTime;
                            }
                        }
                    }

                    // Track highest kernel time
                    if (stats["kernTime"]) {
                        const kernTime = parseTime(stats["kernTime"]);
                        if (!isNaN(kernTime)) {
                            highestKernelTime = Math.max(highestKernelTime, kernTime);
                        }
                    }
                }

                // Recursively check child operators
                if (op["~child"]) {
                    sumExecAndKernelTimes(op["~child"]);
                }
                if (op["~children"]) {
                    for (const child of op["~children"]) {
                        sumExecAndKernelTimes(child);
                    }
                }
            }

            sumExecAndKernelTimes(operator);

            // Calculate core execTime (total minus stream) vs kernel time ratio
            const coreExecTime = totalExecTime - streamExecTime;
            const coreToKernelRatio = highestKernelTime > 0 ? (coreExecTime / highestKernelTime) * 100 : 0;



            return {
                coreToKernelRatio: coreToKernelRatio
            };
        }

        // Analyze stream execution time vs elapsed time
        function analyzeStreamToElapsedRatio(operator, elapsedTimeMs, thresholdPercent) {
            if (!operator) return { qualifies: false, streamRatio: 0 };

            let streamExecTime = 0;

            function findStreamTimes(op) {
                if (!op) return;

                if (op["#stats"]) {
                    const stats = op["#stats"];

                    // Find Stream operations
                    if (op["#operator"] === "Stream" && stats["execTime"]) {
                        const execTime = parseTime(stats["execTime"]);
                        if (!isNaN(execTime)) {
                            streamExecTime += execTime;
                        }
                    }
                }

                // Recursively check child operators
                if (op["~child"]) {
                    findStreamTimes(op["~child"]);
                }
                if (op["~children"]) {
                    for (const child of op["~children"]) {
                        findStreamTimes(child);
                    }
                }
            }

            findStreamTimes(operator);

            // Calculate stream to elapsed time ratio
            const streamRatio = elapsedTimeMs > 0 ? (streamExecTime / elapsedTimeMs) * 100 : 0;
            const qualifies = streamRatio >= thresholdPercent;



            return {
                qualifies: qualifies,
                streamRatio: streamRatio
            };
        }

        // Toggle accordion category
        function toggleCategory(categoryId) {
            const title = document.querySelector(`#${categoryId} .category-title`);
            const content = document.getElementById(`${categoryId}-content`);

            if (title && content) {
                title.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
            }
        }

        // Toggle individual insight
        function toggleInsight(insightId) {
            const title = document.querySelector(`[onclick="toggleInsight('${insightId}')"]`);
            const content = document.getElementById(`${insightId}-content`);

            if (title && content) {
                title.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
            }
        }

        // Update insight accordion states
        function updateInsightNavigation() {
            // Always show all categories and expand them
            const categories = ['index-issues', 'resource-issues', 'pattern-analysis', 'performance-opportunities'];

            categories.forEach(categoryId => {
                const categoryElement = document.getElementById(categoryId);
                const titleElement = categoryElement?.querySelector('.category-title');
                const contentElement = document.getElementById(`${categoryId}-content`);

                // Show category and expand accordion
                if (categoryElement) categoryElement.style.display = 'block';
                if (titleElement) titleElement.classList.remove('collapsed');
                if (contentElement) contentElement.classList.remove('collapsed');
            });

            // Auto-expand individual insights that have issues (non-zero values)
            const totalInsights = autoExpandInsightsWithIssues();
            
            // Update Insights tab badge (Issue #164)
            const badge = document.getElementById('insights-badge');
            if (badge) {
                if (totalInsights > 0) {
                    badge.textContent = totalInsights; // Simple count, not fraction
                    badge.style.display = 'inline-block';
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        // Auto-expand insights with actual issues found (returns total count - Issue #164)
        function autoExpandInsightsWithIssues() {
            const insights = [
                { id: 'inefficient-index-scans', checkElement: 'inefficient-index-scans-count' },
                { id: 'slow-index-scan-times', checkElements: ['slow-indexes-2-10s', 'slow-indexes-10s-plus', 'slow-primary-indexes'] },
                { id: 'primary-index-over-usage', checkElement: 'primary-avg-items-scanned' },
                { id: 'high-kernel-time-queries', checkElement: 'high-kernel-time-queries-count' },
                { id: 'high-memory-usage', checkElement: 'high-memory-count' },
                { id: 'slow-parse-plan-times', checkElement: 'slow-parse-plan-count' },
                { id: 'slow-use-key-queries', checkElement: 'slow-use-keys-count' },
                { id: 'missing-where-clauses', checkElement: 'missing-where-count' },
                { id: 'complex-join-operations', checkElement: 'complex-join-count' },
                { id: 'inefficient-like-operations', checkElement: 'inefficient-like-count' },
                { id: 'select-star-usage', checkElement: 'select-star-count' },
                { id: 'pagination-index-overfetch', checkElement: 'pagination-overfetch-count' },
                { id: 'large-result-set-queries', checkElement: 'large-results-count' },
                { id: 'large-payload-streaming', checkElement: 'large-payload-count' },
                { id: 'timeout-prone-queries', checkElements: ['approaching-timeout-count', 'actual-timeout-count'] },
                { id: 'concurrent-query-conflicts', checkElement: 'concurrent-conflicts-count' }
            ];

            let totalInsightsWithIssues = 0;

            insights.forEach(insight => {
                const titleElement = document.querySelector(`[onclick="toggleInsight('${insight.id}')"]`);
                const contentElement = document.getElementById(`${insight.id}-content`);

                let hasIssues = false;

                // Check if insight has issues (non-zero values)
                if (insight.checkElement) {
                    const element = document.getElementById(insight.checkElement);
                    if (element && element.textContent) {
                        const value = element.textContent.match(/\d+/);
                        hasIssues = value && parseInt(value[0]) > 0;
                    }
                }

                if (insight.checkElements) {
                    hasIssues = insight.checkElements.some(elementId => {
                        const element = document.getElementById(elementId);
                        if (element && element.textContent) {
                            const value = element.textContent.match(/\d+/);
                            return value && parseInt(value[0]) > 0;
                        }
                        return false;
                    });
                }

                // Set accordion state based on whether issues were found
                if (hasIssues) {
                    totalInsightsWithIssues++; // Count insights with issues (Issue #164)
                    // Expand insight with issues
                    if (titleElement) titleElement.classList.remove('collapsed');
                    if (contentElement) contentElement.classList.remove('collapsed');
                } else {
                    // Collapse insight with no issues
                    if (titleElement) titleElement.classList.add('collapsed');
                    if (contentElement) contentElement.classList.add('collapsed');
                }

                // Toggle visual active state (blue edge when issues found)
                const card = titleElement ? titleElement.closest('.insight-item') : null;
                if (card) {
                    card.classList.toggle('active', !!hasIssues);
                }
            });

            // Handle dev insights - always collapsed and not active since they don't have real data
            const devInsights = document.querySelectorAll('.insight-item:has(.dev-badge)');
            devInsights.forEach(devInsight => {
                const titleElement = devInsight.querySelector('.insight-title');
                const contentElement = devInsight.querySelector('.insight-content');

                if (titleElement) titleElement.classList.add('collapsed');
                if (contentElement) contentElement.classList.add('collapsed');
                devInsight.classList.remove('active');
            });

            // Handle beta insights - collapsed by default, but can be expanded based on results
            // (Beta insights are included in the main insights array above)

            // Update category counters (Issue #161)
            updateCategoryCounters();
            
            // Return total count for badge update (Issue #164)
            return totalInsightsWithIssues;
        }

        // Update insight indicators (Issue #183 - moved from category to insight level with numbering)
        function updateCategoryCounters() {
            const categories = {
                'index-issues': ['inefficient-index-scans', 'slow-index-scan-times', 'primary-index-over-usage', 'pagination-index-overfetch'],
                'resource-issues': ['high-kernel-time-queries', 'high-memory-usage', 'slow-parse-plan-times', 'slow-use-key-queries'],
                'pattern-analysis': ['missing-where-clauses', 'complex-join-operations', 'inefficient-like-operations', 'select-star-usage'],
                'performance-opportunities': ['large-payload-streaming', 'large-result-set-queries', 'timeout-prone-queries', 'concurrent-query-conflicts']
            };

            const allInsights = Object.values(categories).flat();
            let activeInsightNumber = 1;

            // Update insight indicators
            allInsights.forEach(insightId => {
                const contentElement = document.getElementById(`${insightId}-content`);
                const card = contentElement?.closest('.insight-item');
                const indicatorElement = document.getElementById(`${insightId}-indicator`);
                
                if (indicatorElement) {
                    // Show indicator with sequential number only if insight is active (has issues)
                    if (card && card.classList.contains('active')) {
                        indicatorElement.textContent = `#${activeInsightNumber}`;
                        indicatorElement.classList.add('active');
                        activeInsightNumber++;
                    } else {
                        indicatorElement.textContent = '';
                        indicatorElement.classList.remove('active');
                    }
                }
            });

            // Auto-expand categories that contain active insights (Issue #183)
            Object.keys(categories).forEach(categoryId => {
                const insightIds = categories[categoryId];
                const hasActiveInsight = insightIds.some(insightId => {
                    const contentElement = document.getElementById(`${insightId}-content`);
                    const card = contentElement?.closest('.insight-item');
                    return card && card.classList.contains('active');
                });

                const categoryTitle = document.querySelector(`#${categoryId} .category-title`);
                const categoryContent = document.getElementById(`${categoryId}-content`);
                
                if (categoryTitle && categoryContent) {
                    if (hasActiveInsight) {
                        // Expand category if it has active insights
                        categoryTitle.classList.remove('collapsed');
                        categoryContent.classList.remove('collapsed');
                    } else {
                        // Keep category collapsed if no active insights
                        categoryTitle.classList.add('collapsed');
                        categoryContent.classList.add('collapsed');
                    }
                }
            });
        }

        // Update slow index scan times insight
        function updateSlowIndexScanTimes(requests) {
            const indexData = {};
            let totalIndexes = 0;
            let slowIndexes2to10s = 0;
            let slowIndexes10sPlus = 0;
            let slowPrimaryIndexes = 0;

            // Collect index data using same logic as Index/Query Flow
            requests.forEach((request) => {
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;

                        // Extract index names and collect timing data
                        extractIndexNamesAndData(planObj, (indexName) => {
                            if (!indexData[indexName]) {
                                indexData[indexName] = {
                                    name: indexName,
                                    scanTimes: [],
                                    totalUsage: 0
                                };
                            }

                            const indexScanData = extractIndexScanDataFromPlan(request.plan, indexName);
                            if (indexScanData.scanTime > 0) {
                                indexData[indexName].scanTimes.push(indexScanData.scanTime);
                                indexData[indexName].totalUsage++;
                            }
                        });
                    } catch (e) {
                        console.error("Error parsing plan for index timing:", e);
                    }
                }
            });

            // Helper function to extract index names
            function extractIndexNamesAndData(operator, callback) {
                if (!operator) return;

                const opType = operator["#operator"];

                if ((opType === "IndexScan3" || opType === "PrimaryScan3" || opType === "KeyScan") && operator.index) {
                    callback(operator.index);
                }

                // Recursively search child operators
                if (operator["~child"]) {
                    extractIndexNamesAndData(operator["~child"], callback);
                }
                if (operator["~children"]) {
                    for (const child of operator["~children"]) {
                        extractIndexNamesAndData(child, callback);
                    }
                }
            }

            // Use the same aggregated index data as Index/Query Flow
            updatePrimaryIndexOverUsageFromAggregatedData(requests);

            // Debug: Log the collected index data
            Logger.debug(`${TEXT_CONSTANTS.COLLECTED_INDEX_DATA}`, window.DebugRedactor ? window.DebugRedactor.redactObject(indexData) : '[REDACTED]');

            // Analyze timing data for each index
            Object.values(indexData).forEach((index) => {
                totalIndexes++;

                if (index.scanTimes && index.scanTimes.length > 0) {
                    const avgScanTimeMs = index.scanTimes.reduce((a, b) => a + b, 0) / index.scanTimes.length;
                    const avgScanTimeSeconds = avgScanTimeMs / 1000;

                    if (avgScanTimeSeconds >= 10) {
                        slowIndexes10sPlus++;
                        Logger.debug(`${window.DebugRedactor ? window.DebugRedactor.hash(index.name) : index.name} is 10+ seconds`);
                    } else if (avgScanTimeSeconds >= 2) {
                        slowIndexes2to10s++;
                        Logger.debug(`${window.DebugRedactor ? window.DebugRedactor.hash(index.name) : index.name} is 2-10 seconds`);
                    }

                    // Check if it's a primary index with 2+ seconds
                    if ((index.name.includes("primary") || index.name === "#primary" || index.name === "def_primary") && avgScanTimeSeconds >= 2) {
                        slowPrimaryIndexes++;
                        Logger.debug(`${index.name} is a slow primary index`);
                    }
                }
            });



            // Update display elements for slow index scan times
            const totalIndexesElement = document.getElementById("total-indexes-count");
            const slowIndexes2to10sElement = document.getElementById("slow-indexes-2-10s");
            const slowIndexes10sPlusElement = document.getElementById("slow-indexes-10s-plus");
            const slowPrimaryIndexesElement = document.getElementById("slow-primary-indexes");

            if (totalIndexesElement) totalIndexesElement.textContent = totalIndexes;
            if (slowIndexes2to10sElement) slowIndexes2to10sElement.textContent = slowIndexes2to10s;
            if (slowIndexes10sPlusElement) slowIndexes10sPlusElement.textContent = slowIndexes10sPlus;
            if (slowPrimaryIndexesElement) slowPrimaryIndexesElement.textContent = slowPrimaryIndexes;
        }

        // Update Primary Index Over-Usage using same aggregated data as Index/Query Flow
        function updatePrimaryIndexOverUsageFromAggregatedData(requests) {
            const allIndexes = new Map();

            // Use the exact same logic as Index/Query Flow to build aggregated index data
            requests.forEach((request) => {
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        extractIndexNamesForFlow(planObj, allIndexes, request);
                    } catch (e) {
                        console.error("Error parsing plan for aggregated index data:", e);
                    }
                }
            });

            // Helper function (simplified version of existing Index/Query Flow logic)
            function extractIndexNamesForFlow(operator, allIndexes, request) {
                if (!operator) return;

                const opType = operator["#operator"];

                if ((opType === "IndexScan3" || opType === "PrimaryScan3" || opType === "KeyScan") && operator.index) {
                    const indexName = operator.index;

                    if (!allIndexes.has(indexName)) {
                        allIndexes.set(indexName, {
                            name: indexName,
                            totalUsage: 0,
                            scanTimes: [],
                            itemsScanned: [],
                            itemsFetched: []
                        });
                    }

                    const indexObj = allIndexes.get(indexName);
                    indexObj.totalUsage++;

                    // Extract data using same function as Index/Query Flow
                    const indexData = extractIndexScanDataFromPlan(request.plan, indexName);
                    if (indexData.scanTime > 0) {
                        indexObj.scanTimes.push(indexData.scanTime);
                    }
                    if (indexData.itemsScanned > 0) {
                        indexObj.itemsScanned.push(indexData.itemsScanned);
                    }
                    if (indexData.itemsFetched > 0) {
                        indexObj.itemsFetched.push(indexData.itemsFetched);
                    }
                }

                // Recursively search child operators (same as existing logic)
                if (operator["~child"]) {
                    extractIndexNamesForFlow(operator["~child"], allIndexes, request);
                }
                if (operator["~children"]) {
                    for (const child of operator["~children"]) {
                        extractIndexNamesForFlow(child, allIndexes, request);
                    }
                }
            }

            // Now analyze primary indexes using aggregated data
            let totalPrimaryItemsScanned = 0;
            let totalPrimaryScanTime = 0;
            let primaryIndexCount = 0;

            allIndexes.forEach((index) => {
                const isPrimary = index.name.includes("primary") || index.name === "#primary" || index.name === "def_primary";

                if (isPrimary && index.itemsScanned.length > 0) {
                    // Calculate aggregated stats using same logic as Index/Query Flow
                    const avgItemsScanned = Math.round(
                        index.itemsScanned.reduce((a, b) => a + b, 0) / index.itemsScanned.length
                    );
                    const avgScanTime = index.scanTimes.length > 0
                        ? Math.round(index.scanTimes.reduce((a, b) => a + b, 0) / index.scanTimes.length)
                        : 0;

                    if (avgItemsScanned > 10000) {
                        totalPrimaryItemsScanned += avgItemsScanned;
                        totalPrimaryScanTime += avgScanTime;
                        primaryIndexCount++;
                    }
                }
            });

            // Update primary index over-usage insight display
            const primaryAvgItemsScannedElement = document.getElementById("primary-avg-items-scanned");
            const primaryAvgScanTimeElement = document.getElementById("primary-avg-scan-time");

            if (primaryIndexCount > 0) {
                const avgItemsScanned = Math.round(totalPrimaryItemsScanned / primaryIndexCount);
                const avgScanTime = Math.round(totalPrimaryScanTime / primaryIndexCount);

                if (primaryAvgItemsScannedElement) {
                    primaryAvgItemsScannedElement.textContent = avgItemsScanned.toLocaleString();
                    primaryAvgItemsScannedElement.className = "highlight-number";
                }
                if (primaryAvgScanTimeElement) {
                    primaryAvgScanTimeElement.textContent = `${avgScanTime}ms`;
                    primaryAvgScanTimeElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (primaryAvgItemsScannedElement) {
                    primaryAvgItemsScannedElement.textContent = "0";
                    primaryAvgItemsScannedElement.className = "";
                }
                if (primaryAvgScanTimeElement) {
                    primaryAvgScanTimeElement.textContent = "0ms";
                    primaryAvgScanTimeElement.className = "";
                }
            }
        }

        // Extract index data for timing analysis (simplified version of existing logic)
        function extractIndexDataForTiming(operator, indexData) {
            if (!operator) return;

            const opType = operator["#operator"];

            if ((opType === "IndexScan3" || opType === "PrimaryScan3" || opType === "KeyScan") && operator.index) {
                const indexName = operator.index;

                if (!indexData[indexName]) {
                    indexData[indexName] = {
                        name: indexName,
                        scanTimes: [],
                        totalUsage: 0
                    };
                }

                if (operator["#stats"] && operator["#stats"]["servTime"]) {
                    const scanTime = parseTime(operator["#stats"]["servTime"]);
                    indexData[indexName].scanTimes.push(scanTime);
                    indexData[indexName].totalUsage++;
                }
            }

            // Recursively search child operators
            if (operator["~child"]) {
                extractIndexDataForTiming(operator["~child"], indexData);
            }
            if (operator["~children"]) {
                for (const child of operator["~children"]) {
                    extractIndexDataForTiming(child, indexData);
                }
            }
        }



        // Validate date range for time grouping
        function validateDateRangeForGrouping(startDate, endDate, grouping) {
            if (!startDate || !endDate || grouping === "optimizer" || grouping === "day")
                return { valid: true };

            const diffMs = endDate.getTime() - startDate.getTime();
            const diffHours = diffMs / (1000 * 60 * 60);
            const diffDays = diffMs / (1000 * 60 * 60 * 24);

            switch (grouping) {
                case "second":
                    if (diffHours > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Second" grouping, please restrict the date range to 1 hour or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "minute":
                    if (diffDays > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Minute" grouping, please restrict the date range to 1 day or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "5min":
                    const diffWeeks5min = diffDays / 7;
                    if (diffWeeks5min > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by 5min" grouping, please restrict the date range to 1 week or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "hour":
                    const diffWeeks = diffDays / 7;
                    if (diffWeeks > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Hour" grouping, please restrict the date range to 1 week or less to avoid chart rendering issues.',
                        };
                    }
                    break;
            }

            return { valid: true };
        }

        // Centralized request data processor with single-pass optimization
        function processRequestData(item) {
            const request = item.completed_requests || item;

            // Parse and cache plan data immediately
            let plan = null;
            if (item.plan) {
                if (typeof item.plan === "string") {
                    try {
                        plan = JSON.parse(item.plan);
                    } catch (e) {
                        Logger.error(`${TEXT_CONSTANTS.JSON_PARSING_ERROR} plan for request:`, e.message);
                        showToast(`${TEXT_CONSTANTS.ERROR_PARSING_JSON} ${e.message}`, "warning");
                        plan = null;
                    }
                } else {
                    plan = item.plan;
                }
            }

            // Get operators once and cache all derived values
            let operators = [];
            let planMetadata = null;

            if (plan) {
                // Check if we already cached the plan stats
                if (planStatsCache.has(plan)) {
                    planMetadata = planStatsCache.get(plan);
                    operators = planMetadata.operators;
                } else {
                    // Single pass through operators to extract all needed data
                    operators = getOperators(plan);

                    // Calculate all time values in one pass
                    let maxKernTime = 0;
                    let totalExecTime = 0;
                    let totalServiceTime = 0;
                    let totalMemoryUsage = 0;
                    let totalItemsIn = 0;
                    let totalItemsOut = 0;
                    let streamTime = 0;
                    let fetchTime = 0;
                    let sortTime = 0;
                    const indexes = [];
                    const stats = { primaryScan: 0, indexScan: 0, fetch: 0 };
                    let usesPrimaryFlag = false;

                    operators.forEach((operator) => {
                        const operatorStats = operator["#stats"] || {};
                        const operatorType = operator["#operator"];

                        // Parse times once
                        const kernTime = parseTime(operatorStats.kernTime);
                        const execTime = parseTime(operatorStats.execTime);
                        const servTime = parseTime(operatorStats.servTime);
                        const usedMemory = operatorStats.usedMemory || 0;

                        // Aggregate times and stats
                        if (!isNaN(kernTime)) maxKernTime = Math.max(maxKernTime, kernTime);
                        if (!isNaN(execTime)) totalExecTime += execTime;
                        if (!isNaN(servTime)) totalServiceTime += servTime;
                        if (!isNaN(usedMemory)) totalMemoryUsage += usedMemory;

                        // Aggregate items in/out
                        totalItemsIn += operatorStats["#itemsIn"] || 0;
                        totalItemsOut += operatorStats["#itemsOut"] || 0;

                        // Extract index information
                        if (operator.index) {
                            indexes.push(operator.index);
                        }

                        // Check for primary index usage
                        if (operatorType === "PrimaryScan" ||
                            operatorType === "PrimaryScan3" ||
                            operator.index === "#primary" ||
                            (operator.spans && operator.spans.length === 0)) {
                            usesPrimaryFlag = true;
                        }

                        // Update stats counters with actual items and extract phase times
                        if (operatorType === "PrimaryScan" || operatorType === "PrimaryScan3") {
                            stats.primaryScan += operatorStats["#itemsOut"] || 0;
                        } else if (operatorType === "IndexScan" || operatorType === "IndexScan3") {
                            stats.indexScan += operatorStats["#itemsOut"] || 0;
                        } else if (operatorType === "Fetch") {
                            stats.fetch += operatorStats["#itemsOut"] || 0;
                            fetchTime += execTime;
                        } else if (operatorType === "Stream") {
                            streamTime += execTime;
                        } else if (operatorType === "Order" || operatorType === "Sort") {
                            sortTime += execTime;
                        }
                    });

                    // Cache all computed values including performance ratios
                    const elapsedTimeMs = parseTime(request.elapsedTime);
                    const streamRatio = elapsedTimeMs > 0 ? (streamTime / elapsedTimeMs) * 100 : 0;
                    const fetchRatio = elapsedTimeMs > 0 ? (fetchTime / elapsedTimeMs) * 100 : 0;

                    planMetadata = {
                        operators: operators,
                        maxKernTime: maxKernTime,
                        totalExecTime: totalExecTime,
                        totalServiceTime: totalServiceTime,
                        totalMemoryUsage: totalMemoryUsage,
                        totalItemsIn: totalItemsIn,
                        totalItemsOut: totalItemsOut,
                        streamTime: streamTime,
                        fetchTime: fetchTime,
                        sortTime: sortTime,
                        streamRatio: streamRatio,
                        fetchRatio: fetchRatio,
                        indexes: indexes,
                        stats: stats,
                        usesPrimary: usesPrimaryFlag,
                        indexInfo: { indexes: indexes, stats: stats }
                    };

                    planStatsCache.set(plan, planMetadata);
                }
            }

            // Pre-calculate commonly used values using cached data
            const elapsedTimeMs = parseTime(request.elapsedTime);
            
            // DO NOT convert requestTime here - keep it in original UTC/ISO format
            // Timezone conversion should only happen in display layer (tables, charts)
            // to avoid breaking date filtering and comparisons
            
            const processedRequest = {
                ...request,
                plan: plan,
                // Use cached time values or fallback to direct parsing
                elapsedTimeMs: elapsedTimeMs,
                serviceTimeMs: planMetadata ? planMetadata.totalServiceTime : parseTime(request.serviceTime || '0ms'),
                kernTimeMs: planMetadata ? planMetadata.maxKernTime : 0,
                memoryBytes: (typeof request.usedMemory === 'number') ? request.usedMemory : null,
                // Use cached boolean flags
                usesPrimary: planMetadata ? planMetadata.usesPrimary : false,
                // Use cached index information
                indexInfo: planMetadata ? planMetadata.indexInfo : null,
                // Store performance insights
                streamRatio: planMetadata ? planMetadata.streamRatio : 0,
                fetchRatio: planMetadata ? planMetadata.fetchRatio : 0,
                isStreamHeavy: planMetadata ? planMetadata.streamRatio > 50 : false,
                isLargePayload: (request.resultSize || 0) > 50000000 || (request.resultCount || 0) > 10000,
                // Store metadata for quick access
                _planMetadata: planMetadata,
                // Normalize prepared queries: prefer raw statement; fallback to preparedText, and clean for display
                statement: (function(){
                    const raw = request.statement || request.preparedText || '';
                    try {
                        const tmp = document.createElement('div');
                        tmp.innerHTML = raw; // decode entities
                        let txt = (tmp.textContent || tmp.innerText || '');
                        txt = txt.replace(/<[^>]*>/g, ' '); // strip any tags like <ud>
                        return txt.replace(/\s+/g, ' ').trim();
                    } catch (e) { return raw; }
                })(),
                // Ensure we have a statement type (derive if not present)
                statementType: request.statementType || deriveStatementType(request.statement || request.preparedText),
            };

            return processedRequest;
        }

        // Fast index information extraction (optimized with cache)
        function extractIndexInfo(plan) {
            // Check plan cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).indexInfo;
            }

            // Fallback to original calculation
            const operators = getOperators(plan);
            const indexes = [];
            const stats = { primaryScan: 0, indexScan: 0, fetch: 0 };

            operators.forEach((operator) => {
                const operatorType = operator["#operator"];
                const operatorStats = operator["#stats"] || {};

                // Extract index names
                if (operator.index) {
                    indexes.push(operator.index);
                }

                // Aggregate stats
                if (
                    operatorType === "PrimaryScan" ||
                    operatorType === "PrimaryScan3"
                ) {
                    stats.primaryScan += operatorStats["#itemsOut"] || 0;
                } else if (
                    operatorType === "IndexScan" ||
                    operatorType === "IndexScan3"
                ) {
                    stats.indexScan += operatorStats["#itemsOut"] || 0;
                } else if (operatorType === "Fetch") {
                    stats.fetch += operatorStats["#itemsOut"] || 0;
                }
            });

            return { indexes, stats };
        }

        // Fast plan stats extraction
        function extractPlanStats(plan) {
            // Check cache first
            if (planStatsCache.has(plan)) {
                const metadata = planStatsCache.get(plan);
                return { totalItemsIn: metadata.totalItemsIn || 0, totalItemsOut: metadata.totalItemsOut || 0 };
            }

            // Fallback calculation
            const operators = getOperators(plan);
            let totalItemsIn = 0;
            let totalItemsOut = 0;

            operators.forEach((operator) => {
                const stats = operator["#stats"] || {};
                totalItemsIn += stats["#itemsIn"] || 0;
                totalItemsOut += stats["#itemsOut"] || 0;
            });

            return { totalItemsIn, totalItemsOut };
        }



        // Track which tabs have been loaded (global for reset on new parse)
        let loadedTabs = new Set();

        // Lazy chart loading setup - generate charts only when tabs are activated
        function setupLazyChartLoading(filteredRequests, fullDataset) {
            // Clear loaded tabs to force regeneration with new data (Step 5 fix)
            loadedTabs.clear();

            // Check currently active tab BEFORE marking dashboard as loaded (Issue #141 fix)
            // This ensures Dashboard refreshes properly when it's already the active tab
            try {
                const $tabs = $('#tabs');
                if ($tabs && $tabs.length) {
                    const activeIndex = $tabs.tabs('option', 'active');
                    const panels = $tabs.find('.ui-tabs-panel');
                    const activePanel = panels && panels.eq ? panels.eq(activeIndex) : null;
                    const activeId = activePanel && activePanel.attr ? activePanel.attr('id') : null;
                    
                    // Generate charts for currently active tab if it's not dashboard
                    // Dashboard will be generated below regardless
                    // Always regenerate active tab on new parse (removed loadedTabs check - Step 5 fix)
                    if (activeId && activeId !== 'dashboard') {
                        const loadStart = performance.now();
                        switch (activeId) {
                            case 'timeline': {
                                const sampleSize = Math.min(500, filteredRequests.length);
                                const sampleStep = Math.max(1, Math.floor(filteredRequests.length / sampleSize));
                                const timelineSample = filteredRequests.filter((_, i) => i % sampleStep === 0);
                                console.log(`${TEXT_CONSTANTS.TIMELINE_CHARTS_USING} ${timelineSample.length} ${TEXT_CONSTANTS.OF_TOTAL} ${filteredRequests.length} ${TEXT_CONSTANTS.REQUESTS_FOR_PERFORMANCE}`);
                                generateFilterChart(filteredRequests);
                                generateTimelineChart(timelineSample);
                                setTimeout(() => setupChartDragAndDrop(), 100);
                                break;
                            }
                            case 'index-query-flow':
                                // Use current filtered data from global variables (Step 5 fix)
                                buildIndexQueryFlow(window.filteredRequests || window.currentFilteredRequests || filteredRequests);
                                break;
                            case 'insights':
                                // nothing
                                break;
                        }
                        loadedTabs.add(activeId);
                        const loadEnd = performance.now();
                        console.log(`${TEXT_CONSTANTS.LAZY_LOADED_TAB} ${activeId} ${TEXT_CONSTANTS.TAB_IN} ${Math.round(loadEnd - loadStart)}${TEXT_CONSTANTS.MS}`);
                    }
                }
            } catch (e) {
                console.error(`${TEXT_CONSTANTS.ERROR_LAZY_LOADING} active-tab`, e);
            }

            // ALWAYS generate dashboard charts immediately after parsing (not lazy)
            // This ensures fresh data every time, regardless of which tab is active
            generateDashboardCharts(fullDataset || filteredRequests);
            loadedTabs.add('dashboard');
            // Initialize drag and drop for dashboard charts
            setTimeout(() => setupChartDragAndDrop(), 100);
            
            // Initialize drag and drop for all charts
            setTimeout(() => setupChartDragAndDrop(), 100);

            // Set up lazy loading for other tabs
            $('#tabs').on('tabsactivate', function (event, ui) {
                const tabId = ui.newPanel.attr('id');

                if (!loadedTabs.has(tabId)) {
                    const loadStart = performance.now();

                    try {
                        switch (tabId) {
                            case 'dashboard':
                                // Dashboard charts are now always generated immediately after parsing
                                // No need to regenerate when switching tabs
                                break;
                            case 'timeline':
                                // Use current filtered data from global variables (Step 5 fix)
                                const currentData = window.filteredRequests || window.currentFilteredRequests || filteredRequests;
                                
                                // For aggregation-based charts (operations, filter), use full data
                                // For timeline chart (individual request visualization), use sampling for performance
                                const sampleSize = Math.min(500, currentData.length);
                                const sampleStep = Math.max(1, Math.floor(currentData.length / sampleSize));
                                const timelineSample = currentData.filter((_, i) => i % sampleStep === 0);

                                console.log(`${TEXT_CONSTANTS.TIMELINE_CHARTS_USING} ${timelineSample.length} ${TEXT_CONSTANTS.OF_TOTAL} ${currentData.length} ${TEXT_CONSTANTS.REQUESTS_FOR_PERFORMANCE}`);

                                // Use full data for aggregation charts that sum/count data
                                generateFilterChart(currentData);
                                // Use sampled data only for individual request timeline
                                generateTimelineChart(timelineSample);
                                
                                // Re-initialize drag and drop for timeline charts
                                setTimeout(() => setupChartDragAndDrop(), 100);
                                
                                // Show timeline-specific feature notifications (Issue #151)
                                showTimelineFeatureNotifications();
                                break;
                            case 'index-query-flow':
                                // Use current filtered data from global variables (Step 5 fix)
                                buildIndexQueryFlow(window.filteredRequests || window.currentFilteredRequests || filteredRequests);
                                break;
                            case 'insights':
                                // Insights don't need chart generation, they use cached data
                                break;
                        }

                        loadedTabs.add(tabId);
                        const loadEnd = performance.now();
                        console.log(`${TEXT_CONSTANTS.LAZY_LOADED_TAB} ${tabId} ${TEXT_CONSTANTS.TAB_IN} ${Math.round(loadEnd - loadStart)}${TEXT_CONSTANTS.MS}`);
                    } catch (e) {
                        console.error(`${TEXT_CONSTANTS.ERROR_LAZY_LOADING} ${tabId} ${TEXT_CONSTANTS.TAB_IN}`, e);
                    }
                }
            });
        }

        // Feature Notification System (Issue #151)
        // Manages new feature tips and announcements with version tracking
        const FEATURE_NOTIFICATIONS = {
            'stake-line-tip': {
                message: "üí° NEW: Double Click on any chart to place a vertical Stake line that syncs across all timeline charts. Click 'Remove Stake' button, on the side, to remove it.",
                type: "info",
                duration: 15000,
                version: "3.27.0",
                trigger: "timeline-tab"  // When to show: "timeline-tab", "startup", "onclick"
            }
            // Add more feature notifications here as needed
            // Example:
            // 'collection-chart-tip': {
            //     message: "üéØ New: Collection queries chart now shows query distribution across buckets!",
            //     type: "success",
            //     duration: 12000,
            //     version: "3.27.0",
            //     trigger: "timeline-tab"
            // }
        };

        // Track which notifications have been shown (in-memory only, resets on page load)
        const shownFeatureNotifications = new Set();

        /**
         * Show notification for a new feature
         * @param {string} featureKey - Key from FEATURE_NOTIFICATIONS
         * @param {boolean} forceShow - Force show even if already seen (for onclick events)
         */
        function newFeatureNotification(featureKey, forceShow = false) {
            const feature = FEATURE_NOTIFICATIONS[featureKey];
            if (!feature) {
                console.warn(`Feature notification '${featureKey}' not found`);
                return;
            }

            // Check if already shown this page load
            if (shownFeatureNotifications.has(featureKey) && !forceShow) {
                return; // Already shown
            }

            // Mark as shown
            shownFeatureNotifications.add(featureKey);

            // Show notification
            setTimeout(() => {
                showToast(feature.message, feature.type, feature.duration);
            }, 800);
        }

        /**
         * Show all startup feature notifications
         * Call this after data is parsed and app is ready
         */
        function showStartupFeatureNotifications() {
            Object.keys(FEATURE_NOTIFICATIONS).forEach(featureKey => {
                const feature = FEATURE_NOTIFICATIONS[featureKey];
                if (feature.trigger === "startup") {
                    newFeatureNotification(featureKey);
                }
            });
        }

        /**
         * Show timeline-specific feature notifications
         * Call this when Timeline tab is activated
         */
        function showTimelineFeatureNotifications() {
            Object.keys(FEATURE_NOTIFICATIONS).forEach(featureKey => {
                const feature = FEATURE_NOTIFICATIONS[featureKey];
                if (feature.trigger === "timeline-tab") {
                    newFeatureNotification(featureKey);
                }
            });
        }

        // Filter reminder toast notification
        let filterReminderTimeout = null;

        function showFilterReminder() {
            // Clear any existing timeout
            if (filterReminderTimeout) {
                clearTimeout(filterReminderTimeout);
            }

            // Remove any existing filter reminder toasts
            const existingFilterToasts = document.querySelectorAll(".filter-reminder-toast");
            existingFilterToasts.forEach((toast) => toast.remove());

            // Create the toast
            const toast = document.createElement("div");
            toast.className = "filter-reminder-toast";
            toast.textContent = TEXT_CONSTANTS.FILTERS_CHANGED_REMINDER;
            toast.style.cssText = `
                position: fixed;
                top: -50px;
                left: 20px;
                padding: 12px 20px;
                border-radius: 6px;
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                color: #856404;
                font-size: 13px;
                font-weight: 500;
                z-index: 10001;
                max-width: 320px;
                word-wrap: break-word;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                transition: all 0.4s ease-out;
                transform: translateY(0px);
            `;

            document.body.appendChild(toast);

            // Animate slide down from top
            setTimeout(() => {
                toast.style.top = "20px";
                toast.style.transform = "translateY(0px)";
            }, 10);

            // Auto-hide after 10 seconds
            filterReminderTimeout = setTimeout(() => {
                toast.style.opacity = "0";
                toast.style.transform = "translateY(-10px)";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 400);
                filterReminderTimeout = null;
            }, 10000);
        }

        function hideFilterReminder() {
            // Clear timeout and remove any existing filter reminder toasts
            if (filterReminderTimeout) {
                clearTimeout(filterReminderTimeout);
                filterReminderTimeout = null;
            }
            const existingFilterToasts = document.querySelectorAll(".filter-reminder-toast");
            existingFilterToasts.forEach((toast) => {
                toast.style.opacity = "0";
                toast.style.transform = "translateY(-10px)";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 400);
            });
        }

        // Build an elapsedTime filter predicate from user input
        function makeElapsedFilterPredicate(input) {
            try {
                if (!input || !(input = String(input).trim())) return null;
                const s = input.toLowerCase();

                const toMs = (num, unit) => {
                    const v = parseFloat(num);
                    const u = (unit || 'ms').toLowerCase();
                    if (u === 'ms') return v;
                    if (u === 's') return v * 1000;
                    if (u === '¬µs' || u === 'us') return v / 1000;
                    // Fallback: attempt parseTime on composed string
                    const ms = parseTime(`${v}${u}`);
                    return isNaN(ms) ? NaN : ms;
                };

                // e.g., "100ms-500ms" or "0.5s - 2s" (inclusive)
                const range = s.match(/^(\d*\.?\d+)\s*(¬µs|us|ms|s)?\s*-\s*(\d*\.?\d+)\s*(¬µs|us|ms|s)?$/);
                if (range) {
                    // If only one side has a unit, apply it to both sides for user-friendly behavior (e.g., "3-15s")
                    const inferredUnit = range[2] || range[4] || 'ms';
                    const leftMs = toMs(range[1], range[2] || inferredUnit);
                    const rightMs = toMs(range[3], range[4] || inferredUnit);
                    if (isNaN(leftMs) || isNaN(rightMs)) return null;
                    const min = Math.min(leftMs, rightMs);
                    const max = Math.max(leftMs, rightMs);
                    return (x) => typeof x === 'number' && !isNaN(x) && x >= min && x <= max;
                }

                // e.g., ">=500ms", "<2s", "=150ms"
                const comp = s.match(/^(<=|>=|<|>|=)\s*(\d*\.?\d+)\s*(¬µs|us|ms|s)?$/);
                if (comp) {
                    const op = comp[1];
                    const valMs = toMs(comp[2], comp[3] || 'ms');
                    if (isNaN(valMs)) return null;
                    return (x) => {
                        if (typeof x !== 'number' || isNaN(x)) return false;
                        if (op === '<') return x < valMs;
                        if (op === '<=') return x <= valMs;
                        if (op === '>') return x > valMs;
                        if (op === '>=') return x >= valMs;
                        return x === valMs; // '='
                    };
                }

                // e.g., "500ms+" (>=)
                const plus = s.match(/^(\d*\.?\d+)\s*(¬µs|us|ms|s)\s*\+$/);
                if (plus) {
                    const valMs = toMs(plus[1], plus[2]);
                    if (isNaN(valMs)) return null;
                    return (x) => typeof x === 'number' && !isNaN(x) && x >= valMs;
                }

                // Bare number: assume ms and '>=' semantics
                const bare = s.match(/^(\d*\.?\d+)$/);
                if (bare) {
                    const valMs = toMs(bare[1], 'ms');
                    if (isNaN(valMs)) return null;
                    return (x) => typeof x === 'number' && !isNaN(x) && x >= valMs;
                }

                return null;
            } catch (e) { return null; }
        }

        // Parse JSON input - Optimized
        function parseJSON() {
            // Hide filter reminder when parsing
            hideFilterReminder();
            
            // Clear caches at start of new parse to prevent memory leaks
            clearCaches();

            // Start performance timing
            const parseStartTime = performance.now();

            // Prefer uploaded file content (in-memory) over textarea to avoid DOM bloat
            const uploadedRaw = (window._uploadedCompletedJsonRaw && typeof window._uploadedCompletedJsonRaw === 'string') ? window._uploadedCompletedJsonRaw : '';
            const taVal = document.getElementById("json-input").value;
            const jsonInput = (uploadedRaw ? uploadedRaw : taVal).trim();
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Reset time grouping to default (By Optimizer) to prevent fine-grain errors
            const timeGroupingSelect = document.getElementById('time-grouping-select');
            if (timeGroupingSelect) {
                timeGroupingSelect.value = 'optimizer';
                // Trigger the change event to update any dependent UI
                changeTimeGrouping();
            }

            // Input validation
            if (!jsonInput) {
                showToast(TEXT_CONSTANTS.PASTE_JSON_FIRST, "warning");
                return;
            }

            // if (jsonInput.length > 50 * 1024 * 1024) {
            //     // 50MB limit
            //     showToast(TEXT_CONSTANTS.INPUT_TOO_LARGE, "error");
            //     return;
            // }

            try {
                const data = JSON.parse(jsonInput);
                let processData = [];

                if (Array.isArray(data)) {
                    processData = data;
                } else if (data && data.results && Array.isArray(data.results)) {
                    processData = data.results;
                } else {
                    showToast(TEXT_CONSTANTS.VALID_JSON_REQUIRED, "error");
                    return;
                }

                if (processData.length === 0) {
                    showToast(TEXT_CONSTANTS.NO_DATA_FOUND, "warning");
                    return;
                }

                // Detect timezone from the data
                detectedTimezone = detectTimezoneFromData(processData);
                const timezoneSelector = document.getElementById("timezone-selector");
                
                Logger.debug(`[parseJSON] Detected timezone: ${detectedTimezone}, User picked: ${timeZoneUserPicked}`);
                
                // Only auto-set timezone if user hasn't manually picked one
                if (timezoneSelector && !timeZoneUserPicked) {
                    // Set the dropdown to detected timezone if available in options
                    const options = Array.from(timezoneSelector.options).map(opt => opt.value);
                    if (options.includes(detectedTimezone)) {
                        timezoneSelector.value = detectedTimezone;
                    } else {
                        timezoneSelector.value = "UTC";
                    }
                    currentTimezone = timezoneSelector.value;
                    Logger.debug(`[parseJSON] Auto-set timezone to: ${currentTimezone}`);
                } else if (timezoneSelector) {
                    // Preserve user's timezone selection
                    currentTimezone = timezoneSelector.value;
                    Logger.debug(`[parseJSON] Preserving user's timezone: ${currentTimezone}`);
                }
                
                // Update the date picker timezone label to match current selection
                updateDatePickerTimezoneLabel();
                
                // Update timezone info display
                const timezoneInfo = document.getElementById("timezone-info");
                if (timezoneInfo) {
                    timezoneInfo.textContent = `${TEXT_CONSTANTS.TIMEZONE_DETECTED} ${detectedTimezone}`;
                }

                if (Array.isArray(processData)) {
                    // Process data in smaller batches for maximum UI responsiveness
                    const batchSize = 75; // Further reduced for smoother progress updates
                    const processedRequests = [];
                    let skippedCount = 0; // Track filtered out requests

                    // Show progress bar
                    document.getElementById("progress-container").style.display =
                        "block";

                    // Get filter settings once outside the loop for performance
                    const excludeCheckbox = document.getElementById("exclude-system-queries");
                    const isExcluding = excludeCheckbox && excludeCheckbox.checked;
                    const sqlFilter = document.getElementById("sql-statement-filter");
                    const sqlFilterText = sqlFilter ? sqlFilter.value.trim().toLowerCase() : "";
                    const collectionFilter = document.getElementById("collection-filter");
                    const collectionFilterValue = collectionFilter ? collectionFilter.value.trim() : "";

                    // Get date filter settings
                    const startDateInput = document.getElementById("start-date");
                    const endDateInput = document.getElementById("end-date");
                    const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
                    const endDate = endDateInput.value ? new Date(endDateInput.value) : null;

                    // Get elapsedTime filter predicate
                    const elapsedFilterInput = document.getElementById("elapsed-time-filter");
                    const elapsedFilterText = elapsedFilterInput ? elapsedFilterInput.value.trim() : "";
                    const elapsedPredicate = makeElapsedFilterPredicate(elapsedFilterText);

                    // ============================================================
                    // DATA PROCESSING OPTIMIZATION (Step 5)
                    // Combined filter function to reduce redundant checks
                    // ============================================================
                    function shouldProcessRequest(request) {
                        // Early exit for system query filtering
                        if (isExcluding && shouldExcludeSystemQuery(request)) {
                            return false;
                        }

                        // SQL statement filtering
                        if (sqlFilterText && sqlFilterText.length > 0) {
                            const statement = (request.statement || request.preparedText || "")
                                .toLowerCase()
                                .replace(/\s+/g, ' ')
                                .trim();
                            const filterText = sqlFilterText.replace(/\s+/g, ' ').trim();
                            if (!statement.includes(filterText)) {
                                return false;
                            }
                        }

                        // Collection filtering (AND condition)
                        if (collectionFilterValue && collectionFilterValue.length > 0) {
                            const sql = request.statement || request.preparedText || "";
                            const collections = extractCollectionsFromSQL(sql);
                            if (!collections.includes(collectionFilterValue)) {
                                return false;
                            }
                        }

                        // Date range filtering
                        if (startDate || endDate) {
                            const requestDate = parseCouchbaseDateTime(request.requestTime);
                            if (requestDate) {
                                if (startDate && requestDate < startDate) return false;
                                if (endDate && requestDate > endDate) return false;
                            }
                        }

                        // Elapsed time filtering
                        if (elapsedPredicate) {
                            const elapsedMs = parseTime(request.elapsedTime || "");
                            if (!elapsedPredicate(elapsedMs)) {
                                return false;
                            }
                        }

                        return true; // Passed all filters
                    }

                    function processBatch(startIndex) {
                        const endIndex = Math.min(
                            startIndex + batchSize,
                            processData.length
                        );

                        for (let i = startIndex; i < endIndex; i++) {
                            try {
                                const item = processData[i];
                                const request = item.completed_requests || item;

                                // Combined filter check (Step 5 optimization)
                                if (!shouldProcessRequest(request)) {
                                    skippedCount++;
                                    continue;
                                }

                                // Only process requests that pass all filters
                                processedRequests.push(processRequestData(item));

                                // Yield every 25 processed items within batch for ultra-smooth progress
                                if ((i - startIndex) % 25 === 24 && i < endIndex - 1) {
                                    // Update progress more frequently for smoother bar
                                    const currentProgress = Math.round(
                                        ((i + 1) / processData.length) * 100
                                    );
                                    document.getElementById("progress-bar").style.width = `${currentProgress}%`;
                                    document.getElementById("progress-text").textContent = `${currentProgress}%`;
                                }
                            } catch (e) {
                                console.warn(`${TEXT_CONSTANTS.ERROR_PROCESSING_REQUEST} ${i}:`, e.message || e);
                                // Continue processing other requests
                            }
                        }

                        // Update progress bar
                        const progress = Math.round(
                            (endIndex / processData.length) * 100
                        );
                        document.getElementById(
                            "progress-bar"
                        ).style.width = `${progress}%`;
                        document.getElementById(
                            "progress-text"
                        ).textContent = `${progress}%`;

                        if (endIndex < processData.length) {
                            // Process next batch with dual yielding for maximum responsiveness
                            requestAnimationFrame(() => {
                                setTimeout(() => processBatch(endIndex), 5); // Reduced delay for faster processing
                            });
                        } else {
                            // All batches processed
                            const parseEndTime = performance.now();
                            Logger.info(`${TEXT_CONSTANTS.PARSE_PERFORMANCE} ${Math.round(parseEndTime - parseStartTime)}${TEXT_CONSTANTS.MS_FOR} ${processedRequests.length} ${TEXT_CONSTANTS.REQUESTS} (${skippedCount} ${TEXT_CONSTANTS.FILTERED_OUT_EARLY})`);
                            finishProcessing(processedRequests);
                        }
                    }

                    // Start processing
                    processBatch(0);
                } else {
                    showToast(TEXT_CONSTANTS.UNEXPECTED_DATA_FORMAT, "error");
                }
            } catch (e) {
                console.error(`${TEXT_CONSTANTS.JSON_PARSING_ERROR}`, e);
                console.log(`${TEXT_CONSTANTS.JSON_PARSING_ERROR}`, e);
                showToast(`${TEXT_CONSTANTS.ERROR_PARSING_JSON} ${e.message}`, "error");
                document.getElementById("progress-container").style.display = "none";
            }
        }

        // Toast notification system - slides down from top-left corner for 10 seconds
        function showToast(message, type = "info", durationMs = 10000) {
            // Remove any existing toasts
            const existingToasts = document.querySelectorAll(".toast, .sliding-toast");
            existingToasts.forEach((toast) => toast.remove());

            const toast = document.createElement("div");
            toast.className = "sliding-toast";
            toast.style.cssText = `
          position: fixed;
          top: -50px;
          left: 20px;
          padding: 12px 40px 12px 20px;
          border-radius: 6px;
          background: #e3f2fd;
          border: 1px solid #bbdefb;
          color: #0d47a1;
          font-size: 13px;
          font-weight: 600;
          z-index: 10001;
          max-width: 360px;
          word-wrap: break-word;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          transition: all 0.35s ease-out;
          transform: translateY(0px);
        `;

            // Add message text
            const messageSpan = document.createElement("span");
            messageSpan.textContent = message;
            toast.appendChild(messageSpan);

            // Add close button
            const closeBtn = document.createElement("button");
            closeBtn.innerHTML = "√ó";
            closeBtn.style.cssText = `
          position: absolute;
          top: 8px;
          right: 8px;
          background: transparent;
          border: none;
          color: inherit;
          font-size: 20px;
          font-weight: bold;
          cursor: pointer;
          padding: 0;
          width: 20px;
          height: 20px;
          line-height: 20px;
          text-align: center;
          opacity: 0.6;
          transition: opacity 0.2s;
        `;
            closeBtn.onmouseover = () => closeBtn.style.opacity = "1";
            closeBtn.onmouseout = () => closeBtn.style.opacity = "0.6";
            closeBtn.onclick = () => {
                toast.style.opacity = "0";
                toast.style.transform = "translateY(-10px)";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 400);
            };
            toast.appendChild(closeBtn);

            // Color scheme by type
            if (type === "error") {
                toast.style.background = "#f8d7da";
                toast.style.border = "1px solid #f5c2c7";
                toast.style.color = "#842029";
            } else if (type === "warning") {
                toast.style.background = "#fff3cd";
                toast.style.border = "1px solid #ffeaa7";
                toast.style.color = "#856404";
            } else if (type === "success") {
                toast.style.background = "#d1e7dd";
                toast.style.border = "1px solid #badbcc";
                toast.style.color = "#0f5132";
            }

            document.body.appendChild(toast);

            // Slide down
            setTimeout(() => {
                toast.style.top = "20px";
                toast.style.transform = "translateY(0px)";
            }, 10);

            // Auto-hide
            setTimeout(() => {
                toast.style.opacity = "0";
                toast.style.transform = "translateY(-10px)";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 400);
            }, durationMs);
            }

            // Redirect to showToast for consistency
            function showSlidingNotification(message, type = "info", durationMs = 8000) {
                showToast(message, type, durationMs);
            }

            // Input panel auto-hide helpers (Issue #88)
            let _inputHideTimer = null;
            let _inputAutoHideDisabled = false;
            function hideInputSection() {
                const input = document.getElementById('input-section');
                const tab = document.getElementById('toggle-input-tab');
                if (!input) return;
                try {
                    const $input = window.jQuery ? jQuery(input) : null;
                    if ($input && $input.hide && jQuery.effects && jQuery.effects.effect && jQuery.effects.effect.blind) {
                        $input.stop(true, true).hide('blind', {}, 600, () => {
                            if (tab) {
                                tab.setAttribute('aria-expanded', 'false');
                                const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.SHOW_INPUT_PANEL) || 'Show Data & Filters';
                                tab.textContent = '‚ñº ' + label;
                                tab.title = label;
                                tab.classList.remove('showing');
                                tab.classList.add('hidden');
                            }
                        });
                    } else {
                        // Fallback if jQuery UI effects missing
                        input.style.display = 'none';
                        if (tab) {
                            tab.setAttribute('aria-expanded', 'false');
                            const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.SHOW_INPUT_PANEL) || 'Show Data & Filters';
                            tab.textContent = '‚ñº ' + label;
                            tab.title = label;
                            tab.classList.remove('showing');
                            tab.classList.add('hidden');
                        }
                    }
                } catch (e) { /* no-op */ }
            }
            function showInputSection() {
                const input = document.getElementById('input-section');
                const tab = document.getElementById('toggle-input-tab');
                if (!input) return;
                try {
                    const $input = window.jQuery ? jQuery(input) : null;
                    if ($input && $input.show && jQuery.effects && jQuery.effects.effect && jQuery.effects.effect.blind) {
                        $input.stop(true, true).show('blind', {}, 600, () => {
                            if (tab) {
                                tab.setAttribute('aria-expanded', 'true');
                                const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.HIDE_INPUT_PANEL) || 'Hide Data & Filters';
                                tab.textContent = '‚ñ≤ ' + label;
                                tab.title = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.TOGGLE_INPUT_TOOLTIP) || 'Click to Show/Hide Data & Filters';
                                tab.classList.remove('hidden');
                                tab.classList.add('showing');
                            }
                        });
                    } else {
                        input.style.display = '';
                        if (tab) {
                            tab.setAttribute('aria-expanded', 'true');
                            const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.HIDE_INPUT_PANEL) || 'Hide Data & Filters';
                            tab.textContent = '‚ñ≤ ' + label;
                            tab.title = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.TOGGLE_INPUT_TOOLTIP) || 'Click to Show/Hide Data & Filters';
                            tab.classList.remove('hidden');
                            tab.classList.add('showing');
                        }
                    }
                } catch (e) { /* no-op */ }
            }
            function toggleInputSection() {
                const input = document.getElementById('input-section');
                if (!input) return;
                // User manually toggled; disable future auto-hide for this session
                _inputAutoHideDisabled = true;
                if (_inputHideTimer) { clearTimeout(_inputHideTimer); _inputHideTimer = null; }
                const cs = window.getComputedStyle ? getComputedStyle(input) : null;
                const isHidden = (
                    (cs && (cs.display === 'none' || cs.visibility === 'hidden' || cs.visibility === 'collapse')) ||
                    input.style.display === 'none' ||
                    input.hidden === true
                );
                if (isHidden) showInputSection(); else hideInputSection();
            }
            function scheduleInputAutoHide(delayMs = 3000) {
                if (_inputAutoHideDisabled) return; // respect user preference
                if (_inputHideTimer) {
                    clearTimeout(_inputHideTimer);
                    _inputHideTimer = null;
                }
                _inputHideTimer = setTimeout(() => {
                    const input = document.getElementById('input-section');
                    if (_inputAutoHideDisabled) return;
                    if (input && input.style.visibility !== 'collapse') {
                        hideInputSection();
                    }
                }, delayMs);
            }

            // Finish processing after all batches are done
        function finishProcessing(allRequests) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Hide progress bar and reset placeholder
            document.getElementById("progress-container").style.display = "none";
            document.getElementById("progress-bar").style.width = "0%";
            document.getElementById("progress-text").textContent = "0%";
            document.getElementById("json-input").placeholder =
                "Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests;";

            // Cache management now handled automatically by size limits (Step 9)
            // No manual clearing needed - cache evicts oldest 20% when limit reached

            // Filtering now happens during parsing, so we can use requests directly
            const filteredAllRequests = allRequests;

            // If this is the first parse (no date filters set), populate date range
            if (
                !startDateInput.value &&
                !endDateInput.value &&
                filteredAllRequests.length > 0
            ) {
                originalRequests = filteredAllRequests;
                const dates = filteredAllRequests
                    .map((r) => parseCouchbaseDateTime(r.requestTime))
                    .filter((d) => d && !isNaN(d.getTime()))
                    .sort((a, b) => a - b);

                if (dates.length > 0) {
                    const minDate = dates[0];
                    const maxDate = dates[dates.length - 1];

                    // Add 1-minute buffer to ensure edge records aren't excluded by minute rounding
                    const startWithBuffer = new Date(minDate.getTime() - 60000); // -1 minute
                    const endWithBuffer = new Date(maxDate.getTime() + 60000); // +1 minute

                    originalStartDate = minDate;
                    originalEndDate = maxDate;
                    
                    // Apply timezone conversion to date pickers (Issue #203)
                    // Use selected timezone so user sees dates in their chosen timezone
                    const timezoneForPicker = currentTimezone || "UTC";
                    startDateInput.value = toDateTimeLocal(startWithBuffer, timezoneForPicker);
                    endDateInput.value = toDateTimeLocal(endWithBuffer, timezoneForPicker);
                    updateDatePickerTimezoneLabel(); // Show timezone info next to date pickers
                    
                    Logger.debug(`[parseJSON] Set date pickers to ${timezoneForPicker}: ${startDateInput.value} to ${endDateInput.value}`);
                }
            } else {
                // Use existing originalRequests if available, otherwise use current data
                if (originalRequests.length === 0) {
                    originalRequests = filteredAllRequests;
                }
            }

            // Apply date filtering
            const startDate = startDateInput.value
                ? new Date(startDateInput.value)
                : null;
            const endDate = endDateInput.value
                ? new Date(endDateInput.value)
                : null;

            const filteredRequests = filterRequestsByDateRange(
                filteredAllRequests,
                startDate,
                endDate
            );
            
            // Debug logging for filtering
            Logger.debug(`Date filtering: ${filteredAllRequests.length} requests -> ${filteredRequests.length} after date range filter`);
            if (filteredRequests.length === 0 && filteredAllRequests.length > 0) {
                console.warn("‚ö†Ô∏è All requests filtered out by date range!");
                console.log("Start date:", startDate);
                console.log("End date:", endDate);
                if (filteredAllRequests.length > 0) {
                    console.log("First request time:", filteredAllRequests[0].requestTime);
                }
            }

            // Store filtered requests globally for Index/Query Flow tab activation
            window.filteredRequests = filteredRequests;

            // Store filtered data globally for lazy loading
            window.currentFilteredRequests = filteredRequests;

            // Update UI with filtered data
            updateFilterInfo(filteredAllRequests.length, filteredRequests.length, filteredRequests);
            try {
                // Only generate essential tables immediately - defer charts until tab activation
                generateTable(filteredRequests);
                generateAnalysisTable(filteredRequests);
                updateOptimizerLabel(filteredRequests);

                // Extract used indexes from the query data
                extractUsedIndexes(filteredRequests);

                // Extract sample queries for display
                extractSampleQueries(filteredRequests);

                // Initialize username autocomplete with current filtered requests
                initializeUsernameAutocomplete(filteredRequests);

                // Log cache stats now that data stores are populated
                logCacheStats();

                // Also parse index data if available
                parseIndexJSON();

                // Set up lazy loading for charts with sampling for large datasets
                const sampleRequests = filteredRequests.length > 1000 ?
                    filteredRequests.filter((_, i) => i % Math.ceil(filteredRequests.length / 1000) === 0) :
                    filteredRequests;

                // Show sampling notice if data was sampled for charts
                if (filteredRequests.length > 1000) {
                    console.log(`${TEXT_CONSTANTS.CHART_SAMPLING} ${sampleRequests.length} ${TEXT_CONSTANTS.OF_TOTAL} ${filteredRequests.length} ${TEXT_CONSTANTS.REQUESTS_FOR_PERFORMANCE}`);
                }

                setupLazyChartLoading(sampleRequests, filteredRequests);
            } catch (e) {
                console.error(`${TEXT_CONSTANTS.ERROR_GENERATING_UI}`, e);
                alert(`${TEXT_CONSTANTS.ERROR_GENERATING_UI} Try reducing the date range or selecting a coarser time grouping.`);
            }
            // Only reset flow diagram if no query was previously selected
            const flowDiagram = document.getElementById("flow-diagram");
            if (!flowDiagram.hasChildNodes() || flowDiagram.children.length === 0) {
                flowDiagram.innerHTML = TEXT_CONSTANTS.SELECT_QUERY_FLOW;
            }

            // Populate collection filter dropdown
            populateCollectionFilter(filteredRequests);

            // Schedule auto-hide of input panel after successful processing
            scheduleInputAutoHide(3000);
        }

        // Populate collection filter dropdown with all unique collections
        function populateCollectionFilter(requests) {
            const collectionFilter = document.getElementById("collection-filter");
            if (!collectionFilter) return;

            // Collect all unique collections from requests
            const collectionsSet = new Set();
            requests.forEach(request => {
                const sql = request.statement || request.preparedText || "";
                const collections = extractCollectionsFromSQL(sql);
                collections.forEach(collection => collectionsSet.add(collection));
            });

            // Sort collections alphabetically
            const sortedCollections = Array.from(collectionsSet).sort();

            // Preserve current selection if it exists
            const currentSelection = collectionFilter.value;

            // Clear and repopulate dropdown
            collectionFilter.innerHTML = '<option value="">(All)</option>';
            sortedCollections.forEach(collection => {
                const option = document.createElement('option');
                option.value = collection;
                option.textContent = collection;
                collectionFilter.appendChild(option);
            });

            // Restore selection if still valid
            if (currentSelection && sortedCollections.includes(currentSelection)) {
                collectionFilter.value = currentSelection;
            }

            Logger.info(`Collection filter populated with ${sortedCollections.length} unique collections`);
        }

        // Modal event listeners
        const planModal = document.getElementById("plan-modal");
        const planCloseBtn = planModal.querySelector(".close");
        planCloseBtn.addEventListener("click", () => {
            planModal.style.display = "none";
        });
        planModal.addEventListener("click", (event) => {
            if (event.target === planModal) {
                planModal.style.display = "none";
            }
        });

        const operatorModal = document.getElementById("operator-modal");
        const operatorCloseBtn = operatorModal.querySelector(".close");
        operatorCloseBtn.addEventListener("click", () => {
            operatorModal.style.display = "none";
        });
        operatorModal.addEventListener("click", (event) => {
            if (event.target === operatorModal) {
                operatorModal.style.display = "none";
            }
        });

        // Function to set time range based on button selection
        function setTimeRange(type) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            if (type === "original") {
                if (originalStartDate && originalEndDate) {
                    // Use selected timezone for datepickers (Issue #203)
                    const timezoneForPicker = currentTimezone || "UTC";
                    startDateInput.value = toDateTimeLocal(originalStartDate, timezoneForPicker);
                    endDateInput.value = toDateTimeLocal(originalEndDate, timezoneForPicker);
                    updateDatePickerTimezoneLabel(); // Update timezone label
                }
            } else if (type === "1day" || type === "1hour" || type === "1week") {
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : new Date();
                const startDate = new Date(endDate);

                if (type === "1day") {
                    startDate.setDate(startDate.getDate() - 1);
                } else if (type === "1hour") {
                    startDate.setHours(startDate.getHours() - 1);
                } else if (type === "1week") {
                    startDate.setDate(startDate.getDate() - 7);
                }

                // Use selected timezone for datepickers (Issue #203)
                const timezoneForPicker = currentTimezone || "UTC";
                startDateInput.value = toDateTimeLocal(startDate, timezoneForPicker);
                updateDatePickerTimezoneLabel(); // Update timezone label
            }

            // Show reminder to click Parse JSON
            if (originalRequests.length > 0) {
                showFilterReminder();
            }
        }

        // Sample queries storage
        let sampleQueries = [];
        let sampleQueriesVisible = false;

        // Extract sample queries from requests for display - only inefficient index scan queries
        function extractSampleQueries(requests) {
            sampleQueries = [];
            const seenStatements = new Set();
            
            for (const request of requests) {
                if (sampleQueries.length >= 5) break;
                
                const statement = request.statement || request.preparedText || '';
                if (!statement || seenStatements.has(statement)) continue;
                
                // Apply the same inefficient index scan criteria as the counter
                const hasAggregates = /\b(COUNT|AVG|MIN|MAX|SUM)\s*\(/i.test(statement);
                
                if (!hasAggregates) {
                    const resultCount = request.resultCount || 0;
                    const phaseCounts = request.phaseCounts || {};

                    // Check various types of index scans (same logic as counter)
                    let totalScanned = 0;
                    if (phaseCounts.primaryScan) totalScanned += phaseCounts.primaryScan;
                    if (phaseCounts.indexScan) totalScanned += phaseCounts.indexScan;
                    if (phaseCounts['primaryScan.GSI']) totalScanned += phaseCounts['primaryScan.GSI'];
                    if (phaseCounts['indexScan.GSI']) totalScanned += phaseCounts['indexScan.GSI'];

                    // Only include if scanned >= 50,000 and efficiency < 10%
                    if (totalScanned >= 50000) {
                        const efficiency = totalScanned > 0 ? (resultCount / totalScanned) * 100 : 0;
                        if (efficiency < 10) {
                            seenStatements.add(statement);
                            sampleQueries.push({
                                requestTime: request.requestTime,
                                statement: statement,
                                requestId: request.requestId
                            });
                        }
                    }
                }
            }
            
            // Update the sample queries table
            updateSampleQueriesTable();
        }

        // Toggle sample queries visibility
        function toggleSampleQueries() {
            const container = document.getElementById('sample-queries-container');
            const btnText = document.getElementById('sample-queries-btn-text');
            
            sampleQueriesVisible = !sampleQueriesVisible;
            
            if (sampleQueriesVisible) {
                container.style.display = 'block';
                btnText.textContent = TEXT_CONSTANTS.HIDE_SAMPLE_QUERIES;
            } else {
                container.style.display = 'none';
                btnText.textContent = TEXT_CONSTANTS.SHOW_SAMPLE_QUERIES;
            }
        }

        // Update sample queries table content
        function updateSampleQueriesTable() {
            const tbody = document.getElementById('sample-queries-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            Logger.debug(`[updateSampleQueriesTable] Updating inefficient-index-scans with ${sampleQueries.length} queries, currentTimezone=${currentTimezone}`);
            
            sampleQueries.forEach((query, index) => {
                // Apply timezone conversion to requestTime
                const originalTime = query.requestTime || "";
                const convertedDate = getChartDate(originalTime);
                const formattedDate = convertedDate ? convertedDate.toISOString().replace('T', ' ').substring(0, 23) + 'Z' : originalTime;
                
                Logger.trace(`[updateSampleQueriesTable] Query ${index}: Original=${originalTime}, Converted=${formattedDate}`);
                
                const statementId = `sample-statement-${index}`;
                const isLongStatement = query.statement.length > 500;
                
                const row = document.createElement('tr');
                
                // Create date cell
                const dateCell = document.createElement('td');
                dateCell.style.whiteSpace = 'nowrap';
                dateCell.style.textAlign = 'center';
                dateCell.style.fontSize = '11px';
                dateCell.textContent = formattedDate;
                
                // Create statement cell
                const statementCell = document.createElement('td');
                statementCell.className = 'statement-cell';
                
                if (isLongStatement) {
                    const truncated = query.statement.substring(0, 500);
                    statementCell.innerHTML = `
                        <div id="${statementId}-truncated">
                            <span>${escapeHtml(truncated)}...</span>
                            <br>
                            <button onclick="toggleSampleStatement('${statementId}', true)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                            <button onclick="copySampleStatement('${statementId}', event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                        <div id="${statementId}-full" style="display: none;">
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="toggleSampleStatement('${statementId}', false)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                            <button onclick="copySampleStatement('${statementId}', event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                } else {
                    statementCell.innerHTML = `
                        <div>
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="copySampleStatement('${statementId}', event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                }
                
                row.appendChild(dateCell);
                row.appendChild(statementCell);
                tbody.appendChild(row);
            });
        }

        // Toggle between truncated and full statement view
        function toggleSampleStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(statementId + '-truncated');
            const fullDiv = document.getElementById(statementId + '-full');
            
            if (showFull) {
                truncatedDiv.style.display = 'none';
                fullDiv.style.display = 'block';
            } else {
                truncatedDiv.style.display = 'block';
                fullDiv.style.display = 'none';
            }
        }

        // Copy sample statement to clipboard
        function copySampleStatement(statementId, event) {
            const index = parseInt(statementId.replace('sample-statement-', ''));
            const statement = sampleQueries[index]?.statement;
            
            if (!statement) {
                console.error(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, statementId);
                showToast(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, "error");
                return;
            }
            
            navigator.clipboard.writeText(statement)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = TEXT_CONSTANTS.COPIED;
                    button.style.backgroundColor = '#4CAF50';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 1000);
                })
                .catch((err) => {
                    console.error(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, err);
                    showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                });
        }

        // Storage for insight-specific sample queries
        let insightSampleQueries = {};
        let insightSampleQueriesVisible = {};

        // Toggle insight-specific sample queries visibility
        function toggleInsightSampleQueries(insightId) {
            const container = document.getElementById(`${insightId}-sample-queries-container`);
            const btnText = document.getElementById(`${insightId}-sample-queries-btn-text`);
            
            if (!container || !btnText) return;
            
            const isVisible = insightSampleQueriesVisible[insightId] || false;
            insightSampleQueriesVisible[insightId] = !isVisible;
            
            if (!isVisible) {
                container.style.display = 'block';
                btnText.textContent = TEXT_CONSTANTS.HIDE_SAMPLE_QUERIES;
            } else {
                container.style.display = 'none';
                btnText.textContent = TEXT_CONSTANTS.SHOW_SAMPLE_QUERIES;
            }
        }

        // Update insight-specific sample queries table
        function updateInsightSampleQueries(insightId, queries) {
            const tbody = document.getElementById(`${insightId}-sample-queries-tbody`);
            if (!tbody) return;
            
            tbody.innerHTML = '';
            insightSampleQueries[insightId] = queries;
            
            Logger.debug(`[Insights] Updating ${insightId} with ${queries.length} queries, currentTimezone=${currentTimezone}`);
            
            queries.forEach((query, index) => {
                // Apply timezone conversion to requestTime
                const originalTime = query.requestTime || "";
                const convertedDate = getChartDate(originalTime);
                const formattedDate = convertedDate ? convertedDate.toISOString().replace('T', ' ').substring(0, 23) + 'Z' : originalTime;
                
                Logger.trace(`[Insights] Query ${index}: Original=${originalTime}, Converted=${formattedDate}`);
                
                const statementId = `${insightId}-statement-${index}`;
                const isLongStatement = query.statement.length > 500;
                
                const row = document.createElement('tr');
                
                // Create date cell
                const dateCell = document.createElement('td');
                dateCell.style.whiteSpace = 'nowrap';
                dateCell.style.textAlign = 'center';
                dateCell.style.fontSize = '11px';
                dateCell.textContent = formattedDate;
                
                // Create statement cell
                const statementCell = document.createElement('td');
                statementCell.className = 'statement-cell';
                
                if (isLongStatement) {
                    const truncated = query.statement.substring(0, 500);
                    statementCell.innerHTML = `
                        <div id="${statementId}-truncated">
                            <span>${escapeHtml(truncated)}...</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', true)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                            <button onclick="copyInsightStatement('${insightId}', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                        <div id="${statementId}-full" style="display: none;">
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', false)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                            <button onclick="copyInsightStatement('${insightId}', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                } else {
                    statementCell.innerHTML = `
                        <div>
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="copyInsightStatement('${insightId}', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                }
                
                row.appendChild(dateCell);
                row.appendChild(statementCell);
                tbody.appendChild(row);
            });
        }

        // Update JOIN sample queries with flags and JOIN time columns
        function updateJoinSampleQueries(queries) {
            const tbody = document.getElementById('complex-join-operations-sample-queries-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            insightSampleQueries['complex-join-operations'] = queries;
            
            Logger.debug(`[Insights] Updating JOIN queries with ${queries.length} queries, currentTimezone=${currentTimezone}`);
            
            queries.forEach((query, index) => {
                // Apply timezone conversion to requestTime
                const originalTime = query.requestTime || "";
                const convertedDate = getChartDate(originalTime);
                const formattedDate = convertedDate ? convertedDate.toISOString().replace('T', ' ').substring(0, 23) + 'Z' : originalTime;
                
                Logger.trace(`[Insights] JOIN Query ${index}: Original=${originalTime}, Converted=${formattedDate}`);
                const flags = query.flags || [];
                const flagDetails = query.flagDetails || {};
                const joinTime = query.joinTime || 0;
                
                const statementId = `complex-join-operations-statement-${index}`;
                const isLongStatement = query.statement.length > 500;
                
                const row = document.createElement('tr');
                
                // Create date cell
                const dateCell = document.createElement('td');
                dateCell.style.whiteSpace = 'nowrap';
                dateCell.style.textAlign = 'center';
                dateCell.style.fontSize = '11px';
                dateCell.textContent = formattedDate;
                
                // Create flags cell with tooltips
                const flagsCell = document.createElement('td');
                flagsCell.style.fontWeight = 'bold';
                flagsCell.style.textAlign = 'center';
                flagsCell.style.fontSize = '12px';
                
                if (flags.length > 0) {
                    // Create each flag span separately with custom large tooltips
                    flagsCell.innerHTML = '';
                    flags.forEach((flag, idx) => {
                        const detail = flagDetails[flag] || '';
                        const color = ['A', 'B', 'D'].includes(flag) ? '#dc3545' : 
                                     ['C', 'E', 'F', 'H'].includes(flag) ? '#fd7e14' : '#ffc107';
                        
                        const flagSpan = document.createElement('span');
                        flagSpan.textContent = flag;
                        flagSpan.style.color = color;
                        flagSpan.className = 'join-flag-tooltip';
                        flagSpan.setAttribute('data-tooltip', detail);
                        
                        flagsCell.appendChild(flagSpan);
                        
                        // Add comma separator if not last flag
                        if (idx < flags.length - 1) {
                            const comma = document.createTextNode(', ');
                            flagsCell.appendChild(comma);
                        }
                    });
                } else {
                    flagsCell.textContent = '-';
                }
                
                // Create JOIN time cell
                const joinTimeCell = document.createElement('td');
                joinTimeCell.style.textAlign = 'center';
                joinTimeCell.style.fontSize = '11px';
                joinTimeCell.textContent = joinTime > 0 ? `${(joinTime / 1000).toFixed(2)}s` : 'N/A';
                
                // Create statement cell
                const statementCell = document.createElement('td');
                statementCell.className = 'statement-cell';
                statementCell.style.fontFamily = 'monospace';
                statementCell.style.fontSize = '11px';
                
                if (isLongStatement) {
                    const truncated = query.statement.substring(0, 500);
                    statementCell.innerHTML = `
                        <div id="${statementId}-truncated">
                            <span>${escapeHtml(truncated)}...</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', true)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                            <button onclick="copyInsightStatement('complex-join-operations', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                        <div id="${statementId}-full" style="display: none;">
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', false)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                            <button onclick="copyInsightStatement('complex-join-operations', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                } else {
                    statementCell.innerHTML = `
                        <div>
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="copyInsightStatement('complex-join-operations', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                }
                
                row.appendChild(dateCell);
                row.appendChild(flagsCell);
                row.appendChild(joinTimeCell);
                row.appendChild(statementCell);
                tbody.appendChild(row);
            });
        }

        // Update Concurrent Conflicts sample queries table
        function updateConcurrentConflictsSampleQueries(queries, flagCountsData) {
            const tbody = document.getElementById('concurrent-query-conflicts-sample-queries-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            insightSampleQueries['concurrent-query-conflicts'] = queries;
            
            // Update flag breakdown
            const flagGrid = document.getElementById('concurrent-conflicts-flag-grid');
            if (flagGrid && flagCountsData) {
                flagGrid.innerHTML = '';
                
                Object.entries(flagCountsData).forEach(([flag, data]) => {
                    if (data.count > 0) {
                        const color = ['B', 'D', 'F', 'H'].includes(flag) ? '#dc3545' : '#fd7e14';
                        const severity = ['B', 'D', 'F', 'H'].includes(flag) ? 'üî¥ Critical' : 'üü° High';
                        
                        const flagDiv = document.createElement('div');
                        flagDiv.style.padding = '8px';
                        flagDiv.style.marginBottom = '6px';
                        flagDiv.style.backgroundColor = '#fff';
                        flagDiv.style.border = `2px solid ${color}`;
                        flagDiv.style.borderRadius = '4px';
                        flagDiv.style.fontSize = '11px';
                        flagDiv.innerHTML = `
                            <strong style="color: ${color};">${flag}:</strong> 
                            <span style="color: #495057;">${data.name}</span>
                            <span style="float: right; font-weight: bold; color: ${color};">(${data.count}) ${severity}</span>
                        `;
                        flagGrid.appendChild(flagDiv);
                    }
                });
            }
            
            // Populate table rows
            queries.forEach((query, index) => {
                const formattedDate = query.requestTime || "";
                const flags = query.flags || [];
                const flagDetails = query.flagDetails || {};
                
                const statementId = `concurrent-query-conflicts-statement-${index}`;
                const isLongStatement = query.statement.length > 500;
                
                const row = document.createElement('tr');
                
                // Create date cell
                const dateCell = document.createElement('td');
                dateCell.style.whiteSpace = 'nowrap';
                dateCell.style.textAlign = 'center';
                dateCell.style.fontSize = '11px';
                dateCell.textContent = formattedDate;
                
                // Create flags cell with tooltips
                const flagsCell = document.createElement('td');
                flagsCell.style.fontWeight = 'bold';
                flagsCell.style.textAlign = 'center';
                flagsCell.style.fontSize = '12px';
                
                if (flags.length > 0) {
                    flagsCell.innerHTML = '';
                    flags.forEach((flag, idx) => {
                        const detail = flagDetails[flag] || '';
                        const color = ['B', 'D', 'F', 'H'].includes(flag) ? '#dc3545' : '#fd7e14';
                        
                        const flagSpan = document.createElement('span');
                        flagSpan.textContent = flag;
                        flagSpan.style.color = color;
                        flagSpan.className = 'join-flag-tooltip';  // Reuse same tooltip class
                        flagSpan.setAttribute('data-tooltip', detail);
                        
                        flagsCell.appendChild(flagSpan);
                        
                        if (idx < flags.length - 1) {
                            flagsCell.appendChild(document.createTextNode(', '));
                        }
                    });
                } else {
                    flagsCell.textContent = '-';
                }
                
                // Create Parse+Plan cell
                const parsePlanCell = document.createElement('td');
                parsePlanCell.style.textAlign = 'center';
                parsePlanCell.style.fontSize = '11px';
                parsePlanCell.textContent = query.parsePlanTime !== undefined ? `${query.parsePlanTime.toFixed(2)}ms` : 'N/A';
                
                // Create Fetch/Doc cell
                const fetchPerDocCell = document.createElement('td');
                fetchPerDocCell.style.textAlign = 'center';
                fetchPerDocCell.style.fontSize = '11px';
                fetchPerDocCell.textContent = query.fetchPerDoc !== null ? `${query.fetchPerDoc.toFixed(2)}ms` : 'N/A';
                
                // Create Scan Rate cell
                const scanRateCell = document.createElement('td');
                scanRateCell.style.textAlign = 'center';
                scanRateCell.style.fontSize = '11px';
                scanRateCell.textContent = query.indexScanRate !== null ? `${Math.round(query.indexScanRate).toLocaleString()}/sec` : 'N/A';
                
                // Create Kernel% cell
                const kernelCell = document.createElement('td');
                kernelCell.style.textAlign = 'center';
                kernelCell.style.fontSize = '11px';
                kernelCell.style.fontWeight = query.kernelPercent !== null && query.kernelPercent >= 30 ? 'bold' : 'normal';
                kernelCell.style.color = query.kernelPercent !== null && query.kernelPercent >= 30 ? '#dc3545' : '#495057';
                kernelCell.textContent = query.kernelPercent !== null ? `${query.kernelPercent.toFixed(1)}%` : 'N/A';
                
                // Create statement cell
                const statementCell = document.createElement('td');
                statementCell.className = 'statement-cell';
                statementCell.style.fontFamily = 'monospace';
                statementCell.style.fontSize = '11px';
                
                if (isLongStatement) {
                    const truncated = query.statement.substring(0, 500);
                    statementCell.innerHTML = `
                        <div id="${statementId}-truncated">
                            <span>${escapeHtml(truncated)}...</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', true)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                            <button onclick="copyInsightStatement('concurrent-query-conflicts', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                        <div id="${statementId}-full" style="display: none;">
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', false)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                            <button onclick="copyInsightStatement('concurrent-query-conflicts', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                } else {
                    statementCell.innerHTML = `
                        <div>
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="copyInsightStatement('concurrent-query-conflicts', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                }
                
                row.appendChild(dateCell);
                row.appendChild(flagsCell);
                row.appendChild(parsePlanCell);
                row.appendChild(fetchPerDocCell);
                row.appendChild(scanRateCell);
                row.appendChild(kernelCell);
                row.appendChild(statementCell);
                tbody.appendChild(row);
            });
        }

        // Toggle insight statement truncation
        function toggleInsightStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(statementId + '-truncated');
            const fullDiv = document.getElementById(statementId + '-full');
            
            if (showFull) {
                truncatedDiv.style.display = 'none';
                fullDiv.style.display = 'block';
            } else {
                truncatedDiv.style.display = 'block';
                fullDiv.style.display = 'none';
            }
        }

        // Copy insight statement to clipboard
        function copyInsightStatement(insightId, index, event) {
            const statement = insightSampleQueries[insightId]?.[index]?.statement;
            
            if (!statement) {
                console.error(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                showToast(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, "error");
                return;
            }
            
            navigator.clipboard.writeText(statement)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = TEXT_CONSTANTS.COPIED;
                    button.style.backgroundColor = '#4CAF50';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 1000);
                })
                .catch((err) => {
                    console.error(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, err);
                    showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                });
        }

        // Storage for timeout queries
        let timeoutQueriesData = {
            actualTimeouts: [],
            approachingTimeouts: []
        };
        let timeoutQueriesVisible = false;

        // Toggle timeout queries table visibility
        function toggleTimeoutQueriesTable() {
            const container = document.getElementById('timeout-prone-queries-sample-queries-container');
            const btnText = document.getElementById('timeout-prone-queries-sample-queries-btn-text');
            
            if (!container || !btnText) return;
            
            timeoutQueriesVisible = !timeoutQueriesVisible;
            
            if (timeoutQueriesVisible) {
                container.style.display = 'block';
                btnText.textContent = TEXT_CONSTANTS.HIDE_SAMPLE_QUERIES;
            } else {
                container.style.display = 'none';
                btnText.textContent = TEXT_CONSTANTS.SHOW_SAMPLE_QUERIES;
            }
        }

        // Update timeout queries table with special 3-column format
        function updateTimeoutQueriesTable(actualTimeouts, approachingTimeouts) {
            const tbody = document.getElementById('timeout-prone-queries-sample-queries-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            timeoutQueriesData.actualTimeouts = actualTimeouts;
            timeoutQueriesData.approachingTimeouts = approachingTimeouts;
            
            // First add actual timeouts (up to 5)
            actualTimeouts.forEach((query, index) => {
                const row = createTimeoutQueryRow(query, index, 'actual');
                row.style.backgroundColor = '#ffebee'; // Light red background for timeouts
                tbody.appendChild(row);
            });
            
            // Then add approaching timeouts (up to 5)
            approachingTimeouts.forEach((query, index) => {
                const row = createTimeoutQueryRow(query, index + actualTimeouts.length, 'approaching');
                row.style.backgroundColor = '#fff3e0'; // Light orange background for approaching
                tbody.appendChild(row);
            });
        }

        // Create a timeout query table row
        function createTimeoutQueryRow(query, index, type) {
            const formattedDate = query.requestTime || "";
            
            const statementId = `timeout-${type}-statement-${index}`;
            const isLongStatement = query.statement.length > 500;
            
            const row = document.createElement('tr');
            
            // Create date cell
            const dateCell = document.createElement('td');
            dateCell.style.whiteSpace = 'nowrap';
            dateCell.style.textAlign = 'center';
            dateCell.style.fontSize = '11px';
            dateCell.textContent = formattedDate;
            
            // Create statement cell
            const statementCell = document.createElement('td');
            statementCell.className = 'statement-cell';
            
            if (isLongStatement) {
                const truncated = query.statement.substring(0, 500);
                statementCell.innerHTML = `
                    <div id="${statementId}-truncated">
                        <span>${escapeHtml(truncated)}...</span>
                        <br>
                        <button onclick="toggleInsightStatement('${statementId}', true)" 
                                class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                        <button onclick="copyTimeoutStatement('${type}', ${index}, event)" 
                                class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                    <div id="${statementId}-full" style="display: none;">
                        <span>${escapeHtml(query.statement)}</span>
                        <br>
                        <button onclick="toggleInsightStatement('${statementId}', false)" 
                                class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                        <button onclick="copyTimeoutStatement('${type}', ${index}, event)" 
                                class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                `;
            } else {
                statementCell.innerHTML = `
                    <div>
                        <span>${escapeHtml(query.statement)}</span>
                        <br>
                        <button onclick="copyTimeoutStatement('${type}', ${index}, event)" 
                                class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                `;
            }
            
            // Create elapsed time cell
            const elapsedTimeCell = document.createElement('td');
            elapsedTimeCell.style.whiteSpace = 'nowrap';
            elapsedTimeCell.style.textAlign = 'center';
            elapsedTimeCell.style.fontSize = '11px';
            elapsedTimeCell.textContent = query.elapsedTime || 'N/A';
            if (type === 'actual') {
                elapsedTimeCell.style.fontWeight = 'bold';
                elapsedTimeCell.style.color = '#d32f2f'; // Red for timeouts
            } else {
                elapsedTimeCell.style.color = '#f57c00'; // Orange for approaching
            }
            
            row.appendChild(dateCell);
            row.appendChild(statementCell);
            row.appendChild(elapsedTimeCell);
            
            return row;
        }

        // Copy timeout statement to clipboard
        function copyTimeoutStatement(type, index, event) {
            const statement = type === 'actual' ? 
                timeoutQueriesData.actualTimeouts[index]?.statement : 
                timeoutQueriesData.approachingTimeouts[index - timeoutQueriesData.actualTimeouts.length]?.statement;
            
            if (!statement) {
                console.error(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                showToast(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, "error");
                return;
            }
            
            navigator.clipboard.writeText(statement)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = TEXT_CONSTANTS.COPIED;
                    button.style.backgroundColor = '#4CAF50';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 1000);
                })
                .catch((err) => {
                    console.error(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, err);
                    showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                });
        }

        // Use global loadedTabs from above (removed duplicate declaration - Step 5 fix)

        // Initialize jQuery UI Tabs with lazy loading
        $(function () {
            // Initialize jQuery UI tooltips (Issue #186)
            $(".help-icon").tooltip({
                position: {
                    my: "center bottom-10",
                    at: "center top"
                },
                show: {
                    effect: "fadeIn",
                    duration: 200
                },
                hide: {
                    effect: "fadeOut",
                    duration: 200
                }
            });

            $("#tabs").tabs({
                activate: function (event, ui) {
                    const tabId = ui.newPanel.attr("id");

                    // Skip lazy loading if we're just changing time grouping
                    if (isChangingTimeGrouping) {
                        Logger.trace(`Skipping lazy load for ${tabId} - time grouping change in progress`);
                        return;
                    }

                    // Lazy load charts when tabs are first activated
                    if (!loadedTabs.has(tabId)) {
                        loadedTabs.add(tabId);

                        if (tabId === "timeline") {
                            // Use current filtered requests, not cached data (Step 5 fix)
                            const currentFilteredRequests = window.filteredRequests || window.currentFilteredRequests || originalRequests;
                            if (currentFilteredRequests.length > 0) {
                                // Sample for performance with large datasets
                                const sampleSize = Math.min(500, currentFilteredRequests.length);
                                const sampleStep = Math.max(1, Math.floor(currentFilteredRequests.length / sampleSize));
                                const timelineSample = currentFilteredRequests.filter((_, i) => i % sampleStep === 0);
                                console.log(`${TEXT_CONSTANTS.TIMELINE_CHARTS_USING} ${timelineSample.length} ${TEXT_CONSTANTS.OF_TOTAL} ${currentFilteredRequests.length} ${TEXT_CONSTANTS.REQUESTS_FOR_PERFORMANCE}`);
                                generateFilterChart(currentFilteredRequests);
                                generateTimelineChart(timelineSample);
                            }
                        } else if (tabId === "dashboard") {
                            // Use current filtered requests, not cached data (Step 5 fix)
                            const currentFilteredRequests = window.filteredRequests || window.currentFilteredRequests || originalRequests;
                            if (currentFilteredRequests.length > 0) {
                                generateDashboardCharts(currentFilteredRequests);
                            }
                        }
                    }

                    // Always check Index/Query Flow tab (not just first time)
                    if (tabId === "index-query-flow" && originalRequests.length > 0) {
                        // Use current filtered requests, not cached data
                        const currentFilteredRequests = window.filteredRequests || window.currentFilteredRequests || originalRequests;
                        
                        Logger.debug(`[Flow] Lazy load triggered. Active tab index: ${$("#tabs").tabs("option", "active")}`);
                        
                        // Rebuild Index/Query Flow with current filtered data
                        buildIndexQueryFlow(currentFilteredRequests);
                    }
                },
            });
        });

        // Whole Record feature (Issue #110)
        function setWholeRecordTexts() {
            try {
                var loadBtn = document.getElementById('whole-record-load-btn');
                if (loadBtn && window.TEXT_CONSTANTS) {
                    loadBtn.textContent = TEXT_CONSTANTS.LOAD || 'Load';
                }
                var label = document.querySelector('label[for="whole-record-request-id-input"]');
                if (label && window.TEXT_CONSTANTS) {
                    label.textContent = TEXT_CONSTANTS.REQUEST_ID || 'Request ID';
                }
                var input = document.getElementById('whole-record-request-id-input');
                if (input && window.TEXT_CONSTANTS) {
                    input.placeholder = TEXT_CONSTANTS.ENTER_REQUEST_ID || 'Enter requestId';
                }
            } catch (e) { /* no-op */ }
        }

        function copyRequestId(reqId, event) {
            if (!reqId) return;
            navigator.clipboard.writeText(String(reqId)).then(() => {
                if (event && event.target) {
                    const btn = event.target;
                    const original = btn.textContent;
                    btn.textContent = TEXT_CONSTANTS.COPIED || 'Copied!';
                    btn.style.backgroundColor = '#4CAF50';
                    setTimeout(() => { btn.textContent = TEXT_CONSTANTS.COPY || 'Copy'; btn.style.backgroundColor=''; }, 1000);
                } else {
                    showToast(TEXT_CONSTANTS.COPIED_CLIPBOARD || 'Copied to clipboard!', 'success');
                }
            }).catch((err) => {
                console.error(err);
                showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD || 'Failed to copy to clipboard', 'error');
            });
            if (event && event.stopPropagation) event.stopPropagation();
        }

        /**
         * Open Raw Record in fullscreen overlay
         * @param {string} reqId - Request ID to display
         * @param {Event} event - Click event to stop propagation
         */
        function openRawRecordFullscreen(reqId, event) {
            Logger.debug(`[Raw Record] üëÅÔ∏è Opening fullscreen for requestId: ${reqId}`);
            
            if (event && event.stopPropagation) {
                event.stopPropagation();
            }
            
            if (!reqId) {
                Logger.error('[Raw Record] ‚ùå No requestId provided');
                return;
            }
            
            // Find the request record
            const record = findRequestById(reqId);
            if (!record) {
                Logger.error(`[Raw Record] ‚ùå Request not found: ${reqId}`);
                showToast('Request ID not found', 'error');
                return;
            }
            
            // Get overlay elements
            const overlay = document.getElementById('raw-record-overlay');
            const jsonPre = document.getElementById('raw-record-overlay-json');
            const info = document.getElementById('raw-record-overlay-info');
            
            if (!overlay || !jsonPre) {
                Logger.error('[Raw Record] ‚ùå Overlay elements not found');
                return;
            }
            
            // Format and display JSON
            const jsonString = JSON.stringify(record, null, 2);
            jsonPre.textContent = jsonString;
            
            // Update info display
            if (info) {
                const sizeBytes = new Blob([jsonString]).size;
                const sizeKB = (sizeBytes / 1024).toFixed(2);
                info.textContent = `Request ID: ${reqId} | Size: ${sizeKB} KB (${sizeBytes.toLocaleString()} bytes)`;
            }
            
            // Show overlay
            overlay.style.display = 'block';
            
            // Add ESC key handler
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    closeRawRecordOverlay();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
            
            // Close on overlay click (outside content area)
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeRawRecordOverlay();
                }
            });
            
            Logger.info(`[Raw Record] ‚úÖ Fullscreen opened for requestId: ${reqId}`);
        }

        /**
         * Close Raw Record fullscreen overlay
         */
        function closeRawRecordOverlay() {
            Logger.debug('[Raw Record] ‚úï Closing fullscreen overlay');
            
            const overlay = document.getElementById('raw-record-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        /**
         * Copy Raw Record JSON from overlay to clipboard
         */
        function copyRawRecordOverlayJSON() {
            Logger.debug('[Raw Record] üìã Copying JSON to clipboard');
            
            const jsonPre = document.getElementById('raw-record-overlay-json');
            if (!jsonPre || !jsonPre.textContent) {
                Logger.error('[Raw Record] ‚ùå No JSON content to copy');
                showToast('No content to copy', 'error');
                return;
            }
            
            navigator.clipboard.writeText(jsonPre.textContent).then(() => {
                Logger.info('[Raw Record] ‚úÖ JSON copied to clipboard');
                showToast('JSON copied to clipboard!', 'success');
            }).catch((err) => {
                Logger.error('[Raw Record] ‚ùå Failed to copy:', err);
                showToast('Failed to copy to clipboard', 'error');
            });
        }

        function findRequestById(requestId) {
            if (!requestId) return null;
            const idStr = String(requestId);
            const pools = [window.filteredRequests, window.currentFilteredRequests, window.originalRequests];
            for (const pool of pools) {
                if (Array.isArray(pool)) {
                    const found = pool.find(r => (r && (r.requestId === idStr || r.requestID === idStr)));
                    if (found) return found;
                }
            }
            return null;
        }

        function renderWholeRecord(record) {
            const pre = document.getElementById('whole-record-json');
            if (!pre) return;
            if (!record) {
                pre.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.RECORD_NOT_FOUND) || 'Request ID not found';
                return;
            }
            try {
                const out = Object.assign({}, record);
                if (out.request && typeof out.request === 'object') out.request = Object.assign({}, out.request);
                if (out.plan && typeof out.plan === 'string') { try { out.plan = JSON.parse(out.plan); } catch(_){} }
                if (out.request && out.request.plan && typeof out.request.plan === 'string') { try { out.request.plan = JSON.parse(out.request.plan); } catch(_){} }
                pre.textContent = JSON.stringify(out, null, 2);
            } catch (e) {
                pre.textContent = ((window.TEXT_CONSTANTS && TEXT_CONSTANTS.ERROR_PARSING_JSON) || 'Error parsing JSON:') + ' ' + (e && e.message ? e.message : e);
            }
        }

        function loadWholeRecordById(requestId) {
            const rec = findRequestById(requestId);
            try { const link = document.querySelector('a[href="#whole-record"]'); if (link && link.click) link.click(); } catch (_) {}
            renderWholeRecord(rec);
        }

        function loadWholeRecordFromInput() {
            const input = document.getElementById('whole-record-request-id-input');
            if (!input) return;
            const val = (input.value || '').trim();
            if (!val) return;
            loadWholeRecordById(val);
        }

        function handleWholeRecordHash() {
            try {
                const hash = window.location.hash || '';
                const m = hash.match(/requestId=([^&]+)/i);
                if (m && m[1]) {
                    const id = decodeURIComponent(m[1]);
                    const input = document.getElementById('whole-record-request-id-input');
                    if (input) input.value = id;
                    loadWholeRecordById(id);
                }
            } catch (e) { /* no-op */ }
        }

        (function(){
            function initWholeRecord() {
                setWholeRecordTexts();
                handleWholeRecordHash();
                try { window.addEventListener('hashchange', handleWholeRecordHash); } catch(_) {}
                try {
                  var inp = document.getElementById('whole-record-request-id-input');
                  if (inp) {
                    inp.addEventListener('paste', function(){
                      setTimeout(function(){
                        var v = (inp.value||'').trim();
                        if (v) loadWholeRecordById(v);
                      }, 0);
                    });
                    // Also auto-load when user types/pastes and pauses
                    var t;
                    inp.addEventListener('input', function(){
                      clearTimeout(t);
                      t = setTimeout(function(){
                        var v = (inp.value||'').trim();
                        if (v) loadWholeRecordById(v);
                      }, 300);
                    });
                  }
                } catch(_) {}
            }
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initWholeRecord);
            } else {
                initWholeRecord();
            }
        })();

        // Index/Query Flow functionality
        let indexQueryFlowData = {
            indexes: new Map(),
            queries: new Map(),
            connections: new Map(),
            mermaidDiagram: ''  // Cached Mermaid diagram text
        };

        // Clear all Index/Query Flow content
        function clearIndexQueryFlow() {
            // Clear the flow elements container
            const flowElements = document.getElementById("flow-elements");
            if (flowElements) {
                flowElements.innerHTML = "";
            }

            // Clear the SVG connections
            const svg = document.getElementById("flow-svg");
            if (svg) {
                svg.innerHTML = "";
            }

            // Clear data structures
            if (indexQueryFlowData) {
                indexQueryFlowData.indexes.clear();
                indexQueryFlowData.queries.clear();
                indexQueryFlowData.connections.clear();
            }
        }

        // Process Index/Query data without DOM rendering (for hidden tabs)
        function processIndexQueryData(requests) {


            // Clear and rebuild data structures
            indexQueryFlowData.indexes.clear();
            indexQueryFlowData.queries.clear();
            indexQueryFlowData.connections.clear();

            // Copy exact logic from buildIndexQueryFlow but skip DOM rendering
            const requestIndexMap = new Map();
            const allIndexes = new Map();
            const queryGroups = new Map();

            let requestsWithPlans = 0;
            let requestsWithOperators = 0;

            requests.forEach((request, requestIndex) => {
                requestIndexMap.set(requestIndex, new Set());
                if (request.plan) {
                    requestsWithPlans++;
                    const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;

                    if (planObj && planObj["#operator"]) {
                        requestsWithOperators++;
                        const statement = request.preparedText || request.statement || "";
                        
                        // Use parseFromClause() for consistent BSC extraction across all statement types
                        const bucketScopeCollection = parseFromClause(statement);
                        
                        // Log BSC extraction for debugging
                        console.log(`[BSC EXTRACTION] Query (SHA-256):`, hashQuery(statement));
                        console.log(`[BSC EXTRACTION] Extracted BSC:`, hashBSC(bucketScopeCollection), `(${bucketScopeCollection})`);

                        extractIndexUsage(planObj, requestIndex, requestIndexMap, bucketScopeCollection);
                    }
                }

                // Group queries by normalized statement  
                const stmt = request.preparedText || request.statement;
                if (stmt) {
                    const normalized = normalizeStatement(stmt);
                    if (!queryGroups.has(normalized)) {
                        queryGroups.set(normalized, {
                            normalizedStatement: normalized,
                            statement: stmt, // Add original statement for createQueryDiv
                            count: 0,
                            totalDuration: 0, // Add totalDuration calculation
                            requests: [],
                            scanConsistencies: [] // non-unbounded values only
                        });
                    }
                    const group = queryGroups.get(normalized);
                    group.count++;
                    // Use same logic as Analysis tab: serviceTime converted to ms
                    const durationMs = parseTime(request.serviceTime);
                    group.totalDuration += isNaN(durationMs) ? 0 : durationMs;
                    // Track non-unbounded scan consistency for this group
                    try {
                        const sc = ((request.scanConsistency) || (request.request && request.request.scanConsistency) || 'unbounded').toLowerCase();
                        if (sc && sc !== 'unbounded' && !group.scanConsistencies.includes(sc)) {
                            group.scanConsistencies.push(sc);
                        }
                    } catch(_) {}
                    group.requests.push(request);
                }
            });

            // Build allIndexes from requestIndexMap (same as main function)
            requestIndexMap.forEach((indexSet, requestIndex) => {
                indexSet.forEach((indexName) => {
                    if (!allIndexes.has(indexName)) {
                        const isPrimaryCheck = indexName === "#primary" ||
                            indexName.includes("#primary") ||
                            indexName.includes("primary") ||
                            indexName.endsWith("_primary");



                        allIndexes.set(indexName, {
                            name: indexName,
                            requests: [],
                            totalUsage: 0,
                            isPrimary: isPrimaryCheck,
                            scanTimes: [],
                            itemsScanned: [],
                            itemsFetched: []
                        });
                    }
                    const indexObj = allIndexes.get(indexName);
                    indexObj.requests.push(requests[requestIndex]);
                    indexObj.totalUsage++;

                    // Collect statistics from the request
                    const request = requests[requestIndex];
                    if (request) {

                        // Extract actual index scan service time and items data from plan data  
                        const indexData = extractIndexScanDataFromPlan(request.plan, indexName);
                        if (indexData.scanTime > 0) {
                            indexObj.scanTimes.push(indexData.scanTime);
                        }
                        if (indexData.itemsScanned > 0) {
                            indexObj.itemsScanned.push(indexData.itemsScanned);
                        }
                        if (indexData.itemsFetched > 0) {
                            indexObj.itemsFetched.push(indexData.itemsFetched);
                        }
                    }
                });
            });

            // CRITICAL: Populate indexQueryFlowData with processed data for SVG rendering
            // Sort indexes by totalUsage (descending) - show all indexes, even without stats
            const sortedIndexes = Array.from(allIndexes.values())
                .sort((a, b) => b.totalUsage - a.totalUsage);
            const sortedQueries = Array.from(queryGroups.values()).sort((a, b) => b.count - a.count);

            indexQueryFlowData.indexes = new Map(sortedIndexes.map(idx => [idx.name, idx]));
            indexQueryFlowData.queries = new Map(sortedQueries.map(q => [q.normalizedStatement, q]));



            // Rebuild connections data
            requestIndexMap.forEach((indexSet, requestIndex) => {
                const request = requests[requestIndex];
                const stmt = request.preparedText || request.statement;
                if (stmt) {
                    const normalized = normalizeStatement(stmt);
                    const bucketScopeCollection = parseFromClause(stmt);
                    
                    indexSet.forEach((indexName) => {
                        const compositeKey = `${indexName}::${bucketScopeCollection}`;
                        const connectionKey = `${normalized}::${compositeKey}`;
                        if (!indexQueryFlowData.connections.has(connectionKey)) {
                            indexQueryFlowData.connections.set(connectionKey, {
                                queryStatement: normalized,
                                indexName: indexName,
                                indexKey: compositeKey,
                                bucketScopeCollection: bucketScopeCollection,
                                count: 0,
                            });
                        }
                        indexQueryFlowData.connections.get(connectionKey).count++;
                    });
                }
            });

            // Update counts with correct data
            // Count unique index NAMES (not composite keys like "indexName::bucket.scope.collection")
            const uniqueIndexNames = new Set();
            allIndexes.forEach((value, key) => {
                // Extract index name from composite key or use key directly
                const indexName = key.includes("::") ? key.split("::")[0] : key;
                uniqueIndexNames.add(indexName);
            });
            const indexCountEl = document.getElementById("index-count");
            const queryCountEl = document.getElementById("query-count");
            if (indexCountEl) indexCountEl.textContent = uniqueIndexNames.size;
            if (queryCountEl) queryCountEl.textContent = queryGroups.size;

            // Generate and cache Mermaid diagram for AI analyzer
            indexQueryFlowData.mermaidDiagram = generateMermaidDiagramFromFlow();
            Logger.debug(`[Flow] ‚úÖ Mermaid diagram cached: ${indexQueryFlowData.connections.size} connections`);

        }
        
        /**
         * Generate Mermaid diagram from flow data (called during flow creation)
         */
        function generateMermaidDiagramFromFlow() {
            Logger.debug(`[Flow] üé® generateMermaidDiagramFromFlow() called`);
            Logger.trace(`[Flow] Connections size: ${indexQueryFlowData?.connections?.size || 0}`);
            
            if (!indexQueryFlowData?.connections?.size) {
                Logger.warn('[Flow] No connections available for Mermaid generation');
                return 'graph LR\n  A[No flow connections]';
            }
            
            Logger.debug(`[Flow] Building Mermaid from ${indexQueryFlowData.connections.size} connections`);
            
            const lines = ['graph LR'];
            const indexNodeIds = new Map();
            const queryNodeIds = new Map();
            let idxCounter = 0;
            let qryCounter = 0;
            
            indexQueryFlowData.connections.forEach(conn => {
                const indexKey = conn.indexKey || conn.indexName || 'unknown';
                const queryStmt = conn.queryStatement || '';
                
                // Create index node
                let indexId = indexNodeIds.get(indexKey);
                if (!indexId) {
                    indexId = `idx${++idxCounter}`;
                    indexNodeIds.set(indexKey, indexId);
                    
                    // Extract just the index name and bucket.scope.collection
                    let indexName = conn.indexName || 'index';
                    let bsc = conn.bucketScopeCollection || '';
                    
                    // Simple single-line label (Mermaid doesn't support HTML)
                    lines.push(`  ${indexId}["${indexName} on ${bsc}"]`);
                }
                
                // Create query node
                let queryId = queryNodeIds.get(queryStmt);
                if (!queryId) {
                    queryId = `q${++qryCounter}`;
                    queryNodeIds.set(queryStmt, queryId);
                    
                    const queryLabel = queryStmt.slice(0, 70).replace(/"/g, "'").replace(/\n/g, ' ');
                    lines.push(`  ${queryId}("${queryLabel}...")`);
                }
                
                // Create edge with count
                const edgeLabel = conn.count ? `${conn.count}x` : '';
                if (edgeLabel) {
                    lines.push(`  ${indexId} -->|${edgeLabel}| ${queryId}`);
                } else {
                    lines.push(`  ${indexId} --> ${queryId}`);
                }
            });
            
            const diagram = lines.join('\n');
            Logger.info(`[Flow] ‚úÖ Mermaid diagram generated: ${indexNodeIds.size} indexes, ${queryNodeIds.size} queries, ${lines.length} lines`);
            Logger.trace(`[Flow] Mermaid preview:\n${diagram.substring(0, 500)}...`);
            
            return diagram;
        }

        // Helper function to resolve #primary to actual primary index name
        function resolvePrimaryIndexName(bucketScopeCollection) {
            // Look through indexData to find the actual primary index for this collection
            for (const index of indexData) {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                    const isPrimary =
                        index.name.includes("primary") ||
                        index.name.includes("#primary") ||
                        index.name.endsWith("_primary");

                    if (isPrimary && targetString === bucketScopeCollection) {
                        return index.name;
                    }
                }
            }
            // If no actual primary index found, keep #primary
            return "#primary";
        }

        // DEPRECATED: Use window.buildIndexQueryFlow from flow-diagram.js
        // The internal implementation has been removed to avoid shadowing the global one.








        // Extract the actual service time and items data for a specific index from the plan JSON
        function extractIndexScanDataFromPlan(planString, indexName) {
            if (!planString || !indexName) return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };

            try {
                // Handle both cases: plan as string (needs parsing) or plan as object (already parsed)
                let plan;
                if (typeof planString === 'string') {
                    plan = JSON.parse(planString);
                } else if (typeof planString === 'object' && planString !== null) {
                    plan = planString; // Already parsed
                } else {
                    return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };
                }

                let result = { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };

                function searchOperatorForIndex(operator) {
                    if (!operator) return;

                    const opType = operator["#operator"];

                    // Check if this operator uses the target index
                    const operatorIndex = operator.index || operator.indexName;

                    if (operatorIndex === indexName ||
                        (indexName.includes("primary") && operatorIndex === "#primary") ||
                        (indexName === "def_primary" && operatorIndex === "#primary")) {

                        // Extract servTime and items data from this operator's stats
                        if (operator["#stats"]) {
                            const stats = operator["#stats"];

                            if (stats["servTime"]) {
                                result.scanTime = parseTime(stats["servTime"]);
                            }
                            
                            // Handle itemsOut - use value if present, otherwise keep as 0 (scan returned no docs)
                            if (stats["#itemsOut"] !== undefined) {
                                result.itemsScanned = stats["#itemsOut"];
                            }
                            // else: keep default 0 value from initialization
                            
                            // Handle itemsIn - use value if present, otherwise keep as 0
                            if (stats["#itemsIn"] !== undefined) {
                                result.itemsFetched = stats["#itemsIn"];
                            }
                            // else: keep default 0 value from initialization
                        }
                    }
                    
                    // For UnionScan, IntersectScan, etc., check scans array FIRST before other traversals
                    // This ensures we find indexes inside UnionScan > DistinctScan > scan structures
                    if (operator["scans"] && Array.isArray(operator["scans"])) {
                        for (const scan of operator["scans"]) {
                            searchOperatorForIndex(scan);
                        }
                    }
                    
                    // For DistinctScan, check the nested scan property
                    if (operator["scan"]) {
                        searchOperatorForIndex(operator["scan"]);
                    }

                    // Recursively search child operators
                    if (operator["~child"]) {
                        searchOperatorForIndex(operator["~child"]);
                    }

                    if (operator["~children"]) {
                        for (const child of operator["~children"]) {
                            searchOperatorForIndex(child);
                        }
                    }

                    // Search other nested operator properties
                    if (operator["input"]) {
                        searchOperatorForIndex(operator["input"]);
                    }

                    if (operator["inputs"] && Array.isArray(operator["inputs"])) {
                        for (const input of operator["inputs"]) {
                            searchOperatorForIndex(input);
                        }
                    }

                    if (operator["left"]) {
                        searchOperatorForIndex(operator["left"]);
                    }

                    if (operator["right"]) {
                        searchOperatorForIndex(operator["right"]);
                    }

                    if (operator["first"]) {
                        searchOperatorForIndex(operator["first"]);
                    }

                    if (operator["second"]) {
                        searchOperatorForIndex(operator["second"]);
                    }
                    
                    // Search subqueries
                    if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                        for (const subquery of operator["~subqueries"]) {
                            if (subquery.executionTimings) {
                                searchOperatorForIndex(subquery.executionTimings);
                            }
                        }
                    }
                }

                searchOperatorForIndex(plan);
                return result;
            } catch (e) {
                console.warn("Failed to process plan data:", e);
                console.warn("Plan type:", typeof planString);
                console.warn("Plan is null:", planString === null);
                return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };
            }
        }

        // Helper function to extract BSC from an operator
        function extractBSCFromOperator(operator) {
            if (!operator) return "unknown.unknown.unknown";
            
            // Handle both old and new Couchbase formats:
            // NEW format: has bucket, scope, keyspace fields
            // OLD format: only has keyspace (which is the bucket name), assumes _default._default
            if (operator.bucket) {
                // New format with explicit bucket/scope/keyspace
                const bucket = operator.bucket;
                const scope = operator.scope || "_default";
                const keyspace = operator.keyspace || "_default";
                return `${bucket}.${scope}.${keyspace}`;
            } else if (operator.keyspace) {
                // Old format: keyspace IS the bucket name, default scope/collection
                return `${operator.keyspace}._default._default`;
            } else {
                return "unknown.unknown.unknown";
            }
        }

        // Special handling for subqueries - extract BSC from each operator dynamically
        function extractIndexUsageFromSubquery(
            operator,
            requestIndex,
            requestIndexMap,
            visited = new WeakSet()
        ) {
            if (!operator) return;
            
            // Prevent infinite recursion
            if (visited.has(operator)) return;
            visited.add(operator);
            
            const opType = operator["#operator"];
            
            // Extract BSC from this operator if it has index/keyspace info
            let bucketScopeCollection = extractBSCFromOperator(operator);
            
            // Record index usage if this is a scan operator
            if (opType === "IndexScan" || opType === "IndexScan2" || opType === "IndexScan3") {
                if (operator.index) {
                    const compositeKey = `${operator.index}::${bucketScopeCollection}`;
                    requestIndexMap.get(requestIndex).add(compositeKey);
                }
                if (operator.indexName) {
                    const compositeKey = `${operator.indexName}::${bucketScopeCollection}`;
                    requestIndexMap.get(requestIndex).add(compositeKey);
                }
            }
            
            if (opType === "PrimaryScan" || opType === "PrimaryScan2" || opType === "PrimaryScan3") {
                let indexName = "#primary";
                const resolvedName = resolvePrimaryIndexName(bucketScopeCollection);
                if (resolvedName && resolvedName !== "#primary") {
                    indexName = resolvedName;
                } else if (operator.index) {
                    indexName = operator.index;
                }
                const compositeKey = `${indexName}::${bucketScopeCollection}`;
                requestIndexMap.get(requestIndex).add(compositeKey);
            }
            
            // Recursively traverse all child operators
            if (operator["~child"]) {
                extractIndexUsageFromSubquery(operator["~child"], requestIndex, requestIndexMap, visited);
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                operator["~children"].forEach((child) =>
                    extractIndexUsageFromSubquery(child, requestIndex, requestIndexMap, visited)
                );
            }
            if (operator.input) {
                extractIndexUsageFromSubquery(operator.input, requestIndex, requestIndexMap, visited);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexUsageFromSubquery(input, requestIndex, requestIndexMap, visited)
                );
            }
            if (operator.left) {
                extractIndexUsageFromSubquery(operator.left, requestIndex, requestIndexMap, visited);
            }
            if (operator.right) {
                extractIndexUsageFromSubquery(operator.right, requestIndex, requestIndexMap, visited);
            }
            if (operator.first) {
                extractIndexUsageFromSubquery(operator.first, requestIndex, requestIndexMap, visited);
            }
            if (operator.second) {
                extractIndexUsageFromSubquery(operator.second, requestIndex, requestIndexMap, visited);
            }
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexUsageFromSubquery(scan, requestIndex, requestIndexMap, visited)
                );
            }
            if (operator.scan) {
                extractIndexUsageFromSubquery(operator.scan, requestIndex, requestIndexMap, visited);
            }
            // Nested subqueries
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexUsageFromSubquery(subquery.executionTimings, requestIndex, requestIndexMap, visited);
                    }
                });
            }
        }

        function extractIndexUsage(
            operator,
            requestIndex,
            requestIndexMap,
            bucketScopeCollection = "unknown.unknown.unknown"
        ) {
            if (!operator) {
                return;
            }

            // Function to record index usage for this request with BSC
            function recordIndexUsage(indexName) {
                // If this is #primary, try to resolve to actual primary index name
                if (indexName === "#primary") {
                    const resolved = resolvePrimaryIndexName(bucketScopeCollection);
                    indexName = resolved;
                }
                // Store as composite key: indexName::bucket.scope.collection
                const compositeKey = `${indexName}::${bucketScopeCollection}`;
                
                // Debug JOINs: only log if operator is a JOIN type
                if (opType && (opType === "Join" || opType === "Nest" || opType === "HashJoin" || opType === "NLJoin")) {
                    console.log(`[JOIN DEBUG] Recording index for ${opType}: ${hashCompositeKey(compositeKey)}`);
                }
                
                requestIndexMap.get(requestIndex).add(compositeKey);
            }

            const opType = operator["#operator"];
            
            // Extract BSC from operator if available (overrides parent BSC for accuracy)
            // This handles both old format (keyspace only) and new format (bucket/scope/keyspace)
            let operatorBSC = bucketScopeCollection;
            if (operator.keyspace || operator.bucket) {
                operatorBSC = extractBSCFromOperator(operator);
            }

            // Update recordIndexUsage to use operator-specific BSC
            function recordIndexUsageWithBSC(indexName) {
                if (indexName === "#primary") {
                    const resolved = resolvePrimaryIndexName(operatorBSC);
                    indexName = resolved;
                }
                const compositeKey = `${indexName}::${operatorBSC}`;
                
                if (opType && (opType === "Join" || opType === "Nest" || opType === "HashJoin" || opType === "NLJoin")) {
                    console.log(`[JOIN DEBUG] Recording index for ${opType}: ${hashCompositeKey(compositeKey)}`);
                }
                
                requestIndexMap.get(requestIndex).add(compositeKey);
            }

            // Check for IndexScan operators
            if (
                opType === "IndexScan" ||
                opType === "IndexScan2" ||
                opType === "IndexScan3"
            ) {
                if (operator.index) {
                    recordIndexUsageWithBSC(operator.index);
                }
                if (operator.indexName) {
                    recordIndexUsageWithBSC(operator.indexName);
                }
            }

            // Check for PrimaryScan operators
            if (
                opType === "PrimaryScan" ||
                opType === "PrimaryScan2" ||
                opType === "PrimaryScan3"
            ) {
                // For primary scans, prefer resolved name over operator.index to avoid duplicates
                let resolvedName = resolvePrimaryIndexName(operatorBSC);
                if (resolvedName && resolvedName !== "#primary") {
                    recordIndexUsageWithBSC(resolvedName);
                } else if (operator.index) {
                    recordIndexUsageWithBSC(operator.index);
                } else {
                    recordIndexUsageWithBSC("#primary");
                }
            }

            // Check for sequential scan
            if (operator.using === "sequentialscan") {
                recordIndexUsage("#sequentialscan");
            }

            // Recursively check child operators (same as Dashboard logic)
            if (operator["~child"]) {
                extractIndexUsage(
                    operator["~child"],
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                operator["~children"].forEach((child) =>
                    extractIndexUsage(
                        child,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            if (operator.input) {
                extractIndexUsage(
                    operator.input,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexUsage(
                        input,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            if (operator.left) {
                extractIndexUsage(
                    operator.left,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.right) {
                // For JOIN/NEST operators, the right side might have its own keyspace
                let rightBSC = bucketScopeCollection;
                if ((opType === "Join" || opType === "Nest" || opType === "HashJoin" || opType === "NLJoin") && operator.keyspace) {
                    console.log(`[JOIN DEBUG] Detected ${opType} operator with keyspace: ${operator.keyspace}`);
                    console.log(`[JOIN DEBUG] Left BSC: ${hashBSC(bucketScopeCollection)}`);
                    
                    // Extract BSC from keyspace field: "bucket:scope.collection" or "bucket"
                    const keyspace = operator.keyspace;
                    const colonIndex = keyspace.indexOf(':');
                    if (colonIndex > 0) {
                        const bucket = keyspace.substring(0, colonIndex);
                        const scopeCollection = keyspace.substring(colonIndex + 1);
                        const parts = scopeCollection.split('.');
                        if (parts.length === 2) {
                            rightBSC = `${bucket}.${parts[0]}.${parts[1]}`;
                        } else if (parts.length === 1) {
                            rightBSC = `${bucket}.${parts[0]}._default`;
                        }
                    } else {
                        // No colon, just bucket name
                        rightBSC = `${keyspace}._default._default`;
                    }
                    
                    console.log(`[JOIN DEBUG] Right BSC: ${hashBSC(rightBSC)}`);
                }
                extractIndexUsage(
                    operator.right,
                    requestIndex,
                    requestIndexMap,
                    rightBSC
                );
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexUsage(
                    operator.first,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.second) {
                extractIndexUsage(
                    operator.second,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexUsage(
                        scan,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexUsage(
                    operator.scan,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        // For subqueries, we need to extract BSC from the subquery operators themselves
                        // since subqueries often access different keyspaces than the parent query
                        extractIndexUsageFromSubquery(
                            subquery.executionTimings,
                            requestIndex,
                            requestIndexMap
                        );
                    }
                });
            }
        }

        function renderIndexQueryFlow(indexes, queries, selectedIndex = "All", selectedBucket = "All", selectedScope = "All", selectedCollection = "All") {

            const flowElements = document.getElementById("flow-elements");

            if (!flowElements) {
                console.error("flow-elements container not found");
                return;
            }

            // Issue #178: Populate filter dropdowns with cascading logic
            const indexDropdown = document.getElementById("index-filter-dropdown");
            const bucketDropdown = document.getElementById("bucket-filter-dropdown");
            const scopeDropdown = document.getElementById("scope-filter-dropdown");
            const collectionDropdown = document.getElementById("collection-filter-dropdown");
            
            // Store original data if not already stored
            if (!window.flowOriginalIndexes) {
                window.flowOriginalIndexes = indexes;
                window.flowOriginalQueries = queries;
            }
            
            // Use original data for building dropdowns
            const originalIndexes = window.flowOriginalIndexes;
            const originalQueries = window.flowOriginalQueries;
            
            // Extract all bucket/scope/collection combinations from connection data (execution plans)
            // This ensures we capture ALL collections used, including JOINs and subqueries
            const queriesData = [];
            
            // Build map of queries to their BSC combinations based on which indexes they use
            const queryToBSCs = new Map(); // normalizedStatement -> Set of "bucket.scope.collection"
            
            if (indexQueryFlowData.connections) {
                indexQueryFlowData.connections.forEach((connection) => {
                    const queryStatement = connection.queryStatement;
                    const indexKey = connection.indexKey || connection.indexName;
                    
                    // Extract BSC from composite key: indexName::bucket.scope.collection
                    if (indexKey && indexKey.includes("::")) {
                        const bsc = indexKey.split("::")[1];
                        if (!queryToBSCs.has(queryStatement)) {
                            queryToBSCs.set(queryStatement, new Set());
                        }
                        queryToBSCs.get(queryStatement).add(bsc);
                    }
                });
            }
            
            // Now build queriesData from the connection-derived BSCs
            originalQueries.forEach(query => {
                const bscSet = queryToBSCs.get(query.normalizedStatement);
                
                // Debug JOINs
                const isJoin = query.statement && query.statement.toUpperCase().includes('JOIN');
                if (isJoin) {
                    const queryHash = hashQuery(query.statement);
                    console.log(`[JOIN DEBUG] Processing ${queryHash}`);
                    console.log(`[JOIN DEBUG] ${queryHash} found ${bscSet ? bscSet.size : 0} BSCs from connections:`, bscSet ? Array.from(bscSet).map(b => hashBSC(b)) : 'none');
                }
                
                if (!bscSet || bscSet.size === 0) {
                // Fallback: try to parse FROM clause if no connection data
                let statement = query.statement;
                if (!statement) return;
                   
                    // Remove comments and normalize whitespace
                    statement = statement
                        .replace(/--.*$/gm, "") // Remove line comments
                        .replace(/\/\*[\s\S]*?\*\//g, "") // Remove block comments
                        .replace(/\s+/g, " ") // Normalize whitespace
                        .trim();

                    // Handle PREPARE statements:
                    // Pattern 1: PREPARE name FROM actual_statement
                    // Pattern 2: PREPARE actual_statement (no name)
                    if (statement.match(/^PREPARE\s+/i)) {
                        // Try pattern with name: PREPARE name FROM statement
                        const namedPrepareMatch = statement.match(/^PREPARE\s+[a-zA-Z0-9_-]+\s+FROM\s+(.+)$/i);
                        if (namedPrepareMatch) {
                            statement = namedPrepareMatch[1].trim();
                        } else {
                            // Simple pattern: PREPARE statement (just strip PREPARE keyword)
                            statement = statement.replace(/^PREPARE\s+/i, '').trim();
                        }
                    }

                    let target = null;
                    let hasBackticks = false;
                    
                    // Define all DML/DQL statement keywords that precede the target keyspace
                    // MERGE INTO, UPSERT INTO, INSERT INTO, UPDATE, DELETE FROM, FROM
                    const statementKeyword = '(?:MERGE\\s+INTO|UPSERT\\s+INTO|INSERT\\s+INTO|UPDATE|DELETE\\s+FROM|FROM)';
                    
                    // Check for subqueries: FROM ( SELECT ... ) or INSERT INTO x (KEY, VALUE) (SELECT ...)
                    const subqueryCheck = statement.match(new RegExp(statementKeyword + '\\s*\\(', 'i'));
                    if (subqueryCheck) {
                        // Find all keyspace references that are NOT followed by (
                        const allTargets = [];
                        const regex = new RegExp(statementKeyword + '\\s+([^\\s(][^\\s]*)', 'gi');
                        let match;
                    while ((match = regex.exec(statement)) !== null) {
                        const possibleTarget = match[1].trim();
                        if (!possibleTarget.startsWith('(')) {
                                allTargets.push(possibleTarget);
                            }
                        }
                        if (allTargets.length > 0) {
                            target = allTargets[0].replace(/`/g, '');
                            hasBackticks = allTargets[0].includes('`');
                        }
                    }
                    
                    // If not subquery or couldn't extract, try normal patterns
                    if (!target) {
                        // Pattern 1: Mixed backticks - bucket.`scope`.`collection` (bucket not backticked)
                        const mixedBacktickMatch = statement.match(new RegExp(statementKeyword + '\\s+([a-zA-Z0-9_-]+)\\.`([^`]+)`\\.`([^`]+)`', 'i'));
                        if (mixedBacktickMatch) {
                            target = `${mixedBacktickMatch[1]}.${mixedBacktickMatch[2]}.${mixedBacktickMatch[3]}`;
                            hasBackticks = true;
                        } else {
                            // Pattern 2: Fully backticked - `bucket`.`scope`.`collection`
                            const fullBacktickMatch = statement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`\\.`([^`]+)`\\.`([^`]+)`', 'i'));
                            if (fullBacktickMatch) {
                                target = `${fullBacktickMatch[1]}.${fullBacktickMatch[2]}.${fullBacktickMatch[3]}`;
                                hasBackticks = true;
                            } else {
                                // Pattern 3: Two-part backticked - `bucket`.`scope`
                                const twoPartBacktickMatch = statement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`\\.`([^`]+)`', 'i'));
                                if (twoPartBacktickMatch) {
                                    target = `${twoPartBacktickMatch[1]}.${twoPartBacktickMatch[2]}`;
                                    hasBackticks = true;
                                } else {
                                    // Pattern 4: Single backticked - `bucket.scope.collection` or `bucket`
                                    const singleBacktickMatch = statement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`', 'i'));
                                    if (singleBacktickMatch) {
                                        target = singleBacktickMatch[1].trim();
                                        hasBackticks = true;
                                    } else {
                                        // Pattern 5: No backticks - bucket.scope.collection or bucket
                                        // Must account for optional aliases: UPDATE hotel h, MERGE INTO airport t
                                        // Syntax: keyspace-ref ( AS? alias )?
                                        // Stop keywords cover SELECT, DML, and JOIN/WHERE clauses:
                                        // - WHERE, JOIN, LET, NEST, UNNEST, GROUP, ORDER, LIMIT (SELECT clauses)
                                        // - USE KEYS (UPDATE with specific keys)
                                        // - USING (MERGE source clause)
                                        // - SET (UPDATE assignments)
                                        // - VALUES (INSERT/UPSERT values)
                                        // - KEY (INSERT/UPSERT key specification)
                                        // - ON (JOIN/MERGE conditions)
                                        // - AS (aliases)
                                        // - RETURNING (DML output)
                                        // - WHEN (MERGE conditions)
                                        const stopKeywords = '(?:WHERE|JOIN|USE\\s+(?:KEYS|INDEX)|USING|LET|NEST|UNNEST|GROUP|ORDER|LIMIT|ON|AS|SET|VALUES|KEY|RETURNING|WHEN)';
                                        // Optional alias pattern: (?:\s+(?:AS\s+)?[a-zA-Z0-9_-]+)?
                                        // This allows: keyspace, keyspace AS alias, or keyspace alias
                                        const multiPartMatch = statement.match(new RegExp(statementKeyword + '\\s+([a-zA-Z0-9_-]+(?:\\.[a-zA-Z0-9_-]+)*)(?:\\s+(?:AS\\s+)?[a-zA-Z0-9_-]+)?(?:\\s+' + stopKeywords + '|;|\\s*$|\\s*\\()', 'i'));
                                        if (multiPartMatch) {
                                            target = multiPartMatch[1].trim();
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // If we have no valid target, log for debugging and skip
                    if (!target) {
                        console.warn(`[PARSE FAILED] Could not extract keyspace from query`);
                        console.warn(`[PARSE FAILED] Statement (SHA-256):`, hashQuery(statement));
                        console.warn(`[PARSE FAILED] Full statement:`, statement);
                        return;
                    }
                    
                    const parts = target.split(".").filter(p => p.length > 0);
                    let bucket, scope, collection;
                    
                    // Validate that parts look like real bucket names (not aliases)
                    const isValid = parts.every(p => /^[a-zA-Z0-9_-]+$/.test(p));
                    if (!isValid) {
                        console.warn(`[PARSE FAILED] Invalid keyspace parts (possible alias captured)`);
                        console.warn(`[PARSE FAILED] Extracted target:`, target);
                        console.warn(`[PARSE FAILED] Parts:`, parts);
                        console.warn(`[PARSE FAILED] Statement (SHA-256):`, hashQuery(statement));
                        console.warn(`[PARSE FAILED] Full statement:`, statement);
                        return;
                    }
                    
                    // Parse based on number of parts
                    if (parts.length === 1) {
                        // Single word bucket name (with or without backticks)
                        bucket = parts[0];
                        scope = "_default";
                        collection = "_default";
                    } else if (parts.length === 2) {
                        bucket = parts[0];
                        scope = parts[1];
                        collection = "_default";
                    } else if (parts.length >= 3) {
                        bucket = parts[0];
                        scope = parts[1];
                        collection = parts[2];
                    }
                    
                    // Log successful parsing
                    const parsedBSC = `${bucket}.${scope}.${collection}`;
                    console.log(`[PARSE SUCCESS] Extracted BSC: ${hashBSC(parsedBSC)} (${parsedBSC})`);
                    console.log(`[PARSE SUCCESS] From statement (SHA-256):`, hashQuery(statement));
                    
                    if (bucket && bucket.length > 0) {
                        queriesData.push({ bucket, scope, collection, query });
                    }
                } else {
                    // Use BSCs from connection data (covers JOINs, subqueries, etc.)
                    if (isJoin) {
                        console.log(`[JOIN DEBUG] ${hashQuery(query.statement)} using connection data`);
                    }
                    
                    bscSet.forEach(bscString => {
                        const parts = bscString.split(".");
                        if (parts.length === 3) {
                            if (isJoin) {
                                console.log(`[JOIN DEBUG] ${hashQuery(query.statement)} adding BSC to dropdown: ${hashBSC(bscString)}`);
                            }
                            queriesData.push({
                                bucket: parts[0],
                                scope: parts[1],
                                collection: parts[2],
                                query: query
                            });
                        }
                    });
                }
            });
            
            // Build cascading dropdown options based on current selections
            // Track counts for each bucket/scope/collection
            const bucketIndexCounts = new Map(); // bucket -> Set of index names
            const scopeIndexCounts = new Map(); // "bucket.scope" -> Set of index names
            const collectionIndexCounts = new Map(); // "bucket.scope.collection" -> Set of index names
            const relevantIndexes = new Set();
            
            // Build counts directly from originalIndexes to ensure all visible indexes are counted
            // Use composite keys to count each unique index+BSC combination
            originalIndexes.forEach(index => {
                const bsc = index.bucketScopeCollection || "unknown.unknown.unknown";
                const parts = bsc.split(".");
                const bucket = parts[0] || "unknown";
                const scope = parts[1] || "unknown";
                const collection = parts[2] || "unknown";
                
                // Use composite key to ensure each index+BSC combination is counted separately
                const compositeKey = `${index.name}::${bsc}`;
                
                // Count for bucket
                if (!bucketIndexCounts.has(bucket)) {
                    bucketIndexCounts.set(bucket, new Set());
                }
                bucketIndexCounts.get(bucket).add(compositeKey);
                
                // Count for scope
                const scopeKey = `${bucket}.${scope}`;
                if (!scopeIndexCounts.has(scopeKey)) {
                    scopeIndexCounts.set(scopeKey, new Set());
                }
                scopeIndexCounts.get(scopeKey).add(compositeKey);
                
                // Count for collection
                const collectionKey = `${bucket}.${scope}.${collection}`;
                if (!collectionIndexCounts.has(collectionKey)) {
                    collectionIndexCounts.set(collectionKey, new Set());
                }
                collectionIndexCounts.get(collectionKey).add(compositeKey);
            });
            
            // Build a map of which indexes are used by which queries
            const queryIndexMap = new Map(); // normalizedStatement -> Set of indexKeys
            if (indexQueryFlowData.connections) {
                indexQueryFlowData.connections.forEach((connection) => {
                    if (!queryIndexMap.has(connection.queryStatement)) {
                        queryIndexMap.set(connection.queryStatement, new Set());
                    }
                    queryIndexMap.get(connection.queryStatement).add(connection.indexKey || connection.indexName);
                });
            }
            
            queriesData.forEach(data => {
                // Get indexes for this query (contains composite keys like "indexName::bucket.scope.collection")
                const queryIndexes = queryIndexMap.get(data.query.normalizedStatement) || new Set();
                
                // Debug JOINs
                const isJoin = data.query.statement && data.query.statement.toUpperCase().includes('JOIN');
                if (isJoin && queryIndexes.size > 0) {
                    const currentBSC = `${data.bucket}.${data.scope}.${data.collection}`;
                    console.log(`[JOIN DEBUG] ${hashQuery(data.query.statement)} building counts for BSC: ${hashBSC(currentBSC)}`);
                    console.log(`[JOIN DEBUG] ${hashQuery(data.query.statement)} has ${queryIndexes.size} indexes:`, Array.from(queryIndexes).map(idx => hashCompositeKey(idx)));
                }
                
                // Add to relevant indexes based on current filter level
                if ((selectedBucket === "All" || data.bucket === selectedBucket) &&
                    (selectedScope === "All" || data.scope === selectedScope) &&
                    (selectedCollection === "All" || data.collection === selectedCollection)) {
                    queryIndexes.forEach(idx => {
                        const indexName = idx.includes("::") ? idx.split("::")[0] : idx;
                        relevantIndexes.add(indexName);
                    });
                }
            });
            
            // Extract unique values from the Maps
            const buckets = new Set(bucketIndexCounts.keys());
            const scopes = new Set();
            const collections = new Set();
            
            scopeIndexCounts.forEach((indexes, key) => {
                const parts = key.split(".");
                scopes.add(parts[1]); // Extract scope name
            });
            
            collectionIndexCounts.forEach((indexes, key) => {
                const parts = key.split(".");
                collections.add(parts[2]); // Extract collection name
            });
            
            // Calculate total indexes for "All" option - use un-deduped count (composite keys)
            // This counts index usage across all BSCs, not unique index names
            const totalIndexCount = originalIndexes.length;
            
            // Populate/rebuild bucket dropdown
            const currentBucketValue = bucketDropdown.value;
            bucketDropdown.innerHTML = `<option value="All">(All) (${totalIndexCount})</option>`;
            Array.from(buckets).sort().forEach(bucket => {
                // Get count from bucketIndexCounts (already contains unique index names)
                const count = (bucketIndexCounts.get(bucket) || new Set()).size;
                // Only show buckets that have at least one index
                if (count > 0) {
                    const option = document.createElement("option");
                    option.value = bucket;
                    option.textContent = `${bucket} (${count})`;
                    bucketDropdown.appendChild(option);
                }
            });
            bucketDropdown.value = selectedBucket;
            
            // Populate/rebuild scope dropdown (cascading from bucket)
            // Calculate total for scopes under current bucket
            let scopeAllCount;
            if (selectedBucket === "All") {
                // Show total indexes when no bucket filter
                scopeAllCount = totalIndexCount;
            } else {
                // Show indexes for selected bucket
                scopeAllCount = bucketIndexCounts.get(selectedBucket)?.size || 0;
            }
            scopeDropdown.innerHTML = `<option value="All">(All) (${scopeAllCount})</option>`;
            Array.from(scopes).sort().forEach(scope => {
                // Find the count for this scope under the selected bucket
                let count = 0;
                if (selectedBucket === "All") {
                    // Sum across all buckets for this scope
                    scopeIndexCounts.forEach((indexes, key) => {
                        if (key.endsWith("." + scope)) {
                            indexes.forEach(idx => count++);
                        }
                    });
                    // Deduplicate
                    const scopeSet = new Set();
                    scopeIndexCounts.forEach((indexes, key) => {
                        if (key.endsWith("." + scope)) {
                            indexes.forEach(idx => scopeSet.add(idx));
                        }
                    });
                    count = scopeSet.size;
                } else {
                    const scopeKey = `${selectedBucket}.${scope}`;
                    count = scopeIndexCounts.get(scopeKey)?.size || 0;
                }
                const option = document.createElement("option");
                option.value = scope;
                option.textContent = `${scope} (${count})`;
                scopeDropdown.appendChild(option);
            });
            // Reset scope to "All" if current selection is not available
            if (!scopes.has(selectedScope) && selectedScope !== "All") {
                selectedScope = "All";
            }
            scopeDropdown.value = selectedScope;
            
            // Populate/rebuild collection dropdown (cascading from bucket+scope)
            // Calculate total for collections under current bucket.scope
            let collectionAllCount;
            if (selectedBucket === "All" && selectedScope === "All") {
                // Show total indexes when no filters
                collectionAllCount = totalIndexCount;
            } else if (selectedBucket !== "All" && selectedScope === "All") {
                // Show indexes for selected bucket
                collectionAllCount = bucketIndexCounts.get(selectedBucket)?.size || 0;
            } else {
                // Show indexes for selected bucket.scope
                const scopeKey = `${selectedBucket}.${selectedScope}`;
                collectionAllCount = scopeIndexCounts.get(scopeKey)?.size || 0;
            }
            collectionDropdown.innerHTML = `<option value="All">(All) (${collectionAllCount})</option>`;
            Array.from(collections).sort().forEach(collection => {
                // Find the count for this collection under the selected bucket.scope
                let count = 0;
                const collectionSet = new Set();
                collectionIndexCounts.forEach((indexes, key) => {
                    const parts = key.split(".");
                    const keyBucket = parts[0];
                    const keyScope = parts[1];
                    const keyCollection = parts[2];
                    if ((selectedBucket === "All" || keyBucket === selectedBucket) &&
                        (selectedScope === "All" || keyScope === selectedScope) &&
                        keyCollection === collection) {
                        indexes.forEach(idx => collectionSet.add(idx));
                    }
                });
                count = collectionSet.size;
                const option = document.createElement("option");
                option.value = collection;
                option.textContent = `${collection} (${count})`;
                collectionDropdown.appendChild(option);
            });
            // Reset collection to "All" if current selection is not available
            if (!collections.has(selectedCollection) && selectedCollection !== "All") {
                selectedCollection = "All";
            }
            collectionDropdown.value = selectedCollection;
            
            // Populate/rebuild index dropdown (cascading from bucket+scope+collection)
            const indexesToShow = selectedBucket === "All" && selectedScope === "All" && selectedCollection === "All" 
                ? originalIndexes 
                : originalIndexes.filter(idx => {
                    // Check if index name is in relevant set
                    if (!relevantIndexes.has(idx.name)) return false;
                    
                    // Also check if the index's BSC matches the selected filters
                    if (!idx.bucketScopeCollection) return false;
                    const parts = idx.bucketScopeCollection.split(".");
                    if (parts.length !== 3) return false;
                    
                    const [bucket, scope, collection] = parts;
                    const bucketMatch = selectedBucket === "All" || bucket === selectedBucket;
                    const scopeMatch = selectedScope === "All" || scope === selectedScope;
                    const collectionMatch = selectedCollection === "All" || collection === selectedCollection;
                    
                    return bucketMatch && scopeMatch && collectionMatch;
                });
            
            // Sort indexes alphabetically by name
            const sortedIndexes = indexesToShow.slice().sort((a, b) => a.name.localeCompare(b.name));
            
            indexDropdown.innerHTML = `<option value="All">(All)</option>`;
            sortedIndexes.forEach(index => {
                const option = document.createElement("option");
                option.value = index.name;
                // Show index name with total usage (scanned count) using [] brackets
                option.textContent = `${index.name} [${index.totalUsage}]`;
                indexDropdown.appendChild(option);
            });
            // Reset index to "All" if current selection is not available
            if (selectedIndex !== "All" && !sortedIndexes.find(idx => idx.name === selectedIndex)) {
                selectedIndex = "All";
            }
            indexDropdown.value = selectedIndex;
            
            // Set up event listeners (use removeEventListener first to avoid duplicates)
            const bucketChangeHandler = function() {
                const newScope = scopeDropdown.value;
                const newCollection = collectionDropdown.value;
                renderIndexQueryFlow(originalIndexes, originalQueries, "All", this.value, "All", "All");
            };
            const scopeChangeHandler = function() {
                const newCollection = collectionDropdown.value;
                renderIndexQueryFlow(originalIndexes, originalQueries, "All", selectedBucket, this.value, "All");
            };
            const collectionChangeHandler = function() {
                renderIndexQueryFlow(originalIndexes, originalQueries, "All", selectedBucket, selectedScope, this.value);
            };
            const indexChangeHandler = function() {
                renderIndexQueryFlow(originalIndexes, originalQueries, this.value, selectedBucket, selectedScope, selectedCollection);
            };
            
            // Remove old listeners and add new ones
            bucketDropdown.removeEventListener("change", bucketDropdown._changeHandler);
            scopeDropdown.removeEventListener("change", scopeDropdown._changeHandler);
            collectionDropdown.removeEventListener("change", collectionDropdown._changeHandler);
            indexDropdown.removeEventListener("change", indexDropdown._changeHandler);
            
            bucketDropdown._changeHandler = bucketChangeHandler;
            scopeDropdown._changeHandler = scopeChangeHandler;
            collectionDropdown._changeHandler = collectionChangeHandler;
            indexDropdown._changeHandler = indexChangeHandler;
            
            bucketDropdown.addEventListener("change", bucketChangeHandler);
            scopeDropdown.addEventListener("change", scopeChangeHandler);
            collectionDropdown.addEventListener("change", collectionChangeHandler);
            indexDropdown.addEventListener("change", indexChangeHandler);
            
            // Issue #178: Filter indexes and queries based on selection
            let filteredIndexes = indexes;
            let filteredQueries = queries;
            
            // Filter by bucket/scope/collection
            if (selectedBucket !== "All" || selectedScope !== "All" || selectedCollection !== "All") {
                filteredQueries = queries.filter(query => {
                    let statement = query.statement;
                    if (!statement) return false;
                    
                    let target = null;
                    let hasBackticks = false;
                    
                    // Support both SELECT (FROM) and DML statements (DELETE, UPDATE, INSERT INTO, MERGE INTO, UPSERT INTO)
                    const statementKeyword = '(?:FROM|DELETE|UPDATE|INSERT\\s+INTO|MERGE\\s+INTO|UPSERT\\s+INTO)';
                    
                    // Try to match with individually backticked components: `bucket`.`scope`.`collection`
                    const individualBacktickMatch = statement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`\\.`([^`]+)`\\.`([^`]+)`', 'i'));
                    if (individualBacktickMatch) {
                        target = `${individualBacktickMatch[1]}.${individualBacktickMatch[2]}.${individualBacktickMatch[3]}`;
                        hasBackticks = true;
                    } else {
                        // Try two-part backticked: `bucket`.`scope`
                        const twoPartBacktickMatch = statement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`\\.`([^`]+)`', 'i'));
                        if (twoPartBacktickMatch) {
                            target = `${twoPartBacktickMatch[1]}.${twoPartBacktickMatch[2]}`;
                            hasBackticks = true;
                        } else {
                            // Try single backticked identifier: `bucket.scope.collection` or `bucket`
                            const singleBacktickMatch = statement.match(new RegExp(statementKeyword + '\\s+`([^`]+)`', 'i'));
                            if (singleBacktickMatch) {
                                target = singleBacktickMatch[1].trim();
                                hasBackticks = true;
                            } else {
                                // Try to match without backticks - can be multi-part OR single word if followed by keyword/end
                                // Added USING (for MERGE) and SET (for UPDATE) as stop keywords
                                const multiPartMatch = statement.match(new RegExp(statementKeyword + '\\s+([a-zA-Z0-9_-]+(?:\\.[a-zA-Z0-9_-]+)*)(?:\\s+(?:WHERE|JOIN|USE|USING|LET|NEST|UNNEST|GROUP|ORDER|LIMIT|ON|AS|SET|VALUES|KEY)|;|\\s*$)', 'i'));
                                if (multiPartMatch) {
                                    target = multiPartMatch[1].trim();
                                }
                            }
                        }
                    }
                    
                    if (!target) return false;
                    
                    const parts = target.split(".").filter(p => p.length > 0);
                    
                    const isValid = parts.every(p => /^[a-zA-Z0-9_-]+$/.test(p));
                    if (!isValid) return false;
                    
                    let bucket, scope, collection;
                    
                    if (parts.length === 1) {
                        // Single word bucket name (with or without backticks)
                        bucket = parts[0];
                        scope = "_default";
                        collection = "_default";
                    } else if (parts.length === 2) {
                        bucket = parts[0];
                        scope = parts[1];
                        collection = "_default";
                    } else if (parts.length >= 3) {
                        bucket = parts[0];
                        scope = parts[1];
                        collection = parts[2];
                    } else {
                        return false;
                    }
                    
                    const bucketMatch = selectedBucket === "All" || bucket === selectedBucket;
                    const scopeMatch = selectedScope === "All" || scope === selectedScope;
                    const collectionMatch = selectedCollection === "All" || collection === selectedCollection;
                    
                    return bucketMatch && scopeMatch && collectionMatch;
                });
                
                // Filter indexes to only show those connected to filtered queries
                const connectedIndexKeys = new Set();
                
                console.log(`[FILTER DEBUG] Number of filtered queries: ${filteredQueries.length}`);
                console.log(`[FILTER DEBUG] Total connections: ${indexQueryFlowData.connections ? indexQueryFlowData.connections.size : 0}`);
                
                filteredQueries.forEach(query => {
                    const isJoin = query.statement && query.statement.toUpperCase().includes('JOIN');
                    
                    if (indexQueryFlowData.connections) {
                        let connectionCount = 0;
                        let primaryConnectionFound = false;
                        indexQueryFlowData.connections.forEach((connection) => {
                            if (connection.queryStatement === query.normalizedStatement) {
                                const indexKey = connection.indexKey || `${connection.indexName}::${connection.bucketScopeCollection}`;
                                connectedIndexKeys.add(indexKey);
                                connectionCount++;
                                if (indexKey.includes("#primary")) {
                                    primaryConnectionFound = true;
                                }
                                
                                if (isJoin) {
                                    console.log(`[JOIN DEBUG] ${hashQuery(query.statement)} adding connected index to LEFT side: ${hashCompositeKey(indexKey)}`);
                                }
                            }
                        });
                        
                        if (isJoin) {
                            console.log(`[JOIN DEBUG] ${hashQuery(query.statement)} added ${connectionCount} indexes to connectedIndexKeys`);
                        }
                        if (primaryConnectionFound) {
                            console.log(`[FILTER DEBUG] Found #primary connection for query:`, query.statement.substring(0, 100));
                        }
                    }
                });
                
                console.log(`[FILTER DEBUG] Total connectedIndexKeys: ${connectedIndexKeys.size}`);
                
                filteredIndexes = indexes.filter(idx => {
                    const key = `${idx.name}::${idx.bucketScopeCollection}`;
                    const included = connectedIndexKeys.has(key);
                    
                    if (!included && idx.name === "#primary") {
                        console.warn(`[FILTER DEBUG] #primary excluded - key: ${key}, has BSC: ${idx.bucketScopeCollection}, connectedKeys:`, Array.from(connectedIndexKeys).filter(k => k.includes("#primary")));
                    }
                    
                    const isJoinIndex = Array.from(connectedIndexKeys).some(ck => {
                        const stmt = [...filteredQueries].find(q => {
                            return indexQueryFlowData.connections && Array.from(indexQueryFlowData.connections.values()).some(conn => 
                                conn.queryStatement === q.normalizedStatement && (conn.indexKey === ck || `${conn.indexName}::${conn.bucketScopeCollection}` === ck)
                            );
                        });
                        return stmt && stmt.statement && stmt.statement.toUpperCase().includes('JOIN');
                    });
                    
                    if (isJoinIndex && !included) {
                        console.log(`[JOIN DEBUG] FILTERED OUT index: ${hashCompositeKey(key)} (not in connectedIndexKeys)`);
                    }
                    
                    return included;
                });
                
                // Also filter queries to only show those that have connections to indexes
                filteredQueries = filteredQueries.filter(query => {
                    if (!indexQueryFlowData.connections) return false;
                    let hasConnection = false;
                    indexQueryFlowData.connections.forEach((connection) => {
                        const key = connection.indexKey || `${connection.indexName}::${connection.bucketScopeCollection}`;
                        if (connection.queryStatement === query.normalizedStatement && connectedIndexKeys.has(key)) {
                            hasConnection = true;
                        }
                    });
                    return hasConnection;
                });
            }
            
            // Filter by index name
            if (selectedIndex !== "All") {
                // Filter to show only selected index
                filteredIndexes = filteredIndexes.filter(idx => idx.name === selectedIndex);
                
                // Filter queries to show only those connected to this index
                filteredQueries = filteredQueries.filter(query => {
                    if (!indexQueryFlowData.connections) return false;
                    let hasConnection = false;
                    indexQueryFlowData.connections.forEach((connection) => {
                        if (connection.queryStatement === query.normalizedStatement && connection.indexName === selectedIndex) {
                            hasConnection = true;
                        }
                    });
                    return hasConnection;
                });
            }
            
            // Set dropdown values
            if (indexDropdown) indexDropdown.value = selectedIndex;
            if (bucketDropdown) bucketDropdown.value = selectedBucket;
            if (scopeDropdown) scopeDropdown.value = selectedScope;
            if (collectionDropdown) collectionDropdown.value = selectedCollection;

            // Update counts in summary
            const indexCountEl = document.getElementById("index-count");
            const queryCountEl = document.getElementById("query-count");
            if (indexCountEl) indexCountEl.textContent = filteredIndexes.length;
            if (queryCountEl) queryCountEl.textContent = filteredQueries.length;
            
            // Debug: Show final filtered indexes for JOINs
            const joinFilteredIndexes = filteredIndexes.filter(idx => {
                // Check if this index is used by any JOIN query
                if (!indexQueryFlowData.connections) return false;
                return Array.from(indexQueryFlowData.connections.values()).some(conn => {
                    const indexKey = conn.indexKey || `${conn.indexName}::${conn.bucketScopeCollection}`;
                    const idxKey = `${idx.name}::${idx.bucketScopeCollection}`;
                    if (indexKey === idxKey) {
                        const query = filteredQueries.find(q => q.normalizedStatement === conn.queryStatement);
                        return query && query.statement && query.statement.toUpperCase().includes('JOIN');
                    }
                    return false;
                });
            });
            console.log(`[FLOW DEBUG] Total indexes on LEFT side: ${filteredIndexes.length}`);
            console.log(`[FLOW DEBUG] JOIN-related indexes on LEFT (first 10):`, 
                joinFilteredIndexes.slice(0, 10).map(idx => `${hashCompositeKey(idx.name + '::' + idx.bucketScopeCollection)} (scanned: ${idx.totalUsage})`));

            // Clear container
            flowElements.innerHTML = "";

            if (filteredIndexes.length === 0) {
                flowElements.innerHTML =
                    '<div style="padding: 20px; text-align: center; color: #666; font-style: italic;">No index usage found in the queries.<br><br>This could mean:<br>‚Ä¢ Queries use sequential scans<br>‚Ä¢ Index information not in execution plans<br>‚Ä¢ All queries are prepared statements without index details</div>';
                return;
            }

            // Generate colors for indexes
            const colors = generateColors(filteredIndexes.length);

            // Calculate layout - indexes on left, queries on right
            const canvasWidth = flowElements.offsetWidth || 1200;
            const indexItemHeight = 164; // Issue #178: Index spacing (144 + 20px gap)
            const queryItemHeight = 193; // Issue #178: Query spacing (173 + 20px gap)
            const canvasHeight = Math.max(
                filteredIndexes.length * indexItemHeight,
                filteredQueries.length * queryItemHeight,
                400
            );

            // Set container height
            flowElements.style.height = canvasHeight + "px";

            // Position indexes on the left
            const indexPositions = [];
            filteredIndexes.forEach((index, i) => {
                const x = 50;
                const y = 20 + i * indexItemHeight; // Issue #178: 20px top padding
                // Pass current filter selections to createIndexDiv
                const indexDiv = createIndexDiv(index, colors[i], x, y, selectedBucket, selectedScope, selectedCollection);
                flowElements.appendChild(indexDiv);
                indexPositions.push({
                    element: indexDiv,
                    x: x + 150,
                    y: y + 40,
                    index: index,
                }); // right edge + center
            });

            // Position queries on the right
            const queryPositions = [];
            filteredQueries.forEach((query, queryIndex) => {
                const x = canvasWidth - 380;
                const y = 20 + queryIndex * queryItemHeight; // Issue #178: 20px top padding
                const queryDiv = createQueryDiv(query, queryIndex, x, y);
                flowElements.appendChild(queryDiv);
                queryPositions.push({
                    element: queryDiv,
                    x: x,
                    y: y + 40,
                    query: query,
                }); // left edge + center
            });

            // Draw connections after elements are positioned
            // Use multiple attempts with increasing delays to ensure layout is complete
            setTimeout(() => {
                drawSimpleConnections(indexPositions, queryPositions, colors);
            }, 100);

            // Additional redraw after longer delay to ensure correct positioning
            setTimeout(() => {
                redrawConnectionsAfterDrag();
            }, 300);
        }

        function createIndexDiv(index, color, x, y, selectedBucket = "All", selectedScope = "All", selectedCollection = "All") {
            const div = document.createElement("div");
            let className = "index-item";
            if (index.isPrimary) className += " primary";
            if (index.name === "#sequentialscan") className += " sequential-scan";

            div.className = className;
            div.style.borderColor = color;
            div.style.position = "absolute";
            div.style.left = x + "px";
            div.style.top = y + "px";
            div.style.width = "280px";
            div.style.margin = "0 0 20px 0"; // Issue #178: Keep bottom margin for spacing

            // Add orange background for sequential scan
            if (index.name === "#sequentialscan") {
                div.style.backgroundColor = "#fff3cd";
                div.style.borderColor = "#ff9800";
            }

            div.draggable = true;
            div.dataset.indexName = index.name;
            div.dataset.bsc = index.bucketScopeCollection || '';

            const stats = calculateIndexStats(index);

            // Check avg scan time for styling:
            // 2-10 seconds: USE KEYS color (orange) and bold
            // 10+ seconds: Red and bold
            const scanTimes = index.scanTimes || [];
            const avgScanTimeMs = scanTimes.length
                ? scanTimes.reduce((a, b) => a + b, 0) / scanTimes.length
                : 0;
            const avgScanTimeSeconds = avgScanTimeMs / 1000;
            let avgScanTimeStyle = "";
            if (avgScanTimeSeconds >= 10) {
                avgScanTimeStyle = "font-weight: bold; color: red;";
            } else if (avgScanTimeSeconds >= 2) {
                avgScanTimeStyle = "font-weight: bold; color: #ff9800;";
            }

            // Display bucket.scope.collection info (now each index is unique per BSC)
            const bscDisplay = index.bucketScopeCollection || '';
            
            div.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <div style="font-weight: bold; font-size: 14px; color: #333;">${index.name} | Scanned: ${index.totalUsage}</div>
              <div style="font-style: italic; font-size: 11px; color: #666; margin-top: 2px;">${bscDisplay}</div>
            </div>
            <button onclick="copyIndexName('${index.name.replace(
                    /'/g,
                    "\\'"
                )}', event)" class="btn-standard" style="font-size: 11px;">Copy</button>
          </div>
          <div class="index-stats" style="font-size: 13px; margin-top: 8px;">
            Avg Scan Time: <span style="${avgScanTimeStyle}">${stats.avgScanTime
                }</span><br>
            Avg Items Scanned: ${stats.avgItemsScanned}<br>
            Avg Items Fetched: ${stats.avgItemsFetched}<br>
            Min/Max Scan Time: ${stats.minScanTime} / ${stats.maxScanTime}<br>
            Min/Max Items: ${stats.minItems} / ${stats.maxItems}
          </div>
        `;

            makeDraggable(div);
            return div;
        }

        function createQueryDiv(query, queryIndex, x, y) {
            const div = document.createElement("div");
            div.className = "query-item";
            div.style.position = "absolute";
            div.style.left = x + "px";
            div.style.top = y + "px";
            div.style.width = "320px";
            div.style.minHeight = "160px"; // Issue #178: Fixed min height for uniform spacing
            div.style.margin = "0 0 20px 0"; // Issue #178: Keep bottom margin for spacing
            div.draggable = true;
            div.dataset.queryId = `query-${queryIndex}`;
            div.dataset.queryStatement = query.normalizedStatement;

            const avgDuration = query.totalDuration / query.count;
            const avgDurationSeconds = avgDuration / 1000;

            // Check for USE KEYS in the statement (excluding SQL comments)
            // Remove SQL line comments (-- ...) and block comments (/* ... */)
            const statementWithoutComments = query.statement
                .replace(/--[^\n]*/g, '') // Remove line comments
                .replace(/\/\*[\s\S]*?\*\//g, ''); // Remove block comments
            const hasUseKeys = statementWithoutComments.includes("USE KEYS");
            const useKeysIndicator = hasUseKeys
                ? ' <span style="color: orange; font-weight: bold;">(USE KEYS)</span>'
                : "";

            // Check if avg duration >= 60 seconds for red/bold styling
            const avgDurationStyle =
                avgDurationSeconds >= 60 ? "font-weight: bold; color: red;" : "";

            const badgesHTML = (Array.isArray(query.scanConsistencies) && query.scanConsistencies.length > 0)
                ? query.scanConsistencies.map((c) => {
                    const lc = String(c).toLowerCase();
                    let bg = '#6c757d';
                    if (lc === 'scan_plus') bg = '#28a745';
                    else if (lc === 'request_plus') bg = '#fd7e14';
                    return `<span class="consistency-badge" style="display:inline-block;margin-left:6px;background:${bg};color:#fff;padding:2px 6px;border-radius:8px;font-size:10px;font-weight:700;">${lc}</span>`;
                }).join('')
                : '';

            div.innerHTML = `
          <div style="font-weight: bold; font-size: 14px; color: #333;">Executions: ${query.count
                }${useKeysIndicator}${badgesHTML}</div>
          <div style="font-size: 12px; color: #666; margin: 4px 0;">Avg Duration: <span style="${avgDurationStyle}">${formatTime(
                    avgDuration
                )}</span></div>
          <div class="query-text" id="query-text-${query.normalizedStatement.replace(
                    /[^a-zA-Z0-9]/g,
                    ""
                )}">
            ${query.statement}
          </div>
          <div class="query-controls">
            <button onclick="toggleQueryText('${query.normalizedStatement.replace(
                    /[^a-zA-Z0-9]/g,
                    ""
                )}')" class="btn-standard">Show More</button>
            <button class="btn-standard query-copy-btn" data-query-statement="${encodeURIComponent(
                    query.statement
                )}">Copy</button>
          </div>
        `;

            // Add event listener for copy button
            const copyBtn = div.querySelector(".query-copy-btn");
            if (copyBtn) {
                copyBtn.addEventListener("click", function (e) {
                    e.stopPropagation(); // Prevent drag from starting
                    const statement = decodeURIComponent(this.dataset.queryStatement);
                    copyQueryText(statement, e);
                });
            }

            makeDraggable(div);
            return div;
        }

        function calculateIndexStats(index) {
            const scanTimes = index.scanTimes || [];
            const itemsScanned = index.itemsScanned || [];
            const itemsFetched = index.itemsFetched || [];

            return {
                avgScanTime: scanTimes.length
                    ? formatTime(
                        scanTimes.reduce((a, b) => a + b, 0) / scanTimes.length
                    )
                    : "N/A",
                minScanTime: scanTimes.length
                    ? formatTime(Math.min(...scanTimes))
                    : "N/A",
                maxScanTime: scanTimes.length
                    ? formatTime(Math.max(...scanTimes))
                    : "N/A",
                avgItemsScanned: itemsScanned.length
                    ? Math.round(
                        itemsScanned.reduce((a, b) => a + b, 0) / itemsScanned.length
                    ).toLocaleString()
                    : "N/A",
                avgItemsFetched: itemsFetched.length
                    ? Math.round(
                        itemsFetched.reduce((a, b) => a + b, 0) / itemsFetched.length
                    ).toLocaleString()
                    : "N/A",
                minItems: itemsScanned.length ? Math.min(...itemsScanned).toLocaleString() : "N/A",
                maxItems: itemsScanned.length ? Math.max(...itemsScanned).toLocaleString() : "N/A",
            };
        }

        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = ((i * 360) / count) % 360;
                colors.push(`hsl(${hue}, 70%, 50%)`);
            }
            return colors;
        }

        function drawSimpleConnections(indexPositions, queryPositions, colors) {
            const svg = document.getElementById("flow-svg");
            if (!svg) {
                console.error("SVG element not found");
                return;
            }

            svg.innerHTML = "";

            // Create maps for easy lookup using composite keys
            const indexMap = new Map();
            indexPositions.forEach((pos, i) => {
                const key = `${pos.index.name}::${pos.index.bucketScopeCollection}`;
                indexMap.set(key, { ...pos, color: colors[i] });
            });

            const queryMap = new Map();
            queryPositions.forEach((pos) => {
                queryMap.set(pos.query.normalizedStatement, pos);
            });

            let connectionsDrawn = 0;

            indexQueryFlowData.connections.forEach((connection) => {
                const indexKey = connection.indexKey || `${connection.indexName}::${connection.bucketScopeCollection}`;
                const indexPos = indexMap.get(indexKey);
                const queryPos = queryMap.get(connection.queryStatement);

                if (indexPos && queryPos) {
                    drawSimpleConnection(svg, indexPos, queryPos, connection.count);
                    connectionsDrawn++;
                }
            });
        }

        function drawSimpleConnection(svg, indexPos, queryPos, count) {
            const startX = indexPos.x;
            const startY = indexPos.y;
            const endX = queryPos.x;
            const endY = queryPos.y;

            // Calculate line thickness (scale between 2 and 12 pixels)
            const maxCount = Math.max(
                ...Array.from(indexQueryFlowData.connections.values()).map(
                    (c) => c.count
                )
            );
            const thickness = Math.max(
                2,
                Math.min(12, (count / maxCount) * 10 + 2)
            );

            // Create curved path instead of straight line
            const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
            );

            // Calculate control points for the curve
            const curveAmount = Math.abs(endX - startX) * 0.4; // Curve intensity based on distance

            // Create a smooth S-curve
            const d = `M ${startX} ${startY} C ${startX + curveAmount} ${startY}, ${endX - curveAmount
                } ${endY}, ${endX} ${endY}`;

            path.setAttribute("d", d);
            path.setAttribute("stroke", indexPos.color);
            path.setAttribute("stroke-width", thickness);
            path.setAttribute("opacity", "0.7");
            path.setAttribute("fill", "none");

            // Create usage count label
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;

            const rect = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
            );
            const text = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
            );

            text.setAttribute("x", midX);
            text.setAttribute("y", midY + 6);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("font-size", "17");
            text.setAttribute("font-weight", "bold");
            text.setAttribute("fill", "#333");
            text.textContent = count;

            // Estimate text dimensions (1.5x larger than original)
            const textWidth = count.toString().length * 11;
            rect.setAttribute("x", midX - textWidth / 2 - 5);
            rect.setAttribute("y", midY - 11);
            rect.setAttribute("width", textWidth + 10);
            rect.setAttribute("height", 22);
            rect.setAttribute("fill", "white");
            rect.setAttribute("stroke", "#333");
            rect.setAttribute("stroke-width", "1.5");
            rect.setAttribute("rx", "3");

            svg.appendChild(path);
            svg.appendChild(rect);
            svg.appendChild(text);
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            element.addEventListener("mousedown", function (e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // Get current position relative to the container, not viewport
                const container = document.getElementById("flow-elements");
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();

                startLeft = elementRect.left - containerRect.left;
                startTop = elementRect.top - containerRect.top;

                element.style.position = "absolute";
                element.style.zIndex = "1000";
                e.preventDefault();
            });

            document.addEventListener("mousemove", function (e) {
                if (!isDragging) return;
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                element.style.left = startLeft + deltaX + "px";
                element.style.top = startTop + deltaY + "px";

                // Redraw connections during drag for smooth following
                if (
                    document.getElementById("index-query-flow").style.display !== "none"
                ) {
                    redrawConnectionsAfterDrag();
                }
            });

            document.addEventListener("mouseup", function () {
                if (isDragging) {
                    isDragging = false;
                    element.style.zIndex = "";
                    // Redraw connections after drag
                    setTimeout(() => {
                        if (
                            document.getElementById("index-query-flow").style.display !==
                            "none"
                        ) {
                            redrawConnectionsAfterDrag();
                        }
                    }, 50);
                }
            });
        }

        function redrawConnectionsAfterDrag() {
            // Get current positions of all elements
            const indexElements = document.querySelectorAll("[data-index-name]");
            const queryElements = document.querySelectorAll("[data-query-id]");

            const indexPositions = [];
            const queryPositions = [];
            const colors = generateColors(indexElements.length);

            // Build current index positions
            indexElements.forEach((element, i) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document
                    .getElementById("flow-elements")
                    .getBoundingClientRect();
                const indexName = element.dataset.indexName;
                const bucketScopeCollection = element.dataset.bsc || '';

                // Create a minimal index object with name and BSC for composite key
                const indexObj = { 
                    name: indexName,
                    bucketScopeCollection: bucketScopeCollection
                };

                indexPositions.push({
                    element: element,
                    x: rect.right - containerRect.left, // right edge
                    y: rect.top - containerRect.top + rect.height / 2, // center
                    index: indexObj,
                });
            });

            // Build current query positions
            queryElements.forEach((element) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document
                    .getElementById("flow-elements")
                    .getBoundingClientRect();
                const queryStatement = element.dataset.queryStatement;

                // Create a minimal query object with just the normalized statement
                const queryObj = { normalizedStatement: queryStatement };

                queryPositions.push({
                    element: element,
                    x: rect.left - containerRect.left, // left edge
                    y: rect.top - containerRect.top + rect.height / 2, // center
                    query: queryObj,
                });
            });

            // Redraw connections with current positions
            drawSimpleConnections(indexPositions, queryPositions, colors);
        }

        function toggleQueryText(id) {
            const element = document.getElementById(`query-text-${id}`);
            const button = element.nextElementSibling.firstElementChild;

            if (element.classList.contains("expanded")) {
                element.classList.remove("expanded");
                button.textContent = "Show More";
            } else {
                element.classList.add("expanded");
                button.textContent = "Hide";
            }
        }

        function copyQueryText(text, event) {
            const button = event ? event.target : window.event.target;
            ClipboardUtils.copyToClipboard(text, button);
        }

        function copyIndexName(indexName, event) {
            ClipboardUtils.copyToClipboard(indexName, event.target);
        }

        // Copy to clipboard function for indexes and keys
        function copyToClipboard(text, event) {
            ClipboardUtils.copyToClipboard(text, event.target, {
                successColor: "#28a745"
            });
        }

        // Toggle USE KEYS visibility
        function toggleUseKeys() {
            const hiddenKeys = document.querySelectorAll(".hidden-key");
            const toggleBtn = document.getElementById("toggle-keys-btn");

            if (hiddenKeys.length > 0) {
                const isHidden = hiddenKeys[0].style.display === "none";

                if (isHidden) {
                    // Show hidden keys
                    hiddenKeys.forEach((key) => (key.style.display = "block"));
                    toggleBtn.textContent = "Hide Keys";
                } else {
                    // Hide keys
                    hiddenKeys.forEach((key) => (key.style.display = "none"));
                    toggleBtn.textContent = `Show ${hiddenKeys.length} More Keys`;
                }
            }
        }

        // Hook removed - buildIndexQueryFlow will be called directly after data processing

        // Version management
        const APP_VERSION = "4.0.0-dev";
const LAST_UPDATED = "2025-11-06";

        // Timezone management - initialize early to avoid undefined errors
        let detectedTimezone = "UTC"; // Timezone detected from data
        let currentTimezone = "UTC"; // Currently selected timezone (default to UTC)
        let timeZoneUserPicked = false; // Track if user manually selected a timezone

        // Vertical stake line for timeline charts (Issue #148)
        let verticalStakePosition = null; // Timestamp where the blue dotted line is staked

        // Detect timezone from requestTime string
        function detectTimezoneFromData(processData) {
            if (!processData || processData.length === 0) return "UTC";
            
            // Get first requestTime that exists
            for (let i = 0; i < Math.min(processData.length, 10); i++) {
                const item = processData[i];
                const request = item.completed_requests || item;
                if (request.requestTime) {
                    const requestTime = request.requestTime;
                    // Check for timezone offset (e.g., "2025-01-15T10:30:00-05:00" or "2025-01-15T10:30:00+00:00")
                    const offsetMatch = requestTime.match(/([+-]\d{2}:\d{2})$/);
                    if (offsetMatch) {
                        const offset = offsetMatch[1];
                        if (offset === "+00:00" || offset === "-00:00") {
                            return "UTC";
                        }
                        // Map common offsets to timezone names
                        const offsetToTimezone = {
                            "-10:00": "America/Honolulu",
                            "-09:00": "America/Anchorage",
                            "-08:00": "America/Los_Angeles",
                            "-07:00": "America/Denver",
                            "-06:00": "America/Chicago",
                            "-05:00": "America/New_York",
                            "-03:00": "America/Sao_Paulo",
                            "+00:00": "UTC",
                            "+01:00": "Europe/Paris",
                            "+02:00": "Europe/Athens",
                            "+03:00": "Europe/Moscow",
                            "+04:00": "Asia/Dubai",
                            "+05:30": "Asia/Kolkata",
                            "+06:00": "Asia/Dhaka",
                            "+07:00": "Asia/Bangkok",
                            "+08:00": "Asia/Shanghai",
                            "+09:00": "Asia/Tokyo",
                            "+09:30": "Australia/Adelaide",
                            "+10:00": "Australia/Sydney",
                            "+11:00": "Pacific/Guam",
                            "+12:00": "Pacific/Auckland"
                        };
                        return offsetToTimezone[offset] || "UTC";
                    }
                    // If no offset, assume UTC
                    return "UTC";
                }
            }
            return "UTC";
        }

        // Handle timezone change - called when user manually changes dropdown
        function handleTimezoneChange() {
            const timezoneSelector = document.getElementById("timezone-selector");
            if (!timezoneSelector) return;
            
            const oldTimezone = currentTimezone;
            currentTimezone = timezoneSelector.value;
            timeZoneUserPicked = true; // User manually picked a timezone
            
            Logger.info(`[handleTimezoneChange] Timezone changed from ${oldTimezone} to ${currentTimezone}`);
            
            // Clear timestamp rounding cache since timezone affects all date calculations
            timestampRoundingCache.clear();
            
            // Show reminder to re-parse data (timezone is a filter setting)
            if (originalRequests && originalRequests.length > 0) {
                showToast(TEXT_CONSTANTS.FILTERS_CHANGED_REMINDER, "warning");
            }
        }

        function getVersionInfo() {
            return {
                version: APP_VERSION,
                lastUpdated: LAST_UPDATED,
                features: [
                    "Global system query exclusion",
                    "Enhanced accessibility (ARIA)",
                    "Chart performance optimizations",
                    "Time range filtering with buffers",
                    "Index/Query Flow analysis",
                    "Toast notification system",
                ],
            };
        }

        // Initialize the application
        // Index Analysis Variables
        let indexData = [];
        let filteredIndexData = [];
        let usedIndexes = new Set(); // Store indexes found in query data

        // Calculate human-readable time difference
        function getTimeSince(dateString) {
            if (!dateString || dateString === "Never") return "";

            const now = new Date();
            const past = new Date(dateString);
            const diffMs = now - past;

            const minutes = Math.floor(diffMs / 60000);
            const hours = Math.floor(diffMs / 3600000);
            const days = Math.floor(diffMs / 86400000);
            const weeks = Math.floor(days / 7);
            const months = Math.floor(days / 30);
            const years = Math.floor(days / 365);

            if (years > 0) return `(${years} year${years > 1 ? "s" : ""} ago)`;
            if (months > 0) return `(${months} month${months > 1 ? "s" : ""} ago)`;
            if (weeks > 0) return `(${weeks} week${weeks > 1 ? "s" : ""} ago)`;
            if (days > 0) return `(${days} day${days > 1 ? "s" : ""} ago)`;
            if (hours > 0) return `(${hours} hour${hours > 1 ? "s" : ""} ago)`;
            if (minutes > 0)
                return `(${minutes} minute${minutes > 1 ? "s" : ""} ago)`;
            return "(just now)";
        }

        // Create state badge HTML
        function createStateBadge(state) {
            const stateClass =
                state === "online"
                    ? "state-online"
                    : state === "offline"
                        ? "state-offline"
                        : state === "building"
                            ? "state-building"
                            : "state-offline";
            return `<span class="state-badge ${stateClass}">${state || "unknown"
                }</span>`;
        }

        // Extract and store all indexes used in queries
        function extractUsedIndexes(requests) {
            usedIndexes.clear();

            let totalIndexReferences = 0;

            requests.forEach((request, index) => {
                // Handle different JSON structures
                let actualRequest = request;
                if (request.completed_requests) {
                    // User's format: { completed_requests: {...}, plan: "..." }
                    actualRequest = {
                        ...request.completed_requests,
                        plan: request.plan,
                    };
                } else {
                }

                if (actualRequest.plan) {
                }

                // Create a copy of the request with parsed plan
                const processedRequest = { ...actualRequest };

                // Parse the plan if it's a string
                if (typeof processedRequest.plan === "string") {
                    try {
                        processedRequest.plan = JSON.parse(processedRequest.plan);
                    } catch (e) {
                        console.warn(
                            `‚ö†Ô∏è Failed to parse plan JSON for request: ${processedRequest.clientContextID ||
                            processedRequest.requestId ||
                            "unknown"
                            }`,
                            e
                        );
                        return; // Skip this request if plan can't be parsed
                    }
                } else if (processedRequest.plan) {
                } else {
                    Logger.warn(`‚ö†Ô∏è No plan found in request`);
                    return;
                }

                const indexesAndKeys = extractIndexesAndKeys(processedRequest);

                // Get bucket.scope.collection from the statement
                const statement =
                    actualRequest.preparedText || actualRequest.statement || "";

                let bucketScopeCollection = "unknown.unknown.unknown";

                // Try to extract FROM clause to get bucket.scope.collection
                const fromMatch = statement.match(/FROM\s+([^\s\n\r\t]+)/i);
                if (fromMatch) {
                    const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                    const parts = target.split(".");
                    if (parts.length === 1) {
                        bucketScopeCollection = `${parts[0]}._default._default`;
                    } else if (parts.length === 2) {
                        bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                    } else if (parts.length >= 3) {
                        bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                    }
                }

                // Add each index with its bucket.scope.collection
                indexesAndKeys.indexes.forEach((indexName) => {
                    const indexKey = `${indexName}|${bucketScopeCollection}`;
                    usedIndexes.add(indexKey);
                    totalIndexReferences++;
                });
            });

            Logger.info(
                `‚úÖ Index extraction complete: ${usedIndexes.size} unique indexes, ${totalIndexReferences} total references`
            );
        }

        // Calculate and update index statistics
        function updateIndexStats() {
            const buckets = new Set();
            const scopes = new Set();
            const collections = new Set();
            let primaryCount = 0;
            let withReplicasCount = 0;
            let noReplicasCount = 0;
            let neverScannedCount = 0;
            let usedCount = 0;
            let mobileIndexCount = 0;

            filteredIndexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    buckets.add(target.bucket);
                    scopes.add(target.scope);
                    collections.add(target.collection);
                }

                // Check if primary
                if (
                    index.name.includes("primary") ||
                    index.name.includes("#primary")
                ) {
                    primaryCount++;
                }

                // Check replicas (skip FTS indexes)
                const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                if (idxType !== 'fts') {
                    const replica = index.metadata?.num_replica || 0;
                    if (replica > 0) {
                        withReplicasCount++;
                    } else {
                        noReplicasCount++;
                    }
                }

                // Check if never scanned (skip FTS indexes)
                const lastScan = index.metadata?.last_scan_time;
                const idxTypeForNever = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                if (idxTypeForNever !== 'fts') {
                    if (!lastScan || lastScan === "Never") {
                        neverScannedCount++;
                    }
                }

                // Check if used in queries
                const target = parseIndexTarget(index.indexString);
                const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");

                const exactKey = `${index.name}|${targetString}`;
                const primaryKey = `#primary|${targetString}`;

                if (
                    usedIndexes.has(exactKey) ||
                    (isPrimary && usedIndexes.has(primaryKey))
                ) {
                    usedCount++;
                }

                // Check if mobile/sync gateway index
                if (index.name.startsWith("sg_")) {
                    mobileIndexCount++;
                }
            });

            // Update stats display
            document.getElementById("stat-indexes").textContent =
                filteredIndexData.length;
            document.getElementById("stat-buckets").textContent = buckets.size;
            document.getElementById("stat-scopes").textContent = scopes.size;
            document.getElementById("stat-collections").textContent =
                collections.size;

            const primaryElement = document.getElementById("stat-primary");
            primaryElement.textContent = primaryCount;
            primaryElement.className = primaryCount > 0 ? "primary-warning" : "";

            const replicaInfoElement = document.getElementById("stat-replica-info");
            replicaInfoElement.innerHTML = `<span class="${noReplicasCount > 0 ? "replica-zero" : ""
                }">${noReplicasCount}</span>/${withReplicasCount}`;

            document.getElementById("stat-never-scanned").textContent =
                neverScannedCount;
            document.getElementById(
                "stat-used-total"
            ).textContent = `${usedCount}/${filteredIndexData.length}`;
            document.getElementById("stat-mobile-indexes").textContent =
                mobileIndexCount;
        }

        // Parse and process index JSON data
        function parseIndexJSON() {
            // Prefer uploaded file content (in-memory) over textarea to avoid DOM bloat
            const uploadedIndexRaw = (window._uploadedIndexesJsonRaw && typeof window._uploadedIndexesJsonRaw === 'string') ? window._uploadedIndexesJsonRaw.trim() : "";
            const indexTextAreaVal = (document.getElementById("indexJsonInput")?.value || "").trim();
            const sourceJson = uploadedIndexRaw || indexTextAreaVal;

            if (!sourceJson) {
                indexData = [];
                displayIndexResults();
                return;
            }

            try {
                const parsedData = JSON.parse(sourceJson);
                indexData = Array.isArray(parsedData) ? parsedData : [parsedData];

                // Extract unique buckets, scopes, collections
                updateFilterDropdowns();

                // Apply current filters and display
                applyIndexFilters();
            } catch (error) {
                document.getElementById("indexResults").innerHTML = `
                    <div class="text-align-center" style="color: #dc3545; margin-top: 50px;">
                        <strong>Invalid JSON Format</strong><br>
                        Please check your JSON syntax: ${error.message}
                    </div>
                `;
            }
        }

        // Extract bucket, scope, collection from indexString
        function parseIndexTarget(indexString) {
            const match = indexString.match(/\bON\s+([^\s(;]+)/i);
            if (!match)
                return { bucket: "unknown", scope: "unknown", collection: "unknown" };

            // Clean up the target string - remove backticks, leading dots, trailing semicolons
            let target = match[1]
                .replace(/`/g, "")
                .replace(/^\.+/, "")
                .replace(/;+$/, "");
            const parts = target.split(".").filter((part) => part.length > 0);

            if (parts.length === 1) {
                return {
                    bucket: parts[0],
                    scope: "_default",
                    collection: "_default",
                };
            } else if (parts.length === 2) {
                return { bucket: parts[0], scope: parts[1], collection: "_default" };
            } else if (parts.length >= 3) {
                return { bucket: parts[0], scope: parts[1], collection: parts[2] };
            }

            return {
                bucket: parts[0] || "unknown",
                scope: parts[1] || "unknown",
                collection: parts[2] || "unknown",
            };
        }

        // Update filter dropdowns with available options
        function updateFilterDropdowns() {
            const buckets = new Set();

            indexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    buckets.add(target.bucket);
                }
            });

            updateDropdown("bucketFilter", Array.from(buckets).sort());

            // Update scopes and collections based on selected filters
            updateCascadingDropdowns();
        }

        // Update scopes and collections based on selected bucket/scope
        function updateCascadingDropdowns() {
            const selectedBucket = document.getElementById("bucketFilter").value;
            const selectedScope = document.getElementById("scopeFilter").value;

            const scopes = new Set();
            const collections = new Set();

            indexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);

                    // If bucket is selected, only show scopes for that bucket
                    if (
                        selectedBucket === "(ALL)" ||
                        target.bucket === selectedBucket
                    ) {
                        scopes.add(target.scope);

                        // If scope is also selected, only show collections for that bucket.scope
                        if (selectedScope === "(ALL)" || target.scope === selectedScope) {
                            collections.add(target.collection);
                        }
                    }
                }
            });

            updateDropdown("scopeFilter", Array.from(scopes).sort());
            updateDropdown("collectionFilter", Array.from(collections).sort());
        }

        function updateDropdown(selectId, options) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;

            // Clear existing options except (ALL)
            select.innerHTML = '<option value="(ALL)">(ALL)</option>';

            // Add new options
            options.forEach((option) => {
                const optionElement = document.createElement("option");
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });

            // Restore previous selection if it still exists
            if (options.includes(currentValue)) {
                select.value = currentValue;
            }
        }

        // Apply current filter settings
        function applyIndexFilters() {
            const bucketFilter = document.getElementById("bucketFilter").value;
            const scopeFilter = document.getElementById("scopeFilter").value;
            const collectionFilter =
                document.getElementById("collectionFilter").value;
            const searchTerm =
                document.getElementById("indexSearch")?.value.toLowerCase().trim() ||
                "";
            const typeFilter = document.querySelector('input[name="indexTypeFilter"]:checked')?.value || 'all';

            // Get checkbox filter states
            const filterPrimary =
                document.getElementById("filter-primary")?.checked || false;
            const filterUsed =
                document.getElementById("filter-used")?.checked || false;
            const filterNoReplica =
                document.getElementById("filter-no-replica")?.checked || false;
            const filterNeverScanned =
                document.getElementById("filter-never-scanned")?.checked || false;
            const filterExcludeMobile =
                document.getElementById("filter-exclude-mobile")?.checked || false;

            filteredIndexData = indexData.filter((index) => {
                if (!index.indexString) return false;

                const target = parseIndexTarget(index.indexString);

                // Basic dropdown filters
                const passesDropdownFilters =
                    (bucketFilter === "(ALL)" || target.bucket === bucketFilter) &&
                    (scopeFilter === "(ALL)" || target.scope === scopeFilter) &&
                    (collectionFilter === "(ALL)" ||
                        target.collection === collectionFilter);

                if (!passesDropdownFilters) return false;

                // Search filter
                if (searchTerm) {
                    const indexName = index.name.toLowerCase();
                    const indexString = index.indexString?.toLowerCase() || "";
                    const matchesSearch =
                        indexName.includes(searchTerm) ||
                        indexString.includes(searchTerm);
                    if (!matchesSearch) return false;
                }

                // Type radio filter (All, GSI, FTS)
                if (typeFilter !== 'all') {
                    const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase()) || 'gsi';
                    if (typeFilter === 'gsi' && idxType !== 'gsi') return false;
                    if (typeFilter === 'fts' && idxType !== 'fts') return false;
                }

                // Checkbox filters
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");
                if (filterPrimary && !isPrimary) return false;

                // Check if used in queries
                if (filterUsed) {
                    const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                    const exactKey = `${index.name}|${targetString}`;
                    const primaryKey = `#primary|${targetString}`;
                    const isUsed =
                        usedIndexes.has(exactKey) ||
                        (isPrimary && usedIndexes.has(primaryKey));
                    if (!isUsed) return false;
                }

                // Check replicas (skip FTS indexes when filtering by no replica)
                if (filterNoReplica) {
                    const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                    if (idxType === 'fts') return false;
                    const replica = index.metadata?.num_replica || 0;
                    if (replica !== 0) return false;
                }

                // Check never scanned (skip FTS indexes)
                if (filterNeverScanned) {
                    const idxTypeNs = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                    if (idxTypeNs === 'fts') return false;
                    const lastScan = index.metadata?.last_scan_time;
                    if (lastScan && lastScan !== "Never") return false;
                }

                // Exclude Sync Gateway/Mobile indexes (sg_ prefixed)
                if (filterExcludeMobile) {
                    if (index.name.startsWith("sg_")) return false;
                }

                return true;
            });

            updateIndexStats();
            displayIndexResults();

            // Count and log matches
            let matchedCount = 0;
            filteredIndexData.forEach((index) => {
                const target = parseIndexTarget(index.indexString);
                const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");

                const exactKey = `${index.name}|${targetString}`;
                const primaryKey = `#primary|${targetString}`;

                if (
                    usedIndexes.has(exactKey) ||
                    (isPrimary && usedIndexes.has(primaryKey))
                ) {
                    matchedCount++;
                }
            });

            console.log(
                `üìä Matching summary: ${matchedCount}/${filteredIndexData.length} indexes found in query data`
            );
        }

        // Display filtered index results
        function displayIndexResults() {
            const resultsContainer = document.getElementById("indexResults");
            const sortBy = document.getElementById("sortBy").value;

            if (filteredIndexData.length === 0) {
                if (indexData.length === 0) {
                    // No index data loaded - show instructions
                    resultsContainer.innerHTML = `
                        <div class="text-align-center" style="margin-top: 30px;">
                            <h4 style="color: #495057; margin-bottom: 20px;">No Index Data Loaded</h4>
                            <p style="color: #666; margin-bottom: 20px;">
                                To analyze indexes, run this query in your Couchbase Query Workbench and paste the results in the second textarea above:
                            </p>
                            <div style="display: flex; justify-content: center;">
                                <div class="sql-query-box" style="text-align: left; max-width: fit-content;">
                                    <button class="btn-standard sql-copy-btn" onclick="copyIndexQuery(event)">Copy Query</button>
                                    <pre>SELECT 
    s.name,
    s.id,
    s.metadata,
    s.state,
    s.num_replica,
    s.\`using\` AS indexType,
    CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
FROM system:indexes AS s
LET bid = CONCAT("", s.bucket_id, ""),
    sid = CONCAT("", s.scope_id, ""),
    kid = CONCAT("", s.keyspace_id, ""),
    k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
    ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
    w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
    p = CASE WHEN s.\`partition\` IS NOT NULL THEN " PARTITION BY " || s.\`partition\` ELSE "" END;</pre>
                                </div>
                            </div>
                            <p style="color: #666; font-size: 13px; margin-top: 15px;">
                                <strong>Steps:</strong><br>
                                1. Copy the query above<br>
                                2. Run it in Couchbase Query Workbench<br>
                                3. Copy the JSON results<br>
                                4. Paste into the second textarea at the top<br>
                                5. Click "Parse JSON" again
                            </p>
                        </div>
                    `;
                } else {
                    // Index data loaded but filtered out
                    resultsContainer.innerHTML = `
                        <p style="color: #666; text-align: center; margin-top: 50px;">
                            No indexes match the current filters.
                        </p>
                    `;
                }
                return;
            }

            console.log(
                `üîÑ Displaying ${filteredIndexData.length} indexes and checking for query matches...`
            );

            let html = "";

            if (sortBy === "Bucket") {
                // Group by bucket
                const grouped = {};
                filteredIndexData.forEach((index) => {
                    const target = parseIndexTarget(index.indexString);
                    if (!grouped[target.bucket]) grouped[target.bucket] = [];
                    grouped[target.bucket].push(index);
                });

                Object.keys(grouped)
                    .sort()
                    .forEach((bucket) => {
                        html += `<div class="bucket-group">`;
                        html += `<h3 style="font-size: 24px;">${bucket}</h3>`;
                        grouped[bucket]
                            .sort((a, b) => a.name.localeCompare(b.name))
                            .forEach((index) => {
                                html += createIndexHTML(index);
                            });
                        html += `</div>`;
                    });
            } else if (sortBy === "LastScanned") {
                // Sort by last scanned time (newest first)
                const sorted = [...filteredIndexData].sort((a, b) => {
                    const aLastScan = a.metadata?.last_scan_time || 0;
                    const bLastScan = b.metadata?.last_scan_time || 0;

                    // Handle 'Never' scanned cases (put them at the end)
                    if (aLastScan === 0 && bLastScan === 0)
                        return a.name.localeCompare(b.name);
                    if (aLastScan === 0) return 1;
                    if (bLastScan === 0) return -1;

                    // Sort by timestamp (newest first)
                    return new Date(bLastScan) - new Date(aLastScan);
                });
                sorted.forEach((index) => {
                    html += createIndexHTML(index);
                });
            } else if (sortBy === "OldestScanned") {
                // Sort by oldest scanned time (oldest first, exclude never scanned)
                const sorted = [...filteredIndexData]
                    .filter((index) => {
                        const lastScan = index.metadata?.last_scan_time || 0;
                        return lastScan !== 0; // Exclude never scanned indexes
                    })
                    .sort((a, b) => {
                        const aLastScan = a.metadata?.last_scan_time;
                        const bLastScan = b.metadata?.last_scan_time;
                        // Sort by timestamp (oldest first)
                        return new Date(aLastScan) - new Date(bLastScan);
                    });
                sorted.forEach((index) => {
                    html += createIndexHTML(index);
                });
            } else {
                // Sort by name (default)
                const sorted = [...filteredIndexData].sort((a, b) =>
                    a.name.localeCompare(b.name)
                );
                sorted.forEach((index) => {
                    html += createIndexHTML(index);
                });
            }

            resultsContainer.innerHTML = html;
        }

        function createIndexHTML(index) {
            const target = parseIndexTarget(index.indexString);
            const isPrimary =
                index.name.includes("primary") || index.name.includes("#primary");
            const lastScan = index.metadata?.last_scan_time || "Never";
            const rawReplica = index.metadata?.num_replica;
            const state = index.state || "unknown";
            
            // Apply timezone conversion to lastScan
            let lastScanFormatted = "Never";
            if (lastScan !== "Never") {
                const convertedDate = getChartDate(lastScan);
                lastScanFormatted = convertedDate ? convertedDate.toLocaleString() : new Date(lastScan).toLocaleString();
            }
            
            const timeSince = getTimeSince(lastScan);
            const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase()) || 'gsi';
            const isFtsIndex = idxType === 'fts';
            const idxTypeLabel = isFtsIndex ? 'FTS' : 'GSI';
            const computedReplica = (rawReplica ?? 0);
            const replicaDisplay = isFtsIndex ? TEXT_CONSTANTS.N_A : computedReplica;
            const replicaClass = (!isFtsIndex && computedReplica === 0) ? "replica-zero" : "";
            const lastScanDisplay = isFtsIndex ? TEXT_CONSTANTS.N_A : lastScanFormatted;
            const timeSinceDisplay = isFtsIndex ? "" : timeSince;

            // Check if this index is used in the parsed query data
            const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
            let isUsed = false;

            // First try exact match
            const exactKey = `${index.name}|${targetString}`;
            if (usedIndexes.has(exactKey)) {
                isUsed = true;
                console.log(
                    `‚úÖ Exact match found: "${index.name}" on ${targetString}`
                );
            }

            // If not found and this is a primary index, also check for #primary match
            if (!isUsed && isPrimary) {
                const primaryKey = `#primary|${targetString}`;
                if (usedIndexes.has(primaryKey)) {
                    isUsed = true;
                    console.log(
                        `‚úÖ Primary match found: "${index.name}" matches "#primary" on ${targetString}`
                    );
                }
            }

            const usedBadge = isUsed ? '<span class="used-badge">Used</span>' : "";

            return `
                <div class="index-item ${isPrimary ? "primary" : ""}">
                    <h4>${index.name} ${usedBadge}</h4>
                    <div class="index-details">
                        <strong>Target:</strong> ${target.bucket}.${target.scope
                }.${target.collection}<br>
                        <strong>State:</strong> ${createStateBadge(
                    state
                )} | <strong>Type:</strong> ${idxTypeLabel} | <strong>Replicas:</strong> <span class="${replicaClass}">${replicaDisplay}</span> | <strong>Last Scan:</strong> ${lastScanDisplay} ${timeSinceDisplay}
                    </div>
                    <div class="index-statement">
                        ${index.indexString}
                        <button class="btn-standard copy-btn" onclick="copyIndexDefinition(this, event)" data-index-string="${index.indexString.replace(/"/g, '&quot;')}">Copy</button>
                    </div>
                </div>
            `;
        }

        // Copy index definition to clipboard
        function copyIndexDefinition(button, event) {
            const indexString = button.getAttribute('data-index-string');
            navigator.clipboard
                .writeText(indexString)
                .then(() => {
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.style.backgroundColor = "#28a745";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "#007bff";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy: ", err);
                });
        }

        // Copy index query to clipboard
        function copyIndexQuery(event) {
            const query = `SELECT 
            s.name,
            s.id,
            s.metadata,
            s.state,
            s.num_replica,
            s.\`using\` AS indexType,
            CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
            FROM system:indexes AS s
            LET bid = CONCAT("", s.bucket_id, ""),
            sid = CONCAT("", s.scope_id, ""),
            kid = CONCAT("", s.keyspace_id, ""),
            k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
            ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
            w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
                p = CASE WHEN s.\`partition\` IS NOT NULL THEN " PARTITION BY " || s.\`partition\` ELSE "" END
 ;`;

            navigator.clipboard
                .writeText(query)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.style.backgroundColor = "#28a745";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "#007bff";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy query: ", err);
                });
        }

        // Initialize index analysis functionality
        function initializeIndexAnalysis() {
            const indexJsonInput = document.getElementById("indexJsonInput");
            const bucketFilter = document.getElementById("bucketFilter");
            const scopeFilter = document.getElementById("scopeFilter");
            const collectionFilter = document.getElementById("collectionFilter");
            const sortBy = document.getElementById("sortBy");

            // Add event listeners
            if (indexJsonInput)
                indexJsonInput.addEventListener("input", parseIndexJSON);
            if (bucketFilter) {
                bucketFilter.addEventListener("change", () => {
                    // Reset scope and collection when bucket changes
                    document.getElementById("scopeFilter").value = "(ALL)";
                    document.getElementById("collectionFilter").value = "(ALL)";
                    updateCascadingDropdowns();
                    applyIndexFilters();
                });
            }
            if (scopeFilter) {
                scopeFilter.addEventListener("change", () => {
                    // Reset collection when scope changes
                    document.getElementById("collectionFilter").value = "(ALL)";
                    updateCascadingDropdowns();
                    applyIndexFilters();
                });
            }
            if (collectionFilter)
                collectionFilter.addEventListener("change", applyIndexFilters);
            if (sortBy) sortBy.addEventListener("change", applyIndexFilters);

            // Add search input event listener with debouncing
            const indexSearch = document.getElementById("indexSearch");
            if (indexSearch) {
                let searchTimeout;
                indexSearch.addEventListener("input", () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(applyIndexFilters, 300); // 300ms debounce
                });
            }

            // Add checkbox event listeners
            const filterCheckboxes = [
                "filter-primary",
                "filter-used",
                "filter-no-replica",
                "filter-never-scanned",
                "filter-exclude-mobile",
            ];

            // Radio buttons for type filter
            const typeRadios = [
                "filter-type-all",
                "filter-type-gsi",
                "filter-type-fts",
            ];
            typeRadios.forEach((id) => {
                const radio = document.getElementById(id);
                if (radio) {
                    radio.addEventListener("change", applyIndexFilters);
                }
            });

            filterCheckboxes.forEach((id) => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener("change", applyIndexFilters);
                }
            });

            Logger.info(TEXT_CONSTANTS.INDEX_ANALYSIS_INITIALIZED);
        }

        document.addEventListener("DOMContentLoaded", function () {
            Logger.info(TEXT_CONSTANTS.INITIALIZING_ANALYZER);
            Logger.info(`üì¶ Version: ${APP_VERSION} (Updated: ${LAST_UPDATED})`);
            Logger.info(`${TEXT_CONSTANTS.FEATURES}`, getVersionInfo().features.join(", "));

            // Log URL flags status
            const urlParams = new URLSearchParams(window.location.search);
            const flagsStatus = {
                dev: urlParams.get('dev') === 'true',
                debug: urlParams.get('debug') === 'true',
                logLevel: getLogLevel()
            };
            Logger.info(`‚öôÔ∏è URL Flags: dev=${flagsStatus.dev}, debug=${flagsStatus.debug}, logLevel=${flagsStatus.logLevel}`);

            // Initialize theme from localStorage
            
            // Show Schema Inference feature if dev mode is enabled
            if (isDevMode()) {
                const schemaTab = document.getElementById('schema-inference-tab');
                const schemaInput = document.getElementById('schema-input-section');
                if (schemaTab) schemaTab.style.display = '';
                if (schemaInput) schemaInput.style.display = '';
                Logger.info('üî¨ Schema Inference feature enabled (dev mode)');
            }

            // Defer keyboard navigation enhancement (Step 8 - not critical for initial load)
            setTimeout(() => enhanceKeyboardNavigation(), 1000);

            // Initialize tabs with enhanced accessibility
            $("#tabs").tabs({
                activate: function (event, ui) {
                    // Announce tab change to screen readers
                    const tabName = ui.newTab.find("a").text();
                    showToast(`${TEXT_CONSTANTS.SWITCHED_TO} ${tabName}`, "info");
                },
            });

            // Add event listener for system query exclusion checkbox
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            if (excludeCheckbox) {
                excludeCheckbox.addEventListener("change", function () {
                    console.log(`System query exclusion changed to: ${this.checked}`);
                    const jsonInput = document.getElementById("json-input").value;
                    if (jsonInput.trim()) {
                        showFilterReminder();
                    }
                });
            }

            // Add event listeners for date/time filter controls
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");
            const sqlFilterInput = document.getElementById("sql-statement-filter");
            const elapsedFilterInput = document.getElementById("elapsed-time-filter");

            if (startDateInput) {
                startDateInput.addEventListener("change", function () {
                    console.log(`Start date changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            if (endDateInput) {
                endDateInput.addEventListener("change", function () {
                    console.log(`End date changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            if (sqlFilterInput) {
                sqlFilterInput.addEventListener("input", function () {
                    console.log(`SQL filter changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            const collectionFilterInput = document.getElementById("collection-filter");
            if (collectionFilterInput) {
                collectionFilterInput.addEventListener("change", function () {
                    console.log(`Collection filter changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            if (elapsedFilterInput) {
                elapsedFilterInput.addEventListener("input", function () {
                    console.log(`Elapsed filter changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            Logger.info(TEXT_CONSTANTS.ANALYZER_INITIALIZED);

            // Setup JSON file upload handlers
            (function setupUploadInputs() {
                try {
                    const setButtonLabels = () => {
                        const btn1 = document.getElementById('upload-completed-btn');
                        const btn2 = document.getElementById('upload-indexes-btn');
                        const btn3 = document.getElementById('upload-schema-btn');
                        if (btn1) btn1.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.UPLOAD_JSON) || 'Upload .json';
                        if (btn2) btn2.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.UPLOAD_JSON) || 'Upload .json';
                        if (btn3) btn3.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.UPLOAD_JSON) || 'Upload .json';
                        const orTxt = (window.TEXT_CONSTANTS && (TEXT_CONSTANTS.OR_LABEL || 'OR')) || 'OR';
                        const or1 = document.getElementById('or-label-1');
                        const or2 = document.getElementById('or-label-2');
                        const or3 = document.getElementById('or-label-3');
                        if (or1) or1.textContent = orTxt;
                        if (or2) or2.textContent = orTxt;
                        if (or3) or3.textContent = orTxt;
                        const completedHeader = document.getElementById('completed-section-title');
                        const indexesHeader = document.getElementById('indexes-section-title');
                        if (completedHeader) completedHeader.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.COMPLETED_JSON_HEADER) || 'Completed Requests JSON (system:completed_requests)';
                        if (indexesHeader) indexesHeader.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.INDEXES_JSON_HEADER) || 'Indexes JSON (system:indexes output)';
                    };
                    setButtonLabels();

                    const jsonTextarea = document.getElementById('json-input');
                    const indexTextarea = document.getElementById('indexJsonInput');
                    const schemaTextarea = document.getElementById('schemaJsonInput');

                    const completedInput = document.getElementById('completed-requests-file');
                    const completedBtn = document.getElementById('upload-completed-btn');
                    const completedName = document.getElementById('completed-file-name');

                    const indexesInput = document.getElementById('indexes-file');
                    const indexesBtn = document.getElementById('upload-indexes-btn');
                    const indexesName = document.getElementById('indexes-file-name');

                    const schemaInput = document.getElementById('schema-file');
                    const schemaBtn = document.getElementById('upload-schema-btn');
                    const schemaName = document.getElementById('schema-file-name');

                    // In-memory upload buffers to avoid populating textareas
                    window._uploadedCompletedJsonRaw = window._uploadedCompletedJsonRaw || '';
                    window._uploadedIndexesJsonRaw = window._uploadedIndexesJsonRaw || '';
                    window._uploadedSchemaJsonRaw = window._uploadedSchemaJsonRaw || '';

                    const readJsonFile = (file, onLoad, onError) => {
                        if (!file) return;
                        const name = file.name || '';
                        if (!/\.json$/i.test(name)) {
                            showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.INVALID_FILE_TYPE) || 'Please select a .json file', 'warning');
                            return;
                        }
                        const reader = new FileReader();
                        reader.onload = () => { try { onLoad(reader.result); } catch (e) { /* no-op */ } };
                        reader.onerror = () => {
                            showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.FILE_READ_ERROR) || 'Error reading file', 'error');
                            if (typeof onError === 'function') onError();
                        };
                        reader.readAsText(file);
                    };

                    if (completedBtn && completedInput) {
                        completedBtn.addEventListener('click', () => completedInput.click());
                        completedInput.addEventListener('change', function () {
                            const file = this.files && this.files[0];
                            if (!file) return;
                            readJsonFile(
                                file,
                                (text) => {
                                    // Store uploaded JSON in memory; do NOT populate textarea to keep DOM light
                                    window._uploadedCompletedJsonRaw = text || '';
                                    if (completedName) completedName.textContent = file.name || '';
                                    // Auto-run parse on successful upload
                                    if (typeof parseJSON === 'function') {
                                        try { setTimeout(() => parseJSON(), 0); } catch (e) { /* no-op */ }
                                    }
                                },
                                () => {
                                    this.value = '';
                                    if (completedName) completedName.textContent = '';
                                }
                            );
                        });
                    }

                    if (indexesBtn && indexesInput) {
                        indexesBtn.addEventListener('click', () => indexesInput.click());
                        indexesInput.addEventListener('change', function () {
                            const file = this.files && this.files[0];
                            if (!file) return;
                            readJsonFile(
                                file,
                                (text) => {
                                    // Store uploaded JSON in memory; do NOT populate textarea to keep DOM light
                                    window._uploadedIndexesJsonRaw = text || '';
                                    // Parse immediately using in-memory data
                                    if (typeof parseIndexJSON === 'function') {
                                        try { parseIndexJSON(); } catch (e) { /* no-op */ }
                                    }
                                    if (indexesName) indexesName.textContent = file.name || '';
                                },
                                () => {
                                    this.value = '';
                                    if (indexesName) indexesName.textContent = '';
                                }
                            );
                        });
                    }

                    if (schemaBtn && schemaInput) {
                        schemaBtn.addEventListener('click', () => schemaInput.click());
                        schemaInput.addEventListener('change', function () {
                            const file = this.files && this.files[0];
                            if (!file) return;
                            readJsonFile(
                                file,
                                (text) => {
                                    // Store uploaded JSON in memory
                                    window._uploadedSchemaJsonRaw = text || '';
                                    // Auto-parse the schema
                                    if (typeof parseSchemaInference === 'function') {
                                        try { parseSchemaInference(); } catch (e) { /* no-op */ }
                                    }
                                    if (schemaName) schemaName.textContent = file.name || '';
                                    // Switch to Schema Inference tab
                                    const tabs = $('#tabs');
                                    if (tabs && tabs.tabs) {
                                        try { tabs.tabs('option', 'active', 6); } catch (e) { /* no-op */ }
                                    }
                                },
                                () => {
                                    this.value = '';
                                    if (schemaName) schemaName.textContent = '';
                                }
                            );
                        });
                    }

                    if (jsonTextarea) {
                        jsonTextarea.addEventListener('paste', () => {
                            const fi = completedInput;
                            if (fi && fi.value) {
                                fi.value = '';
                                if (completedName) completedName.textContent = '';
                            }
                            // Clear in-memory upload to give paste precedence
                            if (window._uploadedCompletedJsonRaw) {
                                window._uploadedCompletedJsonRaw = '';
                                showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.PASTE_OVERRIDES_UPLOAD) || 'Pasted JSON overrides uploaded file; cleared file selection', 'info');
                            }
                            // Auto-run parse after paste completes
                            if (typeof parseJSON === 'function') {
                                try { setTimeout(() => parseJSON(), 0); } catch (e) { /* no-op */ }
                            }
                        });
                    }
                    if (indexTextarea) {
                        indexTextarea.addEventListener('paste', () => {
                            const fi = indexesInput;
                            if (fi && fi.value) {
                                fi.value = '';
                                if (indexesName) indexesName.textContent = '';
                            }
                            // Clear in-memory upload to give paste precedence
                            if (window._uploadedIndexesJsonRaw) {
                                window._uploadedIndexesJsonRaw = '';
                                showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.PASTE_OVERRIDES_UPLOAD) || 'Pasted JSON overrides uploaded file; cleared file selection', 'info');
                            }
                            // Auto-run index parse after paste completes
                            if (typeof parseIndexJSON === 'function') {
                                try { setTimeout(() => parseIndexJSON(), 0); } catch (e) { /* no-op */ }
                            }
                        });
                    }
                    if (schemaTextarea) {
                        schemaTextarea.addEventListener('paste', () => {
                            const fi = schemaInput;
                            if (fi && fi.value) {
                                fi.value = '';
                                if (schemaName) schemaName.textContent = '';
                            }
                            // Clear in-memory upload to give paste precedence
                            if (window._uploadedSchemaJsonRaw) {
                                window._uploadedSchemaJsonRaw = '';
                                showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.PASTE_OVERRIDES_UPLOAD) || 'Pasted JSON overrides uploaded file; cleared file selection', 'info');
                            }
                            // Auto-parse after paste
                            setTimeout(() => {
                                if (typeof parseSchemaInference === 'function') {
                                    try { parseSchemaInference(); } catch (e) { /* no-op */ }
                                }
                            }, 50);
                        });
                    }
                } catch (e) { /* no-op */ }
            })();

            // Initialize index analysis
            initializeIndexAnalysis();

            // Make version info globally accessible
            window.QueryAnalyzer = {
                version: getVersionInfo,
                about: () => {
                    const info = getVersionInfo();
                    console.log(`
üîç Couchbase Query Analyzer v${info.version}
üìÖ Last Updated: 2025-10-20${info.lastUpdated}
üéØ Purpose: Analyze Couchbase N1QL query performance from system:completed_requests
                    
üöÄ Features:
${info.features.map((f) => `   ‚Ä¢ ${f}`).join("\n")}

üí° Usage: Type QueryAnalyzer.version() for version info
                    `);
                },
            };

            Logger.info(TEXT_CONSTANTS.TIP_ABOUT);
        });

        // =====================
        // Report Maker (Phase 1)
        // =====================
        let reportModeActive = false;
        let savedTimelineDisplay = null; // Map<Element, string> original inline display values
        function getReportSelections() {
            const sectionChecks = document.querySelectorAll('#report-sections input[type="checkbox"]');
            const sections = {};
            sectionChecks.forEach(chk => { sections[chk.getAttribute('data-section')] = chk.checked; });

            // Timeline charts from dynamic list
            const chartChecks = document.querySelectorAll('#report-timeline-charts input[type="checkbox"]');
            const timelineChartsSel = {};
            chartChecks.forEach(chk => { timelineChartsSel[chk.getAttribute('data-chart-id')] = chk.checked; });

            return {
                sections,
                options: {
                    includeHeader: !!document.getElementById('opt-include-header')?.checked,
                    includeFilters: !!document.getElementById('opt-include-filters')?.checked,
                    flattenTables: !!document.getElementById('opt-flatten-tables')?.checked,
                    chartsAsImages: !!document.getElementById('opt-charts-as-images')?.checked,
                },
                timelineCharts: timelineChartsSel,
            };
        }

        function populateReportMakerTimelineCharts() {
            const container = document.getElementById('report-timeline-charts');
            if (!container) return;
            container.innerHTML = '';
            const mapNames = {
                'duration-buckets': 'Duration Buckets',
                'query-types': 'Query Types',
                'operations': 'Operations',
                'filter': 'Filter Efficiency',
                'result-count': 'Result Count',
                'result-size': 'Result Size',
                'timeline': 'Timeline',
                'memory': 'Memory',
                'exec-vs-kernel': 'Exec vs Kernel',
                'exec-vs-serv': 'Exec vs Service',
                'exec-vs-elapsed': 'Exec vs Elapsed',
                'enhanced-operations': 'Enhanced Operations',
                'cpu-time': 'CPU Time'
            };
            // Default OFF list
            const defaultOff = new Set(['timeline','memory','exec-vs-kernel','exec-vs-serv','exec-vs-elapsed','cpu-time','enhanced-operations']);
            const cards = document.querySelectorAll('#timeline .chart-container');
            cards.forEach(card => {
                const id = card.getAttribute('data-chart-id') || card.querySelector('canvas')?.id || '';
                if (!id) return;
                const lbl = mapNames[id] || id;
                const checkedAttr = defaultOff.has(id) ? '' : 'checked';
                const label = document.createElement('label');
                label.innerHTML = `<input type=\"checkbox\" data-chart-id=\"${id}\" ${checkedAttr}> ${lbl}`;
                container.appendChild(label);
            });
        }

        function addReportHeader(summaryText) {
            let header = document.getElementById('report-header');
            if (!header) {
                header = document.createElement('div');
                header.id = 'report-header';
                document.body.insertBefore(header, document.body.firstChild);
            }
            // preserve existing exit button
            const existingBtn = header.querySelector('#report-exit-btn');
            const ver = (typeof getVersionInfo === 'function' ? getVersionInfo().version : '');
            const now = new Date().toLocaleString();
            header.innerHTML = `
              <h1>Couchbase Query Analyzer ${ver ? 'v' + ver : ''}</h1>
              <div class=\"meta\">${TEXT_CONSTANTS.REPORT_GENERATED_AT || 'Generated at'}: ${now}${summaryText ? ' ‚Ä¢ ' + summaryText : ''}</div>
            `;
            // ensure header is printable when summary is included
            header.classList.add('print-visible');
            if (existingBtn) header.appendChild(existingBtn);
        }

        function buildTabHighlights(selections) {
            const bullets = [];
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;

            // Dashboard
            if (selections.sections && selections.sections.dashboard) {
                try {
                    const list = Array.isArray(window.everyQueryData) ? window.everyQueryData : [];
                    const total = list.length;
                    const prim = list.filter(r => r["Primary Scan Used"] === 'Yes').length;
                    const fatal = list.filter(r => (r.state || '').toLowerCase() === 'fatal').length;
                    const stCounts = {};
                    list.forEach(r => { const k = (r.statementType || '').toString(); stCounts[k] = (stCounts[k]||0)+1; });
                    const topTypes = Object.entries(stCounts).sort((a,b)=>b[1]-a[1]).slice(0,3).map(([k,v])=>`${k} (${v})`).join(', ');
                    bullets.push(`<h4>Dashboard</h4><ul>
                        <li>Primary index usage: ${total?Math.round((prim/total)*100):0}% (${prim}/${total})</li>
                        <li>Fatal rate: ${total?Math.round((fatal/total)*100):0}% (${fatal}/${total})</li>
                        <li>Top statement types: ${topTypes || '-'}</li>
                    </ul>`);
                } catch(e){}
            }

            // Timeline
            if (selections.sections && selections.sections.timeline) {
                try {
                    const reqs = Array.isArray(window.originalRequests) ? window.originalRequests : [];
                    let minT, maxT; 
                    reqs.forEach(r => { const d = new Date(r.requestTime); if (!isNaN(d)) { if (!minT||d<minT) minT=d; if (!maxT||d>maxT) maxT=d; }});
                    const spanHrs = (minT&&maxT)? Math.round((maxT-minT)/(1000*60*60)) : 0;
                    const unit = reqs.length ? getOptimalTimeUnit(reqs) : 'minute';
                    bullets.push(`<h4>Timeline</h4><ul>
                        <li>Span: ${spanHrs} hours${spanHrs>=24?` (~${Math.round(spanHrs/24)} days)`:''}</li>
                        <li>Grouping: ${unit}</li>
                    </ul>`);
                } catch(e){}
            }

            // Query Groups
            if (selections.sections && selections.sections.analysis) {
                try {
                    const groups = Array.isArray(window.analysisData) ? window.analysisData : [];
                    const count = groups.length;
                    let slow = null;
                    groups.forEach(g => { const ref = g.groupRef; if (ref && !isNaN(ref.avg_duration_in_seconds)) { if (!slow || ref.avg_duration_in_seconds > slow.avg) slow = { avg: ref.avg_duration_in_seconds, stmt: ref.normalized_statement }; }});
                    bullets.push(`<h4>Query Groups</h4><ul>
                        <li>Total groups: ${count}</li>
                        <li>Slowest avg duration: ${slow ? formatTime(slow.avg*1000) : 'N/A'}</li>
                    </ul>`);
                } catch(e){}
            }

            // Every Query
            if (selections.sections && selections.sections["every-query"]) {
                try {
                    const list = Array.isArray(window.everyQueryData) ? window.everyQueryData : [];
                    let longest = null;
                    list.forEach(r => { const ms = parseTime(r.request?.elapsedTime || r.elapsedTime); if (!isNaN(ms)) { if (!longest || ms > longest.ms) longest = { ms, stmt: r.request?.statement || r.statement }; }});
                    bullets.push(`<h4>Every Query</h4><ul>
                        <li>Longest elapsed: ${longest ? formatTime(longest.ms) : 'N/A'}</li>
                    </ul>`);
                } catch(e){}
            }

            // Index/Query Flow
            if (selections.sections && selections.sections["index-query-flow"]) {
                bullets.push(`<h4>Index/Query Flow</h4><ul>
                    <li>Visual map of queries and indexes. Use this to spot overused primary scans and heavy fetch paths.</li>
                </ul>`);
            }

            // Indexes
            if (selections.sections && selections.sections.indexes) {
                try {
                    const ix = (document.getElementById('stat-indexes')||{}).textContent || '0';
                    const prim = (document.getElementById('stat-primary')||{}).textContent || '0';
                    const never = (document.getElementById('stat-never-scanned')||{}).textContent || '0';
                    bullets.push(`<h4>Indexes</h4><ul>
                        <li>Total indexes: ${ix}</li>
                        <li>Primary indexes: ${prim}</li>
                        <li>Never scanned: ${never}</li>
                    </ul>`);
                } catch(e){}
            }

            return bullets.join('');
        }

        function buildCoverDetailedSections(selections) {
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;
            let html = '';
            try {
                if (selections.sections && selections.sections.dashboard) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">üìä <span>Dashboard</span></h3>
                      <p class="muted">High-level overview with draggable charts showing query duration distribution, index type usage, scan consistency patterns, result size analysis, and system health metrics. Perfect for at-a-glance performance monitoring.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections.insights) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">üí° <span>Insights Tab</span></h3>
                      <p class="muted">The Insights tab provides automated analysis organized into three main categories, each with expandable insights and live metrics based on your parsed query data:</p>
                      <div class="cover-grid">
                        <div>
                          <h4>üìä Analysis Categories</h4>
                          <h5>üîç Index Performance Issues</h5>
                          <ul class="list-tight">
                            <li>Inefficient Index Scans - Identifies queries with poor selectivity ratios</li>
                            <li>Slow Index Scan Times - Flags indexes taking 2+ seconds to scan</li>
                            <li>Primary Index Over-Usage - Detects reliance on expensive primary indexes</li>
                            <li>ORDER BY / LIMIT / OFFSET Index Over-Scan - Highlights over-scanning due to pagination patterns <span class="badge beta">BETA</span></li>
                          </ul>
                          <h5>‚ö° Resource Utilization Issues</h5>
                          <ul class="list-tight">
                            <li>High Kernel Time in Queries - CPU scheduling overhead analysis</li>
                            <li>High Memory Usage Detected - Memory-intensive query identification</li>
                            <li>Slow Parse/Plan Times - Detects queries with parse/plan times > 1ms <span class="badge beta">BETA</span></li>
                            <li>Slow USE KEY Queries - KV service bottleneck detection</li>
                          </ul>
                        </div>
                        <div>
                          <h5>üîÑ Query Pattern Analysis</h5>
                          <ul class="list-tight">
                            <li>Missing WHERE Clauses - Identifies full collection scans</li>
                            <li>Inefficient LIKE Operations - Detects leading wildcard usage</li>
                            <li>SELECT * Usage - Finds queries returning entire documents <span class="badge live">LIVE</span></li>
                          </ul>
                          <h5>üöÄ Performance Optimization Opportunities</h5>
                          <ul class="list-tight">
                            <li>Large Payload Streaming - Identifies queries with heavy network usage</li>
                            <li>Large Result Set Queries - Flags memory and bandwidth intensive operations</li>
                            <li>Timeout-Prone Queries - Detects queries approaching timeout limits</li>
                          </ul>
                        </div>
                      </div>
                      <div class="callout" style="margin-top:10px;">
                        <strong>Live Data:</strong> Insights marked with <span class="badge live">LIVE</span> analyze your actual parsed data, while <span class="badge beta">BETA</span> insights are experimental and may show false positives.
                      </div>
                    </div>`;
                }
                if (selections.sections && selections.sections.timeline) {
                    // Build selected timeline charts list
                    const selectedCharts = Object.entries(selections.timelineCharts || {})
                        .filter(([, v]) => v)
                        .map(([k]) => k);
                    let chartsHtml = '<li>-</li>';
                    try {
                        if (selectedCharts.length) {
                            const container = document.getElementById('report-timeline-charts');
                            const items = [];
                            selectedCharts.forEach(id => {
                                let labelText = id;
                                const input = container ? container.querySelector(`input[data-chart-id="${id}"]`) : null;
                                const label = input ? input.closest('label') : null;
                                if (label) labelText = label.textContent.trim();
                                items.push(`<li>${labelText}</li>`);
                            });
                            chartsHtml = items.join('');
                        }
                    } catch (e) {}
                    html += `
                        <div class="section cover-card">
                          <h3 class="emoji-title">‚è∞ <span>Timeline</span></h3>
                          <p class="muted">Chronological analysis with zoomable time-series charts. Track query patterns by time grouping (seconds to days), analyze duration buckets, operation types, result counts, and memory usage trends over time with dual Y-axis support.</p>
                          <h4 style="margin-top:10px;">Timeline charts</h4>
                          <ul>${chartsHtml}</ul>
                        </div>
                    `;
                }
                if (selections.sections && selections.sections.analysis) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">üîç <span>Query Groups</span></h3>
                      <p class="muted">Analyze similar queries grouped by normalized patterns. Compare aggregated statistics, identify frequently executed query types, and optimize query families that share similar execution characteristics and performance profiles.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections['every-query']) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">üìã <span>Every Query</span></h3>
                      <p class="muted">Detailed tabular view of individual query executions with sorting, filtering, and search capabilities. Drill down into specific query metrics, execution plans, and performance details for granular analysis and debugging.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections['index-query-flow']) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">üåä <span>Index/Query Flow</span></h3>
                      <p class="muted">Interactive visual flow diagram showing the relationship between indexes and queries. See which indexes are used by which queries, identify index usage patterns, and optimize index coverage with drag-and-pan visualization.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections.indexes) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">üóÇÔ∏è <span>Indexes</span></h3>
                      <p class="muted">Comprehensive index management with filtering by bucket/scope/collection. Analyze index performance metrics, memory residency, scan times, and usage patterns. Includes search and sorting capabilities for large index inventories.</p>
                    </div>`;
                }
            } catch (e) { /* ignore */ }
            return html;
        }

        function buildReportCoverHTML(selections) {
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;
            const now = new Date().toLocaleString();
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            const sqlFilter = document.getElementById('sql-statement-filter');
            const timeRange = (startDateInput?.value && endDateInput?.value) ? `${startDateInput.value} ‚Üí ${endDateInput.value}` : '-';

            // Counts
            let total = 0, after = 0;
            try { total = Array.isArray(originalRequests) ? originalRequests.length : 0; } catch(e){}
            try { after = Array.isArray(filteredEveryQueryData) ? filteredEveryQueryData.length : (Array.isArray(everyQueryData) ? everyQueryData.length : 0); } catch(e){}

            return `
              <h1>${t('COVER_TITLE','Couchbase Query Analysis Report')}</h1>
              <div class="line">${t('REPORT_GENERATED_AT','Generated at')}: ${now}</div>
              <div class="line">${t('COVER_TIME_RANGE','Time range')}: ${timeRange}</div>
              <div class="line">${t('COVER_FILTERS_APPLIED','Filters applied')}: ${sqlFilter?.value || '-'}</div>
              <div class="line">${t('COVER_DATA_COUNTS','Data counts')}: ${after}${total ? ` ${t('OF_TOTAL','of')} ${total}` : ''}</div>
              ${buildCoverDetailedSections(selections)}
            `;
        }

        function toggleSectionsVisibility(selections) {
            const panels = document.querySelectorAll('[data-report-section]');
            panels.forEach(p => p.classList.remove('report-visible'));
            Object.keys(selections.sections).forEach(key => {
                if (selections.sections[key]) {
                    const el = document.querySelector(`[data-report-section=\"${key}\"]`);
                    if (el) el.classList.add('report-visible');
                }
            });

            // Within timeline, hide unselected chart containers
            const tlSel = selections.timelineCharts || {};
            document.querySelectorAll('#timeline .chart-container').forEach(c => {
                const id = c.getAttribute('data-chart-id');
                if (!id) return;
                c.style.display = (tlSel[id] === false) ? 'none' : '';
            });
        }

        function flattenScrollableAreas(enable) {
            const selectors = [
                '#table-section', '#analysis-table-section', '#table-container', '#analysis-table-container', '.table-scroll', '.overflow-auto'
            ];
            selectors.forEach(sel => {
                document.querySelectorAll(sel).forEach(el => {
                    if (enable) el.classList.add('print-unclamp'); else el.classList.remove('print-unclamp');
                });
            });
        }

        function replaceChartsWithImages(enable) {
            const selectedPanels = document.querySelectorAll('.report-visible');
            const canvases = [];
            selectedPanels.forEach(panel => {
                panel.querySelectorAll('canvas').forEach(cv => canvases.push(cv));
            });

            if (enable) {
                canvases.forEach(canvas => {
                    // Skip if already replaced
                    if (canvas.dataset.replaced === '1') return;
                    try {
                        const ratio = window.devicePixelRatio || 1;
                        const url = canvas.toDataURL('image/png');
                        const img = document.createElement('img');
                        img.className = 'chart-print-img';
                        img.src = url;
                        img.dataset.replaceId = canvas.id || '';
                        canvas.style.display = 'none';
                        canvas.dataset.replaced = '1';
                        canvas.parentElement.insertBefore(img, canvas.nextSibling);
                    } catch (e) { /* ignore */ }
                });
            } else {
                document.querySelectorAll('.chart-print-img').forEach(img => {
                    const canvasId = img.dataset.replaceId;
                    const canvas = canvasId ? document.getElementById(canvasId) : null;
                    if (canvas) {
                        canvas.style.display = '';
                        delete canvas.dataset.replaced;
                    }
                    img.remove();
                });
            }
        }

        function buildReportSummary() {
            const info = [];
            // Data counts if available
            try {
                if (Array.isArray(everyQueryData) && everyQueryData.length) {
                    info.push(`${TEXT_CONSTANTS.SHOWING_TOP || 'Showing top'} ${everyQueryData.length}`);
                }
            } catch (e) {}
            // Date range
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            if (startDateInput?.value && endDateInput?.value) {
                info.push(`${TEXT_CONSTANTS.REPORT_TIME_RANGE || 'Range'}: ${startDateInput.value} ‚Üí ${endDateInput.value}`);
            }
            // SQL++ statement filter
            const sqlFilter = document.getElementById('sql-statement-filter');
            if (sqlFilter?.value) {
                info.push(`${TEXT_CONSTANTS.REPORT_FILTERS_APPLIED || 'Filter'}: ${sqlFilter.value}`);
            }
            // Collection filter
            const collectionFilter = document.getElementById('collection-filter');
            if (collectionFilter?.value) {
                info.push(`${TEXT_CONSTANTS.REPORT_FILTERS_APPLIED || 'Filter'}: collection ${collectionFilter.value}`);
            }
            // Elapsed time filter
            const elapsedFilter = document.getElementById('elapsed-time-filter');
            if (elapsedFilter?.value) {
                info.push(`${TEXT_CONSTANTS.REPORT_FILTERS_APPLIED || 'Filter'}: elapsed ${elapsedFilter.value}`);
            }
            return info.join(' ‚Ä¢ ');
        }

        function enterReportMode() {
            populateReportMakerTimelineCharts();
            const selections = getReportSelections();
            document.body.classList.add('report-mode');
            reportModeActive = true;
            // Save original timeline chart container visibility
            savedTimelineDisplay = new Map();
            document.querySelectorAll('#timeline .chart-container').forEach(c => {
                savedTimelineDisplay.set(c, c.style.display);
            });
            // reset printable header state; will be enabled only if option selected
            const hdr = document.getElementById('report-header');
            if (hdr) hdr.classList.remove('print-visible');

            // Floating exit button
            let exitBtn = document.getElementById('report-exit-btn');
            if (!exitBtn) {
                exitBtn = document.createElement('button');
                exitBtn.id = 'report-exit-btn';
                exitBtn.className = 'report-exit-btn';
                exitBtn.textContent = (TEXT_CONSTANTS && TEXT_CONSTANTS.EXIT_REPORT_PREVIEW) || 'EXIT REPORT PREVIEW';
                exitBtn.addEventListener('click', exitReportMode);
                // append into report header (sticky)
                let header = document.getElementById('report-header');
                if (!header) {
                    header = document.createElement('div');
                    header.id = 'report-header';
                    document.body.insertBefore(header, document.body.firstChild);
                }
                header.appendChild(exitBtn);
            } else {
                exitBtn.style.display = 'inline-block';
            }

            // Cover page
            let cover = document.getElementById('report-cover');
            if (!cover) {
                cover = document.createElement('div');
                cover.id = 'report-cover';
                document.body.insertBefore(cover, document.body.firstChild);
            }
            cover.innerHTML = buildReportCoverHTML(selections);
            cover.style.display = 'block';

            // Cover already forces a page break in print via CSS (#report-cover { page-break-after: always })
            // Remove any legacy cover-break element to avoid blank page 2
            const legacyBrk = document.getElementById('report-cover-break');
            if (legacyBrk) legacyBrk.remove();

            toggleSectionsVisibility(selections);
            if (selections.options.includeHeader) addReportHeader(buildReportSummary());
            flattenScrollableAreas(selections.options.flattenTables);
            replaceChartsWithImages(selections.options.chartsAsImages);
        }

        function resetReportMakerDefaults() {
        // Sections default states
        const defaultSections = {
        'dashboard': true,
        'insights': true,
        'timeline': true,
        'analysis': true,
        'every-query': false,
        'index-query-flow': false,
        'indexes': false
        };
        document.querySelectorAll('#report-sections input[type="checkbox"]').forEach(chk => {
            const k = chk.getAttribute('data-section');
            if (k in defaultSections) chk.checked = !!defaultSections[k];
            });
            // Options default states
            const opt = {
                'opt-include-header': true,
                'opt-include-filters': true,
                'opt-flatten-tables': true,
                'opt-charts-as-images': true
            };
            Object.keys(opt).forEach(id => {
                const el = document.getElementById(id);
                if (el) el.checked = !!opt[id];
            });
            // Timeline charts list regenerated with default ON/OFF
            populateReportMakerTimelineCharts();
        }

        function exitReportMode() {
            reportModeActive = false;
            document.body.classList.remove('report-mode');
            // Restore
            replaceChartsWithImages(false);
            flattenScrollableAreas(false);
            const header = document.getElementById('report-header');
            if (header) { header.style.display = 'none'; header.classList.remove('print-visible'); }
            const cover = document.getElementById('report-cover');
            if (cover) cover.style.display = 'none';
            const legacyBrk = document.getElementById('report-cover-break');
            if (legacyBrk) legacyBrk.remove();
            const exitBtn = document.getElementById('report-exit-btn');
            if (exitBtn) exitBtn.style.display = 'none';
            // Re-show timeline charts to original visibility state
            if (savedTimelineDisplay instanceof Map) {
                document.querySelectorAll('#timeline .chart-container').forEach(c => {
                    const val = savedTimelineDisplay.get(c);
                    c.style.display = (typeof val === 'string') ? val : '';
                });
                savedTimelineDisplay = null;
            }
            // Trigger resize so charts recompute layout
            setTimeout(() => window.dispatchEvent(new Event('resize')), 0);
            // Reset checkboxes back to defaults
            resetReportMakerDefaults();
        }

        function setSearchControlsVisibility(hide) {
            ['analysis-search-controls', 'search-controls'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = hide ? 'none' : '';
            });
        }

        function addPageBreaksForSelectedPanels() {
            // Remove existing auto breaks (keep cover break)
            document.querySelectorAll('.page-break.auto').forEach(el => el.remove());
            const panels = Array.from(document.querySelectorAll('[data-report-section].report-visible'));
            panels.forEach((panel, idx) => {
                if (idx === 0) return;
                const br = document.createElement('div');
                br.className = 'page-break auto';
                panel.insertAdjacentElement('beforebegin', br);
            });
        }


        function printReport() {
            const selections = getReportSelections();
            if (!reportModeActive) {
                // Enter preview with current selections
                enterReportMode();
            } else {
                // Re-apply current selections to preview before printing
                toggleSectionsVisibility(selections);
                if (selections.options.includeHeader) {
                    addReportHeader(buildReportSummary());
                } else {
                    const header = document.getElementById('report-header');
                    if (header) { header.style.display = 'none'; header.classList.remove('print-visible'); }
                }
                flattenScrollableAreas(selections.options.flattenTables);
                replaceChartsWithImages(selections.options.chartsAsImages);
                const cover = document.getElementById('report-cover');
                if (cover) cover.innerHTML = buildReportCoverHTML(selections);
            }
            // Insert page breaks so each selected tab starts on a new page (after cover)
            addPageBreaksForSelectedPanels();
            // Hide non-printable UI just in case the browser ignores CSS
            setSearchControlsVisibility(true);
            // Restore after printing
            const restore = () => setSearchControlsVisibility(false);
            window.addEventListener('afterprint', restore, { once: true });
            // Allow layout to settle before printing
            setTimeout(() => window.print(), 100);
        }

        async function loadTestSample() {
            try {
                const res = await fetch('sample/test_system_completed_requests.json');
                const json = await res.text();
                const textarea = document.getElementById('json-input');
                textarea.value = json;
                parseJSON();
                showToast(TEXT_CONSTANTS.COPIED_CLIPBOARD || 'Loaded');
            } catch (e) {
                console.error('Failed to load sample JSON', e);
                showToast('Failed to load sample JSON', 'error');
            }
        }

        // Wire up Report Maker buttons on DOMContentLoaded
        // ============================================================
        // LAZY REPORT MAKER INITIALIZATION (Step 8)
        // Only initialize Report Maker when tab is first accessed
        // ============================================================
        let reportMakerInitialized = false;

        function initializeReportMaker() {
            if (reportMakerInitialized) return;
            reportMakerInitialized = true;
            
            console.log('üìÑ Initializing Report Maker (lazy load)');
            
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;

            const btnPreview = document.getElementById('btn-preview-report');
            const btnPrint = document.getElementById('btn-print-report');
            const btnExit = document.getElementById('btn-exit-report');
            if (btnPreview) btnPreview.addEventListener('click', enterReportMode);
            if (btnPrint) btnPrint.addEventListener('click', printReport);
            if (btnExit) btnExit.addEventListener('click', exitReportMode);

            // Set localized labels
            if (btnPreview) btnPreview.textContent = t('PREVIEW_REPORT', 'Preview Report');
            if (btnPrint) btnPrint.textContent = t('PRINT_SAVE_PDF', 'Print / Save PDF');
            if (btnExit) btnExit.textContent = t('EXIT_REPORT_MODE', 'Exit Report Mode');

            const hSections = document.getElementById('rm-select-sections-title');
            const hTimeline = document.getElementById('rm-select-timeline-title');
            const hOptions = document.getElementById('rm-options-title');
            if (hSections) hSections.textContent = t('SELECT_SECTIONS', 'Select sections');
            if (hTimeline) hTimeline.textContent = t('SELECT_TIMELINE_CHARTS', 'Select Timeline charts');
            if (hOptions) hOptions.textContent = t('REPORT_OPTIONS', 'Options');

            const lIncHead = document.getElementById('rm-opt-include-header');
            const lIncFilt = document.getElementById('rm-opt-include-filters');
            const lFlatTbl = document.getElementById('rm-opt-flatten-tables');
            const lChartsImg = document.getElementById('rm-opt-charts-as-images');
            if (lIncHead) lIncHead.textContent = t('INCLUDE_HEADER_SUMMARY', 'Include header summary');
            if (lIncFilt) lIncFilt.textContent = t('INCLUDE_FILTERS', 'Include filters applied');
            if (lFlatTbl) lFlatTbl.textContent = t('FLATTEN_TABLES_FOR_PRINT', 'Flatten scrollable tables for print');
            if (lChartsImg) lChartsImg.textContent = t('CONVERT_CHARTS_TO_IMAGES', 'Convert charts to images for printing');

            populateReportMakerTimelineCharts();
        }

        // Initialize essential UI on page load (Step 8)
        document.addEventListener('DOMContentLoaded', () => {
            // No dev-only charts to hide (all removed)
            
            // Setup lazy Report Maker initialization
            $('#tabs').on('tabsactivate', function(event, ui) {
                const tabId = ui.newPanel.attr('id');
                if (tabId === 'reports-history') {
                    initializeReportMaker();
                }
            });

            // Initialize input toggle tab (must run immediately, not deferred)
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;
            
            try {
                // Inject minimal CSS for the toggle tab
                const css = `
                .toggle-input-tab { position: fixed; left: 2px; top: 2px; z-index: 10001; color: #fff; border: 1px solid rgba(255,255,255,0.9); border-radius: 4px; width: auto; min-width: 165px; height: 32px; padding: 6px 12px; display: inline-flex; align-items: center; justify-content: center; font-size: 13px; font-weight: 700; line-height: 1; letter-spacing: 0; gap: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer; white-space: nowrap; }
                .toggle-input-tab::before { content: ''; position: absolute; top: -10px; left: -10px; right: -10px; bottom: -10px; }
                .toggle-input-tab.showing { background: #007bff; }
                .toggle-input-tab.showing:hover { background: #0056b3; }
                .toggle-input-tab.hidden { background: #28a745; }
                .toggle-input-tab.hidden:hover { background: #1e7e34; }
                #input-section { padding-top: 30px; }
                .toggle-input-tooltip { position: fixed; left: 35px; top: 5px; z-index: 10002; background: #343a40; color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 13px; font-weight: 600; white-space: nowrap; box-shadow: 0 4px 12px rgba(0,0,0,0.3); opacity: 0; pointer-events: none; transition: opacity 0.2s ease-in-out; display: none; }
                .toggle-input-tooltip.visible { opacity: 0; display: none; }
                .toggle-input-tooltip::before { content: ''; position: absolute; left: -6px; top: 50%; transform: translateY(-50%); border: 6px solid transparent; border-right-color: #343a40; }
                .help-fixed-badge { position: fixed; right: 6px; top: 6px; z-index: 9998; background: #f1f3f5; color: #343a40; border: 1px solid #dee2e6; border-radius: 14px; padding: 4px 10px; font-size: 11px; font-weight: 700; box-shadow: 0 1px 6px rgba(0,0,0,0.12); }
                .help-fixed-badge a { color: #007bff; text-decoration: none; }
                .help-fixed-badge a:hover { text-decoration: underline; }
                .queries-fixed-badge { position: fixed; top: 6px; left: 50%; transform: translateX(-50%); z-index: 9997; background: #f8f9fa; color: #343a40; border: 1px solid #dee2e6; border-radius: 14px; padding: 4px 12px; font-size: 11px; font-weight: 600; box-shadow: 0 1px 6px rgba(0,0,0,0.08); pointer-events: none; }
                @media print { .toggle-input-tab, .toggle-input-tooltip { display: none !important; } .help-fixed-badge, .queries-fixed-badge { display: none !important; } }
                /* Fade-up animation helpers for input panel */
                #input-section.input-anim { transition: opacity 320ms cubic-bezier(0.22, 1, 0.36, 1), transform 320ms cubic-bezier(0.22, 1, 0.36, 1); will-change: opacity, transform; }
                #input-section.fade-up-hidden { opacity: 0; transform: translateY(-12px); }
                `;
                const styleEl = document.createElement('style');
                styleEl.textContent = css;
                document.head.appendChild(styleEl);

                // Create the toggle tab if not present
                let tab = document.getElementById('toggle-input-tab');
                if (!tab) {
                    tab = document.createElement('button');
                    tab.id = 'toggle-input-tab';
                    tab.type = 'button';
                    tab.className = 'toggle-input-tab';
                    tab.setAttribute('aria-controls', 'input-section');
                    tab.setAttribute('aria-expanded', 'false');
                    tab.title = t('TOGGLE_INPUT_TOOLTIP', 'Click to Show/Hide Data & Filters');
                    tab.textContent = '‚ñº ' + t('SHOW_INPUT_PANEL', 'Show Data & Filters');
                    tab.addEventListener('click', toggleInputSection);
                    document.body.appendChild(tab);
                }
                
                // Create custom tooltip for toggle button
                let tooltip = document.getElementById('toggle-input-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'toggle-input-tooltip';
                    tooltip.className = 'toggle-input-tooltip';
                    tooltip.textContent = t('TOGGLE_INPUT_TOOLTIP', 'Click to Show/Hide Data & Filters');
                    document.body.appendChild(tooltip);
                }
                
                // Add hover handlers to show/hide custom tooltip
                tab.addEventListener('mouseenter', () => {
                    const tooltip = document.getElementById('toggle-input-tooltip');
                    if (tooltip) tooltip.classList.add('visible');
                });
                tab.addEventListener('mouseleave', () => {
                    const tooltip = document.getElementById('toggle-input-tooltip');
                    if (tooltip) tooltip.classList.remove('visible');
                });
                
                // Ensure initial label matches current state (input is visible at load)
                const hideLabel = t('HIDE_INPUT_PANEL', 'Hide Data & Filters');
                tab.textContent = '‚ñ≤ ' + hideLabel;
                tab.title = t('TOGGLE_INPUT_TOOLTIP', 'Click to Show/Hide Data & Filters');
                tab.setAttribute('aria-expanded', 'true');
                tab.classList.remove('hidden');
                tab.classList.add('showing');

                // Create fixed help badge (always visible top-right)
                let help = document.getElementById('help-fixed-badge');
                if (!help) {
                    help = document.createElement('div');
                    help.id = 'help-fixed-badge';
                    help.className = 'help-fixed-badge';
                    help.style.right = '280px';
                    const helpText = t('HELP_DEBUG_TIPS', 'NEED HELP? Debugging + Tool Tips ‚Äî Click Here');
                    help.innerHTML = `<a href="https://cb.fuj.io/analysis_hub#introduction" target="_blank" rel="noopener">${helpText}</a>`;
                    document.body.appendChild(help);
                }

                // Create fixed queries count badge (center top)
                let qbadge = document.getElementById('queries-fixed-badge');
                if (!qbadge) {
                    qbadge = document.createElement('div');
                    qbadge.id = 'queries-fixed-badge';
                    qbadge.className = 'queries-fixed-badge';
                    qbadge.innerHTML = 'Showing all <strong>0</strong> queries';
                    document.body.appendChild(qbadge);
                }
            } catch (e) {
                console.warn('Failed to initialize input toggle tab', e);
            }
        });
        // Chart Expand/Collapse Functionality (Issue #139)
        (function() {
            const overlay = document.getElementById('chart-fullscreen-overlay');
            const fullscreenCanvas = document.getElementById('fullscreen-chart-canvas');
            const collapseBtn = overlay.querySelector('.chart-collapse-btn');
            const resetZoomBtn = overlay.querySelector('.chart-reset-zoom-btn');
            let fullscreenChart = null;
            let originalChart = null;

            // Function to expand chart
            function expandChart(chartContainer) {
                const canvas = chartContainer.querySelector('canvas');
                if (!canvas || !canvas.id) return;

                // Get the original Chart.js instance
                originalChart = Chart.getChart(canvas);
                if (!originalChart) return;

                // Show overlay
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Clone chart configuration
                const config = {
                    type: originalChart.config.type,
                    data: JSON.parse(JSON.stringify(originalChart.config.data)),
                    options: JSON.parse(JSON.stringify(originalChart.config.options)),
                    plugins: originalChart.config.plugins || []
                };
                
                // Preserve tooltip callbacks (they don't survive JSON serialization)
                if (originalChart.config.options?.plugins?.tooltip?.callbacks) {
                    if (!config.options.plugins) config.options.plugins = {};
                    if (!config.options.plugins.tooltip) config.options.plugins.tooltip = {};
                    config.options.plugins.tooltip.callbacks = originalChart.config.options.plugins.tooltip.callbacks;
                }

                // Create fullscreen chart
                setTimeout(() => {
                    fullscreenChart = new Chart(fullscreenCanvas, config);
                }, 100);
            }

            // Function to collapse chart
            function collapseChart() {
                // Destroy fullscreen chart
                if (fullscreenChart) {
                    fullscreenChart.destroy();
                    fullscreenChart = null;
                }

                // Hide overlay
                overlay.classList.remove('active');
                document.body.style.overflow = '';
                originalChart = null;
            }

            // Function to reset zoom on fullscreen chart
            function resetZoom() {
                if (fullscreenChart) {
                    fullscreenChart.resetZoom();
                }
            }

            // Attach expand listeners to all expand buttons
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('chart-expand-btn')) {
                    const chartContainer = e.target.closest('.chart-container');
                    if (chartContainer) {
                        expandChart(chartContainer);
                    }
                }
            });

            // Collapse button click
            collapseBtn.addEventListener('click', collapseChart);

            // Reset zoom button click
            resetZoomBtn.addEventListener('click', resetZoom);

            // Close on overlay background click
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    collapseChart();
                }
            });

            // Close on Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && overlay.classList.contains('active')) {
                    collapseChart();
                }
            });
        })();

        // Schema Inference Tab Functions (Issue #212)
        let schemaDataStore = {}; // Store schema data by path for detail view
        
        function parseSchemaInference() {
            const inputTextarea = document.getElementById('schemaJsonInput');
            const input = (inputTextarea ? inputTextarea.value.trim() : '') || window._uploadedSchemaJsonRaw || '';
            const treeContainer = document.getElementById('schema-tree-container');
            const detailPanel = document.getElementById('schema-detail-panel');
            
            if (!input) {
                treeContainer.innerHTML = '<p style="color: #dc3545; font-size: 12px;">Please paste INFER query results in the top Schema Inference input box first.</p>';
                return;
            }
            
            try {
                const data = JSON.parse(input);
                
                if (!Array.isArray(data) || data.length === 0) {
                    treeContainer.innerHTML = '<p style="color: #dc3545; font-size: 12px;">Invalid format. Expected an array of INFER query results.</p>';
                    return;
                }
                
                // Build hierarchical tree structure
                const tree = {};
                schemaDataStore = {};
                
                data.forEach((sequence, idx) => {
                    const query = sequence._sequence_query || '';
                    const status = sequence._sequence_query_status || 'unknown';
                    const results = sequence._sequence_result || [];
                    
                    // Parse bucket.scope.collection from query
                    // Example: "INFER `travel-sample`._default._default" or "INFER bucket.scope.collection"
                    const inferMatch = query.match(/INFER\s+`?([^`\s]+)`?\.([^.\s]+)\.([^.\s;]+)/i);
                    if (!inferMatch) {
                        Logger.warn('Could not parse bucket.scope.collection from query:', query);
                        return;
                    }
                    
                    const bucket = inferMatch[1].replace(/`/g, '');
                    const scope = inferMatch[2];
                    const collection = inferMatch[3];
                    
                    // Initialize tree structure
                    if (!tree[bucket]) tree[bucket] = {};
                    if (!tree[bucket][scope]) tree[bucket][scope] = {};
                    if (!tree[bucket][scope][collection]) tree[bucket][scope][collection] = [];
                    
                    // Store schemas for this collection
                    if (results.length > 0 && results[0].length > 0) {
                        results[0].forEach((schema, schemaIdx) => {
                            const schemaId = `${bucket}.${scope}.${collection}.schema${schemaIdx}`;
                            const docCount = schema['#docs'] || 0;
                            const properties = schema.properties || {};
                            
                            tree[bucket][scope][collection].push({
                                id: schemaId,
                                name: `Schema ${schemaIdx + 1}`,
                                docCount: docCount,
                                propCount: Object.keys(properties).length,
                                status: status
                            });
                            
                            // Store full schema data
                            schemaDataStore[schemaId] = {
                                schema: schema,
                                bucket: bucket,
                                scope: scope,
                                collection: collection,
                                query: query,
                                status: status
                            };
                        });
                    }
                });
                
                // Render tree
                renderSchemaTree(tree, treeContainer);
                
                // Auto-select the first bucket
                const firstBucket = Object.keys(tree).sort()[0];
                if (firstBucket) {
                    setTimeout(() => {
                        const bucketId = `bucket-${firstBucket.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        selectBucket(firstBucket, bucketId);
                    }, 100);
                } else {
                    detailPanel.innerHTML = '<p style="color: #6c757d; text-align: center; margin-top: 50px;">Select a schema from the tree to view details</p>';
                }
                
                Logger.info(`Schema tree built: ${Object.keys(tree).length} buckets`);
                
            } catch (error) {
                treeContainer.innerHTML = `<p style="color: #dc3545; font-size: 12px;">Error parsing JSON: ${DOMPurify.sanitize(error.message)}</p>`;
                Logger.error('Schema inference parse error:', error);
            }
        }
        
        function renderSchemaTree(tree, container) {
            let html = '';
            
            Object.keys(tree).sort().forEach(bucket => {
            const bucketId = `bucket-${bucket.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const scopes = tree[bucket];
            const scopeCount = Object.keys(scopes).length;
            
            html += `<div class="schema-tree-node">`;
            html += `<div class="schema-tree-item" onclick="event.stopPropagation(); toggleSchemaNode('${bucketId}')">`;
            html += `<span class="schema-tree-toggle" id="${bucketId}-toggle">‚ñ∂</span>`;
            html += `<span class="schema-tree-icon" onclick="event.stopPropagation(); selectBucket('${DOMPurify.sanitize(bucket)}', '${bucketId}')" style="cursor: pointer;" title="Click to view aggregate analysis">üì¶</span>`;
            html += `<span onclick="event.stopPropagation(); selectBucket('${DOMPurify.sanitize(bucket)}', '${bucketId}')" style="cursor: pointer;">${DOMPurify.sanitize(bucket)}</span>`;
            html += `<span class="schema-badge">${scopeCount} scope${scopeCount !== 1 ? 's' : ''}</span>`;
            html += `</div>`;
                html += `<div class="schema-tree-children collapsed" id="${bucketId}-children">`;
                
                Object.keys(scopes).sort().forEach(scope => {
                    const scopeId = `scope-${bucket}-${scope}`.replace(/[^a-zA-Z0-9-]/g, '-');
                    const collections = scopes[scope];
                    const collCount = Object.keys(collections).length;
                    
                    html += `<div class="schema-tree-node">`;
                    html += `<div class="schema-tree-item" onclick="event.stopPropagation(); toggleSchemaNode('${scopeId}')">`;
                    html += `<span class="schema-tree-toggle" id="${scopeId}-toggle">‚ñ∂</span>`;
                    html += `<span class="schema-tree-icon" onclick="event.stopPropagation(); selectScope('${DOMPurify.sanitize(bucket)}', '${DOMPurify.sanitize(scope)}', '${scopeId}')" style="cursor: pointer;" title="Click to view aggregate analysis">üìÅ</span>`;
                    html += `<span onclick="event.stopPropagation(); selectScope('${DOMPurify.sanitize(bucket)}', '${DOMPurify.sanitize(scope)}', '${scopeId}')" style="cursor: pointer;">${DOMPurify.sanitize(scope)}</span>`;
                    html += `<span class="schema-badge">${collCount} coll${collCount !== 1 ? 's' : ''}</span>`;
                    html += `</div>`;
                    html += `<div class="schema-tree-children collapsed" id="${scopeId}-children">`;
                    
                    Object.keys(collections).sort().forEach(collection => {
                        const collId = `coll-${bucket}-${scope}-${collection}`.replace(/[^a-zA-Z0-9-]/g, '-');
                        const schemas = collections[collection];
                        
                        html += `<div class="schema-tree-node">`;
                        html += `<div class="schema-tree-item" onclick="event.stopPropagation(); toggleSchemaNode('${collId}')">`;
                        html += `<span class="schema-tree-toggle" id="${collId}-toggle">‚ñ∂</span>`;
                        html += `<span class="schema-tree-icon" onclick="event.stopPropagation(); selectCollection('${DOMPurify.sanitize(bucket)}', '${DOMPurify.sanitize(scope)}', '${DOMPurify.sanitize(collection)}', '${collId}')" style="cursor: pointer;" title="Click to view aggregate analysis">üìÑ</span>`;
                        html += `<span onclick="event.stopPropagation(); selectCollection('${DOMPurify.sanitize(bucket)}', '${DOMPurify.sanitize(scope)}', '${DOMPurify.sanitize(collection)}', '${collId}')" style="cursor: pointer;">${DOMPurify.sanitize(collection)}</span>`;
                        html += `<span class="schema-badge">${schemas.length} schema${schemas.length !== 1 ? 's' : ''}</span>`;
                        html += `</div>`;
                        html += `<div class="schema-tree-children collapsed" id="${collId}-children">`;
                        
                        schemas.forEach(schema => {
                            const schemaEscId = schema.id.replace(/[^a-zA-Z0-9-]/g, '-');
                            html += `<div class="schema-tree-item" onclick="selectSchema('${DOMPurify.sanitize(schema.id)}', '${schemaEscId}')" id="item-${schemaEscId}">`;
                            html += `<span class="schema-tree-icon">üî∑</span>`;
                            html += `<span>${DOMPurify.sanitize(schema.name)}</span>`;
                            html += `<span class="schema-badge">${schema.docCount} docs</span>`;
                            html += `</div>`;
                        });
                        
                        html += `</div></div>`;
                    });
                    
                    html += `</div></div>`;
                });
                
                html += `</div></div>`;
            });
            
            container.innerHTML = html || '<p style="color: #6c757d; font-size: 12px;">No schema data available</p>';
        }
        
        function toggleSchemaNode(nodeId) {
            const children = document.getElementById(`${nodeId}-children`);
            const toggle = document.getElementById(`${nodeId}-toggle`);
            if (children && toggle) {
                if (children.classList.contains('collapsed')) {
                    children.classList.remove('collapsed');
                    toggle.textContent = '‚ñº';
                } else {
                    children.classList.add('collapsed');
                    toggle.textContent = '‚ñ∂';
                }
            }
        }
        
        function selectBucket(bucket, bucketId) {
            // Remove previous selection
            document.querySelectorAll('.schema-tree-item.selected').forEach(el => el.classList.remove('selected'));
            
            // Get all schemas in this bucket
            const schemas = [];
            Object.keys(schemaDataStore).forEach(schemaId => {
                const data = schemaDataStore[schemaId];
                if (data.bucket === bucket) {
                    schemas.push(data);
                }
            });
            
            displayAggregateAnalysis('Bucket', bucket, schemas, bucketId);
        }
        
        function selectScope(bucket, scope, scopeId) {
            // Remove previous selection
            document.querySelectorAll('.schema-tree-item.selected').forEach(el => el.classList.remove('selected'));
            
            // Get all schemas in this scope
            const schemas = [];
            Object.keys(schemaDataStore).forEach(schemaId => {
                const data = schemaDataStore[schemaId];
                if (data.bucket === bucket && data.scope === scope) {
                    schemas.push(data);
                }
            });
            
            displayAggregateAnalysis('Scope', `${bucket}.${scope}`, schemas, scopeId);
        }
        
        function selectCollection(bucket, scope, collection, collId) {
            // Remove previous selection
            document.querySelectorAll('.schema-tree-item.selected').forEach(el => el.classList.remove('selected'));
            
            // Get all schemas in this collection
            const schemas = [];
            Object.keys(schemaDataStore).forEach(schemaId => {
                const data = schemaDataStore[schemaId];
                if (data.bucket === bucket && data.scope === scope && data.collection === collection) {
                    schemas.push(data);
                }
            });
            
            displayAggregateAnalysis('Collection', `${bucket}.${scope}.${collection}`, schemas, collId);
        }
        
        function displayAggregateAnalysis(level, name, schemas, escapedId) {
            const detailPanel = document.getElementById('schema-detail-panel');
            
            if (schemas.length === 0) {
                detailPanel.innerHTML = '<p style="color: #6c757d; text-align: center; margin-top: 50px;">No schemas found</p>';
                return;
            }
            
            // Aggregate all properties from all schemas
            const aggregatedProperties = {};
            let totalDocs = 0;
            
            schemas.forEach(schemaData => {
                const schema = schemaData.schema;
                const properties = schema.properties || {};
                totalDocs += schema['#docs'] || 0;
                
                Object.entries(properties).forEach(([propName, propData]) => {
                    if (!aggregatedProperties[propName]) {
                        aggregatedProperties[propName] = {
                            types: new Set(),
                            docCounts: [],
                            docPercents: [],
                            allData: []
                        };
                    }
                    
                    const types = Array.isArray(propData.type) ? propData.type : [propData.type];
                    types.forEach(t => aggregatedProperties[propName].types.add(t));
                    aggregatedProperties[propName].allData.push(propData);
                });
            });
            
            // Convert aggregated data to property format
            const properties = {};
            Object.entries(aggregatedProperties).forEach(([propName, data]) => {
                properties[propName] = {
                    type: Array.from(data.types),
                    '#docs': data.allData.map(d => Array.isArray(d['#docs']) ? d['#docs'] : [d['#docs']]).flat(),
                    '%docs': data.allData.map(d => Array.isArray(d['%docs']) ? d['%docs'] : [d['%docs']]).flat()
                };
            });
            
            // Analyze types
            const typeAnalysis = analyzeSchemaTypes(properties);
            
            let html = '';
            html += `<h3 style="margin-top: 0; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 8px;">
                      ${level}: ${DOMPurify.sanitize(name)}
                      <span style="font-size: 12px; color: #0066cc; background: #e7f3ff; 
                                   padding: 2px 8px; border-radius: 4px; font-weight: bold; margin-left: 8px;">
                        AGGREGATE VIEW
                      </span>
                    </h3>`;
            
            html += `<div style="background: #e7f3ff; padding: 12px; border-radius: 4px; margin-bottom: 15px; display: flex; gap: 20px;">`;
            html += `<div><strong>Total Documents:</strong> ${totalDocs}</div>`;
            html += `<div><strong>Schemas:</strong> ${schemas.length}</div>`;
            html += `<div><strong>Unique Properties:</strong> ${Object.keys(properties).length}</div>`;
            html += `</div>`;
            
            // Type Distribution and Inconsistencies Section
            html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">`;
            
            // Pie Chart
            html += `<div style="background: white; border: 1px solid #ddd; border-radius: 6px; padding: 15px;">`;
            html += `<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px;">Type Distribution</h4>`;
            html += `<div style="height: 250px; position: relative;">`;
            html += `<canvas id="schema-type-chart-${escapedId}"></canvas>`;
            html += `</div>`;
            html += `</div>`;
            
            // Inconsistencies
            html += `<div style="background: white; border: 1px solid #ddd; border-radius: 6px; padding: 15px;">`;
            html += `<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px;">Type Consistency</h4>`;
            if (typeAnalysis.inconsistentFields.length > 0) {
                html += `<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; border-radius: 4px; margin-bottom: 10px;">`;
                html += `<strong style="color: #856404;">‚ö†Ô∏è ${typeAnalysis.inconsistentFields.length} field(s) with mixed types</strong>`;
                html += `</div>`;
                html += `<div style="max-height: 200px; overflow-y: auto; font-size: 12px;">`;
                typeAnalysis.inconsistentFields.forEach(field => {
                    html += `<div style="padding: 6px; margin: 4px 0; background: #ffe6e6; border-radius: 4px; border-left: 3px solid #dc3545;">`;
                    html += `<strong style="color: #dc3545; font-family: monospace;">${DOMPurify.sanitize(field.name)}</strong><br>`;
                    html += `<span style="color: #666; font-size: 11px;">Types: ${field.types.join(' | ')}</span><br>`;
                    html += `<span style="color: #666; font-size: 11px;">Coverage: ${field.coverage}</span>`;
                    if (field.isPotentialDate) {
                        html += `<br><span style="color: #0066cc; font-size: 11px;">üìÖ Possible date field</span>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            } else {
                html += `<div style="background: #d4edda; border-left: 4px solid #28a745; padding: 10px; border-radius: 4px;">`;
                html += `<strong style="color: #155724;">‚úì All fields have consistent types</strong>`;
                html += `</div>`;
            }
            html += `</div>`;
            html += `</div>`;
            
            // Property summary table
            html += '<h4 style="margin-top: 20px; margin-bottom: 10px; color: #495057;">Aggregated Properties</h4>';
            html += '<p style="font-size: 12px; color: #666; margin-bottom: 10px;">Showing all unique properties across ' + schemas.length + ' schema(s)</p>';
            html += '<table style="width: 100%; border-collapse: collapse; font-size: 12px;">';
            html += '<thead><tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">';
            html += '<th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Property</th>';
            html += '<th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Types Found</th>';
            html += '<th style="padding: 8px; text-align: center; border: 1px solid #ddd;">Schemas</th>';
            html += '</tr></thead><tbody>';
            
            Object.entries(properties).sort((a, b) => a[0].localeCompare(b[0])).forEach(([propName, propData]) => {
                const types = Array.isArray(propData.type) ? propData.type : [propData.type];
                const isInconsistent = types.length > 1;
                const dateFieldNames = /date|time|timestamp|created|updated|modified|expires|born|anniversary/i;
                const isPotentialDate = dateFieldNames.test(propName);
                
                const rowStyle = isInconsistent ? 'border-bottom: 1px solid #ddd; background: #ffe6e6;' : 'border-bottom: 1px solid #ddd;';
                const nameColor = isInconsistent ? '#dc3545' : '#0056b3';
                const typeColor = isInconsistent ? '#dc3545' : '#6c757d';
                const warningIcon = isInconsistent ? '‚ö†Ô∏è ' : '';
                const dateIcon = isPotentialDate ? 'üìÖ ' : '';
                
                html += `<tr style="${rowStyle}">`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; font-family: monospace; font-weight: bold; color: ${nameColor};">${warningIcon}${dateIcon}${DOMPurify.sanitize(propName)}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; font-family: monospace; color: ${typeColor}; font-weight: ${isInconsistent ? 'bold' : 'normal'};">${types.join(' | ')}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${schemas.length}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            detailPanel.innerHTML = html;
            
            // Render pie chart
            setTimeout(() => {
                renderSchemaTypeChart(`schema-type-chart-${escapedId}`, typeAnalysis.typeCounts);
            }, 100);
        }
        
        function selectSchema(schemaId, escapedId) {
            // Remove previous selection
            document.querySelectorAll('.schema-tree-item.selected').forEach(el => el.classList.remove('selected'));
            // Add selection to clicked item
            const item = document.getElementById(`item-${escapedId}`);
            if (item) item.classList.add('selected');
            
            // Display schema details
            const data = schemaDataStore[schemaId];
            if (!data) return;
            
            const detailPanel = document.getElementById('schema-detail-panel');
            const schema = data.schema;
            const properties = schema.properties || {};
            const docCount = schema['#docs'] || 0;
            
            let html = '';
            html += `<h3 style="margin-top: 0; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 8px;">
                      ${DOMPurify.sanitize(data.bucket)}.${DOMPurify.sanitize(data.scope)}.${DOMPurify.sanitize(data.collection)}
                      <span style="font-size: 12px; color: ${data.status === 'success' ? '#28a745' : '#dc3545'}; 
                                   background: ${data.status === 'success' ? '#d4edda' : '#f8d7da'}; 
                                   padding: 2px 8px; border-radius: 4px; font-weight: bold; margin-left: 8px;">
                        ${data.status.toUpperCase()}
                      </span>
                    </h3>`;
            
            html += `<div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 12px;">`;
            html += `<strong>Query:</strong> <code style="background: #fff; padding: 2px 6px; border-radius: 3px;">${DOMPurify.sanitize(data.query)}</code>`;
            html += `</div>`;
            
            html += `<div style="background: #e7f3ff; padding: 12px; border-radius: 4px; margin-bottom: 15px; display: flex; gap: 20px;">`;
            html += `<div><strong>Documents:</strong> ${docCount}</div>`;
            html += `<div><strong>Properties:</strong> ${Object.keys(properties).length}</div>`;
            html += `</div>`;
            
            // Analyze data types and inconsistencies
            const typeAnalysis = analyzeSchemaTypes(properties);
            
            // Type Distribution and Inconsistencies Section
            html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">`;
            
            // Pie Chart for Type Distribution
            html += `<div style="background: white; border: 1px solid #ddd; border-radius: 6px; padding: 15px;">`;
            html += `<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px;">Type Distribution</h4>`;
            html += `<div style="height: 250px; position: relative;">`;
            html += `<canvas id="schema-type-chart-${escapedId}"></canvas>`;
            html += `</div>`;
            html += `</div>`;
            
            // Inconsistent Types Warning Box
            html += `<div style="background: white; border: 1px solid #ddd; border-radius: 6px; padding: 15px;">`;
            html += `<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px;">Type Consistency</h4>`;
            if (typeAnalysis.inconsistentFields.length > 0) {
                html += `<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; border-radius: 4px; margin-bottom: 10px;">`;
                html += `<strong style="color: #856404;">‚ö†Ô∏è ${typeAnalysis.inconsistentFields.length} field(s) with mixed types</strong>`;
                html += `</div>`;
                html += `<div style="max-height: 200px; overflow-y: auto; font-size: 12px;">`;
                typeAnalysis.inconsistentFields.forEach(field => {
                    html += `<div style="padding: 6px; margin: 4px 0; background: #ffe6e6; border-radius: 4px; border-left: 3px solid #dc3545;">`;
                    html += `<strong style="color: #dc3545; font-family: monospace;">${DOMPurify.sanitize(field.name)}</strong><br>`;
                    html += `<span style="color: #666; font-size: 11px;">Types: ${field.types.join(' | ')}</span><br>`;
                    html += `<span style="color: #666; font-size: 11px;">Coverage: ${field.coverage}</span>`;
                    if (field.isPotentialDate) {
                        html += `<br><span style="color: #0066cc; font-size: 11px;">üìÖ Possible date field</span>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            } else {
                html += `<div style="background: #d4edda; border-left: 4px solid #28a745; padding: 10px; border-radius: 4px;">`;
                html += `<strong style="color: #155724;">‚úì All fields have consistent types</strong>`;
                html += `</div>`;
            }
            html += `</div>`;
            
            html += `</div>`;
            
            // Generate and display sample document
            const sampleDoc = generateSampleDocument(properties);
            const sampleDocId = `sample-doc-${escapedId}`;
            html += '<h4 style="margin-top: 20px; margin-bottom: 10px; color: #495057;">Mock Data from Schema</h4>';
            html += '<div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; padding-top: 45px; margin-bottom: 20px; position: relative;">';
            html += '<div style="position: absolute; top: 10px; right: 10px; display: flex; gap: 5px;">';
            html += '<button onclick="copySampleDocument(this)" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 6px 12px; font-size: 11px; cursor: pointer;">üìã Copy JSON</button>';
            html += `<button onclick="toggleSampleDocument('${sampleDocId}', this)" style="background: #6c757d; color: white; border: none; border-radius: 4px; padding: 6px 12px; font-size: 11px; cursor: pointer;">‚ñº Show Less</button>`;
            html += '</div>';
            html += `<div id="${sampleDocId}" style="max-height: 200px; overflow-y: auto; transition: max-height 0.3s ease;">`;
            html += '<pre style="margin: 0; font-family: monospace; font-size: 12px; overflow-x: auto; white-space: pre-wrap; word-break: break-word;">';
            html += DOMPurify.sanitize(JSON.stringify(sampleDoc, null, 2));
            html += '</pre>';
            html += '</div>';
            html += '</div>';
            
            if (Object.keys(properties).length > 0) {
                html += '<h4 style="margin-top: 20px; margin-bottom: 10px; color: #495057;">Schema Properties</h4>';
                html += '<table style="width: 100%; border-collapse: collapse; font-size: 12px;">';
                html += '<thead><tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">';
                html += '<th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Property</th>';
                html += '<th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Type</th>';
                html += '<th style="padding: 8px; text-align: center; border: 1px solid #ddd;">Doc Count</th>';
                html += '<th style="padding: 8px; text-align: center; border: 1px solid #ddd;">% Coverage</th>';
                html += '<th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Details</th>';
                html += '</tr></thead><tbody>';
                
                Object.entries(properties).sort((a, b) => a[0].localeCompare(b[0])).forEach(([propName, propData]) => {
                    const type = Array.isArray(propData.type) ? propData.type.join(' | ') : propData.type;
                    const propDocCount = Array.isArray(propData['#docs']) ? propData['#docs'].join(', ') : propData['#docs'];
                    const propDocPercent = Array.isArray(propData['%docs']) ? propData['%docs'].join(', ') : propData['%docs'];
                    
                    // Check if this field is inconsistent
                    const types = Array.isArray(propData.type) ? propData.type : [propData.type];
                    const docPercents = Array.isArray(propData['%docs']) ? propData['%docs'] : [propData['%docs']];
                    const isInconsistent = types.length > 1 || (Array.isArray(docPercents) && docPercents.some(p => p < 100));
                    const dateFieldNames = /date|time|timestamp|created|updated|modified|expires|born|anniversary/i;
                    const isPotentialDate = dateFieldNames.test(propName);
                    
                    let details = '';
                    if (propData.items) {
                        const itemType = propData.items.type || 'unknown';
                        details += `<strong>Array of:</strong> ${itemType}`;
                        if (propData.minItems !== undefined || propData.maxItems !== undefined) {
                            details += ` (${propData.minItems || 0}-${propData.maxItems || '‚àû'} items)`;
                        }
                    }
                    if (propData.properties) {
                        const nestedPropCount = Object.keys(propData.properties).length;
                        details += `<strong>Object:</strong> ${nestedPropCount} nested properties`;
                    }
                    if (isPotentialDate) {
                        details += details ? '<br>' : '';
                        details += `<span style="color: #0066cc;">üìÖ Possible date field</span>`;
                    }
                    
                    // Highlight inconsistent fields in red
                    const rowStyle = isInconsistent ? 'border-bottom: 1px solid #ddd; background: #ffe6e6;' : 'border-bottom: 1px solid #ddd;';
                    const nameColor = isInconsistent ? '#dc3545' : '#0056b3';
                    const typeColor = isInconsistent ? '#dc3545' : '#6c757d';
                    const warningIcon = isInconsistent ? '‚ö†Ô∏è ' : '';
                    
                    html += `<tr style="${rowStyle}">`;
                    html += `<td style="padding: 8px; border: 1px solid #ddd; font-family: monospace; font-weight: bold; color: ${nameColor};">${warningIcon}${DOMPurify.sanitize(propName)}</td>`;
                    html += `<td style="padding: 8px; border: 1px solid #ddd; font-family: monospace; color: ${typeColor}; font-weight: ${isInconsistent ? 'bold' : 'normal'};">${DOMPurify.sanitize(type)}</td>`;
                    html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${propDocCount}</td>`;
                    html += `<td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${isInconsistent ? '#dc3545' : 'inherit'}; font-weight: ${isInconsistent ? 'bold' : 'normal'};">${propDocPercent}%</td>`;
                    html += `<td style="padding: 8px; border: 1px solid #ddd; font-size: 11px; color: #666;">${details || '-'}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
            }
            
            detailPanel.innerHTML = html;
            
            // Render pie chart after DOM update
            setTimeout(() => {
                renderSchemaTypeChart(`schema-type-chart-${escapedId}`, typeAnalysis.typeCounts);
            }, 100);
        }
        
        function analyzeSampleValues(samples) {
            if (!samples || !Array.isArray(samples) || samples.length === 0) {
                return { dateFormat: null, isUnique: false };
            }
            
            const flatSamples = samples.flat().filter(s => s !== null && s !== undefined);
            if (flatSamples.length === 0) return { dateFormat: null, isUnique: false };
            
            const sample = flatSamples[0];
            let dateFormat = null;
            
            // Check for ISO-8601 date strings
            if (typeof sample === 'string') {
                if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(sample)) {
                    dateFormat = 'ISO-8601';
                } else if (/^\d{4}-\d{2}-\d{2}$/.test(sample)) {
                    dateFormat = 'Date (YYYY-MM-DD)';
                } else if (/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)/i.test(sample)) {
                    dateFormat = 'Day of Week';
                } else if (/^\d{4}-\d{2}$/.test(sample)) {
                    dateFormat = 'Month/Year (YYYY-MM)';
                }
            } else if (typeof sample === 'number') {
                // Check for Unix timestamps
                if (sample > 1000000000 && sample < 10000000000) {
                    dateFormat = 'Unix Time (seconds)';
                } else if (sample > 1000000000000 && sample < 10000000000000) {
                    dateFormat = 'Unix Time (milliseconds)';
                }
            }
            
            return { dateFormat, isUnique: flatSamples.length === new Set(flatSamples).size };
        }
        
        function generateSampleDocument(properties) {
            const doc = {};
            
            Object.entries(properties).forEach(([propName, propData]) => {
                const samples = propData.samples || [];
                const types = Array.isArray(propData.type) ? propData.type : [propData.type];
                const primaryType = types[0];
                
                // Get a sample value
                const flatSamples = samples.flat().filter(s => s !== null && s !== undefined);
                
                if (flatSamples.length > 0) {
                    // Use first sample value
                    doc[propName] = flatSamples[0];
                } else if (primaryType === 'string') {
                    doc[propName] = '<string>';
                } else if (primaryType === 'number') {
                    doc[propName] = 0;
                } else if (primaryType === 'boolean') {
                    doc[propName] = true;
                } else if (primaryType === 'array') {
                    if (propData.items && propData.items.samples) {
                        // Use sample from items
                        const itemSamples = propData.items.samples;
                        const flatItemSamples = Array.isArray(itemSamples) ? itemSamples.flat() : [];
                        if (flatItemSamples.length > 0) {
                            doc[propName] = [flatItemSamples[0]];
                        } else {
                            doc[propName] = [];
                        }
                    } else {
                        doc[propName] = [];
                    }
                } else if (primaryType === 'object') {
                    if (propData.samples && Array.isArray(propData.samples) && propData.samples.length > 0) {
                        // Use sample object
                        const objSample = propData.samples.find(s => s && typeof s === 'object');
                        if (objSample) {
                            doc[propName] = objSample;
                        } else if (propData.properties) {
                            // Recursively generate nested object
                            doc[propName] = generateSampleDocument(propData.properties);
                        } else {
                            doc[propName] = {};
                        }
                    } else if (propData.properties) {
                        // Recursively generate nested object
                        doc[propName] = generateSampleDocument(propData.properties);
                    } else {
                        doc[propName] = {};
                    }
                } else if (primaryType === 'null') {
                    doc[propName] = null;
                } else {
                    doc[propName] = null;
                }
            });
            
            return doc;
        }
        
        function analyzeSchemaTypes(properties) {
            const typeCounts = {
                string: 0,
                number: 0,
                boolean: 0,
                array: 0,
                object: 0,
                null: 0,
                mixed: 0
            };
            
            const inconsistentFields = [];
            const typeDiscriminators = [];
            const uniqueIdentifiers = [];
            const dateTimeFields = [];
            
            const dateFieldNames = /date|time|timestamp|created|updated|modified|expires|born|anniversary/i;
            const typeFieldNames = /^(type|docType|class|_class|_type|kind|category)$/i;
            const idFieldNames = /^(id|_id|ID|uuid|guid|key|record|recordId|recordKey)$/i;
            
            Object.entries(properties).forEach(([propName, propData]) => {
                const types = Array.isArray(propData.type) ? propData.type : [propData.type];
                const docCounts = Array.isArray(propData['#docs']) ? propData['#docs'] : [propData['#docs']];
                const docPercents = Array.isArray(propData['%docs']) ? propData['%docs'] : [propData['%docs']];
                const samples = propData.samples || [];
                
                // Analyze sample values
                const sampleAnalysis = analyzeSampleValues(samples);
                
                // Check for type discriminator fields
                if (typeFieldNames.test(propName)) {
                    const sampleValues = samples.flat().filter(s => s !== null && s !== undefined);
                    typeDiscriminators.push({
                        name: propName,
                        values: [...new Set(sampleValues)].slice(0, 10)
                    });
                }
                
                // Check for unique identifier fields
                if (idFieldNames.test(propName) && sampleAnalysis.isUnique) {
                    uniqueIdentifiers.push({
                        name: propName,
                        type: types.join(' | ')
                    });
                }
                
                // Check for date/time fields
                if (sampleAnalysis.dateFormat || dateFieldNames.test(propName)) {
                    dateTimeFields.push({
                        name: propName,
                        type: types.join(' | '),
                        format: sampleAnalysis.dateFormat || 'Inferred from name',
                        samples: samples.flat().filter(s => s !== null).slice(0, 3)
                    });
                }
                
                // Check if field has mixed types (not 100% consistent)
                const isMixed = types.length > 1 || (Array.isArray(docPercents) && docPercents.some(p => p < 100));
                
                if (isMixed) {
                    typeCounts.mixed++;
                    
                    const coverageStr = Array.isArray(docPercents) 
                        ? types.map((t, i) => `${t}: ${docPercents[i]}%`).join(', ')
                        : `${types[0]}: ${docPercents}%`;
                    
                    inconsistentFields.push({
                        name: propName,
                        types: types,
                        coverage: coverageStr,
                        isPotentialDate: dateFieldNames.test(propName) || sampleAnalysis.dateFormat
                    });
                } else {
                    // Consistent type - count it
                    const primaryType = types[0];
                    if (primaryType === 'string') typeCounts.string++;
                    else if (primaryType === 'number') typeCounts.number++;
                    else if (primaryType === 'boolean') typeCounts.boolean++;
                    else if (primaryType === 'array') typeCounts.array++;
                    else if (primaryType === 'object') typeCounts.object++;
                    else if (primaryType === 'null') typeCounts.null++;
                }
            });
            
            return { 
                typeCounts, 
                inconsistentFields, 
                typeDiscriminators, 
                uniqueIdentifiers, 
                dateTimeFields 
            };
        }
        
        function renderSchemaTypeChart(canvasId, typeCounts) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const labels = [];
            const data = [];
            const colors = [];
            
            const typeColorMap = {
                string: '#36a2eb',
                number: '#ff6384',
                boolean: '#4bc0c0',
                array: '#ff9f40',
                object: '#9966ff',
                null: '#c9cbcf',
                mixed: '#ffcd56'
            };
            
            Object.entries(typeCounts).forEach(([type, count]) => {
                if (count > 0) {
                    labels.push(type.charAt(0).toUpperCase() + type.slice(1));
                    data.push(count);
                    colors.push(typeColorMap[type] || '#999');
                }
            });
            
            if (data.length === 0) {
                // No data to display
                return;
            }
            
            const total = data.reduce((a, b) => a + b, 0);
            
            new Chart(canvas, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                boxWidth: 12,
                                font: { size: 11 },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label + ' (' + (typeof data.datasets[0].data[index] === 'number' ? data.datasets[0].data[index].toLocaleString() : data.datasets[0].data[index]) + ')',
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index
                                    }));
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    afterDatasetsDraw: function(chart) {
                        drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                    }
                }]
            });
        }
        
        function expandAllSchemaTree() {
            document.querySelectorAll('.schema-tree-children').forEach(el => {
                el.classList.remove('collapsed');
            });
            document.querySelectorAll('.schema-tree-toggle').forEach(el => {
                el.textContent = '‚ñº';
            });
        }
        
        function collapseAllSchemaTree() {
            document.querySelectorAll('.schema-tree-children').forEach(el => {
                el.classList.add('collapsed');
            });
            document.querySelectorAll('.schema-tree-toggle').forEach(el => {
                el.textContent = '‚ñ∂';
            });
        }
        
        function copySampleDocument(button) {
            // Find the pre element - it's in the parent's parent's child div
            const container = button.closest('div[style*="background"]');
            const pre = container ? container.querySelector('pre') : null;
            if (pre) {
                const text = pre.textContent;
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = button.textContent;
                    button.textContent = '‚úì Copied!';
                    button.style.background = '#28a745';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#007bff';
                    }, 2000);
                }).catch(err => {
                    Logger.error('Failed to copy:', err);
                    showToast('Failed to copy to clipboard', 'error');
                });
            }
        }
        
        function toggleSampleDocument(divId, button) {
            const div = document.getElementById(divId);
            if (div) {
                if (div.style.maxHeight === 'none' || div.style.maxHeight === '') {
                    // Collapse
                    div.style.maxHeight = '200px';
                    button.textContent = '‚ñº Show Less';
                } else {
                    // Expand
                    div.style.maxHeight = 'none';
                    button.textContent = '‚ñ≤ Show More';
                }
            }
        }

        // Set timezone label text when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            const label = document.getElementById('timezone-selector-label');
            if (label) {
                label.textContent = TEXT_CONSTANTS.TIMEZONE_LABEL;
            }
        });

        // ============================================
        // AI Analyzer Data Gathering Functions
        // ============================================

        /**
         * Extract data from Chart.js instances
         */
        function extractChartData(chart, chartType = 'pie') {
            if (!chart || !chart.data) return null;
            
            const labels = chart.data.labels || [];
            const datasets = chart.data.datasets || [];
            
            // For timeline charts (multiple datasets), extract all datasets
            // The caller can decide how to simplify it
            if (datasets.length > 1) {
                const datasetMap = {};
                datasets.forEach(ds => {
                    datasetMap[ds.label || 'data'] = ds.data || [];
                });
                return {
                    labels: labels,
                    datasets: datasetMap
                };
            }
            
            // Default single dataset behavior (backward compatible for dashboard stats)
            const data = datasets[0]?.data || [];
            
            return labels.map((label, i) => ({
                label: label,
                value: data[i] || 0
            }));
        }

        /**
         * Gather Timeline Charts data
         */
        function gatherTimelineChartsData() {
            Logger.debug('[AI] üìà Gathering Timeline Charts data');
            
            // Map charts to descriptions
            const chartDefs = [
                { name: 'timelineChart', id: 'request_count', description: 'Request Count over Time (detects traffic spikes, query bursts, and quiet periods)' },
                { name: 'queryTypesChart', id: 'query_types', description: 'Query Types over Time (shows distribution of SELECT, UPDATE, INSERT, DELETE operations to identify workload shifts)' },
                { name: 'durationBucketsChart', id: 'duration_buckets', description: 'Duration Buckets over Time (tracks latency trends by grouping queries into <10ms, 10-100ms, >1s buckets to spot performance degradation)' },
                { name: 'memoryChart', id: 'memory_usage', description: 'Total Memory Usage over Time (identifies Out-Of-Memory risks and memory-intensive query patterns)' },
                { name: 'resultCountChart', id: 'result_count', description: 'Result Count over Time (detects queries returning excessive rows, indicating missing LIMITs or inefficient filtering)' },
                { name: 'resultSizeChart', id: 'result_size', description: 'Result Size (Bytes) over Time (monitors network bandwidth usage and large payload transfers)' },
                { name: 'cpuTimeChart', id: 'cpu_time', description: 'Total CPU Time over Time (shows processing load and CPU-intensive operations)' },
                { name: 'indexScanThroughputChart', id: 'index_throughput', description: 'Index Scan Throughput (measures index usage intensity in items scanned/sec)' },
                { name: 'docFetchThroughputChart', id: 'fetch_throughput', description: 'Doc Fetch Throughput (measures data service load in fetches/sec)' },
                { name: 'execVsKernelChart', id: 'exec_vs_kernel', description: 'Execution Time vs Kernel Time (compares query processing time vs system scheduling overhead)' },
                { name: 'enhancedOperationsChart', id: 'operations', description: 'Detailed Operations over Time (breakdown of specific phases like JOINs, SORTS, FILTERS to pinpoint bottlenecks)' },
                { name: 'serviceTimeAnalysisLineChart', id: 'service_time_analysis', description: 'Service Time vs Elapsed Time (compares server-side processing vs total duration to identify network latency or client-side delays)' }
            ];
            
            // Check if any chart is missing
            const anyChartMissing = chartDefs.some(def => !window[def.name]);
            
            if ((anyChartMissing || !window.timelineChart) && everyQueryData && everyQueryData.length > 0) {
                Logger.info('[AI] ‚ö†Ô∏è Some timeline charts missing. Regenerating ALL for analysis...');
                
                // Helper to safely generate a chart without stopping the chain on error
                const safeGenerate = (fnName) => {
                    try {
                        if (typeof window[fnName] === 'function') {
                            window[fnName](everyQueryData);
                        }
                    } catch (e) {
                        Logger.warn(`[AI] ‚ö†Ô∏è Failed to generate ${fnName}:`, e);
                    }
                };

                // Generate all timeline charts individually
                safeGenerate('generateTimelineChart');
                safeGenerate('generateQueryTypesChart');
                safeGenerate('generateDurationBucketsChart');
                safeGenerate('generateMemoryChart');
                safeGenerate('generateResultCountChart');
                safeGenerate('generateResultSizeChart');
                safeGenerate('generateCpuTimeChart');
                safeGenerate('generateIndexScanThroughputChart');
                safeGenerate('generateDocFetchThroughputChart');
                safeGenerate('generateExecVsKernelChart');
                safeGenerate('generateEnhancedOperationsChart');
                safeGenerate('generateServiceTimeAnalysisLineChart');
                
                Logger.info('[AI] ‚úÖ Timeline charts generation attempt complete');
            }
            
            const charts = {};
            
            // First pass: collect all unique x-axis labels (timestamps) from all charts to build a unified timeline
            const allTimestamps = new Set();
            
            chartDefs.forEach(def => {
                const chartInstance = window[def.name];
                if (chartInstance && chartInstance.data && chartInstance.data.labels) {
                    chartInstance.data.labels.forEach(label => allTimestamps.add(label));
                }
            });
            
            // Sort timestamps
            const sortedTimestamps = Array.from(allTimestamps).sort();
            
            // Sample timestamps if too many (limit to ~60 points)
            let sampledTimestamps = sortedTimestamps;
            let samplingFactor = 1;
            
            if (sortedTimestamps.length > 100) {
                samplingFactor = Math.ceil(sortedTimestamps.length / 60);
                sampledTimestamps = sortedTimestamps.filter((_, i) => i % samplingFactor === 0);
            }
            
            charts.common_timeline = {
                labels: sampledTimestamps,
                note: samplingFactor > 1 ? `Sampled 1/${samplingFactor} points from unified timeline` : 'Complete timeline'
            };
            
            chartDefs.forEach(def => {
                const chartInstance = window[def.name];
                // Only process if chart exists AND has data
                if (chartInstance && chartInstance.data && chartInstance.data.datasets && chartInstance.data.datasets.length > 0) {
                    const data = extractChartData(chartInstance);
                    
                    // Instead of storing labels + data, just store data keyed by timestamp or aligned to common_timeline
                    // For AI payload optimization, we'll map data to the common sampled timeline
                    
                    const sampledDatasets = {};
                    
                    // Helper to find value for a specific timestamp (or nearest)
                    // Chart.js data matches labels index 1:1
                    
                    const chartLabels = data.labels || [];
                    
                    // Handle both flat structure (single dataset) and nested (multi-dataset)
                    let datasetsToProcess = {};
                    if (data.datasets && !Array.isArray(data.datasets)) {
                        datasetsToProcess = data.datasets;
                    } else {
                        // Single dataset case or old format
                        if (Array.isArray(data)) {
                             datasetsToProcess = { 'data': data.map(d => d.value) };
                        } else {
                             datasetsToProcess = { 'data': data.map(d => d.value) };
                        }
                    }
                    
                    // Map each dataset to the sampled common timeline
                    Object.keys(datasetsToProcess).forEach(key => {
                        const sourceData = datasetsToProcess[key];
                        
                        // Create a map for quick lookup: timestamp -> value
                        const timeValueMap = new Map();
                        chartLabels.forEach((ts, idx) => {
                            timeValueMap.set(ts, sourceData[idx]);
                        });
                        
                        // Map to common sampled timeline
                        sampledDatasets[key] = sampledTimestamps.map(ts => {
                            // Exact match
                            if (timeValueMap.has(ts)) return timeValueMap.get(ts);
                            return 0; // Default to 0 if no data point at this exact timestamp
                        });
                    });
                    
                    charts[def.id] = {
                        description: def.description,
                        datasets: sampledDatasets
                    };
                }
            });
            
            return charts;
        }

        /**
         * Gather dashboard statistics from charts and tables
         */
        function gatherDashboardStats() {
            Logger.debug('[AI] üìä Gathering dashboard statistics from charts');
            
            const stats = {
                total_queries: everyQueryData?.length || 0,
                total_patterns: analysisData?.length || 0,
                charts: {}
            };
            
            // Extract data from all dashboard charts
            if (window.primaryScanChart) {
                stats.charts.index_type_usage = extractChartData(window.primaryScanChart);
                Logger.trace('[AI] Extracted index_type_usage chart');
            }
            
            if (window.stateChart) {
                stats.charts.query_state = extractChartData(window.stateChart);
                Logger.trace('[AI] Extracted query_state chart');
            }
            
            if (window.statementTypeChart) {
                stats.charts.statement_type = extractChartData(window.statementTypeChart);
                Logger.trace('[AI] Extracted statement_type chart');
            }
            
            if (window.scanConsistencyChart) {
                stats.charts.scan_consistency = extractChartData(window.scanConsistencyChart);
                Logger.trace('[AI] Extracted scan_consistency chart');
            }
            
            if (window.elapsedTimeChart) {
                stats.charts.query_duration_distribution = extractChartData(window.elapsedTimeChart, 'bar');
                Logger.trace('[AI] Extracted duration_distribution chart');
            }
            
            if (window.queryPatternChart) {
                stats.charts.query_pattern_features = extractChartData(window.queryPatternChart, 'bar');
                Logger.trace('[AI] Extracted pattern_features chart');
            }
            
            Logger.debug(`[AI] Dashboard stats gathered: ${Object.keys(stats.charts).length} charts extracted`);
            return stats;
        }

        /**
         * Gather insights data - all 16 insights with stats
         */
        function gatherInsightsData() {
            Logger.debug('[AI] üí° Gathering all 16 insights data');
            
            const INSIGHT_DEFS = [
                { id: 'inefficient-index-scans', checkElement: 'inefficient-index-scans-count' },
                { id: 'slow-index-scan-times', checkElements: ['slow-indexes-2-10s', 'slow-indexes-10s-plus', 'slow-primary-indexes'] },
                { id: 'primary-index-over-usage', checkElement: 'primary-avg-items-scanned' },
                { id: 'high-kernel-time-queries', checkElement: 'high-kernel-time-queries-count' },
                { id: 'high-memory-usage', checkElement: 'high-memory-count' },
                { id: 'slow-parse-plan-times', checkElement: 'slow-parse-plan-count' },
                { id: 'slow-use-key-queries', checkElement: 'slow-use-keys-count' },
                { id: 'missing-where-clauses', checkElement: 'missing-where-count' },
                { id: 'complex-join-operations', checkElement: 'complex-join-count' },
                { id: 'inefficient-like-operations', checkElement: 'inefficient-like-count' },
                { id: 'select-star-usage', checkElement: 'select-star-count' },
                { id: 'pagination-index-overfetch', checkElement: 'pagination-overfetch-count' },
                { id: 'large-result-set-queries', checkElement: 'large-results-count' },
                { id: 'large-payload-streaming', checkElement: 'large-payload-count' },
                { id: 'timeout-prone-queries', checkElements: ['approaching-timeout-count', 'actual-timeout-count'] },
                { id: 'concurrent-query-conflicts', checkElement: 'concurrent-conflicts-count' }
            ];
            
            const result = { items: [] };
            
            INSIGHT_DEFS.forEach(def => {
                const content = document.getElementById(`${def.id}-content`);
                if (!content) return;
                
                const card = content.closest('.insight-item');
                if (!card) return;
                
                const title = card.querySelector('.insight-title')?.textContent?.trim() || def.id;
                const description = card.querySelector('.insight-description')?.textContent?.trim() || '';
                
                // Extract counts from specific elements
                const counts = {};
                if (def.checkElement) {
                    const el = document.getElementById(def.checkElement);
                    if (el) counts[def.checkElement] = el.textContent.trim();
                }
                if (def.checkElements) {
                    def.checkElements.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) counts[id] = el.textContent.trim();
                    });
                }
                
                // Extract sample queries if available
                const sampleContainer = document.getElementById(`${def.id}-sample-queries-container`);
                let samples = [];
                if (sampleContainer) {
                    const rows = sampleContainer.querySelectorAll('tbody tr');
                    samples = Array.from(rows).slice(0, 5).map(tr => {
                        const tds = tr.querySelectorAll('td');
                        return {
                            requestTime: tds?.[0]?.textContent?.trim() || '',
                            statement: tds?.[1]?.textContent?.trim() || ''
                        };
                    });
                }
                
                result.items.push({
                    id: def.id,
                    title: title,
                    description: description,
                    counts: counts,
                    sample_queries: samples
                });
            });
            
            Logger.debug(`[AI] Insights gathered: ${result.items.length}/16 insights extracted`);
            return result;
        }

        /**
         * Gather parse context - filters, data sources, and settings
         */
        function gatherParseContext() {
            Logger.debug('[AI] ‚öôÔ∏è Gathering parse context (filters & data sources)');
            
            const context = {
                filters: {
                    sql_statement: document.getElementById('sql-statement-filter')?.value || '',
                    elapsed_time: document.getElementById('elapsed-time-filter')?.value || '',
                    collection: document.getElementById('collection-filter')?.value || '',
                    timezone: document.getElementById('timezone-selector')?.value || '',
                    date_range: {
                        from: document.getElementById('start-date')?.value || '',
                        to: document.getElementById('end-date')?.value || ''
                    },
                    exclude_system: document.getElementById('exclude-system-queries')?.checked || false,
                    time_range_preset: document.getElementById('time-range-select')?.value || 'original'
                },
                data_sources: {
                    completed_requests: {
                        source: window._uploadedCompletedRequestsFile ? 'file' : 'paste',
                        filename: window._uploadedCompletedRequestsFile || null,
                        has_data: everyQueryData && everyQueryData.length > 0,
                        record_count: everyQueryData?.length || 0
                    },
                    indexes: {
                        source: window._uploadedIndexesFile ? 'file' : 'paste',
                        filename: window._uploadedIndexesFile || null,
                        has_data: indexData && indexData.length > 0,
                        record_count: indexData?.length || 0
                    }
                },
                stats: {
                    total_queries: everyQueryData?.length || 0,
                    total_patterns: analysisData?.length || 0,
                    total_indexes: indexData?.length || 0,
                    current_timezone: currentTimezone || 'UTC'
                }
            };
            
            Logger.debug(`[AI] Parse context gathered: ${context.stats.total_queries} queries, ${context.filters.exclude_system ? 'EXCLUDED' : 'INCLUDED'} system`);
            return context;
        }

        /**
         * Gather flow diagram data - uses cached Mermaid diagram
         */
        function gatherFlowDiagramData() {
            Logger.debug('[AI] üîÄ Gathering cached flow diagram data');
            
            // Use cached Mermaid diagram (created during flow build)
            const mermaidDiagram = indexQueryFlowData?.mermaidDiagram || 'graph LR\n  A[Flow not generated yet]';
            
            const flowData = {
                mermaid_diagram: mermaidDiagram,
                indexes_count: indexQueryFlowData?.indexes?.size || 0,
                queries_count: indexQueryFlowData?.queries?.size || 0,
                connections_count: indexQueryFlowData?.connections?.size || 0,
                note: 'Mermaid diagram showing index -> query relationships (generated during flow build)'
            };
            
            Logger.debug(`[AI] Flow diagram gathered: ${flowData.connections_count} connections, mermaid length: ${mermaidDiagram.length} chars`);
            return flowData;
        }

        // ============================================
        // AI Analyzer Preview Functions
        // ============================================

        /**
         * Show AI preview overlay with JSON/TOON data that will be sent to AI
         * Sends actual data to Flask for processing
         */
        async function showAIPreview(format = 'json') {
            Logger.debug(`[AI] üëÅÔ∏è showAIPreview(${format}) called`);
            
            const overlay = document.getElementById('ai-preview-overlay');
            const previewJson = document.getElementById('ai-preview-json');
            const previewSize = document.getElementById('ai-preview-size');
            
            // Update title based on format
            const titleEl = overlay ? overlay.querySelector('h2') : null;
            if (titleEl) {
                titleEl.textContent = format === 'toon' ? 'üìã AI Analysis Preview - TOON Payload' : 'üìã AI Analysis Preview - JSON Payload';
            }
            
            if (!overlay || !previewJson) {
                Logger.error('[AI] ‚ùå AI preview overlay elements not found');
                return;
            }
            
            // Check if data exists
            if (!everyQueryData || everyQueryData.length === 0) {
                Logger.error('[AI] ‚ùå No query data available. Please parse JSON first.');
                showToast('Please parse JSON data first before previewing', 'error');
                return;
            }
            
            Logger.debug(`[AI] üìä Gathering data: ${everyQueryData.length} queries, ${analysisData.length} patterns`);
            
            // Gather selections from checkboxes
            const selections = {
                dashboard: document.getElementById('ai-include-dashboard')?.checked || false,
                insights: document.getElementById('ai-include-insights')?.checked || false,
                query_groups: document.getElementById('ai-include-query-groups')?.checked || false,
                indexes: document.getElementById('ai-include-indexes')?.checked || false,
                flow_diagram: document.getElementById('ai-include-flow-diagram')?.checked || false,
                timeline_charts: document.getElementById('ai-include-timeline')?.checked || false
            };
            
            const options = {
                obfuscated: document.getElementById('ai-obfuscate-data')?.checked || false,
                store_results: true,  // Always save for tracking and auditing
                query_group_limit: parseInt(document.querySelector('input[name="ai-qg-limit"]:checked')?.value || "10"),
                use_toon: document.getElementById('ai-send-toon')?.checked || false
            };
            
            const prompt = document.getElementById('ai-user-prompt')?.value || "Analyze query performance";
            
            Logger.debug('[AI] üì§ Sending data to Flask for processing...');
            Logger.trace(`[AI] Selections: ${JSON.stringify(selections)}`);
            
            try {
                // Build request payload with structured data
                const requestData = {
                    data: {
                        everyQueryData: everyQueryData,
                        analysisData: analysisData,
                        indexData: typeof indexData !== 'undefined' ? indexData : [],
                        dashboardStats: gatherDashboardStats(),
                        insightsData: gatherInsightsData(),
                        flowDiagramData: gatherFlowDiagramData(),
                        timelineChartsData: gatherTimelineChartsData(),
                        version: '4.0.0-dev'
                    },
                    prompt: prompt,
                    selections: selections,
                    options: options,
                    format: format,
                    parseContext: gatherParseContext()  // Include filter and data source state
                };
                
                Logger.trace(`[AI] Request data size: ${JSON.stringify(requestData).length} bytes`);
                
                // Show loading state
                previewJson.textContent = `Loading ${format.toUpperCase()} preview from server...`;
                overlay.style.display = 'block';
                
                // POST to Flask endpoint
                const response = await fetch('/api/ai/preview', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                Logger.debug('[AI] ‚úÖ Received response from Flask');
                
                if (!result.success) {
                    throw new Error(result.error || 'Unknown error from server');
                }
                
                // Display formatted content from server (json or toon)
                // Check payload_text (new) first, then payload_json (old), then raw payload fallback
                const contentString = result.payload_text || result.payload_json || JSON.stringify(result.payload, null, 2);
                previewJson.textContent = contentString;
                
                // Update size display
                const sizeKB = result.size_kb || ((result.size_bytes || 0) / 1024).toFixed(2);
                const sizeBytes = result.size_bytes || 0;
                const formatLabel = result.format ? result.format.toUpperCase() : format.toUpperCase();
                
                Logger.debug(`[AI] üìä Payload size: ${sizeKB} KB (${sizeBytes} bytes)`);
                
                if (previewSize) {
                    previewSize.textContent = `${formatLabel} Payload size: ${sizeKB} KB (${sizeBytes.toLocaleString()} bytes)`;
                }
                
                Logger.info('[AI] ‚úÖ Preview overlay displayed with server-processed data');
                
            } catch (error) {
                Logger.error('[AI] ‚ùå Error fetching preview:', error);
                previewJson.textContent = `Error loading preview:\n${error.message}\n\nPlease check the console for details.`;
                
                if (previewSize) {
                    previewSize.textContent = 'Error';
                }
                
                showToast(`Failed to load preview: ${error.message}`, 'error');
            }
        }

        /**
         * Close AI preview overlay
         */
        function closeAIPreview() {
            Logger.debug('[AI] ‚úï closeAIPreview() called');
            
            const overlay = document.getElementById('ai-preview-overlay');
            if (overlay) {
                overlay.style.display = 'none';
                Logger.info('[AI] ‚úÖ Preview overlay closed');
            }
        }

        /**
         * Copy AI preview JSON to clipboard
         */
        function copyAIPreviewJSON() {
            Logger.debug('[AI] üìã copyAIPreviewJSON() called');
            
            const previewJson = document.getElementById('ai-preview-json');
            if (!previewJson) {
                Logger.error('[AI] ‚ùå Preview JSON element not found');
                return;
            }
            
            const jsonText = previewJson.textContent;
            Logger.trace(`[AI] Copying ${jsonText.length} characters to clipboard`);
            
            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(jsonText).then(() => {
                    Logger.info('[AI] ‚úÖ JSON copied to clipboard');
                    showToast('JSON copied to clipboard!', 'success');
                }).catch(err => {
                    Logger.error('[AI] ‚ùå Failed to copy:', err);
                    showToast('Failed to copy JSON', 'error');
                });
            } else {
                // Fallback for older browsers
                Logger.debug('[AI] Using fallback copy method');
                const textArea = document.createElement('textarea');
                textArea.value = jsonText;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    Logger.info('[AI] ‚úÖ JSON copied to clipboard (fallback)');
                    showToast('JSON copied to clipboard!', 'success');
                } catch (err) {
                    Logger.error('[AI] ‚ùå Failed to copy (fallback):', err);
                    showToast('Failed to copy JSON', 'error');
                }
                document.body.removeChild(textArea);
            }
        }

        // ============================================
        // Debug: Mermaid Diagram Viewer
        // ============================================
        
        /**
         * Open cached Mermaid diagram in mermaid.live for debugging
         */
        function openMermaidLive() {
            Logger.debug('[Debug] üêõ Opening Mermaid diagram in mermaid.live');
            
            const mermaidText = indexQueryFlowData?.mermaidDiagram;
            
            if (!mermaidText || mermaidText.includes('No flow')) {
                showToast('No Mermaid diagram available. Parse JSON first.', 'warning');
                Logger.warn('[Debug] No Mermaid diagram available');
                Logger.trace('[Debug] indexQueryFlowData:', indexQueryFlowData);
                return;
            }
            
            Logger.debug(`[Debug] Mermaid diagram: ${mermaidText.length} characters`);
            Logger.trace(`[Debug] Mermaid preview:\n${mermaidText.substring(0, 300)}`);
            
            // Simple approach: Copy to clipboard and open mermaid.live
            // User can paste it manually (URL encoding can fail for large diagrams)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(mermaidText).then(() => {
                    Logger.info('[Debug] ‚úÖ Mermaid diagram copied to clipboard');
                    showToast('Mermaid diagram copied! Paste it in the editor.', 'success');
                    
                    // Open mermaid.live in new tab
                    window.open('https://mermaid.live/edit', '_blank');
                    Logger.info('[Debug] ‚úÖ Opened mermaid.live - paste diagram from clipboard');
                }).catch(err => {
                    Logger.error('[Debug] Failed to copy:', err);
                    showToast('Failed to copy Mermaid diagram', 'error');
                });
            } else {
                // Fallback: Show in alert
                alert('Mermaid diagram (copy this):\n\n' + mermaidText.substring(0, 500) + '\n\n... (truncated)');
                window.open('https://mermaid.live/edit', '_blank');
            }
        }
        
        /**
         * Show/hide debug Mermaid button based on URL flag
         */
        function toggleDebugMermaidButton() {
            const debugBtn = document.getElementById('debug-mermaid-btn');
            if (debugBtn && isDebugMode()) {
                debugBtn.style.display = 'block';
                Logger.debug('[Debug] Mermaid debug button shown');
            }
        }
        
        // Show debug button on load if debug mode
        document.addEventListener('DOMContentLoaded', () => {
            toggleDebugMermaidButton();
            
            // Show/Hide TOON Preview button and Timeline Charts option based on Dev Mode
            if (isDevMode()) {
                const toonBtn = document.getElementById('ai-preview-toon-btn');
                if (toonBtn) toonBtn.style.display = 'inline-block';
                
                // Show Timeline Charts checkbox
                const timelineContainer = document.getElementById('ai-include-timeline-container');
                if (timelineContainer) timelineContainer.style.display = 'flex';
                
                // Add TOON checkbox option if in dev mode
                const optionsDiv = document.querySelector('#ai-obfuscate-data')?.closest('.background-f5');
                if (optionsDiv && !document.getElementById('ai-send-toon')) {
                    const toonOption = document.createElement('div');
                    toonOption.innerHTML = `
                        <label style="display: flex; align-items: center; gap: 6px; margin-top: 8px; color: #6610f2; font-weight: bold;">
                            <input type="checkbox" id="ai-send-toon"> üì¶ Send as TOON (Experimental)
                        </label>
                        <div style="font-size: 11px; color: #666; margin-left: 22px;">Use optimized TOON format to reduce payload size</div>
                    `;
                    optionsDiv.appendChild(toonOption);
                }
            }
        });

        /**
         * Analyze data with AI (sends to AI provider)
         */
        async function analyzeWithAI() {
            Logger.info('[AI] ü§ñ analyzeWithAI() called');
            
            // Check if data exists
            if (!everyQueryData || everyQueryData.length === 0) {
                Logger.error('[AI] ‚ùå No query data available');
                showToast('Please parse JSON data first', 'error');
                return;
            }
            
            // Get AI provider settings from dropdown
            const providerDropdown = document.getElementById('ai-provider-select');
            const provider = providerDropdown?.value;
            
            if (!provider) {
                showToast('Please select an AI provider', 'error');
                return;
            }
            
            // Check if provider is configured (has credentials in Couchbase)
            const selectedOption = providerDropdown.options[providerDropdown.selectedIndex];
            const hasApiKey = selectedOption?.dataset.apiKey && selectedOption.dataset.apiKey.length > 0;
            
            if (!hasApiKey) {
                showToast('No API key configured for this provider. Please add in Settings.', 'error');
                Logger.error('[AI] No API key for provider:', provider);
                return;
            }
            
            Logger.debug(`[AI] Provider: ${provider} (credentials in Couchbase)`);
            
            // Gather selections
            const selections = {
                dashboard: document.getElementById('ai-include-dashboard')?.checked || false,
                insights: document.getElementById('ai-include-insights')?.checked || false,
                query_groups: document.getElementById('ai-include-query-groups')?.checked || false,
                indexes: document.getElementById('ai-include-indexes')?.checked || false,
                flow_diagram: document.getElementById('ai-include-flow-diagram')?.checked || false,
                timeline_charts: document.getElementById('ai-include-timeline')?.checked || false
            };
            
            const options = {
                obfuscated: document.getElementById('ai-obfuscate-data')?.checked || false,
                store_results: true,  // Always save for tracking and auditing
                query_group_limit: parseInt(document.querySelector('input[name="ai-qg-limit"]:checked')?.value || "10"),
                use_toon: document.getElementById('ai-send-toon')?.checked || false
            };
            
            // Get and validate Cluster Name (Required)
            const clusterNameInput = document.getElementById('ai-cluster-name');
            const clusterName = clusterNameInput ? clusterNameInput.value.trim() : '';
            
            if (!clusterName) {
                showToast('Please enter a Cluster Name in the Analysis Source section.', 'error');
                if (clusterNameInput) {
                    clusterNameInput.focus();
                    clusterNameInput.style.borderColor = '#dc3545';
                    setTimeout(() => clusterNameInput.style.borderColor = '#ccc', 3000);
                }
                return;
            }

            const prompt = document.getElementById('ai-user-prompt')?.value || "Analyze query performance";
            
            Logger.debug(`[AI] Provider: ${provider}, Store: ${options.store_results}`);
            
            // Check if save is requested
            if (options.store_results) {
                // Get Couchbase config from global clusterConfig (loaded from config.json)
                const cbConfig = window.clusterConfig || (typeof clusterConfig !== 'undefined' ? clusterConfig : null);
                
                if (!cbConfig || !cbConfig.cluster) {
                    showToast('Couchbase not configured. Please configure in Settings ‚Üí Save Data To CB.', 'error');
                    Logger.error('[AI] No Couchbase config available');
                    Logger.trace('[AI] window.clusterConfig:', window.clusterConfig);
                    return;
                }
                
                Logger.info('[AI] üíæ Save to Couchbase is enabled - preparing to save');
                
                // Build payload (for saving, even without AI call)
                const savePayload = {
                    data: {
                        clusterName: clusterName,
                        everyQueryData: everyQueryData,
                        analysisData: analysisData,
                        indexData: typeof indexData !== 'undefined' ? indexData : [],
                        dashboardStats: gatherDashboardStats(),
                        insightsData: gatherInsightsData(),
                        flowDiagramData: gatherFlowDiagramData(),
                        timelineChartsData: gatherTimelineChartsData(),
                        version: '4.0.0-dev'
                    },
                    prompt: prompt,
                    selections: selections,
                    options: options,
                    parseContext: gatherParseContext(),
                    couchbaseConfig: cbConfig,
                    // Only send provider ID - Flask will get credentials from user::config
                    provider: provider
                };
                
                Logger.info(`[AI] Payload size: ${JSON.stringify(savePayload).length} bytes`);
                
                try {
                    // Show immediate feedback with loading state
                    const btn = document.getElementById('ai-analyze-btn');
                    const originalBtnContent = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = 'ü§ñ Processing... <span class="spinner-border" style="width: 12px; height: 12px; border-width: 2px; display: inline-block; border: 2px solid #fff; border-right-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-left: 8px;"></span>';
                    
                    // Show progress bar
                    const progressBar = document.getElementById('ai-progress-bar');
                    if (progressBar) progressBar.style.display = 'flex';
                    
                    // Function to update progress steps
                    const updateProgress = (step, isError = false) => {
                        if (!progressBar) return;
                        
                        // Calculate width based on step (0-3 = 4 steps)
                        // Step 1: Sending (0% line)
                        // Step 2: Processing (33% line)
                        // Step 3: Saving (66% line)
                        // Step 4: Done (100% line)
                        
                        const steps = progressBar.querySelectorAll('.progress-step');
                        const lineFill = progressBar.querySelector('.progress-line-fill');
                        
                        // Update line width
                        if (step === 1) lineFill.style.width = '0%';
                        else if (step === 2) lineFill.style.width = '33%';
                        else if (step === 3) lineFill.style.width = '66%';
                        else if (step === 4) lineFill.style.width = '100%';
                        
                        // Update step classes
                        steps.forEach((el, index) => {
                            const stepNum = index + 1;
                            el.classList.remove('active', 'completed', 'error');
                            
                            if (stepNum < step) {
                                el.classList.add('completed');
                            } else if (stepNum === step) {
                                if (isError) el.classList.add('error');
                                else el.classList.add('active');
                            }
                        });
                    };
                    
                    // Initial state: Step 1 (Sending)
                    updateProgress(1);
                    
                    // Add CSS keyframe for spin if not exists
                    if (!document.getElementById('spinner-style')) {
                        const style = document.createElement('style');
                        style.id = 'spinner-style';
                        style.textContent = '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
                        document.head.appendChild(style);
                    }

                    showToast('üöÄ AI Analyzer job has been submitted. This may take a few minutes...', 'info');
                    Logger.info('[AI] üöÄ Job submitted to Flask');
                    
                    // POST to Flask analyze endpoint (which will save even without real AI)
                    const response = await fetch('/api/ai/analyze', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(savePayload)
                    });
                    
                    const result = await response.json();
                    
                    // Move to Step 2 (Processing)
                    updateProgress(2);
                    
                    if (result.success) {
                        const docId = result.document_id;
                        
                        // Immediately show in history table as "Pending"
                        setTimeout(() => loadAIAnalysisHistory(), 500);
                        
                        if (result.status === 'submitted' || result.status === 'pending') {
                            Logger.info(`[AI] üîÑ Job submitted (ID: ${docId}), starting poll...`);
                            
                            // Polling loop
                            const pollInterval = 3000; // 3 seconds
                            let attempts = 0;
                            const maxAttempts = 200; // ~10 minutes timeout
                            
                            const poll = async () => {
                                attempts++;
                                if (attempts > maxAttempts) {
                                    updateProgress(2, true); // Error on processing step
                                    throw new Error('Analysis timed out after 10 minutes');
                                }
                                
                                try {
                                    const statusRes = await fetch(`/api/ai/status/${docId}`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            config: cbConfig.cluster,
                                            bucketConfig: cbConfig.bucketConfig
                                        })
                                    });
                                    
                                    const statusData = await statusRes.json();
                                    
                                    if (statusData.status === 'completed') {
                                        // Move to Step 3 (Saving) -> Step 4 (Done) quickly
                                        updateProgress(3);
                                        setTimeout(() => updateProgress(4), 500);
                                        
                                        showToast(`‚úÖ Analysis complete!`, 'success');
                                        Logger.info(`[AI] ‚úÖ Analysis completed for ${docId}`);
                                        
                                        // Restore button
                                        const btn = document.getElementById('ai-analyze-btn');
                                        if (btn) {
                                            btn.disabled = false;
                                            btn.innerHTML = originalBtnContent;
                                        }
                                        
                                        // Hide progress bar after delay
                                        setTimeout(() => {
                                            if (progressBar) progressBar.style.display = 'none';
                                        }, 3000);
                                        
                                        // Refresh history
                                        setTimeout(() => loadAIAnalysisHistory(), 500);
                                        return;
                                    } else if (statusData.status === 'failed') {
                                        updateProgress(2, true); // Error on processing step
                                        throw new Error(statusData.error?.message || 'Analysis failed during processing');
                                    } else {
                                        // Still pending, poll again
                                        setTimeout(poll, pollInterval);
                                    }
                                } catch (e) {
                                    if (e.message.includes('timed out') || e.message.includes('failed')) throw e;
                                    Logger.warn('[AI] Polling error (retrying):', e);
                                    setTimeout(poll, pollInterval);
                                }
                            };
                            
                            await poll();
                            
                        } else {
                            // Immediate success (fallback or cached)
                            updateProgress(4);
                            showToast(`‚úÖ Analysis saved: ${docId}`, 'success');
                            Logger.info(`[AI] ‚úÖ Saved to Couchbase: ${docId}`);
                            
                            // Hide progress bar after delay
                            setTimeout(() => {
                                if (progressBar) progressBar.style.display = 'none';
                            }, 3000);
                            
                            setTimeout(() => loadAIAnalysisHistory(), 500);
                        }
                    } else {
                        updateProgress(1, true); // Error on sending/initial step
                        throw new Error(result.error || 'Save failed');
                    }
                } catch (error) {
                    Logger.error('[AI] ‚ùå Error during analysis:', error);
                    showToast(`‚ùå Analysis failed: ${error.message}`, 'error');
                    
                    // Ensure button is reset on error
                    const btn = document.getElementById('ai-analyze-btn');
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = originalBtnContent;
                    }
                    
                    // Keep progress bar visible but in error state for a bit
                    setTimeout(() => {
                        const progressBar = document.getElementById('ai-progress-bar');
                        if (progressBar) progressBar.style.display = 'none';
                    }, 5000);
                } 
                
                return; // Exit early for now (no AI call yet)
            }
            
            // TODO: Actual AI API call (when not saving)
            showToast('AI analysis feature coming soon!', 'info');
            Logger.warn('[AI] ‚ö†Ô∏è AI API call not yet implemented');
        }

        let aiHistoryCurrentPage = 1;
        let aiHistoryPageSize = 10;

        /**
         * Load AI analysis history from Couchbase
         */
        async function loadAIAnalysisHistory(page = 1) {
            aiHistoryCurrentPage = page;
            Logger.debug(`[AI] üìã Loading analysis history page ${page}`);
            
            const cbConfig = window.clusterConfig || (typeof clusterConfig !== 'undefined' ? clusterConfig : null);
            
            if (!cbConfig || !cbConfig.cluster) {
                Logger.debug('[AI] No Couchbase config - skipping history load');
                return;
            }
            
            try {
                const offset = (page - 1) * aiHistoryPageSize;
                
                const response = await fetch('/api/ai/history', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: cbConfig.cluster,
                        bucketConfig: cbConfig.bucketConfig,
                        limit: aiHistoryPageSize,
                        offset: offset
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.results) {
                    displayAIHistory(result.results, result.count); // Pass count of returned rows
                    Logger.info(`[AI] ‚úÖ Loaded ${result.count} analysis records (Page ${page})`);
                }
            } catch (error) {
                Logger.error('[AI] Error loading history:', error);
            }
        }
        
        /**
         * Get relative time string (e.g., "5 minutes ago")
         */
        function getRelativeTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffSeconds = Math.floor(diffMs / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            const diffDays = Math.floor(diffHours / 24);
            const diffWeeks = Math.floor(diffDays / 7);
            const diffMonths = Math.floor(diffDays / 30);
            
            if (diffSeconds < 60) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
            if (diffWeeks < 4) return `${diffWeeks} week${diffWeeks > 1 ? 's' : ''} ago`;
            return `${diffMonths} month${diffMonths > 1 ? 's' : ''} ago`;
        }
        
        /**
         * Truncate text with ellipsis
         */
        function truncateText(text, maxLength = 60) {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }
        
        /**
         * Display AI analysis history in table
         */
        function displayAIHistory(records, currentCount) {
            const tbody = document.getElementById('ai-history-list');
            if (!tbody) {
                Logger.warn('[AI] ai-history-list tbody not found');
                return;
            }
            
            Logger.debug(`[AI] Displaying ${records.length} history records`);
            Logger.debug(`[AI] tbody parent tab: ${tbody.closest('[data-report-section]')?.id}`);
            
            // Auto-expand the AI Analyzer History section if it has data
            if (records.length > 0) {
                Logger.debug('[AI] Attempting to auto-expand history section');
                const section = document.getElementById('ai-analyzer-history');
                const content = document.getElementById('ai-analyzer-history-content');
                Logger.debug(`[AI] Section found: ${!!section}, Content found: ${!!content}`);
                if (section && content) {
                    const title = section.querySelector('.category-title');
                    Logger.debug(`[AI] Title found: ${!!title}, Has collapsed class: ${title?.classList.contains('collapsed')}`);
                    if (title && title.classList.contains('collapsed')) {
                        title.classList.remove('collapsed');
                        content.classList.remove('collapsed');
                        Logger.debug('[AI] ‚úÖ Auto-expanded AI Analyzer History section');
                    } else {
                        Logger.debug('[AI] ‚ö†Ô∏è Section already expanded or title not found');
                    }
                } else {
                    Logger.warn('[AI] ‚ùå Could not find section or content elements');
                }
            }
            
            // Update table headers to center text (find the table that contains our tbody)
            const table = tbody.closest('table');
            if (table) {
                const headers = table.querySelectorAll('thead th');
                headers.forEach(th => {
                    th.style.textAlign = 'center';
                });
            }
            
            tbody.innerHTML = '';
            tbody.setAttribute('data-last-update', new Date().toISOString());
            
            Logger.debug(`[AI] Building ${records.length} table rows`);
            
            records.forEach(record => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #dee2e6';
                
                const exactTime = new Date(record.createdAt).toLocaleString();
                const relativeTime = getRelativeTime(record.createdAt);
                const sourceCluster = record.sourceCluster || '<span style="color: #999;">N/A</span>';
                
                // Obfuscation badge
                const isObfuscated = record.metadata?.obfuscated;
                const obfuscatedBadge = isObfuscated 
                    ? '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">Yes</span>'
                    : '<span style="background: #dc3545; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">No</span>';
                
                const providerBadge = getProviderBadge(record.provider);
                const statusBadge = getStatusBadge(record.status);
                const dataIncluded = formatDataIncluded(record.metadata?.selections);
                
                const promptFull = record.prompt || 'N/A';
                const promptShort = truncateText(promptFull, 60);
                
                row.innerHTML = `
                    <td style="padding: 10px; border: 1px solid #dee2e6;" title="${exactTime}">${relativeTime}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6; font-weight: 500;">${sourceCluster}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">${obfuscatedBadge}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6;">${providerBadge}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6;" title="${promptFull}">${promptShort}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6;">${dataIncluded}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6;">${statusBadge}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">
                        <button class="btn-standard" style="font-size: 11px; padding: 4px 8px;" onclick="viewAnalysis('${record.documentId}')">View</button>
                        <button class="btn-standard" style="font-size: 11px; padding: 4px 8px; margin-left: 4px; background-color: #dc3545; color: white; display: inline-flex; align-items: center; vertical-align: middle;" onclick="deleteAnalysis('${record.documentId}', this)" title="Delete Analysis">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            Logger.debug(`[AI] ‚úÖ Table now has ${tbody.children.length} rows`);
            
            // Check if rows persist after 500ms
            setTimeout(() => {
                Logger.debug(`[AI] üîç After 500ms, table has ${tbody.children.length} rows`);
                if (tbody.children.length === 0) {
                    Logger.warn('[AI] ‚ö†Ô∏è Rows were CLEARED after being added!');
                }
            }, 500);

            // Update pagination controls
            addAIHistoryPaginationControls(currentCount);
        }

        function addAIHistoryPaginationControls(currentCount) {
            const paginationDiv = document.getElementById('ai-history-pagination');
            if (!paginationDiv) return;
            
            paginationDiv.innerHTML = '';
            
            // Prev button
            const prevButton = document.createElement('button');
            prevButton.className = 'btn-standard';
            prevButton.textContent = '‚óÄ Prev';
            prevButton.style.margin = '0 5px';
            prevButton.disabled = aiHistoryCurrentPage === 1;
            prevButton.onclick = () => {
                if (aiHistoryCurrentPage > 1) {
                    loadAIAnalysisHistory(aiHistoryCurrentPage - 1);
                }
            };
            if (prevButton.disabled) prevButton.style.opacity = '0.5';
            
            // Page info
            const pageInfo = document.createElement('span');
            pageInfo.textContent = ` Page ${aiHistoryCurrentPage} `;
            pageInfo.style.margin = '0 15px';
            pageInfo.style.fontWeight = 'bold';
            
            // Next button
            const nextButton = document.createElement('button');
            nextButton.className = 'btn-standard';
            nextButton.textContent = 'Next ‚ñ∂';
            nextButton.style.margin = '0 5px';
            // Disable if we got fewer records than page size (end of list)
            nextButton.disabled = !currentCount || currentCount < aiHistoryPageSize;
            nextButton.onclick = () => {
                loadAIAnalysisHistory(aiHistoryCurrentPage + 1);
            };
            if (nextButton.disabled) nextButton.style.opacity = '0.5';
            
            paginationDiv.appendChild(prevButton);
            paginationDiv.appendChild(pageInfo);
            paginationDiv.appendChild(nextButton);
        }
        
        function getProviderBadge(provider) {
            const badges = {
                'openai': '<span style="background: #10a37f; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">OpenAI</span>',
                'anthropic': '<span style="background: #d97706; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">Anthropic</span>',
                'grok': '<span style="background: #000000; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">Grok</span>'
            };
            return badges[provider] || `<span>${provider}</span>`;
        }
        
        function getStatusBadge(status) {
            if (status === 'completed') {
                return '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">‚úì Complete</span>';
            } else if (status === 'failed') {
                return '<span style="background: #dc3545; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">‚úó Failed</span>';
            } else if (status === 'pending' || status === 'submitted') {
                return '<span style="background: #ffc107; color: #212529; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">‚è≥ Pending</span>';
            }
            return '<span>Unknown</span>';
        }
        
        function formatDataIncluded(selections) {
            if (!selections) return 'N/A';
            const included = [];
            if (selections.dashboard) included.push('Dashboard');
            if (selections.insights) included.push('Insights');
            if (selections.query_groups) included.push('Query Groups');
            if (selections.indexes) included.push('Indexes');
            if (selections.flow_diagram) included.push('Flow');
            return included.join(', ') || 'None';
        }
        
        function viewAnalysis(docId) {
            Logger.info(`[AI] Viewing analysis: ${docId}`);
            showToast(`View analysis: ${docId}`, 'info');
            // TODO: Load and display full analysis
        }
        
        // Load history when AI Analyzer or Reports/History tab is opened
        document.addEventListener('DOMContentLoaded', function() {
            $('#tabs').on('tabsactivate', function(event, ui) {
                const tabId = ui.newPanel.attr('id');
                
                if (tabId === 'ai-analyzer') {
                    populateAIProviderDropdown();
                    loadAIAnalysisHistory();
                } else if (tabId === 'reports-history') {
                    loadAIAnalysisHistory();
                }
            });
        });

        // Make functions globally accessible
        window.showAIPreview = showAIPreview;
        window.closeAIPreview = closeAIPreview;
        window.copyAIPreviewJSON = copyAIPreviewJSON;
        window.openMermaidLive = openMermaidLive;
        window.analyzeWithAI = analyzeWithAI;
        window.loadAIAnalysisHistory = loadAIAnalysisHistory;
        window.viewAnalysis = viewAnalysis;
        window.deleteAnalysis = deleteAnalysis;

        /**
         * Populate AI provider dropdown from user config
         */
        async function populateAIProviderDropdown() {
            Logger.debug('[AI] Populating AI provider dropdown');

            const dropdown = document.getElementById('ai-provider-select');
            if (!dropdown) return;
            
            // Get CB config
            const cbConfig = window.clusterConfig || (typeof clusterConfig !== 'undefined' ? clusterConfig : null);
            
            if (!cbConfig || !cbConfig.cluster) {
                dropdown.innerHTML = '<option value="">‚ö†Ô∏è Configure Couchbase in Settings first</option>';
                Logger.warn('[AI] No Couchbase config - cannot load AI providers');
                return;
            }

            try {
                // Load preferences from Couchbase
                const response = await fetch('/api/couchbase/load-preferences/user_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: cbConfig.cluster,
                        bucketConfig: cbConfig.bucketConfig
                    })
                });
                
                const result = await response.json();
                
                if (!result.success || !result.data || !result.data.aiApis) {
                    dropdown.innerHTML = '<option value="">‚ö†Ô∏è No AI providers configured</option>';
                    Logger.warn('[AI] No aiApis found in preferences');
                    return;
                }
                
                const aiApis = result.data.aiApis;
                dropdown.innerHTML = '<option value="">-- Select AI Provider --</option>';
                
                let hasUsableProvider = false;

                aiApis.forEach((api, index) => {
                    const hasApiKey = api.apiKey && api.apiKey.length > 0;
                    const status = hasApiKey ? '‚úÖ' : '‚ùå';
                    const defaultTag = index === 0 ? ' (Default)' : '';
                    const modelInfo = api.model ? ` - ${api.model}` : '';

                    const option = document.createElement('option');
                    option.value = api.id;
                    option.textContent = `${status} ${api.name}${defaultTag}${modelInfo}`;
                    option.disabled = !hasApiKey;
                    
                    // Store full API config as data attribute
                    option.dataset.apiUrl = api.apiUrl;
                    option.dataset.model = api.model;
                    option.dataset.apiKey = api.apiKey;

                    if (hasApiKey) {
                        hasUsableProvider = true;
                        if (index === 0) {
                            option.selected = true;
                        }
                    }

                    dropdown.appendChild(option);
                });
                
                Logger.info(`[AI] Dropdown populated: ${aiApis.length} providers, ${hasUsableProvider ? 'HAS' : 'NO'} usable keys`);
                
            } catch (error) {
                Logger.error('[AI] Error loading AI providers:', error);
                dropdown.innerHTML = '<option value="">‚ö†Ô∏è Error loading providers</option>';
            }
        }

        window.populateAIProviderDropdown = populateAIProviderDropdown;

        /**
         * Delete AI analysis
         */
        async function deleteAnalysis(docId, buttonEl) {
            if (!confirm('Are you sure you want to delete this analysis history? This cannot be undone.')) {
                return;
            }
            
            Logger.info(`[AI] Deleting analysis: ${docId}`);
            
            const cbConfig = window.clusterConfig || (typeof clusterConfig !== 'undefined' ? clusterConfig : null);
            
            if (!cbConfig) {
                showToast('Cannot delete analysis - Couchbase not configured', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/couchbase/delete-analyzer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: cbConfig.cluster,
                        bucketConfig: cbConfig.bucketConfig,
                        requestId: docId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showToast('Analysis deleted successfully', 'success');
                    
                    // Remove row from DOM immediately
                    if (buttonEl) {
                        const row = buttonEl.closest('tr');
                        if (row) {
                            row.remove();
                            Logger.debug('[AI] Removed deleted row from table');
                        }
                    } else {
                        // Fallback if button element not passed
                        loadAIAnalysisHistory();
                    }
                } else {
                    showToast(`Failed to delete: ${result.error || 'Unknown error'}`, 'error');
                }
                
            } catch (error) {
                Logger.error('[AI] Error deleting analysis:', error);
                showToast(`Error deleting analysis: ${error.message}`, 'error');
            }
        }

        /**
         * View saved AI analysis in full-screen overlay
         */
        async function viewAnalysis(docId) {
            Logger.info(`[AI] Loading analysis: ${docId}`);
            
            const cbConfig = window.clusterConfig || (typeof clusterConfig !== 'undefined' ? clusterConfig : null);
            
            if (!cbConfig) {
                showToast('Cannot load analysis - Couchbase not configured', 'error');
                return;
            }
            
            try {
                // Fetch full document
                const response = await fetch(`/api/couchbase/load-analyzer/${docId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: cbConfig.cluster,
                        bucketConfig: cbConfig.bucketConfig
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.data) {
                    displayAIAnalysis(result.data);
                } else {
                    throw new Error(result.error || 'Failed to load');
                }
            } catch (error) {
                Logger.error('[AI] Error loading analysis:', error);
                showToast(`Failed to load: ${error.message}`, 'error');
            }
        }
        
        /**
         * Display AI analysis in overlay
         */
        function displayAIAnalysis(doc) {
            const overlay = document.getElementById('ai-view-overlay');
            const contextDiv = document.getElementById('ai-view-context');
            const responseDiv = document.getElementById('ai-view-response');
            const statsSpan = document.getElementById('ai-view-stats');
            
            if (!overlay || !contextDiv || !responseDiv) return;
            
            // Build context HTML
            const ctx = doc.parseJson || {};
            const meta = doc.metadata || {};
            
            contextDiv.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="color: #ffc107; font-weight: bold; margin-bottom: 8px;">üìÖ Request Info</div>
                    <div style="margin-left: 10px;">
                        <div>Date: ${new Date(doc.createdAt).toLocaleString()}</div>
                        <div>Provider: <span style="background: #000; color: #fff; padding: 2px 6px; border-radius: 4px;">${doc.provider}</span></div>
                        <div>Model: ${doc.model}</div>
                        <div>Status: <span style="color: ${doc.status === 'completed' ? '#28a745' : '#dc3545'}; font-weight: bold;">${doc.status}</span></div>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="color: #007bff; font-weight: bold; margin-bottom: 6px; font-size: 13px;">üí¨ Prompt</div>
                    <div style="margin-left: 10px; background: #f8f9fa; padding: 8px; border-radius: 4px; border-left: 3px solid #007bff; font-size: 12px; line-height: 1.5;">
                        ${doc.prompt || 'N/A'}
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="color: #007bff; font-weight: bold; margin-bottom: 6px; font-size: 13px;">üîß Filters Applied</div>
                    <div style="margin-left: 10px;">
                        <div>Timezone: ${ctx.filters?.timezone || 'N/A'}</div>
                        <div>Date Range: ${ctx.filters?.date_range?.from || 'N/A'} ‚Üí ${ctx.filters?.date_range?.to || 'N/A'}</div>
                        <div>SQL Filter: ${ctx.filters?.sql_statement || 'None'}</div>
                        <div>Time Filter: ${ctx.filters?.elapsed_time || 'None'}</div>
                        <div>Collection: ${ctx.filters?.collection || 'All'}</div>
                        <div>Exclude System: ${ctx.filters?.exclude_system ? 'Yes' : 'No'}</div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="color: #ffc107; font-weight: bold; margin-bottom: 8px;">üìÇ Data Sources</div>
                    <div style="margin-left: 10px;">
                        <div>Queries: ${ctx.data_sources?.completed_requests?.record_count || 0} (${ctx.data_sources?.completed_requests?.source || 'N/A'})</div>
                        <div>Indexes: ${ctx.data_sources?.indexes?.record_count || 0} (${ctx.data_sources?.indexes?.source || 'N/A'})</div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="color: #ffc107; font-weight: bold; margin-bottom: 8px;">üìä Metrics</div>
                    <div style="margin-left: 10px;">
                        <div>Payload Size: ${(meta.requestPayloadSize / 1024).toFixed(2)} KB</div>
                        <div>Response Size: ${(meta.responsePayloadSize / 1024).toFixed(2)} KB</div>
                        <div>AI Time: ${(meta.elapsed_ms / 1000).toFixed(2)}s</div>
                        <div>Obfuscated: ${meta.obfuscated ? 'Yes' : 'No'}</div>
                    </div>
                </div>
            `;
            
            // Parse and display AI response
            const aiResponse = doc.aiResponse;
            let analysisData;
            
            if (typeof aiResponse === 'object' && aiResponse.choices) {
                // OpenAI/Grok format - try content_parsed first
                const message = aiResponse.choices[0]?.message || {};
                
                if (message.content_parsed) {
                    analysisData = message.content_parsed;
                } else {
                    try {
                        const content = message.content || '';
                        analysisData = JSON.parse(content);
                    } catch (e) {
                        responseDiv.innerHTML = `<div style="color: #dc3545;">Error parsing AI response</div><pre>${message.content}</pre>`;
                        overlay.style.display = 'block';
                        return;
                    }
                }
            } else {
                analysisData = aiResponse;
            }
            
            // Render formatted HTML response
            responseDiv.innerHTML = formatAIAnalysisHTML(analysisData);
            
            // Stats
            if (statsSpan) {
                const tokens = aiResponse.usage?.total_tokens || 0;
                statsSpan.textContent = `Tokens: ${tokens.toLocaleString()}`;
            }
            
            overlay.style.display = 'block';
            Logger.info('[AI] ‚úÖ Analysis view displayed');
        }
        
        function closeAIView() {
            const overlay = document.getElementById('ai-view-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }
        
        function copyAIResponse() {
            const responseDiv = document.getElementById('ai-view-response');
            if (!responseDiv) return;
            
            navigator.clipboard.writeText(responseDiv.textContent).then(() => {
                showToast('AI response copied!', 'success');
            }).catch(err => {
                showToast('Failed to copy', 'error');
            });
        }
        
        window.closeAIView = closeAIView;
        window.copyAIResponse = copyAIResponse;

        /**
         * Format AI analysis data as HTML
         */
        function formatAIAnalysisHTML(data) {
            let html = '';
            
            // Analysis Summary - New Section
            if (data.analysis_summary && data.analysis_summary.overview_html) {
                html += `<div style="background: #f8f9fa; padding: 12px 15px; border-radius: 4px; margin-bottom: 15px; border-left: 4px solid #6c757d;">
                    <h4 style="color: #495057; margin: 0 0 10px 0; font-size: 16px;">üìã Analysis Summary</h4>
                    <div style="font-size: 13px; line-height: 1.5; color: #333;">
                        ${data.analysis_summary.overview_html}
                    </div>
                </div>`;
            }
            
            // Summary - Compact
            if (data.summary) {
                html += `<div style="background: #fff3cd; padding: 10px 12px; border-radius: 4px; margin-bottom: 12px; border-left: 3px solid #ffc107;">
                    <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 13px;">
                        <div>Total: <strong>${data.summary.total_queries_analyzed || 0}</strong> queries</div>
                        <div>Issues: <span class="severity-critical">${data.summary.critical_issues_found || 0}</span></div>
                        <div>Rating: <span class="severity-${data.summary.performance_rating}">${data.summary.performance_rating || 'N/A'}</span></div>
                        <div>Potential: <strong>${data.summary.estimated_improvement_potential || 'N/A'}</strong></div>
                    </div>
                </div>`;
            }
            
            // Critical Issues - Compact
            if (data.critical_issues && data.critical_issues.length > 0) {
                html += `<div style="margin-bottom: 12px;">
                    <h4 style="color: #dc3545; margin: 0 0 8px 0; font-size: 15px;">üö® Critical Issues (${data.critical_issues.length})</h4>`;
                
                data.critical_issues.forEach((issue, idx) => {
                    const priorityNum = issue.priority_number || issue.priority || '?';
                    
                    html += `<div style="background: #fff; padding: 10px; border-radius: 4px; margin-bottom: 8px; border-left: 3px solid #dc3545; border: 1px solid #f8d7da;">
                        <div style="margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                            <div><strong style="font-size: 14px;">${idx + 1}. ${issue.title}</strong></div>
                            <div style="display: flex; gap: 6px; align-items: center;">
                                <span style="background: #000; color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold;">P${priorityNum}/10</span>
                                <span class="severity-${issue.severity}" style="font-size: 10px;">${issue.severity.toUpperCase()}</span>
                            </div>
                        </div>
                        <div style="margin-bottom: 6px; font-size: 12px; line-height: 1.4;">${issue.description_html || issue.description || ''}</div>
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; font-size: 12px; margin-bottom: 6px;">
                            <div><strong>Affected:</strong></div><div>${issue.affected_queries || 0} queries</div>
                            <div><strong>Fix:</strong></div><div>${issue.recommendation || ''}</div>
                            <div><strong>Impact:</strong></div><div>${issue.expected_impact || ''}</div>
                        </div>
                        ${issue.sources ? '<div style="font-size: 10px; color: #666; padding: 6px; background: #f8f9fa; border-radius: 3px; margin-top: 6px;"><strong>üìç Sources:</strong> ' + issue.sources.map(s => `<span style="display: inline-block; margin: 2px 4px; padding: 2px 6px; background: #e9ecef; border-radius: 2px;">${s.location}</span>`).join('') + '</div>' : ''}
                    </div>`;
                });
                
                html += '</div>';
            }
            
            // Recommendations - Compact
            if (data.recommendations && data.recommendations.length > 0) {
                html += `<div style="margin-bottom: 12px;">
                    <h4 style="color: #28a745; margin: 0 0 8px 0; font-size: 15px;">üí° Recommendations (${data.recommendations.length})</h4>`;
                
                data.recommendations.forEach((rec, idx) => {
                    html += `<div style="background: #fff; padding: 10px; border-radius: 4px; margin-bottom: 8px; border-left: 3px solid #28a745; border: 1px solid #d4edda;">
                        <div style="margin-bottom: 6px; font-size: 13px;"><strong>${idx + 1}. ${rec.recommendation_html || rec.recommendation || ''}</strong></div>
                        <div style="margin-bottom: 6px; font-size: 12px; line-height: 1.4;">${rec.rationale_html || rec.rationale || ''}</div>
                        ${rec.implementation_steps ? '<div style="margin-bottom: 6px; font-size: 12px;"><strong>Steps:</strong><ol style="margin: 4px 0 0 18px; padding: 0;">' + rec.implementation_steps.map(s => `<li style="margin: 2px 0;">${s}</li>`).join('') + '</ol></div>' : ''}
                        <div style="font-size: 12px;"><strong>Impact:</strong> ${rec.estimated_impact || ''}</div>
                    </div>`;
                });
                
                html += '</div>';
            }
            
            // Next Steps - Compact
            if (data.next_steps && data.next_steps.length > 0) {
                html += `<div style="background: #e7f3ff; padding: 10px 12px; border-radius: 4px; border-left: 3px solid #007bff;">
                    <h4 style="color: #007bff; margin: 0 0 8px 0; font-size: 14px;">üéØ Next Steps</h4>
                    <ol style="margin: 0; padding-left: 18px; font-size: 12px;">
                        ${data.next_steps.map(step => `<li style="margin: 4px 0;">${step}</li>`).join('')}
                    </ol>
                </div>`;
            }
            
            return html || '<div style="color: #999;">No formatted content available</div>';
        }
        
        window.formatAIAnalysisHTML = formatAIAnalysisHTML;

        // Add event listener for cluster name input to toggle analyze button
        document.addEventListener('DOMContentLoaded', function() {
            const clusterInput = document.getElementById('ai-cluster-name');
            const analyzeBtn = document.getElementById('ai-analyze-btn');
            
            if (clusterInput && analyzeBtn) {
                // Initial check
                analyzeBtn.disabled = !clusterInput.value.trim();
                if (analyzeBtn.disabled) {
                    analyzeBtn.style.opacity = '0.6';
                    analyzeBtn.style.cursor = 'not-allowed';
                    analyzeBtn.title = 'Please enter a Cluster Name first';
                }
                
                // Update on input
                clusterInput.addEventListener('input', function() {
                    const hasValue = this.value.trim().length > 0;
                    analyzeBtn.disabled = !hasValue;
                    
                    if (hasValue) {
                        analyzeBtn.style.opacity = '1';
                        analyzeBtn.style.cursor = 'pointer';
                        analyzeBtn.title = '';
                    } else {
                        analyzeBtn.style.opacity = '0.6';
                        analyzeBtn.style.cursor = 'not-allowed';
                        analyzeBtn.title = 'Please enter a Cluster Name first';
                    }
                });

                // Initialize jQuery UI Autocomplete
                if (typeof $ !== 'undefined' && $.fn.autocomplete) {
                    $(clusterInput).autocomplete({
                        source: function(request, response) {
                            const cbConfig = window.clusterConfig || (typeof clusterConfig !== 'undefined' ? clusterConfig : null);
                            if (!cbConfig) return response([]);
                            
                            fetch('/api/ai/clusters', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    config: cbConfig.cluster,
                                    bucketConfig: cbConfig.bucketConfig,
                                    term: request.term
                                })
                            })
                            .then(res => res.json())
                            .then(data => {
                                if (data.success) {
                                    response(data.results);
                                } else {
                                    response([]);
                                }
                            })
                            .catch(err => {
                                console.error('Error fetching clusters:', err);
                                response([]);
                            });
                        },
                        minLength: 0, // Allow showing list on focus
                        delay: 300,
                        select: function(event, ui) {
                            // Trigger input event manually to update button state
                            this.value = ui.item.value;
                            this.dispatchEvent(new Event('input'));
                        }
                    }).focus(function() {
                        // Trigger search on focus to show recent history if empty
                        // Or just show recent 10 always
                        $(this).autocomplete("search", $(this).val());
                    });
                }
            }
        });
