<!DOCTYPE html>
<html lang="pt">
<!--
    Couchbase Query Analyzer
    Version: 3.6.2
    Last Updated: 2025-08-23
    
    🤖 AI AGENT NOTE: When updating versions, follow the detailed guide in settings/VERSION_UPDATE_GUIDE.md
    This guide covers all HTML elements, JavaScript variables, and documentation files that need updating.
    
    Use semantic versioning: MAJOR.MINOR.PATCH
    - MAJOR: Breaking changes or complete rewrites
    - MINOR: New features, significant enhancements  
    - PATCH: Bug fixes, small improvements
    
    🌍 LOCALIZATION NOTE: This file has Spanish (es_index.html), Portuguese (pt_index.html), and German (de_index.html) versions.
    When making changes to index.html, please also update all localized versions to maintain sync.
    See LOCALIZATION_GUIDE.md and translations.json for detailed instructions.
-->

<head>
    <meta charset="UTF-8" />
    <meta name="version" content="3.8.0" />
    <meta name="last-updated" content="2025-08-27" />
    <title>Analisador de Consultas v3.8.0</title>
    <!-- Include jQuery UI CSS -->
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.0/themes/base/jquery-ui.css?v=362" />
    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0?v=362"></script>
    <!-- Include Chart.js datetime adapter -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js?v=362"></script>
    <!-- Include Chart.js zoom plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js?v=362"></script>
    <!-- Include Hammer.js for touch/gesture support -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8?v=362"></script>
    <!-- Include DOMPurify for security -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js?v=362"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5
        }

        #input-section {
            margin-bottom: 20px
        }

        textarea {
            width: 100%;
            height: 50px;
            margin-bottom: 10px
        }

        #tabs {
            flex: 1;
            overflow: auto
        }

        #every-query,
        #analysis {
            display: flex;
            flex-direction: column;
            height: 100%
        }

        #flow-diagram-section,
        #charts-placeholder {
            flex: 0 0 250px;
            overflow: auto;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #fff
        }

        #flow-diagram {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center
        }

        .step-bubble {
            border: 1px solid #000;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            cursor: pointer
        }

        .step-bubble p {
            margin: 5px 0;
            line-height: 1
        }

        .index-item {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1)
        }

        .index-item.primary {
            background: #ffe6e6;
            border-color: #ff9999
        }

        .index-item h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: bold;
            color: #333
        }

        .index-item .index-details {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px
        }

        .index-item .index-statement {
            font-family: monospace;
            font-size: 11px;
            background: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #007bff;
            word-wrap: break-word;
            position: relative
        }

        .bucket-group {
            margin-bottom: 20px
        }

        .bucket-group h3 {
            background: #e9ecef;
            padding: 8px 12px;
            margin: 0 0 10px 0;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            color: #495057
        }

        .state-badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase
        }

        .state-online {
            background: #d4edda;
            color: #155724
        }

        .state-offline {
            background: #f8d7da;
            color: #721c24
        }

        .state-building {
            background: #fff3cd;
            color: #856404
        }

        .replica-zero {
            color: #dc3545;
            font-weight: bold
        }

        .copy-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer
        }

        .copy-btn:hover {
            background: #0056b3
        }

        .primary-warning {
            color: #dc3545;
            font-weight: bold
        }

        .used-badge {
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 8px;
            text-transform: uppercase
        }

        .sql-query-box {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            position: relative
        }

        .sql-query-box pre {
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto
        }

        .sql-copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer
        }

        .sql-copy-btn:hover {
            background: #0056b3
        }

        .green {
            background-color: #d4edda
        }

        .yellow {
            background-color: #fff3cd
        }

        .orange {
            background-color: #ffe5d0
        }

        .red {
            background-color: #f8d7da
        }

        .connector {
            width: 20px;
            height: 2px;
            background-color: #000
        }

        .index-item,
        .query-item {
            border: 2px solid #007bff;
            border-radius: 12px;
            padding: 12px;
            margin: 10px 40px 10px 0;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: move;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s
        }

        .index-item:hover,
        .query-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15)
        }

        .index-item.primary {
            background-color: #ffebee;
            border-color: #f44336
        }

        .index-stats {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
            line-height: 1.3
        }

        .query-text {
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            max-height: 60px;
            overflow: hidden;
            position: relative
        }

        .query-text.expanded {
            max-height: none
        }

        .query-controls {
            margin-top: 8px;
            display: flex;
            gap: 8px
        }

        .query-controls button:not(.btn-standard) {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px
        }

        .query-controls button:not(.btn-standard):hover {
            background: #f0f0f0
        }

        .usage-count {
            background: white;
            border: 1px solid #333;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            border-radius: 3px;
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 10
        }

        #table-section,
        #analysis-table-section {
            flex: 1;
            overflow-y: auto
        }

        #table-container,
        #analysis-table-container {
            overflow-x: auto
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #fff
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center
        }

        th {
            background-color: #f2f2f2;
            cursor: pointer;
            user-select: none
        }

        th:hover {
            background-color: #e8e8e8
        }

        .sort-arrow {
            margin-left: 5px;
            font-size: 12px;
            color: #666
        }

        tr:hover {
            background-color: #f1f1f1;
            cursor: pointer
        }

        .primary-scan-yes {
            font-weight: bold !important;
            color: red !important
        }

        .fatal-state {
            font-weight: bold;
            color: red
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4)
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer
        }

        #plan-modal-body ul {
            list-style-type: none;
            padding-left: 20px
        }

        #plan-modal-body li {
            margin-bottom: 5px
        }

        #operator-modal-body dl {
            margin: 0
        }

        #operator-modal-body dt {
            font-weight: bold
        }

        #operator-modal-body dd {
            margin-left: 20px
        }

        #operator-modal-body,
        #plan-modal-body {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text
        }

        #operator-modal-body *,
        #plan-modal-body * {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text
        }

        .btn-standard {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            margin: 2px;
            font-weight: normal;
            text-transform: none
        }

        .btn-standard:hover {
            background: #0056b3
        }

        .btn-standard:active {
            background: #004494
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.3s ease
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0)
        }

        .toast.error {
            background: #dc3545
        }

        .version-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.1);
            color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-family: monospace;
            z-index: 999;
            opacity: 0.7;
            transition: opacity 0.3s ease
        }

        .version-info:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.2)
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            grid-template-rows: 300px
        }

        .dashboard-tables-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px
        }

        .chart-container {
            background: white;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            height: 400px;
            overflow: hidden
        }

        .chart-container.with-margin-top-20 {
            margin-top: 20px
        }

        .table-container {
            background: white;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px
        }

        .table-container.with-margin-top-40 {
            margin-top: 40px
        }

        .chart-title {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center
        }

        .chart-title.fixed-height {
            height: 30px
        }

        .table-scroll {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #eee
        }

        .table-header {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #ddd;
            width: 80px
        }

        .note-text {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            text-align: center;
            font-style: italic
        }

        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px
        }

        .button-row {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap
        }

        .progress-container {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
            height: 20px;
            width: 200px;
            overflow: hidden;
            position: relative
        }

        .progress-bar {
            background-color: #007bff;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: #333
        }

        .flex-row {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .flex-row-small {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px
        }

        .flex-row-5px {
            display: flex;
            gap: 5px;
            align-items: center
        }

        .flex-row-20px {
            display: flex;
            gap: 20px;
            margin-bottom: 20px
        }

        .height-250-relative {
            height: 250px;
            position: relative
        }

        .height-400-flex {
            flex: 1;
            height: 400px;
            position: relative
        }

        .flex-1 {
            flex: 1
        }

        .margin-top-5 {
            margin-top: 5px
        }

        .margin-top-5-right-5 {
            margin-top: 5px;
            margin-right: 5px
        }

        .margin-left-10 {
            margin-left: 10px
        }

        .margin-0 {
            margin: 0
        }

        .margin-bottom-30 {
            margin-bottom: 30px
        }

        .font-bold {
            font-weight: bold
        }

        .font-bold-block {
            font-weight: bold;
            display: block;
            margin-bottom: 5px
        }

        .font-bold-margin-right {
            font-weight: bold;
            margin-right: 5px
        }

        .text-muted {
            color: #6c757d;
            font-weight: 500
        }

        .input-full {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px
        }

        .input-250 {
            width: 250px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px
        }

        .input-200 {
            width: 200px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 0.8em
        }

        .card-white {
            background: white;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #e9ecef
        }

        .table-full {
            width: 100%;
            border-collapse: collapse
        }

        .text-center-margin-top-30 {
            text-align: center;
            margin-top: 30px
        }

        .label-flex {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 15px
        }

        .chart-flex-container {
            display: flex;
            height: 250px;
            gap: 15px
        }

        #progress-container {
            display: none;
            margin: 10px 15px
        }

        #filter-info {
            color: #666;
            font-size: 0.9em
        }

        .progress-background {
            background-color: #f0f0f0;
            border-radius: 5px;
            height: 20px;
            position: relative
        }

        .progress-bar-fill {
            background-color: #4caf50;
            height: 100%;
            border-radius: 5px;
            width: 0%;
            transition: width 0.3s ease
        }

        .progress-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            font-weight: bold
        }

        .checkbox-label-text {
            font-size: 0.9em;
            user-select: none;
            cursor: pointer
        }

        .warning-box {
            flex: 0 0 200px;
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            display: none;
            flex-direction: column;
            justify-content: center
        }

        .warning-title {
            text-align: center;
            color: #ff6b35;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px
        }

        .warning-text {
            color: #333;
            font-size: 13px;
            line-height: 1.4;
            text-align: center
        }

        .warning-text-highlight {
            color: #dc3545;
            font-weight: bold
        }

        .warning-link-container {
            margin-top: 10px;
            text-align: center
        }

        .warning-link {
            color: #007bff;
            text-decoration: none;
            font-size: 12px;
            font-weight: bold
        }

        .pattern-analysis-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
            grid-template-rows: 400px
        }

        .height-350-relative {
            height: 350px;
            position: relative
        }

        .sticky-header {
            position: sticky;
            top: 0;
            background: #f5f5f5
        }

        .table-header-cell {
            font-weight: bold;
            text-align: center;
            padding: 12px 8px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            user-select: none;
            cursor: pointer
        }

        .table-subheader {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            text-align: center;
            font-style: italic
        }

        .padding-8 {
            padding: 8px
        }

        .padding-5 {
            padding: 5px
        }

        .padding-15 {
            padding: 15px
        }

        .border-bottom {
            border-bottom: 1px solid #ddd
        }

        .text-align-center {
            text-align: center
        }

        .width-100 {
            width: 100%
        }

        .width-80px {
            width: 80px
        }

        .width-300px {
            width: 300px
        }

        .position-sticky-top {
            position: sticky;
            top: 0
        }

        .background-f5 {
            background: #f5f5f5
        }

        .overflow-hidden {
            overflow: hidden
        }

        .cursor-pointer {
            cursor: pointer
        }

        .user-select-none {
            user-select: none
        }

        .font-size-12 {
            font-size: 12px
        }

        .font-size-11 {
            font-size: 11px
        }

        .margin-bottom-15 {
            margin-bottom: 15px
        }

        .margin-bottom-10 {
            margin-bottom: 10px
        }

        .margin-bottom-5 {
            margin-bottom: 5px
        }

        .margin-right-10 {
            margin-right: 10px
        }

        .vertical-align-top {
            vertical-align: top
        }

        .display-none {
            display: none
        }

        .max-width-500 {
            max-width: 500px
        }

        .background-white {
            background: white
        }

        .border-none {
            border: none
        }

        .border-radius-3 {
            border-radius: 3px
        }

        .color-666 {
            color: #666
        }

        .gap-10 {
            gap: 10px
        }

        .gap-15 {
            gap: 15px
        }

        .gap-20 {
            gap: 20px
        }

        .margin-bottom-20 {
            margin-bottom: 20px
        }

        .margin-left-8 {
            margin-left: 8px
        }

        .margin-left-20 {
            margin-left: 20px
        }

        .margin-left-30 {
            margin-left: 30px
        }

        .overflow-auto {
            overflow: auto
        }

        .position-relative {
            position: relative
        }

        .display-flex {
            display: flex
        }

        .display-flex-center {
            display: flex;
            align-items: center
        }

        .display-flex-wrap {
            display: flex;
            flex-wrap: wrap
        }

        .height-100 {
            height: 100%
        }

        .height-300 {
            height: 300px
        }

        .height-400 {
            height: 400px
        }

        .width-90 {
            width: 90%
        }

        .width-250 {
            width: 250px
        }

        .width-200 {
            width: 200px
        }

        .flex-1-height-400 {
            flex: 1;
            height: 400px;
            position: relative
        }

        .form-input {
            width: 250px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px
        }

        .form-input-small {
            width: 200px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px
        }

        .btn-gray {
            padding: 5px 15px;
            background: #6c757d;
            color: white
        }

        .background-f8 {
            background: #f8f9fa
        }

        .border-radius-8 {
            border-radius: 8px
        }

        .border-radius-6 {
            border-radius: 6px
        }

        .border-radius-4 {
            border-radius: 4px
        }

        .z-index-1 {
            z-index: 1
        }

        .z-index-2 {
            z-index: 2
        }

        .z-index-3 {
            z-index: 3
        }

        .padding-10-20 {
            padding: 10px 20px
        }

        .padding-4-8 {
            padding: 4px 8px
        }

        .font-size-14 {
            font-size: 14px
        }

        .font-size-0-8em {
            font-size: 0.8em
        }

        .calc-height-minus-50 {
            height: calc(100% - 50px)
        }

        .position-absolute {
            position: absolute
        }

        .top-0 {
            top: 0
        }

        .left-0 {
            left: 0
        }

        .pointer-events-none {
            pointer-events: none
        }

        .border-1-ddd {
            border: 1px solid #ddd
        }

        .border-1-ccc {
            border: 1px solid #ccc
        }

        .justify-space-between {
            justify-content: space-between
        }

        .align-center {
            align-items: center
        }

        .color-333 {
            color: #333
        }

        .grid-2-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 300px
        }

        .chart-card {
            background: white;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            height: 300px;
            overflow: hidden
        }

        .chart-card-header {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            height: 30px
        }

        .chart-card-content {
            height: 250px;
            position: relative
        }
    </style>
    <style>
        /* Larger Parse JSON Button */
        #parse-json-btn {
            font-size: 18px !important;
            padding: 12px 24px !important;
            font-weight: bold !important;
            background: #28a745 !important;
            color: white !important;
            border: none !important;
            border-radius: 8px !important;
            cursor: pointer !important;
            transition: all 0.3s ease !important;
        }

        #parse-json-btn:hover {
            background: #1e7e34 !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2) !important;
        }

        #parse-json-btn:active {
            transform: translateY(0) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
        }

        /* Fix text selection in table cells */
        table td,
        table th {
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        /* Ensure table rows still have pointer cursor but allow text selection */
        table tr {
            cursor: pointer;
        }

        table tr:hover {
            background-color: #f1f1f1;
        }

        /* Insights Tab Styles */
        .insights-navigation {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav-category-link {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            text-decoration: none;
            color: #495057;
            font-weight: 500;
            font-size: 12px;
            transition: all 0.2s ease;
            min-width: 100px;
            justify-content: center;
        }

        .nav-category-link:hover {
            background: #e3f2fd;
            border-color: #90caf9;
            color: #1565c0;
            text-decoration: none;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .nav-emoji {
            font-size: 16px;
        }

        .nav-text {
            flex: 1;
            text-align: center;
        }

        .nav-count {
            background: #6c757d;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
        }

        .nav-category-link:hover .nav-count {
            background: #1565c0;
        }

        .insight-category {
            margin-bottom: 40px;
            scroll-margin-top: 20px;
        }

        .category-title {
            color: #343a40;
            font-size: 22px;
            font-weight: 700;
            margin: 0 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #007bff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .insight-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #007bff;
        }

        .insight-title {
            color: #495057;
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 12px 0;
        }

        .insight-description {
            color: #6c757d;
            font-size: 14px;
            line-height: 1.6;
            margin: 0 0 10px 0;
        }

        .highlight-number {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #5a5a00;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 13px;
            border: 1px solid #e6c300;
            display: inline-block;
            margin: 0 2px;
        }

        .learn-more-section {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }

        .learn-more-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            line-height: 1.4;
        }

        .learn-more-item:last-child {
            margin-bottom: 0;
        }

        .learn-more-icon {
            font-size: 14px;
            margin-top: 1px;
            flex-shrink: 0;
        }

        .insight-link {
            color: #1565c0;
            text-decoration: none;
            font-weight: 600;
            border-bottom: 1px dotted #1565c0;
        }

        .insight-link:hover {
            color: #0d47a1;
            text-decoration: none;
            border-bottom: 1px solid #0d47a1;
        }
    </style>
    <!-- Include Panzoom, jQuery, and jQuery UI -->
    <script src="https://cdn.jsdelivr.net/npm/panzoom@9.4.2/dist/panzoom.min.js?v=362"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js?v=362"></script>
    <script src="https://code.jquery.com/ui/1.14.0/jquery-ui.min.js?v=362"></script>
</head>

<body>
    <!-- Version info -->
    <div class="version-info" title="Couchbase Query Analyzer Version">
        v3.8.0
    </div>

    <!-- Input Section (outside tabs) -->
    <div id="input-section">
        <div class="input-grid">
            <textarea id="json-input"
                placeholder="Cole sua saída JSON de: SELECT * , meta().plan FROM system:completed_requests LIMIT 2000;"
                aria-label="Campo de entrada JSON para dados de consulta do Couchbase" role="textbox"></textarea>
            <textarea id="indexJsonInput"
                placeholder="Clique na aba 'Índices' abaixo para obter a consulta SQL para executar. Cole os resultados aqui..."
                aria-label="Campo de entrada JSON de índices" role="textbox"></textarea>
        </div>

        <div style="margin: 10px 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
            <!-- Parse Button and Progress (Left Side) -->
            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="parse-json-btn" onclick="parseJSON()" aria-label="Analisar e analisar dados JSON"
                    tabindex="0" role="button">
                    Analisar JSON
                </button>
                <div id="progress-container">
                    <div class="progress-background">
                        <div id="progress-bar" class="progress-bar-fill"></div>
                        <span id="progress-text" class="progress-text">0%</span>
                    </div>
                </div>
            </div>

            <!-- Filtering Controls Group -->
            <div
                style="display: flex; flex-wrap: wrap; align-items: center; gap: 10px; background: #f8f9fa; padding: 8px 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <label class="label-flex" style="margin: 0;">
                    <input type="checkbox" id="exclude-system-queries" checked
                        title="Exclui declarações INFER, ADVISE, CREATE, ALTER INDEX e consultas de keyspaces do sistema:"
                        aria-label="Excluir consultas do sistema da análise" />
                    <span class="checkbox-label-text"
                        title="Exclui declarações INFER, ADVISE, CREATE, ALTER INDEX e consultas de keyspaces do sistema:"
                        style="font-size: 12px;">
                        Excluir Sistema
                    </span>
                </label>

                <div style="display: flex; align-items: center; gap: 5px;">
                    <label for="start-date" style="font-size: 12px; color: #6c757d;">De:</label>
                    <input type="datetime-local" id="start-date" step="1" title="Data/hora de início para filtragem"
                        style="font-size: 11px; padding: 2px 4px;" />
                </div>

                <div style="display: flex; align-items: center; gap: 5px;">
                    <label for="end-date" style="font-size: 12px; color: #6c757d;">Até:</label>
                    <input type="datetime-local" id="end-date" step="1" title="Data/hora de fim para filtragem"
                        style="font-size: 11px; padding: 2px 4px;" />
                </div>

                <input type="text" id="sql-statement-filter" placeholder="Filtrar Declaração SQL++ Contém..."
                    title="Filtrar declarações SQL++ durante a análise JSON"
                    style="width: 150px; font-size: 11px; padding: 4px 6px;" />
            </div>

            <!-- Time Range Buttons -->
            <div class="flex-row-5px">
                <button onclick="setTimeRange('original')" class="cursor-pointer border-none border-radius-3 btn-gray"
                    style="font-size: 11px; padding: 4px 8px;">
                    Original
                </button>
                <button onclick="setTimeRange('1week')" class="cursor-pointer border-none border-radius-3 btn-gray"
                    style="font-size: 11px; padding: 4px 8px;">
                    1 Semana
                </button>
                <button onclick="setTimeRange('1day')" class="cursor-pointer border-none border-radius-3 btn-gray"
                    style="font-size: 11px; padding: 4px 8px;">
                    1 Dia
                </button>
                <button onclick="setTimeRange('1hour')" class="cursor-pointer border-none border-radius-3 btn-gray"
                    style="font-size: 11px; padding: 4px 8px;">
                    1 Hora
                </button>
            </div>

            <span id="filter-info" style="font-size: 12px; color: #6c757d;"></span>

            <!-- Help Link (Right Side) -->
            <div style="margin-left: auto;">
                <a href="https://cb.fuj.io/analysis_hub#readStats" target="_blank"
                    style="text-decoration: none; color: #007bff; font-size: 14px;">
                    PRECISA DE AJUDA? Depuração + Dicas da Ferramenta
                </a>
            </div>
        </div>
    </div>

    <!-- Tabs Container -->
    <div id="tabs" role="tabpanel" aria-label="Query analysis tabs">
        <!-- Tab Headers -->
        <ul role="tablist" aria-label="Analysis views">
            <li role="tab">
                <a href="#dashboard" aria-controls="dashboard" tabindex="0">Painel de Controle</a>
            </li>
            <li role="tab">
                <a href="#insights" aria-controls="insights" tabindex="0">Insights</a>
            </li>
            <li role="tab">
                <a href="#timeline" aria-controls="timeline" tabindex="0">Linha do Tempo</a>
            </li>
            <li role="tab">
                <a href="#analysis" aria-controls="analysis" tabindex="0">Grupos de Consulta</a>
            </li>
            <li role="tab">
                <a href="#every-query" aria-controls="every-query" tabindex="0">Cada Consulta</a>
            </li>
            <li role="tab">
                <a href="#index-query-flow" aria-controls="index-query-flow" tabindex="0">Fluxo de Índice/Consulta</a>
            </li>
            <li role="tab">
                <a href="#indexes" aria-controls="indexes" tabindex="0">Índices</a>
            </li>
        </ul>

        <!-- Dashboard Tab Content -->
        <div id="dashboard">
            <div class="dashboard-grid">
                <!-- Elapsed Time Distribution Bar Chart -->
                <div class="chart-container height-300">
                    <h3 class="chart-title fixed-height">
                        Distribuição de Duração de Consultas
                    </h3>
                    <div class="height-250-relative">
                        <canvas id="elapsed-time-chart"></canvas>
                    </div>
                </div>
                <!-- Primary Index(es) Scan Used Chart -->
                <div class="chart-container height-300">
                    <h3 class="chart-title fixed-height">Uso de Tipo de Índice</h3>
                    <div class="chart-flex-container">
                        <div class="flex-1 position-relative">
                            <canvas id="primary-scan-chart"></canvas>
                        </div>
                        <div id="primary-scan-warning" class="warning-box">
                            <div class="warning-title">⚠️ AVISO ⚠️</div>
                            <div class="warning-text">
                                Verificações de índice primário em produção podem causar verificações completas de
                                bucket
                                levando a
                                <span class="warning-text-highlight">problemas graves de desempenho</span>
                            </div>
                            <div class="warning-link-container">
                                <a href="https://www.couchbase.com/blog/primary-uses-for-couchbase-primary-index/"
                                    target="_blank" class="warning-link">
                                    📖 Saiba Mais
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Query Pattern Analysis Row -->
            <div class="pattern-analysis-grid">
                <!-- Query Pattern Features Bar Chart -->
                <div class="chart-container with-margin-top-20">
                    <h3 class="chart-title fixed-height">Características do Padrão de Consulta</h3>
                    <div class="height-350-relative">
                        <canvas id="query-pattern-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Data Tables Row -->
            <div class="dashboard-tables-grid">
                <!-- User Query Count Table -->
                <div class="table-container with-margin-top-40">
                    <h3 class="chart-title">Usuários por Contagem de Consultas</h3>
                    <div class="table-scroll">
                        <table id="user-count-table" class="table-full">
                            <thead class="sticky-header">
                                <tr>
                                    <th class="width-80px">Contagem</th>
                                    <th>Usuário</th>
                                </tr>
                            </thead>
                            <tbody id="user-count-body"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Index Usage Count Table -->
                <div class="table-container with-margin-top-40">
                    <h3 class="chart-title">Contagem de Uso de Índices</h3>
                    <div class="table-subheader">
                        Nota: a contagem #primary mostra operações totais, não consultas únicas
                    </div>
                    <div class="table-scroll">
                        <table id="index-count-table" class="table-full">
                            <thead class="sticky-header">
                                <tr>
                                    <th class="padding-8 text-align-center border-bottom width-80px">
                                        Contagem
                                    </th>
                                    <th class="padding-8 text-align-center border-bottom">
                                        Nome do Índice
                                    </th>
                                    <th class="padding-8 text-align-center border-bottom">
                                        Bucket.Escopo.Coleção
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="index-count-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="grid-2-col gap-20 margin-bottom-20">
                <!-- Statement Type Pie Chart -->
                <div class="chart-card">
                    <h3 class="chart-card-header">Tipo de Declaração</h3>
                    <div class="chart-card-content">
                        <canvas id="statement-type-chart"></canvas>
                    </div>
                </div>

                <!-- Query State Pie Chart -->
                <div class="chart-card">
                    <h3 class="chart-card-header">Estado da Consulta</h3>
                    <div class="chart-card-content">
                        <canvas id="state-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Insights Tab Content -->
        <div id="insights">
            <div
                style="padding: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; margin-bottom: 20px;">
                <h2 style="color: #856404; margin-top: 0; font-size: 24px; font-weight: bold; text-align: center;">
                    ⚠️ DADOS FICTÍCIOS ESTÁTICOS NÃO FUNCIONAIS ⚠️
                </h2>
                <p style="color: #856404; text-align: center; margin: 0;">
                    Este é um conteúdo de espaço reservado para funcionalidade futura de insights
                </p>
            </div>

            <div style="background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">

                <!-- Category Navigation -->
                <div class="insights-navigation">
                    <a href="#index-issues" class="nav-category-link">
                        <span class="nav-emoji">🔍</span>
                        <span class="nav-text">Problemas de Índice</span>
                        <span class="nav-count">(3)</span>
                    </a>
                    <a href="#resource-issues" class="nav-category-link">
                        <span class="nav-emoji">⚡</span>
                        <span class="nav-text">Problemas de Recursos</span>
                        <span class="nav-count">(3)</span>
                    </a>
                    <a href="#pattern-analysis" class="nav-category-link">
                        <span class="nav-emoji">🔄</span>
                        <span class="nav-text">Padrões de Consulta</span>
                        <span class="nav-count">(3)</span>
                    </a>
                    <a href="#performance-opportunities" class="nav-category-link">
                        <span class="nav-emoji">🚀</span>
                        <span class="nav-text">Desempenho</span>
                        <span class="nav-count">(3)</span>
                    </a>
                </div>

                <!-- Indexes Category -->
                <div id="index-issues" class="insight-category">
                    <h3 class="category-title">🔍 Index Performance Issues</h3>

                    <div class="insight-item">
                        <h4 class="insight-title">Inefficient Index Scans</h4>
                        <p class="insight-description">
                            There are <span class="highlight-number">200 queries</span> that scan <span
                                class="highlight-number">1 million+</span> entries from the index but return <span
                                class="highlight-number">≤10 items</span>, and these are not aggregate functions such as
                            COUNT, AVG, MIN, or MAX.
                        </p>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Delayed Index Responses</h4>
                        <p class="insight-description">
                            <span class="highlight-number">300 queries</span> involve indexes that take more than <span
                                class="highlight-number">10 seconds</span> to respond, yet on average return fewer than
                            <span class="highlight-number">50,000 items</span>, with many occurring concurrently.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Are the Index and Query services co-located? <a href="#" class="insight-link">Learn
                                    more</a>
                            </div>
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                What percentage of your index is stored in memory? <a href="#"
                                    class="insight-link">Learn more</a>
                            </div>
                        </div>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Primary Index Over-Usage</h4>
                        <p class="insight-description">
                            <span class="highlight-number">85 queries</span> are using primary index scans which
                            represent <span class="highlight-number">34%</span> of all slow queries. These could benefit
                            from secondary indexes.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Review your indexing strategy for better performance <a href="#"
                                    class="insight-link">Learn more</a>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Resources Category -->
                <div id="resource-issues" class="insight-category">
                    <h3 class="category-title">⚡ Resource Utilization Issues</h3>

                    <div class="insight-item">
                        <h4 class="insight-title">High Kernel Time in Queries</h4>
                        <p class="insight-description">
                            Analysis indicates <span class="highlight-number">300 queries</span> where CPU time
                            constitutes <span class="highlight-number">≤10%</span> of the total execution time, while
                            kernel time accounts for <span class="highlight-number">≥90%</span> of the execution time.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Is the Query Service co-located with other services? <a href="#"
                                    class="insight-link">Learn more</a>
                            </div>
                        </div>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Memory Pressure Detected</h4>
                        <p class="insight-description">
                            <span class="highlight-number">127 queries</span> are using more than <span
                                class="highlight-number">100MB</span> of memory each, with <span
                                class="highlight-number">23 queries</span> exceeding <span
                                class="highlight-number">500MB</span> memory usage.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Consider increasing query memory limits or optimizing queries <a href="#"
                                    class="insight-link">Learn more</a>
                            </div>
                        </div>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Slow USE KEY Queries</h4>
                        <p class="insight-description">
                            <span class="highlight-number">50 USE KEY queries</span> exceed <span
                                class="highlight-number">1 second</span> in execution time, suggesting potential KV
                            service bottlenecks.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Is the Data Service and/or Query Service co-located with other services? <a href="#"
                                    class="insight-link">Learn more</a>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Query Patterns Category -->
                <div id="pattern-analysis" class="insight-category">
                    <h3 class="category-title">🔄 Query Pattern Analysis</h3>

                    <div class="insight-item">
                        <h4 class="insight-title">Missing WHERE Clauses</h4>
                        <p class="insight-description">
                            <span class="highlight-number">156 queries</span> (<span
                                class="highlight-number">18.3%</span>) lack WHERE clauses, potentially scanning entire
                            collections unnecessarily.
                        </p>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Complex JOIN Operations</h4>
                        <p class="insight-description">
                            <span class="highlight-number">89 JOIN queries</span> are taking an average of <span
                                class="highlight-number">4.2 seconds</span> each, with <span
                                class="highlight-number">67%</span> showing suboptimal join patterns.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Consider denormalizing frequently joined data <a href="#" class="insight-link">Learn
                                    more</a>
                            </div>
                        </div>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Inefficient LIKE Operations</h4>
                        <p class="insight-description">
                            <span class="highlight-number">234 queries</span> use LIKE operations with leading wildcards
                            (<code>%text</code>), preventing index usage and causing full scans.
                        </p>
                    </div>
                </div>

                <!-- Performance Category -->
                <div id="performance-opportunities" class="insight-category">
                    <h3 class="category-title">🚀 Performance Optimization Opportunities</h3>

                    <div class="insight-item">
                        <h4 class="insight-title">Large Payload Streaming</h4>
                        <p class="insight-description">
                            <span class="highlight-number">250 queries</span> return <span
                                class="highlight-number">100,000+ items</span>, with an overall average payload of <span
                                class="highlight-number">15 MB+</span> and <span class="highlight-number">40%</span> of
                            query time dedicated to streaming data to the client.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Consider implementing pagination for large result sets <a href="#"
                                    class="insight-link">Learn more</a>
                            </div>
                        </div>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Timeout-Prone Queries</h4>
                        <p class="insight-description">
                            <span class="highlight-number">43 queries</span> are consistently approaching timeout
                            thresholds, with <span class="highlight-number">12 queries</span> actually timing out in the
                            analyzed period.
                        </p>
                    </div>

                    <div class="insight-item">
                        <h4 class="insight-title">Concurrent Query Conflicts</h4>
                        <p class="insight-description">
                            <span class="highlight-number">178 queries</span> show evidence of resource contention, with
                            execution times varying by more than <span class="highlight-number">300%</span> during peak
                            hours.
                        </p>
                        <div class="learn-more-section">
                            <div class="learn-more-item">
                                <span class="learn-more-icon">💡</span>
                                Review query scheduling and resource allocation <a href="#" class="insight-link">Learn
                                    more</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Tab Content -->
        <div id="timeline">
            <div class="margin-bottom-10">
                <button id="reset-zoom-btn" onclick="resetTimelineZoom()"
                    class="cursor-pointer border-none border-radius-3 btn-gray">
                    Reset Zoom
                </button>
                <div class="margin-left-20"
                    style="display: inline-block; background: #f8f9fa; padding: 6px 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                    <label style="font-weight: bold; margin-right: 8px; color: #495057;">Y-Axis Scale:</label>
                    <label><input type="radio" name="yScale" value="linear" checked onchange="changeYAxisScale()" />
                        Linear</label>
                    <label class="margin-left-10"><input type="radio" name="yScale" value="logarithmic"
                            onchange="changeYAxisScale()" />
                        Logarithmic</label>
                </div>
                <span class="margin-left-30">
                    <label style="font-weight: bold; margin-right: 8px; color: #495057;">Time Grouping:</label>
                    <select id="time-grouping-select" onchange="changeTimeGrouping()"
                        style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px;">
                        <option value="optimizer">By Optimizer (...)</option>
                        <option value="hour">By Hour</option>
                        <option value="minute">By Minute</option>
                        <option value="second">By Second</option>
                    </select>
                </span>
                <span class="color-666 font-size-12 margin-left-20">
                    Drag box to zoom area
                </span>
                <button id="use-time-range-btn" onclick="useCurrentTimeRange()"
                    class="margin-left-20 cursor-pointer border-none border-radius-3 btn-gray">
                    Use Charts Current X-Axis Date Range
                </button>
            </div>
            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400">
                    <canvas id="duration-buckets-chart"></canvas>
                </div>
                <div class="flex-1-height-400">
                    <canvas id="query-types-chart"></canvas>
                </div>
            </div>

            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400">
                    <canvas id="operations-chart"></canvas>
                </div>
                <div class="flex-1-height-400">
                    <canvas id="filter-chart"></canvas>
                </div>
            </div>

            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400">
                    <canvas id="result-count-chart"></canvas>
                </div>
                <div class="flex-1-height-400">
                    <canvas id="result-size-chart"></canvas>
                </div>
            </div>

            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400">
                    <canvas id="timeline-chart"></canvas>
                </div>
                <div class="flex-1-height-400">
                    <canvas id="memory-chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Analysis Tab Content -->
        <div id="analysis">
            <!--
        <div id="charts-placeholder">
          *Future charts and visualizations will be displayed here.
          <canvas id="analysis-chart" width="10" height="10"></canvas>
        </div>
      -->
            <div id="analysis-table-section">
                <!-- Search Controls for Analysis Table -->
                <div id="analysis-search-controls"
                    class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                    <div class="gap-15 display-flex-center display-flex-wrap">
                        <div>
                            <label for="analysis-statement-search" class="font-bold-margin-right">Buscar
                                Declaração:</label>
                            <input type="text" id="analysis-statement-search"
                                placeholder="Buscar em declarações SQL++..." class="form-input" />
                        </div>
                        <div>
                            <label for="analysis-username-search" class="font-bold-margin-right">Buscar Usuário:</label>
                            <input type="text" id="analysis-username-search" placeholder="Buscar usuários..."
                                class="form-input-small" />
                        </div>
                        <button id="analysis-clear-search" class="cursor-pointer border-none border-radius-3 btn-gray">
                            Clear All
                        </button>
                        <div id="analysis-search-results-info" class="color-666 font-bold"></div>
                    </div>
                </div>
                <div id="analysis-table-container">
                    <table id="analysis-table">
                        <thead id="analysis-table-header"></thead>
                        <tbody id="analysis-table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Every Query Tab Content -->
        <div id="every-query">
            <div id="flow-diagram-section">
                <div id="flow-diagram"></div>
            </div>
            <div id="table-section">
                <!-- Search Controls -->
                <div id="search-controls"
                    class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                    <div class="gap-15 display-flex-center display-flex-wrap">
                        <div>
                            <label for="statement-search" class="font-bold-margin-right">Buscar Declaração:</label>
                            <input type="text" id="statement-search" placeholder="Buscar em declarações SQL++..."
                                class="form-input" />
                        </div>
                        <div>
                            <label for="username-search" class="font-bold-margin-right">Buscar Usuário:</label>
                            <input type="text" id="username-search" placeholder="Buscar usuários..."
                                class="form-input-small" />
                        </div>
                        <button id="clear-search" class="cursor-pointer border-none border-radius-3 btn-gray">
                            Clear All
                        </button>
                        <div id="search-results-info" class="color-666 font-bold"></div>
                    </div>
                </div>
                <div id="table-container">
                    <table id="query-table">
                        <thead id="table-header"></thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Index/Query Flow Tab Content -->
        <div id="index-query-flow">
            <div class="height-100 position-relative background-f8 border-radius-8 overflow-hidden">
                <!-- Summary counts above the flow chart -->
                <div id="flow-summary"
                    class="position-relative z-index-3 background-white padding-10-20 border-bottom display-flex justify-space-between align-center">
                    <div class="font-bold color-333">
                        Índices Utilizados: <span id="index-count">0</span>
                    </div>
                    <div class="font-bold color-333">
                        Consultas Executadas: <span id="query-count">0</span>
                    </div>
                </div>
                <div id="flow-canvas" class="width-100 calc-height-minus-50 position-relative overflow-auto">
                    <svg id="flow-svg"
                        class="width-100 height-100 position-absolute top-0 left-0 pointer-events-none z-index-1"></svg>
                    <div id="flow-elements" class="position-relative z-index-2 padding-20"></div>
                </div>
            </div>
        </div>

        <!-- Indexes Tab Content -->
        <div id="indexes">
            <!-- Filter Controls -->
            <div class="margin-bottom-20 padding-15 background-f8 border-radius-6">
                <!-- First row: Search, Bucket, Scope, Collection, Sort -->
                <div class="gap-15 margin-bottom-15" style="display: grid; grid-template-columns: repeat(5, 1fr)">
                    <div>
                        <label for="indexSearch" class="margin-bottom-5 font-bold-block">Search:</label>
                        <input type="text" id="indexSearch" placeholder="Buscar índices..."
                            class="width-90 padding-8 border-radius-4 font-size-14" style="border: 1px solid #ccc" />
                    </div>
                    <div>
                        <label for="bucketFilter" class="margin-bottom-5 font-bold-block">Bucket:</label>
                        <select id="bucketFilter" class="width-100 padding-8 border-radius-4"
                            style="border: 1px solid #ccc">
                            <option value="(ALL)">(ALL)</option>
                        </select>
                    </div>
                    <div>
                        <label for="scopeFilter" class="margin-bottom-5 font-bold-block">Scope:</label>
                        <select id="scopeFilter" class="width-100 padding-8 border-radius-4"
                            style="border: 1px solid #ccc">
                            <option value="(ALL)">(ALL)</option>
                        </select>
                    </div>
                    <div>
                        <label for="collectionFilter" class="margin-bottom-5 font-bold-block">Collection:</label>
                        <select id="collectionFilter" class="width-100 padding-8 border-radius-4"
                            style="border: 1px solid #ccc">
                            <option value="(ALL)">(ALL)</option>
                        </select>
                    </div>
                    <div>
                        <label for="sortBy" class="margin-bottom-5 font-bold-block">Ordenar Por:</label>
                        <select id="sortBy" class="width-100 padding-8 border-radius-4" style="border: 1px solid #ccc">
                            <option value="Name">Nome</option>
                            <option value="Bucket">Bucket</option>
                            <option value="LastScanned">Último Verificado</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Stats Panel -->
            <div id="indexStats" style="
            margin-bottom: 15px;
            padding: 12px;
            background: #e7f3ff;
            border: 1px solid #b3d7ff;
            border-radius: 6px;
            font-size: 13px;
          ">
                <div style="
              display: grid;
              grid-template-columns: repeat(4, 1fr);
              gap: 15px;
            ">
                    <div>
                        <strong>Total Indexes:</strong> <span id="stat-indexes">0</span>
                    </div>
                    <div>
                        <strong>Buckets:</strong> <span id="stat-buckets">0</span>
                    </div>
                    <div><strong>Scopes:</strong> <span id="stat-scopes">0</span></div>
                    <div>
                        <strong>Collections:</strong> <span id="stat-collections">0</span>
                    </div>
                </div>
                <div style="
              display: grid;
              grid-template-columns: repeat(2, 1fr);
              gap: 15px;
              margin-top: 8px;
            ">
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Primary Indexes:</strong>
                            <span id="stat-primary">0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-primary" style="margin: 0" />
                            Primary Only
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Used/Total Indexes:</strong>
                            <span id="stat-used-total">0/0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-used" style="margin: 0" />
                            Used Only
                        </label>
                    </div>
                </div>
                <div style="
              display: grid;
              grid-template-columns: repeat(2, 1fr);
              gap: 15px;
              margin-top: 8px;
            ">
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Without/With Replica:</strong>
                            <span id="stat-replica-info">0/0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-no-replica" style="margin: 0" />
                            No Replicas Only
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Never Scanned Indexes:</strong>
                            <span id="stat-never-scanned">0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-never-scanned" style="margin: 0" />
                            Never Scanned Only
                        </label>
                    </div>
                </div>
                <div style="
              display: grid;
              grid-template-columns: repeat(2, 1fr);
              gap: 15px;
              margin-top: 8px;
            ">
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Índices do Sync Gateway:</strong>
                            <span id="stat-mobile-indexes">0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-exclude-mobile" style="margin: 0" />
                            Excluir Índices Móveis
                        </label>
                    </div>
                    <div></div>
                </div>
            </div>

            <!-- Results Panel -->
            <div id="indexResults" class="background-white padding-15" style="
            overflow-y: auto;
            height: calc(100% - 120px);
            border: 1px solid #ccc;
            border-radius: 4px;
          ">
                <div class="text-align-center" style="margin-top: 30px">
                    <h4 style="color: #495057; margin-bottom: 20px">
                        Nenhum Dado de Índice Carregado
                    </h4>
                    <p class="color-666" style="margin-bottom: 20px">
                        Para analisar índices, execute esta consulta em seu Couchbase Query
                        Workbench e cole os resultados na segunda área de texto acima:
                    </p>
                    <div class="sql-query-box">
                        <button class="btn-standard sql-copy-btn" onclick="copyIndexQuery(event)">
                            Copiar Consulta
                        </button>
                        <pre>
                          SELECT 
                            s.name,
                            s.id,
                            s.metadata,
                            s.state,
                            s.num_replica,
                            CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
                            FROM system:indexes AS s
                            LET bid = CONCAT("", s.bucket_id, ""),
                                sid = CONCAT("", s.scope_id, ""),
                                kid = CONCAT("", s.keyspace_id, ""),
                                k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
                                ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
                                w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
                                p = CASE WHEN s.`partition` IS NOT NULL THEN " PARTITION BY " || s.`partition` ELSE "" END;
                      </pre>
                    </div>
                    <p style="color: #666; font-size: 13px; margin-top: 15px">
                        <strong>Steps:</strong><br />
                        1. Copy the query above<br />
                        2. Run it in Couchbase Query Workbench<br />
                        3. Copy the JSON results<br />
                        4. Paste into the second textarea ,on the right, at the top<br />
                        5. Click "Parse JSON" again
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- Modals (outside tabs) -->
    <div id="plan-modal" class="modal">
        <div class="modal-content">
            <span class="close">×</span>
            <div id="plan-modal-body"></div>
        </div>
    </div>
    <div id="operator-modal" class="modal">
        <div class="modal-content">
            <span class="close">×</span>
            <div id="operator-modal-body"></div>
        </div>
    </div>

    <script>
        // Disable Chart.js animations globally for better performance
        Chart.defaults.animation = false;
        Chart.defaults.animations = false;
        Chart.defaults.responsive = true;
        Chart.defaults.maintainAspectRatio = false;

        // Register the zoom plugin
        try {
            if (window.ChartZoom) {
                Chart.register(window.ChartZoom);
            } else if (window.chartjsPluginZoom) {
                Chart.register(window.chartjsPluginZoom);
            } else if (window.zoomPlugin) {
                Chart.register(window.zoomPlugin);
            }
        } catch (error) {
            // Silent fallback
        }

        // Global variables for time range tracking
        let originalTimeRange = { min: null, max: null };
        let currentTimeRange = { min: null, max: null };
        let isZoomSyncing = false;

        // Sync zoom across all timeline charts
        function syncChartZoom(sourceChart, xMin, xMax) {
            if (isZoomSyncing) return;
            isZoomSyncing = true;

            const charts = [
                window.operationsChart,
                window.filterChart,
                window.timelineChart,
                window.queryTypesChart,
                window.durationBucketsChart,
                window.memoryChart,
                window.resultCountChart,
                window.resultSizeChart,
            ];

            charts.forEach((chart) => {
                if (chart && chart !== sourceChart) {
                    chart.zoomScale("x", { min: xMin, max: xMax }, "none");
                }
            });

            setTimeout(() => {
                isZoomSyncing = false;
            }, 100);
        }

        // Toast notification system
        function showToast(message, type = "success") {
            const toast = document.createElement("div");
            toast.className = `toast ${type === "error" ? "error" : ""}`;
            toast.textContent = message;
            toast.setAttribute("role", "alert");
            toast.setAttribute("aria-live", "polite");

            document.body.appendChild(toast);

            // Trigger animation
            setTimeout(() => toast.classList.add("show"), 100);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.classList.remove("show");
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // Enhanced clipboard copy function
        async function copyToClipboard(text, button) {
            try {
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    showToast("Copiado para a área de transferência!");
                } else {
                    fallbackCopyTextToClipboard(text, button);
                }
            } catch (err) {
                console.error("Failed to copy: ", err);
                showToast("Falha ao copiar para a área de transferência", "error");
            }
        }

        // Keyboard navigation enhancement
        function enhanceKeyboardNavigation() {
            // Add keyboard support for tab elements
            document.addEventListener("keydown", function (e) {
                if (e.key === "Enter" || e.key === " ") {
                    const target = e.target;
                    if (
                        target.matches('a[href^="#"]') ||
                        target.matches(".step-bubble")
                    ) {
                        e.preventDefault();
                        target.click();
                    }
                }
            });
        }

        // Chart optimization utilities
        function getOptimizedChartOptions(baseOptions = {}) {
            return {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    intersect: false,
                    mode: "index",
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 4,
                    },
                    line: {
                        tension: 0, // Disable bezier curves for better performance
                    },
                },
                ...baseOptions,
            };
        }

        // Enhanced error handling for data processing
        function processRequestData(requestData) {
            try {
                if (!requestData || typeof requestData !== "object") {
                    throw new Error("Invalid request data");
                }

                // Validate required fields
                const requiredFields = ["requestTime", "statement"];
                for (const field of requiredFields) {
                    if (!(field in requestData)) {
                        console.warn(`Missing required field: ${field}`);
                        return null;
                    }
                }

                return requestData;
            } catch (error) {
                console.error("Error processing request data:", error);
                return null;
            }
        }

        // Memory cleanup for charts
        function destroyAllCharts() {
            const chartNames = [
                "operationsChart",
                "filterChart",
                "timelineChart",
                "queryTypesChart",
                "durationBucketsChart",
                "memoryChart",
                "resultCountChart",
                "resultSizeChart",
                "primaryScanChart",
                "stateChart",
                "statementTypeChart",
                "elapsedTimeChart",
                "queryPatternChart",
            ];

            chartNames.forEach((chartName) => {
                if (window[chartName]) {
                    // Remove event listeners if they exist
                    if (window[chartName]._crosshairHandlers && window[chartName].canvas) {
                        const canvas = window[chartName].canvas;
                        const handlers = window[chartName]._crosshairHandlers;
                        canvas.removeEventListener('mousemove', handlers.mousemove);
                        canvas.removeEventListener('mouseleave', handlers.mouseleave);
                    }

                    window[chartName].destroy();
                    window[chartName] = null;
                }
            });

            // Clear timeline charts array
            timelineCharts.length = 0;
        }

        // Global system query filtering
        function shouldExcludeSystemQuery(request) {
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            const isChecked = excludeCheckbox ? excludeCheckbox.checked : false;

            // If checkbox doesn't exist or is unchecked, don't exclude anything
            if (!excludeCheckbox || !excludeCheckbox.checked) {
                return false;
            }

            const stmt = request.preparedText || request.statement;
            if (!stmt) {
                return false;
            }

            const upperStmt = stmt.toUpperCase();

            // Apply same filtering logic as Query Groups tab
            // Get derived statement type and normalize underscores to spaces
            const statementType = request.statementType || deriveStatementType(request.statement) || "";
            const normalizedType = statementType.replace(/_/g, " ").toUpperCase();

            // Define system query patterns (both with and without underscores)
            const systemPatterns = [
                "INFER", "ADVISE", "CREATE", "ALTER", "DROP", "BUILD", "EXPLAIN"
            ];

            const shouldExclude =
                upperStmt.startsWith("INFER ") ||
                upperStmt.startsWith("ADVISE ") ||
                upperStmt.startsWith("CREATE ") ||
                upperStmt.startsWith("ALTER ") ||
                upperStmt.startsWith("DROP ") ||
                upperStmt.startsWith("BUILD ") ||
                upperStmt.startsWith("EXPLAIN ") ||
                upperStmt.includes(" SYSTEM:") ||
                // Check normalized statement type for any system operation with underscores
                systemPatterns.some(pattern => normalizedType.startsWith(pattern + " "));

            return shouldExclude;
        }

        // Filter requests based on system query exclusion setting and SQL statement filter
        function filterSystemQueries(requests) {
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            const isExcluding = excludeCheckbox && excludeCheckbox.checked;

            // Get SQL statement filter
            const sqlFilter = document.getElementById("sql-statement-filter");
            const sqlFilterText = sqlFilter ? sqlFilter.value.trim().toLowerCase() : "";

            console.log("🔍 SQL Filter text:", sqlFilterText);
            console.log("📝 Original requests:", requests.length);

            const filtered = requests.filter((request) => {
                // Apply system query exclusion first
                if (isExcluding && shouldExcludeSystemQuery(request)) {
                    return false;
                }

                // Apply SQL statement filtering only if filter text is not empty
                if (sqlFilterText && sqlFilterText.length > 0) {
                    const statement = (request.statement || "").toLowerCase();
                    if (!statement.includes(sqlFilterText)) {
                        return false;
                    }
                }

                return true;
            });

            console.log("✅ Filtered requests:", filtered.length);
            return filtered;
        }

        // Parse time strings to milliseconds
        function parseTime(timeStr) {
            if (!timeStr) {
                return 0;
            }

            // Handle empty or invalid strings
            timeStr = timeStr.trim();
            if (!timeStr) {
                return 0;
            }

            // Try different regex patterns for different time formats

            // Pattern 1: Handle ms, ns, µs, us formats like "681.413039ms", "250ns", "146.266µs"
            const simplePattern = /^(\d+\.?\d*)(ms|ns|µs|us)$/;
            let simpleMatch = timeStr.match(simplePattern);

            if (simpleMatch) {
                const value = parseFloat(simpleMatch[1]);
                const unit = simpleMatch[2];

                let totalMs = 0;
                if (unit === "ms") {
                    totalMs = value;
                } else if (unit === "ns") {
                    totalMs = value / 1000000; // nanoseconds to milliseconds
                } else if (unit === "µs" || unit === "us") {
                    totalMs = value / 1000; // microseconds to milliseconds
                }

                return totalMs;
            }

            // Pattern 2: Handle complex formats like "1h4m17.8098098s" or "4m17.8098098s" or "1h"
            const complexPattern = /(?:(\d+)h)?(?:(\d+)m)?(?:(\d+\.?\d*)s)?/;
            const complexMatch = timeStr.match(complexPattern);

            if (
                !complexMatch ||
                (complexMatch[1] === undefined &&
                    complexMatch[2] === undefined &&
                    complexMatch[3] === undefined)
            ) {
                return 0;
            }

            let totalMs = 0;
            const hours = parseInt(complexMatch[1] || 0); // Hours (optional)
            const minutes = parseInt(complexMatch[2] || 0); // Minutes (optional)
            const seconds = parseFloat(complexMatch[3] || 0); // Seconds (optional, including decimals)

            // Convert to milliseconds
            totalMs += hours * 60 * 60 * 1000; // Hours to milliseconds
            totalMs += minutes * 60 * 1000; // Minutes to milliseconds
            totalMs += seconds * 1000; // Seconds to milliseconds

            return totalMs;
        }

        // Format time in standardized mm:ss.sss format
        function formatTime(milliseconds) {
            if (!milliseconds || isNaN(milliseconds) || milliseconds <= 0) {
                return "00:00.000";
            }

            const totalSeconds = Math.floor(milliseconds / 1000);
            const ms = Math.floor(milliseconds % 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;

            // Format with leading zeros
            const formattedMinutes = minutes.toString().padStart(2, "0");
            const formattedSeconds = seconds.toString().padStart(2, "0");
            const formattedMs = ms.toString().padStart(3, "0");

            return `${formattedMinutes}:${formattedSeconds}.${formattedMs}`;
        }

        // Cache for normalized statements with size limit
        const normalizeCache = new Map();
        const MAX_CACHE_SIZE = 5000;

        // Normalize statement by replacing literals and numbers with "?" (with improved caching)
        function normalizeStatement(statement) {
            if (!statement) return "";

            // Check cache first
            if (normalizeCache.has(statement)) {
                return normalizeCache.get(statement);
            }

            let normalized = statement
                .replace(/"(?:[^"\\]|\\.)*"/g, "?")
                .replace(/'(?:[^'\\]|\\.)*'/g, "?")
                .replace(/\b\d+\.?\d*\b/g, "?");

            // Cache the result with size management
            if (normalizeCache.size >= MAX_CACHE_SIZE) {
                // Remove oldest entries (LRU-like behavior)
                const firstKey = normalizeCache.keys().next().value;
                normalizeCache.delete(firstKey);
            }
            normalizeCache.set(statement, normalized);

            return normalized;
        }

        // Get color class based on percentage
        function getColorClass(percentage) {
            if (percentage === "N/A" || isNaN(percentage)) return "green";
            if (percentage < 25) return "green";
            if (percentage < 50) return "yellow";
            if (percentage < 75) return "orange";
            return "red";
        }

        // Get percentage-based background color for bubble
        function getPercentageColor(percentage) {
            if (percentage === "N/A" || isNaN(percentage)) {
                return { bg: "#d4edda", border: "#28a745" }; // Light green
            }

            const percent = parseFloat(percentage);

            if (percent <= 33) {
                // 0-33%: Light to darker green
                const intensity = Math.min(percent / 33, 1);
                // Start with very light green and go to medium green
                const red = Math.floor(212 - (84 * intensity)); // 212 to 128
                const green = Math.floor(237 - (18 * intensity)); // 237 to 219  
                const blue = Math.floor(218 - (90 * intensity)); // 218 to 128
                return {
                    bg: `rgb(${red}, ${green}, ${blue})`,
                    border: "#28a745"
                };
            } else if (percent <= 90) {
                // 33-90%: Light orange to hard orange
                const intensity = (percent - 33) / 57; // 0 to 1
                const red = Math.floor(255);
                const green = Math.floor(193 - (67 * intensity)); // 193 to 126
                const blue = Math.floor(7 + (93 * intensity)); // 7 to 100, then back to 7
                return {
                    bg: `rgb(${red}, ${green}, 7)`,
                    border: "#fd7e14"
                };
            } else {
                // 90-100%: Light red to bright red
                const intensity = (percent - 90) / 10; // 0 to 1
                const red = Math.floor(255);
                const green = Math.floor(205 - (205 * intensity)); // 205 to 0
                const blue = Math.floor(210 - (210 * intensity)); // 210 to 0
                return {
                    bg: `rgb(${red}, ${green}, ${blue})`,
                    border: "#dc3545"
                };
            }
        }

        // Cache for operators to avoid reprocessing the same plans
        const operatorsCache = new WeakMap();

        // Recursively extract operators from the plan
        function getOperators(
            operator,
            operators = [],
            visited = new WeakSet(),
            depth = 0
        ) {
            if (!operator) return operators;

            // Check cache first for the root operator
            if (depth === 0 && operatorsCache.has(operator)) {
                return operatorsCache.get(operator);
            }

            // Prevent infinite recursion by tracking visited objects
            if (visited.has(operator)) {
                return operators;
            }
            visited.add(operator);

            // Add depth limit as additional safety
            if (depth > 50) {
                return operators;
            }

            if (operator["#operator"]) {
                operators.push(operator);
            }
            if (operator["~child"]) {
                getOperators(operator["~child"], operators, visited, depth + 1);
            } else if (operator["~children"]) {
                operator["~children"].forEach((child, i) => {
                    getOperators(child, operators, visited, depth + 1);
                });
            }
            // Check for input/inputs
            if (operator.input) {
                getOperators(operator.input, operators, visited, depth + 1);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input, i) => {
                    getOperators(input, operators, visited, depth + 1);
                });
            }
            // Check for left/right (binary operations)
            if (operator.left) {
                getOperators(operator.left, operators, visited, depth + 1);
            }
            if (operator.right) {
                getOperators(operator.right, operators, visited, depth + 1);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                getOperators(operator.first, operators, visited, depth + 1);
            }
            if (operator.second) {
                getOperators(operator.second, operators, visited, depth + 1);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan, i) => {
                    getOperators(scan, operators, visited, depth + 1);
                });
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                getOperators(operator.scan, operators, visited, depth + 1);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery, i) => {
                    if (subquery.executionTimings) {
                        getOperators(
                            subquery.executionTimings,
                            operators,
                            visited,
                            depth + 1
                        );
                    }
                });
            }

            // Cache the result for root operator
            if (depth === 0) {
                operatorsCache.set(operator, operators);
            }

            return operators;
        }

        // Calculate the maximum of all kernTimes
        function calculateTotalKernTime(plan) {
            const operators = getOperators(plan);
            let maxKernTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const kernTime = parseTime(stats.kernTime);
                if (!isNaN(kernTime)) {
                    maxKernTime = Math.max(maxKernTime, kernTime);
                }
            });
            return maxKernTime;
        }

        // Calculate the total memory usage from all operators in the plan
        function calculateTotalMemoryUsage(plan) {
            const operators = getOperators(plan);
            let totalMemory = 0;

            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const usedMemory = stats.usedMemory || 0;
                if (!isNaN(usedMemory)) {
                    totalMemory += usedMemory;
                }
            });
            return totalMemory;
        }

        // Calculate the sum of all execution times for percentage calculation
        function calculateTotalExecTime(plan) {
            const operators = getOperators(plan);
            let totalExecTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const execTime = parseTime(stats.execTime);
                if (!isNaN(execTime)) {
                    totalExecTime += execTime;
                }
            });
            return totalExecTime;
        }

        // Calculate the sum of all service times from all operators in the plan
        function calculateTotalServiceTime(plan) {
            const operators = getOperators(plan);
            let totalServiceTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const servTime = parseTime(stats.servTime);
                if (!isNaN(servTime)) {
                    totalServiceTime += servTime;
                }
            });
            return totalServiceTime;
        }

        // Build operator stats for modal
        function buildOperatorStats(operator) {
            const operatorType = operator["#operator"] || "Unknown";
            let html = `<h3>Operator: ${operatorType}</h3>`;

            // Add copy button
            html += `<button class="btn-standard" onclick="copyOperatorStats(this)">Copiar Estatísticas</button>`;

            // Show index name for specific operators
            if (
                (operatorType === "PrimaryScan3" ||
                    operatorType === "IndexFtsSearch" ||
                    operatorType === "IndexScan3") &&
                operator.index
            ) {
                html += `<p><strong>Index Used: ${operator.index}</strong></p>`;
            }

            if (operator["#stats"]) {
                html += "<dl>";
                for (const [key, value] of Object.entries(operator["#stats"])) {
                    let formattedValue = value;
                    // Format time fields
                    if (
                        key === "execTime" ||
                        key === "kernTime" ||
                        key === "servTime"
                    ) {
                        const timeMs = parseTime(value);
                        formattedValue = timeMs > 0 ? formatTime(timeMs) : value;
                    }
                    html += `<dt>${key}</dt><dd>${formattedValue}</dd>`;
                }
                html += "</dl>";
            } else {
                html += "<p>No stats available.</p>";
            }
            return html;
        }

        // Function to copy operator stats to clipboard
        function copyOperatorStats(button) {
            const modalBody = document.getElementById("operator-modal-body");
            const text = modalBody.innerText || modalBody.textContent;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard
                    .writeText(text)
                    .then(() => {
                        button.textContent = "Copiado!";
                        setTimeout(() => {
                            button.textContent = "Copiar Estatísticas";
                        }, 2000);
                    })
                    .catch((err) => {
                        console.error("Failed to copy: ", err);
                        fallbackCopyTextToClipboard(text, button);
                    });
            } else {
                fallbackCopyTextToClipboard(text, button);
            }
        }

        // Fallback copy function for older browsers
        function fallbackCopyTextToClipboard(text, button) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.top = "-1000px";
            textArea.style.left = "-1000px";
            textArea.setAttribute("aria-hidden", "true");
            textArea.setAttribute("tabindex", "-1");

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand("copy");
                if (successful) {
                    showToast("Copiado para a área de transferência!");
                } else {
                    showToast("Falha ao copiar para a área de transferência", "error");
                }
            } catch (err) {
                console.error("Fallback: Oops, unable to copy", err);
                showToast("Falha ao copiar para a área de transferência", "error");
            }

            document.body.removeChild(textArea);
        }

        // Generate flow diagram
        function generateFlowDiagram(request) {
            const flowDiagram = document.getElementById("flow-diagram");
            flowDiagram.innerHTML = "";
            if (!request || !request.plan) {
                flowDiagram.textContent = "No execution plan available.";
                return;
            }

            const totalKernTime = calculateTotalKernTime(request.plan);
            // Use overall query elapsed time instead of summing operator exec times
            const totalElapsedTimeMs = request.elapsedTimeMs || parseTime(request.elapsedTime) || 0;
            const operators = getOperators(request.plan);

            if (operators.length === 0) {
                flowDiagram.textContent = "No operators found in the execution plan.";
                return;
            }

            operators.forEach((operator, index) => {
                const operatorName = operator["#operator"] || "Unknown Operator";
                const stats = operator["#stats"] || {};
                const kernTime = stats.kernTime || "N/A";
                const execTime = stats.execTime || "N/A";
                const servTime = stats.servTime || "N/A";
                const itemsIn =
                    stats["#itemsIn"] !== undefined ? stats["#itemsIn"] : "-";
                const itemsOut =
                    stats["#itemsOut"] !== undefined ? stats["#itemsOut"] : "-";

                const kernTimeMs = parseTime(kernTime);
                const execTimeMs = parseTime(execTime);
                const servTimeMs = parseTime(servTime);

                // Calculate percentage based on execTime only (not servTime)
                const percentage =
                    totalElapsedTimeMs > 0 && !isNaN(execTimeMs) && execTimeMs > 0
                        ? ((execTimeMs / totalElapsedTimeMs) * 100).toFixed(2)
                        : "N/A";

                const bubble = document.createElement("div");
                bubble.className = "step-bubble";

                // Use percentage-based colors to draw attention to performance issues
                const percentageColors = getPercentageColor(percentage);
                bubble.style.backgroundColor = percentageColors.bg;
                bubble.style.borderColor = percentageColors.border;
                bubble.style.borderWidth = "2px";

                // Still add performance-based class as fallback for other styling
                const colorClass = getColorClass(parseFloat(percentage));
                bubble.classList.add(colorClass);

                // Build the HTML content
                let bubbleContent = `
                    <h4>${operatorName}</h4>
                    <p>${formatTime(execTimeMs)} (${percentage}%)</p>`;

                // Add servTime if available
                if (servTime !== "N/A" && !isNaN(servTimeMs) && servTimeMs > 0) {
                    bubbleContent += `<p>${formatTime(servTimeMs)} servTime</p>`;
                }

                // Only show in/out line if both values are present and not "-"
                if (itemsIn !== "-" && itemsOut !== "-") {
                    bubbleContent += `<p>${itemsIn} in / ${itemsOut} out</p>`;
                }

                bubble.innerHTML = bubbleContent;
                bubble.addEventListener("click", () => {
                    const statsHtml = buildOperatorStats(operator);
                    document.getElementById("operator-modal-body").innerHTML =
                        statsHtml;
                    document.getElementById("operator-modal").style.display = "block";
                });
                flowDiagram.appendChild(bubble);

                if (index < operators.length - 1) {
                    const connector = document.createElement("div");
                    connector.className = "connector";
                    flowDiagram.appendChild(connector);
                }
            });

            if (request.plan) {
                const viewPlanButton = document.createElement("button");
                viewPlanButton.textContent =
                    "View Detailed Execution Plan & Indexes/Keys Used";
                viewPlanButton.style.marginTop = "10px";
                viewPlanButton.addEventListener("click", () => {
                    const indexesAndKeys = extractIndexesAndKeys(request);
                    const planTreeHtml = buildEnhancedPlanModal(
                        request.plan,
                        indexesAndKeys
                    );
                    document.getElementById("plan-modal-body").innerHTML = planTreeHtml;
                    document.getElementById("plan-modal").style.display = "block";
                });
                flowDiagram.appendChild(viewPlanButton);
            }

            panzoom(flowDiagram, { smoothScroll: false });
        }

        // Extract indexes and USE KEYS from request
        function extractIndexesAndKeys(request) {
            const indexes = new Set();
            const useKeys = [];
            let hasUseKeys = false;

            // Get bucket.scope.collection from the statement for primary index resolution
            const requestStatement =
                request.preparedText || request.statement || "";
            let bucketScopeCollection = "unknown.unknown.unknown";

            const fromMatch = requestStatement.match(/FROM\s+([^\s\n\r\t]+)/i);
            if (fromMatch) {
                const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                const parts = target.split(".");
                if (parts.length === 1) {
                    bucketScopeCollection = `${parts[0]}._default._default`;
                } else if (parts.length === 2) {
                    bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                } else if (parts.length >= 3) {
                    bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                }
            }

            // Extract indexes from plan
            if (request.plan) {
                const operators = getOperators(request.plan);

                operators.forEach((operator, opIndex) => {
                    const opType = operator["#operator"];

                    if (
                        opType === "IndexScan" ||
                        opType === "IndexScan2" ||
                        opType === "IndexScan3"
                    ) {
                        if (operator.index) {
                            indexes.add(operator.index);
                        }
                    }

                    if (
                        opType === "PrimaryScan" ||
                        opType === "PrimaryScan2" ||
                        opType === "PrimaryScan3"
                    ) {
                        try {
                            // First try to resolve #primary to actual name
                            let resolvedName = resolvePrimaryIndexName(
                                bucketScopeCollection
                            );

                            // If we got a real index name (not #primary), use it
                            if (resolvedName && resolvedName !== "#primary") {
                                indexes.add(resolvedName);
                            }
                            // If operator has explicit index name, use that instead
                            else if (operator.index) {
                                indexes.add(operator.index);
                            }
                            // Fallback to #primary
                            else {
                                indexes.add("#primary");
                            }
                        } catch (error) {
                            // Fallback to operator.index if available
                            if (operator.index) {
                                indexes.add(operator.index);
                            } else {
                                indexes.add("#primary");
                            }
                        }
                    }
                });
            }

            // Extract USE KEYS from statement
            if (requestStatement.includes("USE KEYS")) {
                hasUseKeys = true;

                // Handle all USE KEYS formats:
                // USE KEYS(["key1","key2"]) or USE KEYS ["key1","key2"]
                // USE KEYS(['key1','key2']) or USE KEYS ['key1','key2']
                // USE KEYS("key1") or USE KEYS "key1"
                // USE KEYS('key1') or USE KEYS 'key1'

                let match;

                // Extract array format with double quotes: USE KEYS(?)["key1","key2"]
                const arrayDoubleQuotes = /USE\s+KEYS\s*\(?\s*\[(.*?)\]\s*\)?/gi;
                while ((match = arrayDoubleQuotes.exec(requestStatement)) !== null) {
                    // Split by comma and clean up each key, handle both single and double quotes
                    const keys = match[1]
                        .split(",")
                        .map((key) => {
                            return key.trim().replace(/^['"]|['"]$/g, ""); // Remove leading/trailing quotes
                        })
                        .filter((key) => key.length > 0);
                    useKeys.push(...keys);
                }

                // Reset regex for single key formats
                arrayDoubleQuotes.lastIndex = 0;

                // Extract single key format: USE KEYS(?) "key" or USE KEYS(?) 'key'
                // This should not match array formats, so we exclude those with brackets
                const singleKeyRegex =
                    /USE\s+KEYS\s*\(?\s*([^[\],]+?)\s*\)?(?:\s+WHERE|\s*$)/gi;
                while ((match = singleKeyRegex.exec(requestStatement)) !== null) {
                    const key = match[1].trim().replace(/^['"]|['"]$/g, ""); // Remove leading/trailing quotes
                    if (key && !key.includes("[") && !key.includes("]")) {
                        useKeys.push(key);
                    }
                }
            }

            return {
                indexes: Array.from(indexes),
                useKeys: [...new Set(useKeys)], // Remove duplicates
                hasUseKeys,
            };
        }

        // Build enhanced plan modal with indexes and keys
        function buildEnhancedPlanModal(plan, indexesAndKeys) {
            let html = '<div style="margin-bottom: 20px;">';

            // Indexes section
            if (indexesAndKeys.indexes.length > 0) {
                html += '<div style="margin-bottom: 15px;">';
                html +=
                    '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                html +=
                    '<h3 style="margin: 0; color: #333; font-size: 16px;">📋 Indexes Used:</h3>';
                const allIndexes = indexesAndKeys.indexes.join(", ");
                html += `<button onclick="copyToClipboard('${allIndexes.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="background: #4CAF50;">Copiar Tudo</button>`;
                html += "</div>";
                html += '<div style="display: flex; flex-wrap: wrap; gap: 10px;">';
                indexesAndKeys.indexes.forEach((index) => {
                    html += `<div style="background: #f0f8ff; padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd;">
                        <code style="font-family: monospace; color: #333;">${index}</code>
                    </div>`;
                });
                html += "</div></div>";
            }

            // USE KEYS section
            if (indexesAndKeys.hasUseKeys) {
                html += '<div style="margin-bottom: 15px;">';

                if (indexesAndKeys.useKeys.length > 0) {
                    // Header with Copy All button
                    html +=
                        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                    html +=
                        '<h3 style="margin: 0; color: #333; font-size: 16px;">🔑 USE KEYS:</h3>';
                    const allKeys = indexesAndKeys.useKeys.join(", ");
                    html += `<button onclick="copyToClipboard('${allKeys.replace(
                        /'/g,
                        "\\'"
                    )}', event)" 
                            class="btn-standard" style="background: #ff9800;">Copiar Tudo</button>`;
                    html += "</div>";

                    const maxKeysToShow = 15;
                    const shouldTruncate =
                        indexesAndKeys.useKeys.length > maxKeysToShow;

                    // Keys display container
                    html +=
                        '<div id="keys-container" style="display: flex; flex-wrap: wrap; gap: 8px;">';

                    // Show initial set of keys
                    const keysToShow = shouldTruncate
                        ? indexesAndKeys.useKeys.slice(0, maxKeysToShow)
                        : indexesAndKeys.useKeys;
                    keysToShow.forEach((key) => {
                        html += `<div style="background: #fff3cd; padding: 4px 8px; border-radius: 4px; border: 1px solid #ffeaa7;">
                            <code class="font-size-12" style="font-family: monospace; color: #856404;">${key}</code>
                        </div>`;
                    });

                    // Hidden keys (if truncated)
                    if (shouldTruncate) {
                        const remainingKeys = indexesAndKeys.useKeys.slice(maxKeysToShow);
                        remainingKeys.forEach((key) => {
                            html += `<div class="hidden-key display-none" style="background: #fff3cd; padding: 4px 8px; border-radius: 4px; border: 1px solid #ffeaa7;">
                                <code class="font-size-12" style="font-family: monospace; color: #856404;">${key}</code>
                            </div>`;
                        });
                    }

                    html += "</div>";

                    // Show more/hide button
                    if (shouldTruncate) {
                        const remainingCount =
                            indexesAndKeys.useKeys.length - maxKeysToShow;
                        html += `<div style="margin-top: 10px;">`;
                        html += `<button id="toggle-keys-btn" onclick="toggleUseKeys()" 
                                style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500;">
                                Show ${remainingCount} more keys
                            </button>`;
                        html += `</div>`;
                    }

                    // Summary info
                    html += `<div style="margin-top: 8px; font-size: 11px; color: #666; font-style: italic;">
                        Total: ${indexesAndKeys.useKeys.length} key${indexesAndKeys.useKeys.length !== 1 ? "s" : ""
                        }
                    </div>`;
                } else {
                    html +=
                        '<h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">🔑 USE KEYS:</h3>';
                    html +=
                        '<div style="color: #666; font-style: italic;">Keys could not be extracted from the query</div>';
                }
                html += "</div>";
            }

            html += "</div>";

            // Execution plan section
            html += '<div style="border-top: 1px solid #ddd; padding-top: 15px;">';
            html +=
                '<h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">⚙️ Execution Plan:</h3>';
            html += "<ul>" + buildPlanTree(plan) + "</ul>";
            html += "</div>";

            return html;
        }

        // Get operator icon and color based on type
        function getOperatorStyle(operatorName) {
            const styles = {
                Authorize: { icon: "🔐", color: "#6f42c1", bg: "#f8f7ff" },
                Sequence: { icon: "📋", color: "#856404", bg: "#fff3cd" },
                IndexScan: { icon: "🔍", color: "#007bff", bg: "#e7f3ff" },
                IndexScan2: { icon: "🔍", color: "#007bff", bg: "#e7f3ff" },
                IndexScan3: { icon: "🔍", color: "#007bff", bg: "#e7f3ff" },
                PrimaryScan: { icon: "🔑", color: "#dc3545", bg: "#fff5f5" },
                PrimaryScan3: { icon: "🔑", color: "#dc3545", bg: "#fff5f5" },
                Fetch: { icon: "📥", color: "#28a745", bg: "#f1f8e9" },
                Filter: { icon: "🔧", color: "#fd7e14", bg: "#fff4e6" },
                InitialGroup: { icon: "📊", color: "#20c997", bg: "#e6fffa" },
                IntermediateGroup: { icon: "📈", color: "#20c997", bg: "#e6fffa" },
                FinalGroup: { icon: "🎯", color: "#20c997", bg: "#e6fffa" },
                InitialProject: { icon: "📋", color: "#6f42c1", bg: "#f8f7ff" },
                Stream: { icon: "🌊", color: "#17a2b8", bg: "#e2f7fa" },
                Sort: { icon: "🔄", color: "#ffc107", bg: "#fff8e1" },
                Limit: { icon: "✂️", color: "#e83e8c", bg: "#fce4ec" },
                Offset: { icon: "⏭️", color: "#6c757d", bg: "#f8f9fa" },
                Union: { icon: "🔗", color: "#795548", bg: "#f3e5f5" },
                Join: { icon: "🤝", color: "#9c27b0", bg: "#f3e5f5" },
            };

            return (
                styles[operatorName] || {
                    icon: "⚙️",
                    color: "#6c757d",
                    bg: "#f8f9fa",
                }
            );
        }

        // Format time values for better readability
        function formatTimeValue(timeStr) {
            if (!timeStr || timeStr === "N/A")
                return '<span style="color: #999;">N/A</span>';

            // Parse time and check if it's a high value (potential bottleneck)
            const timeMs = parseTime(timeStr);
            const isBottleneck = timeMs > 60000; // > 1 minute
            const isWarning = timeMs > 10000; // > 10 seconds

            let color = "#333";
            let bgColor = "transparent";
            let fontWeight = "normal";

            if (isBottleneck) {
                color = "#dc3545";
                bgColor = "#fff5f5";
                fontWeight = "bold";
            } else if (isWarning) {
                color = "#fd7e14";
                bgColor = "#fff4e6";
                fontWeight = "bold";
            }

            return `<span style="color: ${color}; background: ${bgColor}; font-weight: ${fontWeight}; padding: 1px 4px; border-radius: 3px;">${timeStr}</span>`;
        }

        // Format item count with color coding
        function formatItemCount(count) {
            if (count === undefined || count === null)
                return '<span style="color: #999;">N/A</span>';

            const numCount = typeof count === "number" ? count : parseInt(count);
            let color = "#333";
            let icon = "";

            if (numCount > 1000000) {
                color = "#dc3545";
                icon = "⚠️ ";
            } else if (numCount > 100000) {
                color = "#fd7e14";
                icon = "⚡ ";
            } else if (numCount > 10000) {
                color = "#ffc107";
            }

            return `<span style="color: ${color};">${icon}${numCount.toLocaleString()}</span>`;
        }

        // Build plan tree for modal with enhanced formatting
        function buildPlanTree(operator) {
            if (!operator) return "";

            const operatorName = operator["#operator"] || "Unknown Operator";
            const style = getOperatorStyle(operatorName);

            let html = `<li style="margin: 8px 0; padding: 12px; border-left: 4px solid ${style.color}; background: ${style.bg}; border-radius: 6px;">`;

            // Operator header with icon and name
            html += `<div style="display: flex; align-items: center; margin-bottom: 8px;">`;
            html += `<span style="font-size: 18px; margin-right: 8px;">${style.icon}</span>`;
            html += `<strong style="color: ${style.color}; font-size: 16px;">${operatorName}</strong>`;
            html += `</div>`;

            // Statistics section
            if (operator["#stats"]) {
                const stats = operator["#stats"];
                html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; margin: 8px 0; font-size: 13px;">`;

                // Items In/Out
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">📥 Items In:</span> ${formatItemCount(
                    stats["#itemsIn"]
                )}`;
                html += `</div>`;

                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">📤 Items Out:</span> ${formatItemCount(
                    stats["#itemsOut"]
                )}`;
                html += `</div>`;

                // Execution Time
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">⏱️ Exec Time:</span> ${formatTimeValue(
                    stats.execTime
                )}`;
                html += `</div>`;

                // Kernel Time
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">🔧 Kern Time:</span> ${formatTimeValue(
                    stats.kernTime
                )}`;
                html += `</div>`;

                html += `</div>`;

                // Efficiency indicator
                const itemsIn = stats["#itemsIn"];
                const itemsOut = stats["#itemsOut"];
                if (itemsIn !== undefined && itemsOut !== undefined && itemsIn > 0) {
                    const efficiency = (itemsOut / itemsIn) * 100;
                    let efficiencyColor = "#28a745";
                    let efficiencyIcon = "✅";

                    if (efficiency < 50) {
                        efficiencyColor = "#dc3545";
                        efficiencyIcon = "⚠️";
                    } else if (efficiency < 80) {
                        efficiencyColor = "#ffc107";
                        efficiencyIcon = "⚡";
                    }

                    html += `<div style="margin-top: 6px; font-size: 12px;">`;
                    html += `<span style="color: ${efficiencyColor};">${efficiencyIcon} Efficiency: ${efficiency.toFixed(
                        1
                    )}%</span>`;
                    html += `</div>`;
                }
            }

            // Child operations
            const childContainerStyle =
                "margin-top: 10px; margin-left: 20px; border-left: 2px dashed #dee2e6; padding-left: 15px;";

            if (operator["~child"]) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator["~child"]) +
                    "</ul>";
            } else if (operator["~children"]) {
                html += `<ul style="${childContainerStyle}">`;
                operator["~children"].forEach((child) => {
                    html += buildPlanTree(child);
                });
                html += "</ul>";
            }

            // Handle other child properties
            if (operator.input) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.input) +
                    "</ul>";
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                html += `<ul style="${childContainerStyle}">`;
                operator.inputs.forEach((input) => {
                    html += buildPlanTree(input);
                });
                html += "</ul>";
            }
            if (operator.left) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.left) +
                    "</ul>";
            }
            if (operator.right) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.right) +
                    "</ul>";
            }
            if (operator.first) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.first) +
                    "</ul>";
            }
            if (operator.second) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.second) +
                    "</ul>";
            }
            if (operator.scans && Array.isArray(operator.scans)) {
                html += `<ul style="${childContainerStyle}">`;
                operator.scans.forEach((scan) => {
                    html += buildPlanTree(scan);
                });
                html += "</ul>";
            }
            if (operator.scan) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.scan) +
                    "</ul>";
            }
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                html += `<ul style="${childContainerStyle}">`;
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        html += buildPlanTree(subquery.executionTimings);
                    }
                });
                html += "</ul>";
            }

            html += "</li>";
            return html;
        }

        // Sorting functionality
        let currentSortColumn = null;
        let currentSortDirection = "asc";
        let currentTableType = "every-query"; // 'every-query' or 'analysis'
        let everyQueryData = [];
        let analysisData = [];

        // Pagination variables
        let currentPage = 1;
        const pageSize = 50; // Records per page

        // Search/filter variables
        let filteredEveryQueryData = [];
        let currentStatementFilter = "";
        let currentUsernameFilter = "";

        // Analysis table search/filter variables
        let filteredAnalysisData = [];
        let currentAnalysisStatementFilter = "";
        let currentAnalysisUsernameFilter = "";

        // Enhanced time parsing for sorting (handles various units and mm:ss.sss format)
        function parseTimeForSorting(timeStr) {
            if (!timeStr || timeStr === "N/A" || timeStr === "-") return 0;

            // Check if it's in mm:ss.sss format
            const mmssMatch = timeStr.match(/^(\d+):(\d{2})\.(\d{3})$/);
            if (mmssMatch) {
                const minutes = parseInt(mmssMatch[1]);
                const seconds = parseInt(mmssMatch[2]);
                const milliseconds = parseInt(mmssMatch[3]);
                return minutes * 60000 + seconds * 1000 + milliseconds;
            }

            // Handle legacy formats
            const match = timeStr
                .replace(/(\d+\.?\d*)(\D+)/, "$1 $2")
                .match(/(\d+\.?\d*)\s*(\D+)/);
            if (!match) return 0;
            const value = parseFloat(match[1]);
            const unit = match[2].toLowerCase().trim();
            // Convert everything to milliseconds for consistent sorting
            if (unit === "h" || unit === "hour" || unit === "hours")
                return value * 3600000;
            if (
                unit === "m" ||
                unit === "min" ||
                unit === "minute" ||
                unit === "minutes"
            )
                return value * 60000;
            if (
                unit === "s" ||
                unit === "sec" ||
                unit === "second" ||
                unit === "seconds"
            )
                return value * 1000;
            if (unit === "ms" || unit === "millisecond" || unit === "milliseconds")
                return value;
            if (
                unit === "us" ||
                unit === "µs" ||
                unit === "microsecond" ||
                unit === "microseconds"
            )
                return value / 1000;
            if (unit === "ns" || unit === "nanosecond" || unit === "nanoseconds")
                return value / 1000000;
            return value;
        }

        // Get sortable value for a column
        function getSortableValue(item, column) {
            let value = item[column];

            // Handle columns with newlines in their names
            const cleanColumn = column.replace(/\n/g, " ");

            // Handle special columns for Every Query table
            if (column === "#") {
                // "#" column is calculated dynamically, use a default sort order
                return parseInt(item.rowIndex) || 0;
            }
            if (column === "requestTime" || cleanColumn === "request Time") {
                return new Date(value).getTime() || 0;
            }
            if (
                ["elapsedTime", "kernTime", "cpuTime", "serviceTime"].includes(
                    column
                ) ||
                ["elapsed Time", "kern Time", "cpu Time", "service Time"].includes(
                    cleanColumn
                )
            ) {
                return parseTimeForSorting(value);
            }
            if (column === "KernTime %" || cleanColumn === "KernTime %") {
                const numStr = String(value).replace("%", "");
                return parseFloat(numStr) || 0;
            }
            if (column === "memory (MB)" || cleanColumn === "memory (MB)") {
                return parseFloat(value) || 0;
            }
            if (
                [
                    "resultCount",
                    "resultSize",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                ].includes(column) ||
                [
                    "result Count",
                    "result Size",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                ].includes(cleanColumn)
            ) {
                return parseInt(value) || 0;
            }
            if (
                column === "Primary Scan Used" ||
                cleanColumn === "Primary Scan Used"
            ) {
                return value === "Sim" ? 1 : 0;
            }
            if (column === "statementType" || cleanColumn === "statement Type") {
                return String(value || "").toLowerCase();
            }
            if (column === "state") {
                // Sort fatal states first, then by alphabetical order
                if (value === "fatal") return "aaa_fatal";
                if (value === "completed") return "bbb_completed";
                return String(value || "zzz_unknown").toLowerCase();
            }
            if (column === "statement") {
                return String(value || "").toLowerCase();
            }
            if (column === "users") {
                return String(value || "").toLowerCase();
            }

            // Handle Analysis table columns
            if (
                [
                    "min_duration_in_seconds",
                    "max_duration_in_seconds",
                    "avg_duration_in_seconds",
                    "median_duration_in_seconds",
                ].includes(column)
            ) {
                return parseTimeForSorting(value);
            }
            if (
                [
                    "total_count",
                    "avg_fetch",
                    "avg_primaryScan",
                    "avg_indexScan",
                ].includes(column)
            ) {
                return parseFloat(value) || 0;
            }

            // Default: string comparison
            return String(value || "").toLowerCase();
        }

        // Sort data
        function sortData(data, column, direction) {
            return [...data].sort((a, b) => {
                const aVal = getSortableValue(a, column);
                const bVal = getSortableValue(b, column);

                let comparison = 0;
                if (aVal < bVal) comparison = -1;
                else if (aVal > bVal) comparison = 1;

                return direction === "asc" ? comparison : -comparison;
            });
        }

        // Update sort arrows in headers
        function updateSortArrows(tableHeaderId, column, direction) {
            const headers = document.querySelectorAll(`#${tableHeaderId} th`);
            headers.forEach((th) => {
                // Remove existing sort indicators
                const existingArrow = th.querySelector(".sort-arrow");
                const existingSortHint = th.querySelector(".sort-hint");
                if (existingArrow) existingArrow.remove();
                if (existingSortHint) existingSortHint.remove();

                // Handle multi-line headers by removing newlines for comparison
                const headerText = th.innerHTML
                    .replace(/<br>/g, " ")
                    .replace(/<[^>]*>/g, "")
                    .replace(/\s+/g, " ")
                    .trim();
                const columnText = column.replace(/\n/g, " ").trim();

                if (
                    headerText.includes(columnText) ||
                    columnText.includes(headerText)
                ) {
                    // Remove the old sort hint and add prominent arrow
                    const oldHint = th.querySelector("div");
                    if (oldHint && oldHint.textContent === "↕ Sort") {
                        oldHint.remove();
                    }

                    const arrow = document.createElement("div");
                    arrow.className = "sort-arrow";
                    arrow.style.fontSize = "14px";
                    arrow.style.color = "#0066cc";
                    arrow.style.fontWeight = "bold";
                    arrow.style.marginTop = "2px";

                    if (direction === "asc") {
                        arrow.textContent = "▲ ASC";
                        arrow.style.color = "#28a745";
                    } else {
                        arrow.textContent = "▼ DESC";
                        arrow.style.color = "#dc3545";
                    }

                    th.appendChild(arrow);
                } else {
                    // Add back the sort hint for non-active columns
                    const sortHint = document.createElement("div");
                    sortHint.className = "sort-hint";
                    sortHint.style.fontSize = "10px";
                    sortHint.style.color = "#6c757d";
                    sortHint.style.fontWeight = "normal";
                    sortHint.style.marginTop = "2px";
                    sortHint.textContent = "↕ Sort";
                    th.appendChild(sortHint);
                }
            });
        }

        // Map display column names to data field names
        function getDataFieldName(displayColumn) {
            // Map display names back to data field names (same logic as in populateEveryQueryTable)
            if (displayColumn === "request\nTime") return "requestTime";
            else if (displayColumn === "statement\nType") return "statementType";
            else if (displayColumn === "elapsed\nTime") return "elapsedTime";
            else if (displayColumn === "service\nTime") return "serviceTime";
            else if (displayColumn === "kern\nTime") return "kernTime";
            else if (displayColumn === "KernTime\n%") return "KernTime %";
            else if (displayColumn === "cpu\nTime") return "cpuTime";
            else if (displayColumn === "memory\n(MB)") return "memory (MB)";
            else if (displayColumn === "result\nCount") return "resultCount";
            else if (displayColumn === "result\nSize") return "resultSize";
            else if (displayColumn === "Items from\nIndex Scan")
                return "Items from Index Scan";
            else if (displayColumn === "Doc Fetch\nCount") return "Doc Fetch Count";
            else if (displayColumn === "Primary Scan\nUsed")
                return "Primary Scan Used";
            else return displayColumn; // For columns without newlines like "#", "state", "statement", "users"
        }

        // Handle column sort click
        function handleColumnSort(column, tableType) {
            // Map display column to data field
            const dataField = getDataFieldName(column);

            if (currentSortColumn === column && currentTableType === tableType) {
                currentSortDirection =
                    currentSortDirection === "asc" ? "desc" : "asc";
            } else {
                currentSortColumn = column;
                currentSortDirection = "asc";
                currentTableType = tableType;
            }

            if (tableType === "every-query") {
                currentPage = 1; // Reset to first page after sorting

                // Sort using the data field name, not the display name
                const sortedData = sortData(
                    filteredEveryQueryData,
                    dataField,
                    currentSortDirection
                );

                filteredEveryQueryData = sortedData;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSortArrows("table-header", column, currentSortDirection);
            } else if (tableType === "analysis") {
                // Sort the filtered analysis data
                const sortedData = sortData(
                    filteredAnalysisData,
                    column,
                    currentSortDirection
                );
                filteredAnalysisData = sortedData;
                populateAnalysisTable(filteredAnalysisData);
                updateSortArrows(
                    "analysis-table-header",
                    column,
                    currentSortDirection
                );
            }
        }

        // Create pagination controls
        function addPaginationControls(totalRecords) {
            const tableContainer = document.getElementById("table-container");
            let paginationDiv = document.getElementById("pagination");
            if (!paginationDiv) {
                paginationDiv = document.createElement("div");
                paginationDiv.id = "pagination";
                paginationDiv.style.textAlign = "center";
                paginationDiv.style.marginTop = "10px";
                paginationDiv.style.backgroundColor = "#f5f5f5";
                paginationDiv.style.padding = "10px";
                paginationDiv.style.borderTop = "1px solid #ddd";
                tableContainer.appendChild(paginationDiv);
            }
            paginationDiv.innerHTML = "";

            const totalPages = Math.ceil(totalRecords / pageSize);

            // Previous button
            const prevButton = createButton("◀ Prev", () => {
                if (currentPage > 1) {
                    currentPage--;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            prevButton.disabled = currentPage === 1;

            // Next button
            const nextButton = createButton("Next ▶", () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            nextButton.disabled = currentPage === totalPages;

            // Page info
            const pageInfo = document.createElement("span");
            pageInfo.textContent = ` Page ${currentPage} of ${totalPages} (${totalRecords} records) `;
            pageInfo.style.margin = "0 15px";
            pageInfo.style.fontWeight = "bold";

            // Page jump input
            const pageInput = document.createElement("input");
            pageInput.type = "number";
            pageInput.min = "1";
            pageInput.max = totalPages.toString();
            pageInput.value = currentPage.toString();
            pageInput.style.width = "60px";
            pageInput.style.margin = "0 5px";
            pageInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                    const newPage = parseInt(pageInput.value);
                    if (newPage >= 1 && newPage <= totalPages) {
                        currentPage = newPage;
                        populateEveryQueryTable(filteredEveryQueryData);
                    }
                }
            });

            const jumpLabel = document.createElement("span");
            jumpLabel.textContent = "Go to page: ";
            jumpLabel.style.marginLeft = "20px";

            paginationDiv.appendChild(prevButton);
            paginationDiv.appendChild(pageInfo);
            paginationDiv.appendChild(nextButton);
            paginationDiv.appendChild(jumpLabel);
            paginationDiv.appendChild(pageInput);
        }

        function createButton(text, onClick) {
            const btn = document.createElement("button");
            btn.textContent = text;
            btn.style.margin = "0 5px";
            btn.style.padding = "5px 10px";
            btn.style.cursor = "pointer";
            btn.onclick = onClick;
            return btn;
        }

        // Filter data based on search criteria
        function filterEveryQueryData(data) {
            return data.filter((rowData) => {
                // Filter by statement
                if (currentStatementFilter) {
                    const statement = (rowData.statement || "").toLowerCase();
                    if (!statement.includes(currentStatementFilter.toLowerCase())) {
                        return false;
                    }
                }

                // Filter by username
                if (currentUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update search results info
        function updateSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} records`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} records`;
            }
        }

        // Filter analysis data based on search criteria
        function filterAnalysisData(data) {
            return data.filter((rowData) => {
                // Filter by statement
                if (currentAnalysisStatementFilter) {
                    const statement = (rowData.statement || "").toLowerCase();
                    if (
                        !statement.includes(currentAnalysisStatementFilter.toLowerCase())
                    ) {
                        return false;
                    }
                }

                // Filter by username
                if (currentAnalysisUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentAnalysisUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update analysis search results info
        function updateAnalysisSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("analysis-search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} groups`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} groups`;
            }
        }

        // Setup analysis search event listeners
        function setupAnalysisSearchListeners() {
            const statementSearch = document.getElementById(
                "analysis-statement-search"
            );
            const usernameSearch = document.getElementById(
                "analysis-username-search"
            );
            const clearButton = document.getElementById("analysis-clear-search");

            function performAnalysisSearch() {
                currentAnalysisStatementFilter = statementSearch.value.trim();
                currentAnalysisUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredAnalysisData = filterAnalysisData(analysisData);

                // Update display
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(
                    filteredAnalysisData.length,
                    analysisData.length
                );
            }

            // Add debouncing to search inputs
            let analysisSearchTimeout;
            function debouncedAnalysisSearch() {
                clearTimeout(analysisSearchTimeout);
                analysisSearchTimeout = setTimeout(performAnalysisSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedAnalysisSearch);
            usernameSearch.addEventListener("input", debouncedAnalysisSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentAnalysisStatementFilter = "";
                currentAnalysisUsernameFilter = "";
                filteredAnalysisData = [...analysisData];
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(
                    filteredAnalysisData.length,
                    analysisData.length
                );
            });
        }

        // Setup search event listeners
        function setupSearchListeners() {
            const statementSearch = document.getElementById("statement-search");
            const usernameSearch = document.getElementById("username-search");
            const clearButton = document.getElementById("clear-search");

            function performSearch() {
                currentStatementFilter = statementSearch.value.trim();
                currentUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredEveryQueryData = filterEveryQueryData(everyQueryData);

                // Reset to first page
                currentPage = 1;

                // Update display
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(
                    filteredEveryQueryData.length,
                    everyQueryData.length
                );
            }

            // Add debouncing to search inputs
            let searchTimeout;
            function debouncedSearch() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(performSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedSearch);
            usernameSearch.addEventListener("input", debouncedSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentStatementFilter = "";
                currentUsernameFilter = "";
                filteredEveryQueryData = [...everyQueryData];
                currentPage = 1;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(
                    filteredEveryQueryData.length,
                    everyQueryData.length
                );
            });
        }

        // Generate main table
        function generateTable(requests) {
            const tableHeader = document.getElementById("table-header");
            const tableBody = document.getElementById("table-body");
            tableHeader.innerHTML = "";
            tableBody.innerHTML = "";

            const columns = [
                "#",
                "request\nTime",
                "statement\nType",
                "elapsed\nTime",
                "service\nTime",
                "kern\nTime",
                "KernTime\n%",
                "cpu\nTime",
                "memory\n(MB)",
                "result\nCount",
                "result\nSize",
                "Doc Fetch\nCount",
                "Items from\nIndex Scan",
                "Primary Scan\nUsed",
                "state",
                "statement",
                "Scan\nConsistency",
                "users",
            ];

            const headerRow = document.createElement("tr");
            columns.forEach((col) => {
                const th = document.createElement("th");
                th.innerHTML = col.replace(/\n/g, "<br>");
                th.style.textAlign = "center";
                th.style.whiteSpace = "nowrap";
                th.style.cursor = "pointer";
                th.style.userSelect = "none";
                th.style.padding = "8px";
                th.style.backgroundColor = "#f8f9fa";
                th.style.border = "1px solid #dee2e6";
                th.style.fontWeight = "bold";
                th.style.position = "relative";

                // Add hover effect
                th.addEventListener("mouseenter", () => {
                    th.style.backgroundColor = "#e9ecef";
                });
                th.addEventListener("mouseleave", () => {
                    th.style.backgroundColor = "#f8f9fa";
                });

                if (col === "statement") {
                    th.style.width = "300px";
                    th.style.maxWidth = "300px";
                }

                // Add sorting indicator text
                const sortHint = document.createElement("div");
                sortHint.className = "sort-hint";
                sortHint.style.fontSize = "10px";
                sortHint.style.color = "#6c757d";
                sortHint.style.fontWeight = "normal";
                sortHint.style.marginTop = "2px";
                sortHint.textContent = "↕ Sort";
                th.appendChild(sortHint);

                th.addEventListener("click", () => {
                    handleColumnSort(col, "every-query");
                });
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);

            // Prepare data with pre-calculated values
            const tableData = requests.map((request, index) => {
                // Use pre-calculated values from processRequestData
                const totalKernTimeMs = request.kernTimeMs || 0;
                const totalMemoryBytes = request.memoryBytes || 0;
                const elapsedTimeMs = request.elapsedTimeMs || 0;

                // Create row data object
                const rowData = {
                    rowIndex: index + 1,
                    request: request, // Keep original request for click handler
                };

                // Add all column values (skip "#" as it's calculated dynamically)
                [
                    "requestTime",
                    "statementType",
                    "elapsedTime",
                    "serviceTime",
                    "kernTime",
                    "KernTime %",
                    "cpuTime",
                    "memory (MB)",
                    "resultCount",
                    "resultSize",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                    "Primary Scan Used",
                    "state",
                    "statement",
                    "users",
                ].forEach((col) => {
                    let value;
                    if (col === "Primary Scan Used") {
                        value = request.usesPrimary ? "Sim" : "Não";
                    } else if (col === "Items from Index Scan") {
                        if (request.indexInfo) {
                            const stats = request.indexInfo.stats;
                            if (stats.primaryScan > 0) {
                                value = stats.primaryScan;
                            } else if (stats.indexScan > 0) {
                                value = stats.indexScan;
                            } else {
                                value = "N/A";
                            }
                        } else {
                            value = "N/A";
                        }
                    } else if (col === "Doc Fetch Count") {
                        value = request.indexInfo
                            ? request.indexInfo.stats.fetch || "N/A"
                            : "N/A";
                    } else if (col === "kernTime") {
                        value = totalKernTimeMs > 0 ? formatTime(totalKernTimeMs) : "N/A";
                    } else if (col === "KernTime %") {
                        value =
                            elapsedTimeMs > 0 && totalKernTimeMs > 0
                                ? ((totalKernTimeMs / elapsedTimeMs) * 100).toFixed(2) + "%"
                                : "N/A";
                    } else if (col === "memory (MB)") {
                        value =
                            totalMemoryBytes > 0
                                ? (totalMemoryBytes / 1024 / 1024).toFixed(2)
                                : "0.00";
                    } else if (col === "elapsedTime") {
                        value = formatTime(elapsedTimeMs);
                    } else if (col === "cpuTime") {
                        value = formatTime(parseTime(request[col]));
                    } else if (col === "serviceTime") {
                        value = formatTime(request.serviceTimeMs || parseTime(request[col]));
                    } else {
                        value = request[col] || "N/A";
                    }
                    rowData[col] = value;
                });

                return rowData;
            });

            // Sort by elapsedTime by default
            const sortedData = sortData(tableData, "elapsedTime", "desc");
            everyQueryData = sortedData;
            filteredEveryQueryData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "elapsedTime";
            currentSortDirection = "desc";
            currentTableType = "every-query";

            // Reset pagination when new data is loaded
            currentPage = 1;

            // Setup search listeners (only once)
            if (
                !document
                    .getElementById("statement-search")
                    .hasAttribute("data-listeners-added")
            ) {
                setupSearchListeners();
                document
                    .getElementById("statement-search")
                    .setAttribute("data-listeners-added", "true");
            }

            populateEveryQueryTable(filteredEveryQueryData);
            updateSortArrows("table-header", "elapsedTime", "desc");
            updateSearchResultsInfo(
                filteredEveryQueryData.length,
                everyQueryData.length
            );
        }

        // Populate Every Query table body
        function populateEveryQueryTable(data) {
            const tableBody = document.getElementById("table-body");
            tableBody.innerHTML = "";

            // Clear statement store for new data (only for current page)
            statementStore = {};

            const columns = [
                "#",
                "request\nTime",
                "statement\nType",
                "elapsed\nTime",
                "service\nTime",
                "kern\nTime",
                "KernTime\n%",
                "cpu\nTime",
                "memory\n(MB)",
                "result\nCount",
                "result\nSize",
                "Doc Fetch\nCount",
                "Items from\nIndex Scan",
                "Primary Scan\nUsed",
                "state",
                "statement",
                "Scan\nConsistency",
                "users",
            ];

            // Pagination: get only the current page data
            const start = (currentPage - 1) * pageSize;
            const end = Math.min(start + pageSize, data.length);
            const pageData = data.slice(start, end);

            // Use DocumentFragment for batch DOM insertion
            const fragment = document.createDocumentFragment();

            pageData.forEach((rowData, pageIndex) => {
                const globalIndex = start + pageIndex; // For "#" column and statement IDs
                const row = document.createElement("tr");

                columns.forEach((col) => {
                    const td = document.createElement("td");
                    // Map display names back to data field names
                    let dataField;
                    if (col === "request\nTime") dataField = "requestTime";
                    else if (col === "statement\nType") dataField = "statementType";
                    else if (col === "elapsed\nTime") dataField = "elapsedTime";
                    else if (col === "service\nTime") dataField = "serviceTime";
                    else if (col === "kern\nTime") dataField = "kernTime";
                    else if (col === "KernTime\n%") dataField = "KernTime %";
                    else if (col === "cpu\nTime") dataField = "cpuTime";
                    else if (col === "memory\n(MB)") dataField = "memory (MB)";
                    else if (col === "result\nCount") dataField = "resultCount";
                    else if (col === "result\nSize") dataField = "resultSize";
                    else if (col === "Items from\nIndex Scan")
                        dataField = "Items from Index Scan";
                    else if (col === "Doc Fetch\nCount") dataField = "Doc Fetch Count";
                    else if (col === "Primary Scan\nUsed")
                        dataField = "Primary Scan Used";
                    else if (col === "Scan\nConsistency") dataField = "scanConsistency";
                    else dataField = col;

                    // Use globalIndex for row number to maintain correct numbering across pages
                    let value;
                    if (col === "#") {
                        value = globalIndex + 1;
                    } else if (col === "Scan\nConsistency") {
                        // scanConsistency is nested under request object
                        value = rowData.request && rowData.request.scanConsistency ? rowData.request.scanConsistency : "N/A";
                    } else {
                        value = rowData[dataField];
                    }

                    if (col === "request\nTime") {
                        // Set fixed width for requestTime column to handle long ISO-8601 timestamps
                        td.style.width = "120px";
                        td.style.maxWidth = "120px";
                        td.style.overflow = "hidden";
                        td.style.wordWrap = "break-word";
                        td.style.fontSize = "11px";
                        td.textContent = value || "";
                    } else if (col === "statement") {
                        // Set fixed width for statement column
                        td.style.width = "300px";
                        td.style.maxWidth = "300px";
                        td.style.overflow = "hidden";
                        td.style.wordWrap = "break-word";
                        // Handle statement column with truncation and controls
                        const statement = value || "";
                        const statementId = `statement-${globalIndex}`;

                        // Store the statement safely
                        statementStore[statementId] = statement;

                        if (statement.length > 500) {
                            // Create truncated version
                            const truncated = statement.substring(0, 500);

                            td.innerHTML = `
                  <div id="${statementId}-truncated">
                    <span>${truncated}...</span>
                    <br>
                    <button onclick="toggleStatement('${statementId}', true)" 
                            class="btn-standard" style="margin-top: 5px; margin-right: 5px;">Mostrar Mais</button>
                    <button onclick="copyStatement('${statementId}', event)" 
                            class="btn-standard" style="margin-top: 5px;">Copiar</button>
                  </div>
                  <div id="${statementId}-full" style="display: none;">
                    <span>${statement}</span>
                    <br>
                    <button onclick="toggleStatement('${statementId}', false)" 
                            class="btn-standard" style="margin-top: 5px; margin-right: 5px;">Ocultar</button>
                    <button onclick="copyStatement('${statementId}', event)" 
                            class="btn-standard" style="margin-top: 5px;">Copiar</button>
                  </div>
                `;
                        } else {
                            // Short statement - just show it with copy button
                            td.innerHTML = `
                  <div>
                    <span>${statement}</span>
                    <br>
                    <button onclick="copyStatement('${statementId}', event)" 
                            class="btn-standard" style="margin-top: 5px;">Copiar</button>
                  </div>
                `;
                        }
                    } else if (
                        ["result\nCount", "result\nSize", "Doc Fetch\nCount", "Items from\nIndex Scan"].includes(col)
                    ) {
                        // Format numeric columns with commas
                        const numValue = Number(value);
                        td.textContent = isNaN(numValue) ? value : numValue.toLocaleString();
                    } else {
                        td.textContent = value;
                    }

                    if (
                        col === "Primary Scan\nUsed" &&
                        (value === "Sim" || value === "True" || value === true)
                    ) {
                        td.classList.add("primary-scan-yes");
                    }

                    if (col === "state" && value === "fatal") {
                        td.classList.add("fatal-state");
                    }
                    row.appendChild(td);
                });

                row.addEventListener("click", (event) => {
                    // Allow text selection - only handle clicks, not text selection
                    if (window.getSelection().toString().length > 0) {
                        return; // User is selecting text, don't handle the click
                    }

                    document
                        .querySelectorAll("tr")
                        .forEach((r) => (r.style.backgroundColor = ""));
                    row.style.backgroundColor = "#e0e0e0";
                    generateFlowDiagram(rowData.request);
                });
                fragment.appendChild(row);
            });

            // Batch insert all rows at once
            tableBody.appendChild(fragment);

            // Add pagination controls
            addPaginationControls(data.length);
        }

        // Toggle statement display between truncated and full view
        function toggleStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy statement to clipboard
        function copyStatement(statementId, event) {
            const statement = statementStore[statementId];
            if (!statement) {
                console.error("Statement not found in store:", statementId);
                alert("Declaração não encontrada");
                return;
            }

            navigator.clipboard
                .writeText(statement)
                .then(() => {
                    // Show brief feedback
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "copied!";
                    button.style.backgroundColor = "#4CAF50";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy statement:", err);
                    alert("Falha ao copiar para a área de transferência");
                });
        }

        // Toggle analysis statement display between truncated and full view
        function toggleAnalysisStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy analysis statement to clipboard
        function copyAnalysisStatement(statementId, event) {
            const statement = analysisStatementStore[statementId];
            if (!statement) {
                console.error("Statement not found in store:", statementId);
                alert("Declaração não encontrada");
                return;
            }

            navigator.clipboard
                .writeText(statement)
                .then(() => {
                    // Show brief feedback
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "copied!";
                    button.style.backgroundColor = "#4CAF50";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy statement:", err);
                    alert("Falha ao copiar para a área de transferência");
                });
        }

        // Calculate statistics for a group of requests based on SQL++ query logic
        function calculateGroupStats(normalized_statement, groupedRequests) {
            const users_agg = groupedRequests.map((r) => r.users).filter((u) => u);
            const durations = groupedRequests
                .map((r) => {
                    const ms = parseTime(r.serviceTime);
                    return isNaN(ms) ? NaN : ms / 1000; // Convert ms to seconds
                })
                .filter((d) => !isNaN(d));
            const total_count = durations.length;
            if (total_count === 0) return null;

            const min_duration = Math.min(...durations);
            const max_duration = Math.max(...durations);
            const avg_duration =
                durations.reduce((sum, d) => sum + d, 0) / total_count;
            const sorted_durations = [...durations].sort((a, b) => a - b);
            const midFloor = Math.floor(total_count / 2);
            const midCeil = Math.ceil(total_count / 2) - 1;
            const median_duration =
                (sorted_durations[midFloor] + sorted_durations[midCeil]) / 2;

            const fetchValues = groupedRequests.map(
                (r) => r.phaseCounts?.fetch || 0
            );
            const primaryScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.primaryScan || 0
            );
            const indexScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.indexScan || 0
            );
            const avg_fetch =
                fetchValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_primaryScan =
                primaryScanValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_indexScan =
                indexScanValues.reduce((sum, v) => sum + v, 0) / total_count;

            // Compute user_query_counts as an object: { user: count }
            const uniqueUsers = [...new Set(users_agg)];
            const user_query_counts = {};
            uniqueUsers.forEach((user) => {
                user_query_counts[user] = users_agg.filter((v) => v === user).length;
            });

            return {
                normalized_statement,
                user_query_counts,
                total_count,
                min_duration_in_seconds: min_duration,
                max_duration_in_seconds: max_duration,
                avg_duration_in_seconds: avg_duration,
                median_duration_in_seconds: median_duration,
                avg_fetch: Math.round(avg_fetch),
                avg_primaryScan: Math.round(avg_primaryScan),
                avg_indexScan: Math.round(avg_indexScan),
            };
        }

        // Generate analysis table based on SQL++ query logic
        function generateAnalysisTable(requests) {
            const analysisTableHeader = document.getElementById(
                "analysis-table-header"
            );
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableHeader.innerHTML = "";
            analysisTableBody.innerHTML = "";

            // Group requests by normalized_statement
            const groups = {};
            requests.forEach((request) => {
                const stmt = request.preparedText || request.statement;
                if (!stmt) return;
                // Note: System query filtering is now handled globally in parseJSON()
                const normalized = normalizeStatement(stmt);
                if (!groups[normalized]) {
                    groups[normalized] = [];
                }
                groups[normalized].push(request);
            });

            // Calculate stats for each group
            const groupData = Object.keys(groups)
                .map((key) => calculateGroupStats(key, groups[key]))
                .filter((data) => data !== null);
            groupData.sort((a, b) => b.total_count - a.total_count);

            // Define table columns
            const analysisColumns = [
                "total_count",
                "min_duration_in_seconds",
                "max_duration_in_seconds",
                "avg_duration_in_seconds",
                "median_duration_in_seconds",
                "avg_fetch",
                "avg_primaryScan",
                "avg_indexScan",
                "normalized_statement",
                "user_query_counts",
            ];

            // Create header row
            const headerRow = document.createElement("tr");
            analysisColumns.forEach((col) => {
                const th = document.createElement("th");
                let displayName = col
                    .replace(/_/g, " ")
                    .replace("in seconds", " (mm:ss.sss)");
                if (col === "user_query_counts") {
                    displayName = "user: (count)";
                }
                th.textContent = displayName;
                th.style.textAlign = "center";
                th.addEventListener("click", () => handleColumnSort(col, "analysis"));
                headerRow.appendChild(th);
            });
            analysisTableHeader.appendChild(headerRow);

            // Prepare table data
            const analysisTableData = groupData.map((group) => {
                const rowData = {};
                analysisColumns.forEach((col) => {
                    let value;
                    if (col === "user_query_counts") {
                        value = Object.entries(group.user_query_counts)
                            .map(([user, count]) => `${user}: (${count})`)
                            .join(", ");
                    } else if (col === "total_count") {
                        value = group.total_count;
                    } else if (
                        [
                            "min_duration_in_seconds",
                            "max_duration_in_seconds",
                            "avg_duration_in_seconds",
                            "median_duration_in_seconds",
                        ].includes(col)
                    ) {
                        value = isNaN(group[col])
                            ? "N/A"
                            : formatTime(Number(group[col]) * 1000);
                    } else if (
                        ["avg_fetch", "avg_primaryScan", "avg_indexScan"].includes(col)
                    ) {
                        value = isNaN(group[col]) ? "N/A" : Number(group[col]).toLocaleString();
                    } else {
                        value = group[col] || "N/A";
                    }
                    rowData[col] = value;
                });

                // Add fields for search filtering
                rowData.statement = group.normalized_statement || "";
                rowData.users = Object.keys(group.user_query_counts || {}).join(", ");

                return rowData;
            });

            // Sort by total_count by default
            const sortedData = sortData(analysisTableData, "total_count", "desc");
            analysisData = sortedData;
            filteredAnalysisData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "total_count";
            currentSortDirection = "desc";
            currentTableType = "analysis";

            // Setup search listeners (only once)
            if (
                !document
                    .getElementById("analysis-statement-search")
                    .hasAttribute("data-listeners-added")
            ) {
                setupAnalysisSearchListeners();
                document
                    .getElementById("analysis-statement-search")
                    .setAttribute("data-listeners-added", "true");
            }

            populateAnalysisTable(filteredAnalysisData);
            updateSortArrows("analysis-table-header", "total_count", "desc");
            updateAnalysisSearchResultsInfo(
                filteredAnalysisData.length,
                analysisData.length
            );
        }

        // Populate Analysis table body
        function populateAnalysisTable(data) {
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableBody.innerHTML = "";

            // Clear statement store for new data
            analysisStatementStore = {};

            const analysisColumns = [
                "total_count",
                "min_duration_in_seconds",
                "max_duration_in_seconds",
                "avg_duration_in_seconds",
                "median_duration_in_seconds",
                "avg_fetch",
                "avg_primaryScan",
                "avg_indexScan",
                "normalized_statement",
                "user_query_counts",
            ];

            data.forEach((rowData, index) => {
                const row = document.createElement("tr");
                analysisColumns.forEach((col) => {
                    const td = document.createElement("td");
                    const value = rowData[col];

                    if (col === "normalized_statement") {
                        // Handle normalized_statement column with truncation and controls
                        const statement = value || "";
                        const statementId = `analysis-statement-${index}`;

                        // Store the statement safely
                        analysisStatementStore[statementId] = statement;

                        if (statement.length > 500) {
                            // Create truncated version
                            const truncated = statement.substring(0, 500);

                            td.innerHTML = `
                  <div id="${statementId}-truncated">
                    <span>${truncated}...</span>
                    <br>
                    <button onclick="toggleAnalysisStatement('${statementId}', true)" 
                            class="btn-standard" style="margin-top: 5px; margin-right: 5px;">Mostrar Mais</button>
                    <button onclick="copyAnalysisStatement('${statementId}', event)" 
                            class="btn-standard" style="margin-top: 5px;">Copiar</button>
                  </div>
                  <div id="${statementId}-full" style="display: none;">
                    <span>${statement}</span>
                    <br>
                    <button onclick="toggleAnalysisStatement('${statementId}', false)" 
                            class="btn-standard" style="margin-top: 5px; margin-right: 5px;">Ocultar</button>
                    <button onclick="copyAnalysisStatement('${statementId}', event)" 
                            class="btn-standard" style="margin-top: 5px;">Copiar</button>
                  </div>
                `;
                        } else {
                            // Short statement - just show it with copy button
                            td.innerHTML = `
                  <div>
                    <span>${statement}</span>
                    <br>
                    <button onclick="copyAnalysisStatement('${statementId}', event)" 
                            class="btn-standard" style="margin-top: 5px;">Copiar</button>
                  </div>
                `;
                        }
                    } else if (col === "user_query_counts") {
                        // Bold the counts in parentheses
                        const formattedValue = value.replace(/\((\d+)\)/g, "<b>($1)</b>");
                        td.innerHTML = formattedValue;
                    } else if (col === "total_count") {
                        // Format total_count with commas
                        const numValue = Number(value);
                        td.textContent = isNaN(numValue) ? value : numValue.toLocaleString();
                    } else {
                        td.textContent = value;
                    }

                    // Style avg primaryScan when > 0 (red and bold)
                    if (col === "avg_primaryScan") {
                        // Handle comma-formatted numbers by removing commas first
                        const cleanValue = String(value).replace(/,/g, '');
                        const originalValue = Number(cleanValue);
                        if (!isNaN(originalValue) && originalValue > 0) {
                            td.classList.add("primary-scan-yes");
                        }
                    }

                    row.appendChild(td);
                });
                analysisTableBody.appendChild(row);
            });
        }

        // Helper function to get time grouping settings
        function getTimeGrouping() {
            const dropdown = document.getElementById('time-grouping-select');
            return dropdown ? dropdown.value : "optimizer";
        }

        // Helper function to round timestamp based on grouping and optimal unit
        function roundTimestamp(timestamp, grouping, requests) {
            const date = new Date(timestamp);

            // Determine actual unit to use
            let actualUnit;
            if (grouping === "optimizer") {
                actualUnit = getOptimalTimeUnit(requests);
            } else {
                // Use exactly what the user selected
                actualUnit = grouping;
            }

            // Round based on actual unit
            switch (actualUnit) {
                case "second":
                    date.setMilliseconds(0);
                    break;
                case "minute":
                    date.setSeconds(0, 0);
                    break;
                case "hour":
                    date.setMinutes(0, 0, 0);
                    break;
                case "day":
                    date.setHours(0, 0, 0, 0);
                    break;
                case "week":
                    const dayOfWeek = date.getDay();
                    date.setDate(date.getDate() - dayOfWeek);
                    date.setHours(0, 0, 0, 0);
                    break;
                case "month":
                    date.setDate(1);
                    date.setHours(0, 0, 0, 0);
                    break;
                case "year":
                    date.setMonth(0, 1);
                    date.setHours(0, 0, 0, 0);
                    break;
                default:
                    date.setSeconds(0, 0);
            }
            return date;
        }

        // Helper function to automatically determine optimal time unit based on data span
        function getOptimalTimeUnit(requests) {
            if (!requests || requests.length === 0) return "minute";

            const times = requests
                .map((r) => new Date(r.requestTime))
                .filter((t) => !isNaN(t));
            if (times.length === 0) return "minute";

            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            const timeSpanMs = maxTime - minTime;
            const timeSpanHours = timeSpanMs / (1000 * 60 * 60);
            const timeSpanDays = timeSpanHours / 24;

            // Choose time unit based on span to keep Chart.js happy
            if (timeSpanDays > 365) {
                return "year";
            } else if (timeSpanDays > 60) {
                return "month";
            } else if (timeSpanDays > 14) {
                return "week";
            } else if (timeSpanDays > 2) {
                return "day";
            } else if (timeSpanHours > 2) {
                return "hour";
            } else if (timeSpanHours > 0.1) {
                return "minute";
            } else {
                return "second";
            }
        }

        // Helper function to get Chart.js time configuration with auto-adjustment
        function getTimeConfig(requestedGrouping, requests) {
            // Use exactly the unit that was requested
            let actualUnit = requestedGrouping;

            // Calculate appropriate stepSize based on data span to prevent Chart.js errors
            let stepSize = 1;
            if (requests && requests.length > 0) {
                const times = requests
                    .map((r) => new Date(r.requestTime))
                    .filter((t) => !isNaN(t));
                if (times.length > 0) {
                    const minTime = Math.min(...times);
                    const maxTime = Math.max(...times);
                    const timeSpanMs = maxTime - minTime;

                    // Calculate stepSize to keep data points reasonable (max ~1000 points)
                    switch (actualUnit) {
                        case "second":
                            stepSize = Math.max(1, Math.ceil(timeSpanMs / (1000 * 1000))); // timeSpanMs / (1000ms * 1000 points)
                            break;
                        case "minute":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (60 * 1000 * 1000))
                            ); // timeSpanMs / (60s * 1000ms * 1000 points)
                            break;
                        case "hour":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (3600s * 1000ms * 1000 points)
                            break;
                        case "day":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (86400s * 1000ms * 1000 points)
                            break;
                        case "week":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (7 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (604800s * 1000ms * 1000 points)
                            break;
                        case "month":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (30 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (~2592000s * 1000ms * 1000 points)
                            break;
                        case "year":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (365 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (~31536000s * 1000ms * 1000 points)
                            break;
                    }
                }
            }

            // Return appropriate config based on actual unit
            const configs = {
                second: {
                    unit: "second",
                    stepSize: stepSize,
                    displayFormats: { second: "HH:mm:ss" },
                },
                minute: {
                    unit: "minute",
                    stepSize: stepSize,
                    displayFormats: { minute: "MMM dd HH:mm" },
                },
                hour: {
                    unit: "hour",
                    stepSize: stepSize,
                    displayFormats: { hour: "MMM dd HH:mm" },
                },
                day: {
                    unit: "day",
                    stepSize: stepSize,
                    displayFormats: { day: "MMM dd" },
                },
                week: {
                    unit: "week",
                    stepSize: stepSize,
                    displayFormats: { week: "MMM dd" },
                },
                month: {
                    unit: "month",
                    stepSize: stepSize,
                    displayFormats: { month: "MMM yyyy" },
                },
                year: {
                    unit: "year",
                    stepSize: stepSize,
                    displayFormats: { year: "yyyy" },
                },
            };

            return configs[actualUnit] || configs["minute"];
        }

        // Helper function to get current time config with requests data
        function getCurrentTimeConfig(requests) {
            const grouping = getTimeGrouping();
            let actualUnit;
            if (grouping === "optimizer") {
                actualUnit = getOptimalTimeUnit(requests);
            } else {
                actualUnit = grouping;
            }
            return getTimeConfig(actualUnit, requests);
        }

        // Helper function to update the optimizer label
        function updateOptimizerLabel(requests) {
            const optimizedUnit = getOptimalTimeUnit(requests);
            const dropdown = document.getElementById("time-grouping-select");
            if (dropdown) {
                // Update the first option text to show the actual optimized unit
                const optimizerOption = dropdown.querySelector('option[value="optimizer"]');
                if (optimizerOption) {
                    optimizerOption.textContent = `By Optimizer (${optimizedUnit})`;
                }
            }
        }

        // Array to store all timeline charts for synchronization
        const timelineCharts = [];

        // Custom plugin to draw a vertical line on hover
        const verticalLinePlugin = {
            id: 'verticalLine',
            afterInit(chart) {
                chart.verticalLine = { draw: false, x: 0 };
            },
            afterEvent(chart, args) {
                const { inChartArea, event } = args;
                if (chart.verticalLine) {
                    chart.verticalLine.draw = inChartArea;
                    chart.verticalLine.x = event ? event.x : args.x;
                    // Let Chart.js handle the redraw naturally, don't force it
                }
            },
            afterDatasetsDraw(chart) {
                if (!chart.verticalLine || !chart.verticalLine.draw || !chart.verticalLine.x) return;

                const { ctx, chartArea: { top, bottom } } = chart;
                ctx.save();
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#007bff';
                ctx.setLineDash([5, 5]);
                ctx.moveTo(chart.verticalLine.x, top);
                ctx.lineTo(chart.verticalLine.x, bottom);
                ctx.stroke();
                ctx.restore();
            }
        };

        // Function to sync crosshairs across all timeline charts
        function syncTimelineCharts(sourceEvent, activeChart) {
            if (!activeChart || !activeChart.chartArea) return;

            const chartArea = activeChart.chartArea;
            const inChartArea = sourceEvent.x >= chartArea.left && sourceEvent.x <= chartArea.right &&
                sourceEvent.y >= chartArea.top && sourceEvent.y <= chartArea.bottom;

            // Filter out null/destroyed charts and exclude the active chart
            const validCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart !== activeChart &&  // Exclude active chart to prevent flicker
                    chart.canvas &&
                    chart.canvas.getContext &&
                    chart.scales &&
                    chart.scales.x &&
                    chart.chartArea &&
                    !chart.isDestroyed;
            });

            // Update active chart's crosshair state without redrawing
            if (activeChart.verticalLine) {
                activeChart.verticalLine.draw = inChartArea;
                if (inChartArea) {
                    activeChart.verticalLine.x = sourceEvent.x;
                }
            }

            // Sync other charts
            validCharts.forEach(chart => {
                if (!inChartArea) {
                    if (chart.verticalLine && chart.verticalLine.draw) {
                        chart.verticalLine.draw = false;
                        requestAnimationFrame(() => chart.draw());
                    }
                    return;
                }

                try {
                    const xValue = activeChart.scales.x.getValueForPixel(sourceEvent.x);
                    const targetX = chart.scales.x.getPixelForValue(xValue);

                    if (chart.verticalLine && targetX >= chart.chartArea.left && targetX <= chart.chartArea.right) {
                        const wasDrawn = chart.verticalLine.draw;
                        const oldX = chart.verticalLine.x;

                        chart.verticalLine.draw = true;
                        chart.verticalLine.x = targetX;

                        // Only redraw if position changed significantly or wasn't drawn before
                        if (!wasDrawn || Math.abs(oldX - targetX) > 2) {
                            requestAnimationFrame(() => chart.draw());
                        }
                    }
                } catch (error) {
                    // Silently handle errors
                    if (chart.verticalLine) {
                        chart.verticalLine.draw = false;
                    }
                }
            });

            // Update the timelineCharts array to only contain valid charts (including active chart)
            const allValidCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart.canvas &&
                    chart.canvas.getContext &&
                    chart.scales &&
                    chart.scales.x &&
                    chart.chartArea &&
                    !chart.isDestroyed;
            });

            if (allValidCharts.length !== timelineCharts.length) {
                timelineCharts.length = 0;
                timelineCharts.push(...allValidCharts);
            }
        }

        // Clear crosshairs on all timeline charts
        function clearTimelineCrosshairs() {
            // Filter out null/destroyed charts
            const validCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart.canvas &&
                    chart.canvas.getContext &&
                    !chart.isDestroyed &&
                    chart.verticalLine;
            });

            validCharts.forEach(chart => {
                if (chart.verticalLine && chart.verticalLine.draw) {
                    chart.verticalLine.draw = false;
                    requestAnimationFrame(() => chart.draw());
                }
            });

            // Update the timelineCharts array to only contain valid charts
            if (validCharts.length !== timelineCharts.length) {
                timelineCharts.length = 0;
                timelineCharts.push(...validCharts);
            }
        }

        // Helper function to register a chart for crosshair synchronization
        function registerTimelineChart(chart, ctx) {
            if (!chart || !ctx || !ctx.canvas) return;

            // Add to timeline charts array for synchronization
            timelineCharts.push(chart);

            // Throttle mousemove events to prevent excessive redraws
            let mouseMoveTimeout;
            const mouseMoveHandler = (event) => {
                if (mouseMoveTimeout) return;

                mouseMoveTimeout = setTimeout(() => {
                    mouseMoveTimeout = null;

                    const rect = ctx.canvas.getBoundingClientRect();
                    const canvasEvent = {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    };
                    syncTimelineCharts(canvasEvent, chart);
                }, 8); // Throttle to ~120fps
            };

            // Add mouseleave event listener to clear crosshairs
            const mouseLeaveHandler = () => {
                if (mouseMoveTimeout) {
                    clearTimeout(mouseMoveTimeout);
                    mouseMoveTimeout = null;
                }
                clearTimelineCrosshairs();
            };

            ctx.canvas.addEventListener('mousemove', mouseMoveHandler);
            ctx.canvas.addEventListener('mouseleave', mouseLeaveHandler);

            // Store handlers for cleanup if needed
            chart._crosshairHandlers = {
                mousemove: mouseMoveHandler,
                mouseleave: mouseLeaveHandler
            };
        }

        // Generate operations chart showing index scan vs fetch operations
        function generateOperationsChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.operationsChart) {
                window.operationsChart.destroy();
                window.operationsChart = null;
            }

            const canvas = document.getElementById("operations-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalIndexScan: 0,
                        totalFetch: 0,
                        indexScanQueryCount: 0,
                    };
                }

                // Use pre-calculated values from indexInfo
                const indexInfo = request.indexInfo || {
                    stats: { primaryScan: 0, indexScan: 0, fetch: 0 },
                };
                const { primaryScan, indexScan, fetch } = indexInfo.stats;

                timeGroups[key].totalIndexScan += primaryScan + indexScan;
                timeGroups[key].totalFetch += fetch;

                // Count queries that performed index scans
                if (primaryScan > 0 || indexScan > 0) {
                    timeGroups[key].indexScanQueryCount++;
                }
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const indexScanData = sortedData.map((item) => item.totalIndexScan);
            const fetchData = sortedData.map((item) => item.totalFetch);
            const avgIndexScanData = sortedData.map((item) =>
                item.indexScanQueryCount > 0 ? Math.round(item.totalIndexScan / item.indexScanQueryCount) : null
            );

            // Create new side-by-side bar chart
            window.operationsChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Fetch Documents",
                            data: fetchData,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Index Scan Items",
                            data: indexScanData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Index Scans per Query",
                            data: avgIndexScanData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            spanGaps: false,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Database Operations Timeline: Index Scans vs Document Fetches",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Sync pan with other charts
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Operation Count",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg Index Scans per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.operationsChart, ctx);
        }

        // Generate filter chart showing filter efficiency (IN vs OUT)
        function generateFilterChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.filterChart) {
                window.filterChart.destroy();
                window.filterChart = null;
            }

            const canvas = document.getElementById("filter-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime || !request.plan) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        filtersEqual: 0,
                        filtersNotEqual: 0,
                    };
                }

                // Find all Filter operators in the plan
                const operators = getOperators(request.plan);
                operators.forEach((operator) => {
                    if (operator["#operator"] === "Filter") {
                        const stats = operator["#stats"] || {};
                        const itemsIn = stats["#itemsIn"];
                        const itemsOut = stats["#itemsOut"];

                        if (itemsIn !== undefined && itemsOut !== undefined) {
                            if (itemsIn === itemsOut) {
                                timeGroups[key].filtersEqual++;
                            } else {
                                timeGroups[key].filtersNotEqual++;
                            }
                        }
                    }
                });
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const filtersEqualData = sortedData.map((item) => item.filtersEqual);
            const filtersNotEqualData = sortedData.map(
                (item) => item.filtersNotEqual
            );
            const percentageData = sortedData.map((item) => {
                const total = item.filtersEqual + item.filtersNotEqual;
                return total > 0 ? (item.filtersNotEqual / total) * 100 : 0;
            });

            // Create new mixed chart with bars and line
            window.filterChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Filters: IN = OUT",
                            data: filtersEqualData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                            order: 2,
                        },
                        {
                            label: "Filters: IN ≠ OUT",
                            data: filtersNotEqualData,
                            backgroundColor: "#dc3545", // Red
                            borderColor: "#b02a37",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                            order: 3,
                        },
                        {
                            label: "Efficiency %",
                            data: percentageData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            tension: 0.3,
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Filter Operations Timeline: Efficiency Analysis (IN vs OUT)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Filter Count",
                            },
                            beginAtZero: true,
                            stacked: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Efficiency %",
                            },
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.filterChart, ctx);
        }

        // Generate timeline chart showing kernel time vs execution time performance
        function generateTimelineChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.timelineChart) {
                window.timelineChart.destroy();
                window.timelineChart = null;
            }

            const canvas = document.getElementById("timeline-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        percent0to10: 0,
                        percent10to20: 0,
                        percent20to30: 0,
                        percent30to40: 0,
                        percent40to50: 0,
                        percent50to60: 0,
                        percent60to70: 0,
                        percent70to80: 0,
                        percent80to90: 0,
                        percent90to100: 0,
                        percentOver100: 0,
                    };
                }

                // Use pre-calculated values
                const totalKernTimeMs = request.kernTimeMs || 0;
                const elapsedTimeMs = request.elapsedTimeMs || 0;

                // Calculate percentage of kernTime vs executionTime
                const kernTimePercentage =
                    elapsedTimeMs > 0 ? (totalKernTimeMs / elapsedTimeMs) * 100 : 0;

                // Group by percentage ranges
                if (kernTimePercentage < 10) {
                    timeGroups[key].percent0to10++;
                } else if (kernTimePercentage < 20) {
                    timeGroups[key].percent10to20++;
                } else if (kernTimePercentage < 30) {
                    timeGroups[key].percent20to30++;
                } else if (kernTimePercentage < 40) {
                    timeGroups[key].percent30to40++;
                } else if (kernTimePercentage < 50) {
                    timeGroups[key].percent40to50++;
                } else if (kernTimePercentage < 60) {
                    timeGroups[key].percent50to60++;
                } else if (kernTimePercentage < 70) {
                    timeGroups[key].percent60to70++;
                } else if (kernTimePercentage < 80) {
                    timeGroups[key].percent70to80++;
                } else if (kernTimePercentage < 90) {
                    timeGroups[key].percent80to90++;
                } else if (kernTimePercentage <= 100) {
                    timeGroups[key].percent90to100++;
                } else {
                    timeGroups[key].percentOver100++;
                }
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Set original time range from data
            if (sortedData.length > 0) {
                originalTimeRange.min = sortedData[0].timestamp;
                originalTimeRange.max = sortedData[sortedData.length - 1].timestamp;
                currentTimeRange = { ...originalTimeRange };
                updateTimeRangeDisplay();
            }

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const percent0to10Data = sortedData.map((item) => item.percent0to10);
            const percent10to20Data = sortedData.map((item) => item.percent10to20);
            const percent20to30Data = sortedData.map((item) => item.percent20to30);
            const percent30to40Data = sortedData.map((item) => item.percent30to40);
            const percent40to50Data = sortedData.map((item) => item.percent40to50);
            const percent50to60Data = sortedData.map((item) => item.percent50to60);
            const percent60to70Data = sortedData.map((item) => item.percent60to70);
            const percent70to80Data = sortedData.map((item) => item.percent70to80);
            const percent80to90Data = sortedData.map((item) => item.percent80to90);
            const percent90to100Data = sortedData.map(
                (item) => item.percent90to100
            );
            const percentOver100Data = sortedData.map(
                (item) => item.percentOver100
            );

            // Create new stacked bar chart
            window.timelineChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "0-10%",
                            data: percent0to10Data,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                        },
                        {
                            label: "10-20%",
                            data: percent10to20Data,
                            backgroundColor: "#6cb2eb", // Light blue
                            borderColor: "#3490dc",
                            borderWidth: 1,
                        },
                        {
                            label: "20-30%",
                            data: percent20to30Data,
                            backgroundColor: "#a78bfa", // Light purple
                            borderColor: "#8b5cf6",
                            borderWidth: 1,
                        },
                        {
                            label: "30-40%",
                            data: percent30to40Data,
                            backgroundColor: "#34d399", // Light green
                            borderColor: "#10b981",
                            borderWidth: 1,
                        },
                        {
                            label: "40-50%",
                            data: percent40to50Data,
                            backgroundColor: "#fbbf24", // Yellow
                            borderColor: "#f59e0b",
                            borderWidth: 1,
                        },
                        {
                            label: "50-60%",
                            data: percent50to60Data,
                            backgroundColor: "#fb923c", // Orange
                            borderColor: "#ea580c",
                            borderWidth: 1,
                        },
                        {
                            label: "60-70%",
                            data: percent60to70Data,
                            backgroundColor: "#f472b6", // Pink
                            borderColor: "#ec4899",
                            borderWidth: 1,
                        },
                        {
                            label: "70-80%",
                            data: percent70to80Data,
                            backgroundColor: "#a855f7", // Purple
                            borderColor: "#9333ea",
                            borderWidth: 1,
                        },
                        {
                            label: "80-90%",
                            data: percent80to90Data,
                            backgroundColor: "#ef4444", // Red
                            borderColor: "#dc2626",
                            borderWidth: 1,
                        },
                        {
                            label: "90-100%",
                            data: percent90to100Data,
                            backgroundColor: "#991b1b", // Dark red
                            borderColor: "#7f1d1d",
                            borderWidth: 1,
                        },
                        {
                            label: "100%+",
                            data: percentOver100Data,
                            backgroundColor: "#450a0a", // Very dark red
                            borderColor: "#1c0a0a",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        intersect: false,
                        mode: "index",
                    },
                    elements: {
                        point: {
                            radius: 0, // Hide points for better performance
                            hoverRadius: 4,
                        },
                    },
                    scales: {
                        x: {
                            stacked: true,
                            type: "time",
                            time: {
                                displayFormats: {
                                    minute: "HH:mm",
                                    hour: "MM-DD HH:mm",
                                },
                            },
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                        },
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Performance Timeline: KernTime % of ExecutionTime",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range - convert chart scale values to Date objects
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                            stacked: true,
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Contagem de Consultas",
                            },
                            stacked: true,
                            beginAtZero: true,
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.timelineChart, ctx);

            // Create Query Types Scatter Plot Chart
            createQueryTypesChart(requests, grouping);

            // Create Duration Buckets Chart
            createDurationBucketsChart(requests, grouping);

            // Create Memory Usage Chart
            createMemoryChart(requests, grouping);

            // Create Result Count Chart
            createResultCountChart(requests, grouping);

            // Create Result Size Chart
            createResultSizeChart(requests, grouping);
        }

        // Create Query Types Scatter Plot Chart
        function createQueryTypesChart(requests, grouping) {
            const canvas = document.getElementById("query-types-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.queryTypesChart) {
                window.queryTypesChart.destroy();
            }

            // Group requests by time and statement type
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        statementTypes: {},
                    };
                }

                // Use consistent statement type parsing
                let statementType = request.statementType || deriveStatementType(request.statement) || "UNKNOWN";

                if (!timeGroups[key].statementTypes[statementType]) {
                    timeGroups[key].statementTypes[statementType] = {
                        count: 0,
                        durations: [],
                    };
                }

                timeGroups[key].statementTypes[statementType].count++;

                // Get duration in seconds
                const elapsedTimeMs = parseTime(request.elapsedTime);
                const durationSeconds = elapsedTimeMs / 1000;
                timeGroups[key].statementTypes[statementType].durations.push(
                    durationSeconds
                );
            });

            // Get all unique statement types
            const allStatementTypes = new Set();
            Object.values(timeGroups).forEach((group) => {
                Object.keys(group.statementTypes).forEach((type) => {
                    allStatementTypes.add(type);
                });
            });

            // Console log all statement types found
            console.log(
                "Statement types found:",
                Array.from(allStatementTypes).sort()
            );

            // Predefined colors for all statement types found
            const colorMap = {
                SELECT: "#007bff", // Blue
                INSERT: "#28a745", // Green
                DELETE: "#dc3545", // Red
                UPSERT: "#6f42c1", // Purple
                CREATE: "#fd7e14", // Orange
                DROP: "#e83e8c", // Pink
                EXPLAIN: "#20c997", // Teal
                ADVISE: "#17a2b8", // Cyan
                INFER: "#ffc107", // Yellow
                WITH: "#6c757d", // Gray
                PREPARE: "#fd7e14", // Orange-red
                EXECUTE: "#6610f2", // Indigo
                "--": "#343a40", // Dark gray (comments)
                UNKNOWN: "#868e96", // Light gray
            };

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.statementTypes).forEach((typeData) => {
                    minCount = Math.min(minCount, typeData.count);
                    maxCount = Math.max(maxCount, typeData.count);
                });
            });

            // Generate datasets for each statement type with variable circle sizes
            const datasets = Array.from(allStatementTypes).map((statementType) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    if (group.statementTypes[statementType]) {
                        const typeData = group.statementTypes[statementType];
                        // Calculate average duration for this time group and statement type
                        const avgDuration =
                            typeData.durations.reduce((sum, d) => sum + d, 0) /
                            typeData.durations.length;

                        // Calculate circle size based on count (3-15 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (typeData.count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 3 + sizeRatio * 12; // Range from 3 to 15 pixels

                        data.push({
                            x: group.timestamp,
                            y: avgDuration,
                            r: circleSize,
                            count: typeData.count,
                            maxDuration: Math.max(...typeData.durations),
                            minDuration: Math.min(...typeData.durations),
                        });
                    }
                });

                return {
                    label: `${statementType} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 50%)`,
                    borderColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 40%)`,
                    borderWidth: 1,
                };
            });

            // Create bubble chart
            window.queryTypesChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Duration by Statement Type (Bubble Size = Query Count)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const statementType = context.dataset.label.split(" (")[0];
                                    return [
                                        `${statementType}`,
                                        `Count: ${dataPoint.count}`,
                                        `Avg Duration: ${dataPoint.y.toFixed(3)}s`,
                                        `Min Duration: ${dataPoint.minDuration.toFixed(3)}s`,
                                        `Max Duration: ${dataPoint.maxDuration.toFixed(3)}s`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Average Duration (seconds)",
                            },
                            beginAtZero: true,
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.queryTypesChart, ctx);
        }

        // Create Duration Buckets Chart
        function createDurationBucketsChart(requests, grouping) {
            const canvas = document.getElementById("duration-buckets-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.durationBucketsChart) {
                window.durationBucketsChart.destroy();
            }

            // Group requests by time and duration buckets
            const timeGroups = {};

            console.log(
                "Duration buckets chart - processing requests:",
                requests.length
            );

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        durationBuckets: {
                            "0-1s": 0,
                            "1-2s": 0,
                            "2-3s": 0,
                            "3-4s": 0,
                            "4-5s": 0,
                            "5-10s": 0,
                            "10-30s": 0,
                            "30-60s": 0,
                            "60-120s": 0,
                            "120-240s": 0,
                            "240-500s": 0,
                            "500-900s": 0,
                            "900s+": 0,
                        },
                    };
                }

                // Get duration in seconds
                const durationMs = parseTime(request.elapsedTime);
                const durationSeconds = durationMs / 1000;

                // Categorize into duration buckets
                if (durationSeconds < 1) {
                    timeGroups[key].durationBuckets["0-1s"]++;
                } else if (durationSeconds < 2) {
                    timeGroups[key].durationBuckets["1-2s"]++;
                } else if (durationSeconds < 3) {
                    timeGroups[key].durationBuckets["2-3s"]++;
                } else if (durationSeconds < 4) {
                    timeGroups[key].durationBuckets["3-4s"]++;
                } else if (durationSeconds < 5) {
                    timeGroups[key].durationBuckets["4-5s"]++;
                } else if (durationSeconds < 10) {
                    timeGroups[key].durationBuckets["5-10s"]++;
                } else if (durationSeconds < 30) {
                    timeGroups[key].durationBuckets["10-30s"]++;
                } else if (durationSeconds < 60) {
                    timeGroups[key].durationBuckets["30-60s"]++;
                } else if (durationSeconds < 120) {
                    timeGroups[key].durationBuckets["60-120s"]++;
                } else if (durationSeconds < 240) {
                    timeGroups[key].durationBuckets["120-240s"]++;
                } else if (durationSeconds < 500) {
                    timeGroups[key].durationBuckets["240-500s"]++;
                } else if (durationSeconds < 900) {
                    timeGroups[key].durationBuckets["500-900s"]++;
                } else {
                    timeGroups[key].durationBuckets["900s+"]++;
                }
            });

            if (Object.keys(timeGroups).length > 0) {
            }

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.durationBuckets).forEach((count) => {
                    if (count > 0) {
                        minCount = Math.min(minCount, count);
                        maxCount = Math.max(maxCount, count);
                    }
                });
            });

            // Color mapping for duration buckets - progressive darkness
            const bucketColors = {
                "0-1s": "#28a745", // Green - fast
                "1-2s": "#6cb2eb", // Light blue
                "2-3s": "#ffc107", // Yellow
                "3-4s": "#fd7e14", // Orange
                "4-5s": "#dc3545", // Red
                "5-10s": "#6f42c1", // Purple
                "10-30s": "#495057", // Dark gray
                "30-60s": "#343a40", // Darker gray
                "60-120s": "#721c24", // Dark red
                "120-240s": "#5a1a1a", // Darker red
                "240-500s": "#450a0a", // Very dark red
                "500-900s": "#2d0a0a", // Extremely dark red
                "900s+": "#1a0404", // Nearly black red
            };

            // Generate datasets for each duration bucket
            const datasets = Object.keys(bucketColors).map((bucket) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    const count = group.durationBuckets[bucket];
                    if (count > 0) {
                        // Calculate circle size based on count (5-20 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 5 + sizeRatio * 15; // Range from 5 to 20 pixels

                        // Use bucket midpoint for y-axis position
                        let yPosition;
                        switch (bucket) {
                            case "0-1s":
                                yPosition = 0.5;
                                break;
                            case "1-2s":
                                yPosition = 1.5;
                                break;
                            case "2-3s":
                                yPosition = 2.5;
                                break;
                            case "3-4s":
                                yPosition = 3.5;
                                break;
                            case "4-5s":
                                yPosition = 4.5;
                                break;
                            case "5-10s":
                                yPosition = 7.5;
                                break;
                            case "10-30s":
                                yPosition = 20;
                                break;
                            case "30-60s":
                                yPosition = 45;
                                break;
                            case "60-120s":
                                yPosition = 90;
                                break;
                            case "120-240s":
                                yPosition = 180;
                                break;
                            case "240-500s":
                                yPosition = 370;
                                break;
                            case "500-900s":
                                yPosition = 700;
                                break;
                            case "900s+":
                                yPosition = 1200;
                                break;
                        }

                        data.push({
                            x: group.timestamp,
                            y: yPosition,
                            r: circleSize,
                            count: count,
                        });
                    }
                });

                return {
                    label: `${bucket} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor: bucketColors[bucket],
                    borderColor: bucketColors[bucket],
                    borderWidth: 1,
                };
            });

            // Create bubble chart
            window.durationBucketsChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Duration Distribution by Time Buckets (Bubble Size = Query Count)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const bucket = context.dataset.label.split(" (")[0];
                                    return [
                                        `Duration: ${bucket}`,
                                        `Count: ${dataPoint.count}`,
                                        `Time: ${new Date(dataPoint.x).toLocaleString()}`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: {
                                displayFormats: {
                                    millisecond: "HH:mm:ss.SSS",
                                    second: "HH:mm:ss",
                                    minute: "HH:mm",
                                    hour: "HH:mm",
                                    day: "MM/dd",
                                    week: "MM/dd",
                                    month: "MM/yy",
                                    quarter: "MM/yy",
                                    year: "yyyy",
                                },
                            },
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Duration Range (seconds)",
                            },
                            beginAtZero: true,
                            type: "logarithmic",
                            ticks: {
                                callback: function (value) {
                                    if (value === 0.5) return "0-1s";
                                    if (value === 1.5) return "1-2s";
                                    if (value === 2.5) return "2-3s";
                                    if (value === 3.5) return "3-4s";
                                    if (value === 4.5) return "4-5s";
                                    if (value === 7.5) return "5-10s";
                                    if (value === 20) return "10-30s";
                                    if (value === 45) return "30-60s";
                                    if (value === 90) return "60-120s";
                                    if (value === 180) return "120-240s";
                                    if (value === 370) return "240-500s";
                                    if (value === 700) return "500-900s";
                                    if (value === 1200) return "900s+";
                                    return "";
                                },
                            },
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.durationBucketsChart, ctx);
        }

        // Create Memory Usage Chart
        function createMemoryChart(requests, grouping) {
            const canvas = document.getElementById("memory-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.memoryChart) {
                window.memoryChart.destroy();
            }

            // Group requests by time and sum memory usage
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalMemoryBytes: 0,
                        queryCount: 0,
                    };
                }

                // Use pre-calculated memory value
                const usedMemoryBytes = request.memoryBytes || 0;
                timeGroups[key].totalMemoryBytes += usedMemoryBytes;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array and convert bytes to MB
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map((item) => ({
                    timestamp: item.timestamp,
                    totalMemoryMB: item.totalMemoryBytes / (1024 * 1024), // Convert bytes to MB
                    queryCount: item.queryCount,
                }));

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const memoryData = sortedData.map((item) => item.totalMemoryMB);

            // Calculate average memory per query for line chart
            const avgMemoryData = sortedData.map(
                (item) => item.totalMemoryMB / item.queryCount
            );

            // Create memory usage bar chart with line overlay
            window.memoryChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Memory Usage (MB)",
                            data: memoryData,
                            backgroundColor: "#17a2b8", // Info blue-cyan
                            borderColor: "#138496",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg per Query (MB)",
                            data: avgMemoryData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            tension: 0.3,
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Uso Total de Memória do Processo de Consultas",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataIndex = context.dataIndex;
                                    const memoryMB = context.parsed.y;
                                    const queryCount = sortedData[dataIndex].queryCount;
                                    return [
                                        `Memory Usage: ${memoryMB.toFixed(2)} MB`,
                                        `Queries: ${queryCount}`,
                                        `Avg per Query: ${(memoryMB / queryCount).toFixed(2)} MB`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Memory Usage (MB)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query (MB)",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.memoryChart, ctx);
        }

        // Create Result Count Chart (light green bar + orange line for resultCount/query)
        function createResultCountChart(requests, grouping) {
            const canvas = document.getElementById("result-count-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.resultCountChart) {
                window.resultCountChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalResultCount: 0,
                        queryCount: 0,
                    };
                }

                const resultCount = request.resultCount || 0;
                timeGroups[key].totalResultCount += resultCount;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const resultCountData = sortedData.map((item) => item.totalResultCount);
            const avgResultCountData = sortedData.map((item) =>
                item.queryCount > 0 ? item.totalResultCount / item.queryCount : 0
            );

            window.resultCountChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Total Result Count",
                            data: resultCountData,
                            backgroundColor: "rgba(144, 238, 144, 0.8)", // Light green
                            borderColor: "rgba(144, 238, 144, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Result Count per Query",
                            data: avgResultCountData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Result Count Analysis: Total vs Average per Query",
                        },
                        legend: {
                            display: true,
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Total Result Count",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.resultCountChart, ctx);
        }

        // Create Result Size Chart (dark green bar + orange line for resultSize/query)
        function createResultSizeChart(requests, grouping) {
            const canvas = document.getElementById("result-size-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.resultSizeChart) {
                window.resultSizeChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalResultSize: 0,
                        queryCount: 0,
                    };
                }

                const resultSize = request.resultSize || 0;
                timeGroups[key].totalResultSize += resultSize;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data (convert bytes to MB)
            const labels = sortedData.map((item) => item.timestamp);
            const resultSizeData = sortedData.map((item) => item.totalResultSize / (1024 * 1024));
            const avgResultSizeData = sortedData.map((item) =>
                item.queryCount > 0 ? (item.totalResultSize / item.queryCount) / (1024 * 1024) : 0
            );

            window.resultSizeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Total Result Size (MB)",
                            data: resultSizeData,
                            backgroundColor: "rgba(0, 100, 0, 0.8)", // Dark green
                            borderColor: "rgba(0, 100, 0, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Result Size per Query (MB)",
                            data: avgResultSizeData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Result Size Analysis: Total vs Average per Query",
                        },
                        legend: {
                            display: true,
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Total Result Size (MB)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query (MB)",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.resultSizeChart, ctx);
        }

        // Reset timeline chart zoom
        function resetTimelineZoom() {
            if (window.timelineChart) {
                window.timelineChart.resetZoom();
            }
            if (window.operationsChart) {
                window.operationsChart.resetZoom();
            }
            if (window.filterChart) {
                window.filterChart.resetZoom();
            }
            if (window.queryTypesChart) {
                window.queryTypesChart.resetZoom();
            }
            if (window.durationBucketsChart) {
                window.durationBucketsChart.resetZoom();
            }
            if (window.memoryChart) {
                window.memoryChart.resetZoom();
            }
            if (window.resultCountChart) {
                window.resultCountChart.resetZoom();
            }
            if (window.resultSizeChart) {
                window.resultSizeChart.resetZoom();
            }

            // Reset to original time range
            currentTimeRange = { ...originalTimeRange };
            updateTimeRangeDisplay();
        }

        // Format date to datetime-local format
        function formatDateForInput(date) {
            if (!date) return "";
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            const hours = String(d.getHours()).padStart(2, "0");
            const minutes = String(d.getMinutes()).padStart(2, "0");
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Update the time range display
        function updateTimeRangeDisplay() {
            // Function kept for compatibility but display removed
        }

        // Use current time range in the date pickers
        function useCurrentTimeRange() {
            // Get current x-axis range directly from the chart
            if (
                window.timelineChart &&
                window.timelineChart.scales &&
                window.timelineChart.scales.x
            ) {
                const xScale = window.timelineChart.scales.x;
                const currentMin = new Date(xScale.min);
                const currentMax = new Date(xScale.max);

                const startValue = formatDateForInput(currentMin);
                const endValue = formatDateForInput(currentMax);

                document.getElementById("start-date").value = startValue;
                document.getElementById("end-date").value = endValue;
            }
        }

        // Change Y-axis scale for both charts
        function changeYAxisScale() {
            const selectedScale = document.querySelector(
                'input[name="yScale"]:checked'
            ).value;
            const scaleType =
                selectedScale === "logarithmic" ? "logarithmic" : "linear";

            // Update operations chart Y-axis scale
            if (window.operationsChart) {
                window.operationsChart.options.scales.y.type = scaleType;
                window.operationsChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.operationsChart.options.scales.y.beginAtZero = false;
                    window.operationsChart.options.scales.y.min = 1; // Avoid log(0)
                    window.operationsChart.options.scales.y1.beginAtZero = false;
                    window.operationsChart.options.scales.y1.min = 0.1; // Avoid log(0)
                } else {
                    window.operationsChart.options.scales.y.beginAtZero = true;
                    window.operationsChart.options.scales.y1.beginAtZero = true;
                    delete window.operationsChart.options.scales.y.min;
                    delete window.operationsChart.options.scales.y1.min;
                }
                window.operationsChart.update();
            }

            // Update filter chart Y-axis scale
            if (window.filterChart) {
                window.filterChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.filterChart.options.scales.y.beginAtZero = false;
                    window.filterChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.filterChart.options.scales.y.beginAtZero = true;
                    delete window.filterChart.options.scales.y.min;
                }
                window.filterChart.update();
            }

            // Update timeline chart Y-axis scale
            if (window.timelineChart) {
                window.timelineChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.timelineChart.options.scales.y.beginAtZero = false;
                    window.timelineChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.timelineChart.options.scales.y.beginAtZero = true;
                    delete window.timelineChart.options.scales.y.min;
                }
                window.timelineChart.update();
            }

            // Update query types chart Y-axis scale
            if (window.queryTypesChart) {
                window.queryTypesChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.queryTypesChart.options.scales.y.beginAtZero = false;
                    window.queryTypesChart.options.scales.y.min = 0.001; // Avoid log(0) for very small durations
                } else {
                    window.queryTypesChart.options.scales.y.beginAtZero = true;
                    delete window.queryTypesChart.options.scales.y.min;
                }
                window.queryTypesChart.update();
            }

            // Update memory chart Y-axis scale
            if (window.memoryChart) {
                window.memoryChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.memoryChart.options.scales.y.beginAtZero = false;
                    window.memoryChart.options.scales.y.min = 0.001; // Avoid log(0) for small memory values
                } else {
                    window.memoryChart.options.scales.y.beginAtZero = true;
                    delete window.memoryChart.options.scales.y.min;
                }
                window.memoryChart.update();
            }



            // Update result count chart Y-axis scale
            if (window.resultCountChart) {
                window.resultCountChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.resultCountChart.options.scales.y.beginAtZero = false;
                    window.resultCountChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.resultCountChart.options.scales.y.beginAtZero = true;
                    delete window.resultCountChart.options.scales.y.min;
                }
                window.resultCountChart.update();
            }

            // Update result size chart Y-axis scale
            if (window.resultSizeChart) {
                window.resultSizeChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.resultSizeChart.options.scales.y.beginAtZero = false;
                    window.resultSizeChart.options.scales.y.min = 0.001; // Avoid log(0) for small sizes
                } else {
                    window.resultSizeChart.options.scales.y.beginAtZero = true;
                    delete window.resultSizeChart.options.scales.y.min;
                }
                window.resultSizeChart.update();
            }


        }

        // Change time grouping for all charts
        function changeTimeGrouping() {
            // Use the filtered data if available, otherwise fall back to parsing JSON
            let requests = [];
            if (originalRequests.length > 0) {
                // Apply current date filtering to original data
                const startDateInput = document.getElementById("start-date");
                const endDateInput = document.getElementById("end-date");
                const startDate = startDateInput.value
                    ? new Date(startDateInput.value)
                    : null;
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : null;
                requests = filterRequestsByDateRange(
                    originalRequests,
                    startDate,
                    endDate
                );
            } else {
                // Fallback to parsing JSON if no original data
                const jsonInput = document.getElementById("json-input").value;
                if (!jsonInput.trim()) return;

                try {
                    const data = JSON.parse(jsonInput);
                    if (Array.isArray(data)) {
                        requests = data.map((item) => ({
                            ...item.completed_requests,
                            plan: item.plan
                                ? typeof item.plan === "string"
                                    ? JSON.parse(item.plan)
                                    : item.plan
                                : null,
                        }));
                    }
                } catch (e) {
                    console.error("Error parsing JSON for time grouping change:", e);
                    return;
                }
            }

            // Validate date range for the selected grouping
            const grouping = getTimeGrouping();
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");
            const startDate = startDateInput.value
                ? new Date(startDateInput.value)
                : null;
            const endDate = endDateInput.value
                ? new Date(endDateInput.value)
                : null;

            const validation = validateDateRangeForGrouping(
                startDate,
                endDate,
                grouping
            );
            if (!validation.valid) {
                alert(validation.message);
                return;
            }

            try {
                // Update the optimizer label to show current optimization
                updateOptimizerLabel(requests);

                // Regenerate all charts with new time grouping
                generateOperationsChart(requests);
                generateFilterChart(requests);
                generateTimelineChart(requests);
            } catch (e) {
                console.error("Error regenerating charts:", e);
                alert(
                    "Erro ao gerar gráficos. Tente reduzir o intervalo de datas ou selecionar um agrupamento de tempo mais amplo."
                );
            }
        }

        // Global variable to store original unfiltered data
        let originalRequests = [];
        let originalStartDate = null;
        let originalEndDate = null;

        // Store statements for safe access without HTML escaping issues
        let statementStore = {};
        let analysisStatementStore = {};

        // Parse Couchbase datetime to JavaScript Date
        function parseCouchbaseDateTime(dateTimeStr) {
            if (!dateTimeStr) return null;
            // Handle various Couchbase datetime formats
            const isoString = dateTimeStr.replace(" ", "T");
            return new Date(isoString);
        }

        // Convert Date to datetime-local input format
        function toDateTimeLocal(date) {
            if (!date || isNaN(date.getTime())) return "";
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            const hours = String(date.getHours()).padStart(2, "0");
            const minutes = String(date.getMinutes()).padStart(2, "0");
            const seconds = String(date.getSeconds()).padStart(2, "0");
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
        }

        // Filter requests by date range
        function filterRequestsByDateRange(requests, startDate, endDate) {
            if (!startDate && !endDate) return requests;

            return requests.filter((request) => {
                const requestDate = parseCouchbaseDateTime(request.requestTime);
                if (!requestDate) return true; // Include requests with invalid dates

                if (startDate && requestDate < startDate) return false;
                if (endDate && requestDate > endDate) return false;
                return true;
            });
        }

        // Update filter info display
        function updateFilterInfo(originalCount, filteredCount) {
            const filterInfo = document.getElementById("filter-info");
            if (originalCount === filteredCount) {
                filterInfo.textContent = `Showing all ${originalCount} queries`;
            } else {
                filterInfo.textContent = `Showing ${filteredCount} of ${originalCount} queries`;
            }
        }

        // Generate Dashboard Charts
        function generateDashboardCharts(requests) {
            generatePrimaryScanChart(requests);
            generateStateChart(requests);
            generateStatementTypeChart(requests);
            generateElapsedTimeChart(requests);
            generateQueryPatternChart(requests);
            generateUserCountTable(requests);
            generateIndexCountTable(requests);
        }

        // Check if a query uses primary index by analyzing the plan
        function usesPrimaryIndex(request) {
            if (!request.plan) return false;

            try {
                const planObj =
                    typeof request.plan === "string"
                        ? JSON.parse(request.plan)
                        : request.plan;
                return checkOperatorForPrimary(planObj);
            } catch (e) {
                return false;
            }
        }

        // Determine the index type used: 'Primary', 'Sequential Scan', or 'GSI'
        function getIndexType(request) {
            if (!request.plan) return 'GSI';

            try {
                const planObj =
                    typeof request.plan === "string"
                        ? JSON.parse(request.plan)
                        : request.plan;
                return checkOperatorForIndexType(planObj);
            } catch (e) {
                return 'GSI';
            }
        }

        // Recursively check operators to determine index type
        function checkOperatorForIndexType(operator) {
            if (!operator) return 'GSI';

            // Check for sequential scan first (most specific)
            if (operator.using === "sequentialscan") {
                return 'Sequential Scan';
            }

            // Check for primary index indicators
            if (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                (operator.spans && operator.spans.length === 0)
            ) {
                return 'Primary';
            }

            // Recursively check child operators
            if (operator["~child"]) {
                const childType = checkOperatorForIndexType(operator["~child"]);
                if (childType !== 'GSI') return childType;
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                for (const child of operator["~children"]) {
                    const childType = checkOperatorForIndexType(child);
                    if (childType !== 'GSI') return childType;
                }
            }
            if (operator.input) {
                const inputType = checkOperatorForIndexType(operator.input);
                if (inputType !== 'GSI') return inputType;
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                for (const input of operator.inputs) {
                    const inputType = checkOperatorForIndexType(input);
                    if (inputType !== 'GSI') return inputType;
                }
            }
            if (operator.left) {
                const leftType = checkOperatorForIndexType(operator.left);
                if (leftType !== 'GSI') return leftType;
            }
            if (operator.right) {
                const rightType = checkOperatorForIndexType(operator.right);
                if (rightType !== 'GSI') return rightType;
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                const firstType = checkOperatorForIndexType(operator.first);
                if (firstType !== 'GSI') return firstType;
            }
            if (operator.second) {
                const secondType = checkOperatorForIndexType(operator.second);
                if (secondType !== 'GSI') return secondType;
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                for (const scan of operator.scans) {
                    const scanType = checkOperatorForIndexType(scan);
                    if (scanType !== 'GSI') return scanType;
                }
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                const scanType = checkOperatorForIndexType(operator.scan);
                if (scanType !== 'GSI') return scanType;
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                for (const subquery of operator["~subqueries"]) {
                    if (subquery.executionTimings) {
                        const subType = checkOperatorForIndexType(subquery.executionTimings);
                        if (subType !== 'GSI') return subType;
                    }
                }
            }

            return 'GSI';
        }

        // Recursively check operators for primary index usage
        function checkOperatorForPrimary(operator) {
            if (!operator) return false;

            // Check for primary index indicators
            if (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                operator.using === "sequentialscan" ||
                (operator.spans && operator.spans.length === 0)
            ) {
                return true;
            }

            // Recursively check child operators
            if (operator["~child"] && checkOperatorForPrimary(operator["~child"]))
                return true;
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                for (const child of operator["~children"]) {
                    if (checkOperatorForPrimary(child)) return true;
                }
            }
            if (operator.input && checkOperatorForPrimary(operator.input))
                return true;
            if (operator.inputs && Array.isArray(operator.inputs)) {
                for (const input of operator.inputs) {
                    if (checkOperatorForPrimary(input)) return true;
                }
            }
            if (operator.left && checkOperatorForPrimary(operator.left))
                return true;
            if (operator.right && checkOperatorForPrimary(operator.right))
                return true;
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first && checkOperatorForPrimary(operator.first))
                return true;
            if (operator.second && checkOperatorForPrimary(operator.second))
                return true;
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                for (const scan of operator.scans) {
                    if (checkOperatorForPrimary(scan)) return true;
                }
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan && checkOperatorForPrimary(operator.scan))
                return true;
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                for (const subquery of operator["~subqueries"]) {
                    if (
                        subquery.executionTimings &&
                        checkOperatorForPrimary(subquery.executionTimings)
                    )
                        return true;
                }
            }

            return false;
        }

        // Primary Scan Used Donut Chart
        function generatePrimaryScanChart(requests) {
            const scanCounts = { 'Primary': 0, 'Sequential Scan': 0, 'GSI': 0 };

            requests.forEach((request) => {
                const indexType = getIndexType(request);
                scanCounts[indexType]++;
            });

            const total = scanCounts['Primary'] + scanCounts['Sequential Scan'] + scanCounts['GSI'];

            // Show/hide warning div based on whether primary scans are detected
            const warningDiv = document.getElementById("primary-scan-warning");
            if (scanCounts['Primary'] > 0) {
                warningDiv.style.display = "flex";
            } else {
                warningDiv.style.display = "none";
            }

            const ctx = document
                .getElementById("primary-scan-chart")
                .getContext("2d");
            if (window.primaryScanChart) {
                window.primaryScanChart.destroy();
            }

            window.primaryScanChart = new Chart(ctx, {
                type: "doughnut",
                data: {
                    labels: ["Primary", "Sequential Scan", "GSI"],
                    datasets: [
                        {
                            data: [scanCounts['Primary'], scanCounts['Sequential Scan'], scanCounts['GSI']],
                            backgroundColor: ["#dc3545", "#fd7e14", "#f8f9fa"],
                            borderColor: ["#dc3545", "#fd7e14", "#dee2e6"],
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: "60%",
                    plugins: {
                        legend: {
                            position: "bottom",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                        datalabels: {
                            display: true,
                            color: function (context) {
                                // White text for Primary (red) and Sequential Scan (orange), dark text for GSI (light gray)
                                return context.dataIndex <= 1 ? "white" : "#6c757d";
                            },
                            font: {
                                weight: "bold",
                                size: 14,
                            },
                            formatter: function (value, context) {
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return percent + "%";
                            },
                        },
                    },
                },
                plugins: [
                    {
                        beforeDraw: function (chart) {
                            const ctx = chart.ctx;
                            ctx.save();

                            // Draw percentage labels on segments
                            chart.data.datasets[0].data.forEach((value, index) => {
                                const meta = chart.getDatasetMeta(0);
                                const arc = meta.data[index];
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;

                                if (value > 0) {
                                    // White text for Primary (red) and Sequential Scan (orange), dark text for GSI (light gray)
                                    ctx.fillStyle = index <= 1 ? "white" : "#6c757d";
                                    ctx.font = "bold 14px Arial";
                                    ctx.textAlign = "center";
                                    ctx.textBaseline = "middle";
                                    ctx.fillText(percent + "%", arc.x, arc.y);
                                }
                            });
                            ctx.restore();
                        },
                    },
                ],
            });
        }

        // Query State Pie Chart
        function generateStateChart(requests) {
            const stateCounts = {};

            requests.forEach((request) => {
                const state = request.state || "Unknown";
                stateCounts[state] = (stateCounts[state] || 0) + 1;
            });

            const total = Object.values(stateCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(stateCounts);
            const data = Object.values(stateCounts);

            // Semantic colors based on query state
            const colors = labels.map(state => {
                const lowerState = state.toLowerCase();
                switch (lowerState) {
                    case "completed":
                    case "success":
                        return "#28a745"; // Green - success
                    case "fatal":
                    case "errors":
                        return "#dc3545"; // Red - error
                    case "timeout":
                        return "#fd7e14"; // Orange - timeout
                    case "stopped":
                    case "cancelled":
                        return "#6c757d"; // Gray - stopped/cancelled
                    case "running":
                        return "#007bff"; // Blue - in progress
                    default:
                        return "#6f42c1"; // Purple - unknown/other
                }
            });

            const ctx = document.getElementById("state-chart").getContext("2d");
            if (window.stateChart) {
                window.stateChart.destroy();
            }

            window.stateChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        beforeDraw: function (chart) {
                            const ctx = chart.ctx;
                            ctx.save();
                            chart.data.datasets[0].data.forEach((value, index) => {
                                const meta = chart.getDatasetMeta(0);
                                const arc = meta.data[index];
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;

                                if (value > 0 && percent >= 5) {
                                    ctx.fillStyle = "white";
                                    ctx.font = "bold 12px Arial";
                                    ctx.textAlign = "center";
                                    ctx.textBaseline = "middle";
                                    ctx.fillText(percent + "%", arc.x, arc.y);
                                }
                            });
                            ctx.restore();
                        },
                    },
                ],
            });
        }

        // Derive statement type from SQL statement text
        function deriveStatementType(statement) {
            if (!statement || typeof statement !== "string") {
                return "UNKNOWN";
            }

            const trimmed = statement.trim().toUpperCase();
            if (!trimmed) {
                return "UNKNOWN";
            }

            // Handle common multi-word statement types first
            if (trimmed.startsWith("CREATE INDEX")) return "CREATE_INDEX";
            if (trimmed.startsWith("DROP INDEX")) return "DROP_INDEX";
            if (trimmed.startsWith("ALTER INDEX")) return "ALTER_INDEX";
            if (trimmed.startsWith("BUILD INDEX")) return "BUILD_INDEX";

            // Get first word for other statement types
            const firstWord = trimmed.split(/\s+/)[0];
            return firstWord;
        }

        // Statement Type Pie Chart
        function generateStatementTypeChart(requests) {
            const typeCounts = {};

            requests.forEach((request) => {
                // First try the statementType field, then derive from statement
                const type = request.statementType || deriveStatementType(request.statement) || "UNKNOWN";
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            });

            const total = Object.values(typeCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(typeCounts);
            const data = Object.values(typeCounts);
            const colors = [
                "#ff6384",
                "#36a2eb",
                "#ffce56",
                "#4bc0c0",
                "#9966ff",
                "#ff9f40",
                "#c9cbcf",
                "#4bc0c0",
            ];

            const ctx = document
                .getElementById("statement-type-chart")
                .getContext("2d");
            if (window.statementTypeChart) {
                window.statementTypeChart.destroy();
            }

            window.statementTypeChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label,
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        beforeDraw: function (chart) {
                            const ctx = chart.ctx;
                            ctx.save();
                            chart.data.datasets[0].data.forEach((value, index) => {
                                const meta = chart.getDatasetMeta(0);
                                const arc = meta.data[index];
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;

                                if (value > 0 && percent >= 5) {
                                    ctx.fillStyle = "white";
                                    ctx.font = "bold 12px Arial";
                                    ctx.textAlign = "center";
                                    ctx.textBaseline = "middle";
                                    ctx.fillText(percent + "%", arc.x, arc.y);
                                }
                            });
                            ctx.restore();
                        },
                    },
                ],
            });
        }

        // Elapsed Time Distribution Bar Chart
        function generateElapsedTimeChart(requests) {
            const timeBuckets = {
                "0-1s": 0,
                "1-2s": 0,
                "2-5s": 0,
                "5-10s": 0,
                "10-20s": 0,
                "20-40s": 0,
                "40-60s": 0,
                "60-90s": 0,
                "90s-5m": 0,
                "5-15m": 0,
                "15-30m": 0,
                "30-60m": 0,
                ">60m": 0,
            };

            requests.forEach((request) => {
                const elapsed = (request.elapsedTimeMs || 0) / 1000; // Convert ms to seconds

                if (elapsed <= 1) timeBuckets["0-1s"]++;
                else if (elapsed <= 2) timeBuckets["1-2s"]++;
                else if (elapsed <= 5) timeBuckets["2-5s"]++;
                else if (elapsed <= 10) timeBuckets["5-10s"]++;
                else if (elapsed <= 20) timeBuckets["10-20s"]++;
                else if (elapsed <= 40) timeBuckets["20-40s"]++;
                else if (elapsed <= 60) timeBuckets["40-60s"]++;
                else if (elapsed <= 90) timeBuckets["60-90s"]++;
                else if (elapsed <= 300) timeBuckets["90s-5m"]++;
                else if (elapsed <= 900) timeBuckets["5-15m"]++;
                else if (elapsed <= 1800) timeBuckets["15-30m"]++;
                else if (elapsed <= 3600) timeBuckets["30-60m"]++;
                else timeBuckets[">60m"]++;
            });

            const ctx = document
                .getElementById("elapsed-time-chart")
                .getContext("2d");
            if (window.elapsedTimeChart) {
                window.elapsedTimeChart.destroy();
            }

            window.elapsedTimeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(timeBuckets),
                    datasets: [
                        {
                            label: "Contagem de Consultas",
                            data: Object.values(timeBuckets),
                            backgroundColor: "#36a2eb",
                            borderColor: "#36a2eb",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Elapsed Time Range",
                            },
                        },
                    },
                },
            });
        }

        // Generate Query Pattern Chart
        function generateQueryPatternChart(requests) {
            const patternCounts = {
                // Far left
                WITH: 0,
                EXECUTE: 0,
                "SELECT *": 0,
                COUNT: 0,
                // Left-center
                "USE INDEX": 0,
                "USE KEYS": 0,
                // Center
                "No WHERE": 0,
                // Center-right  
                JOIN: 0,
                NEST: 0,
                UNNEST: 0,
                SEARCH: 0,
                "ARRAY QUERY": 0,
                LIKE: 0,
                REGEX: 0,
                // Far right
                "GROUP BY": 0,
                "ORDER BY": 0,
                LIMIT: 0,
                OFFSET: 0,
            };

            requests.forEach((request) => {
                const statement = (request.statement || "").toUpperCase();

                // No WHERE
                if (!statement.includes(" WHERE ")) {
                    patternCounts["No WHERE"]++;
                }

                // GROUP BY
                if (statement.includes(" GROUP BY ")) {
                    patternCounts["GROUP BY"]++;
                }

                // ORDER BY
                if (statement.includes(" ORDER BY ")) {
                    patternCounts["ORDER BY"]++;
                }

                // USE INDEX
                if (statement.includes("USE INDEX")) {
                    patternCounts["USE INDEX"]++;
                }

                // USE KEYS
                if (statement.includes("USE KEYS")) {
                    patternCounts["USE KEYS"]++;
                }

                // JOIN
                if (statement.includes(" JOIN ")) {
                    patternCounts["JOIN"]++;
                }

                // NEST
                if (statement.includes(" NEST ")) {
                    patternCounts["NEST"]++;
                }

                // UNNEST
                if (statement.includes(" UNNEST ")) {
                    patternCounts["UNNEST"]++;
                }

                // OFFSET
                if (statement.includes(" OFFSET ")) {
                    patternCounts["OFFSET"]++;
                }

                // SEARCH
                if (statement.includes(" SEARCH(")) {
                    patternCounts["SEARCH"]++;
                }

                // WITH (ensure it's a SQL clause, not a backticked field name)
                if ((statement.startsWith("WITH ") || statement.includes(" WITH ")) && !statement.includes("`WITH`")) {
                    patternCounts["WITH"]++;
                }

                // ARRAY QUERY (has ANY/EVERY + SATISFIES + END)
                if (
                    (statement.includes(" ANY ") || statement.includes(" EVERY ") || statement.includes("ANY AND EVERY")) &&
                    statement.includes(" SATISFIES ") &&
                    (statement.includes(" END ") || statement.endsWith(" END"))
                ) {
                    patternCounts["ARRAY QUERY"]++;
                }

                // SELECT * (between SELECT and FROM)
                const selectMatch = statement.match(/SELECT\s+(.+?)\s+FROM/);
                if (selectMatch) {
                    const selectPart = selectMatch[1].trim();
                    if (selectPart === "*" || selectPart.includes(".*")) {
                        patternCounts["SELECT *"]++;
                    }
                }

                // LIKE (ensure it's an operator, not a backticked field name)
                if (statement.includes(" LIKE ") && !statement.includes("`LIKE`")) {
                    patternCounts["LIKE"]++;
                }

                // COUNT
                if (statement.includes(" COUNT(")) {
                    patternCounts["COUNT"]++;
                }

                // REGEX
                if (statement.includes("REGEXP_") || /REGEX\s*\(/.test(statement)) {
                    patternCounts["REGEX"]++;
                }

                // EXECUTE
                if (statement.startsWith("EXECUTE")) {
                    patternCounts["EXECUTE"]++;
                }

                // LIMIT
                if (statement.includes(" LIMIT ")) {
                    patternCounts["LIMIT"]++;
                }
            });

            const ctx = document
                .getElementById("query-pattern-chart")
                .getContext("2d");
            if (window.queryPatternChart) {
                window.queryPatternChart.destroy();
            }

            // Generate colors based on pattern names
            const colors = Object.keys(patternCounts).map((pattern) => {
                if (pattern === "SELECT *") {
                    return "#dc3545"; // Red
                } else if (
                    pattern === "LIKE" ||
                    pattern === "No WHERE" ||
                    pattern === "REGEX"
                ) {
                    return "#fd7e14"; // Orange
                } else {
                    return "#28a745"; // Green
                }
            });

            window.queryPatternChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(patternCounts),
                    datasets: [
                        {
                            label: "Contagem de Consultas",
                            data: Object.values(patternCounts),
                            backgroundColor: colors,
                            borderColor: colors,
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Query Pattern Features",
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                            },
                        },
                    },
                },
            });
        }

        // Generate User Count Table
        function generateUserCountTable(requests) {
            const userCounts = {};

            requests.forEach((request) => {
                const user = request.users || "Unknown";
                userCounts[user] = (userCounts[user] || 0) + 1;
            });

            const sortedUsers = Object.entries(userCounts).sort(
                ([, a], [, b]) => b - a
            );

            const tbody = document.getElementById("user-count-body");
            tbody.innerHTML = "";

            sortedUsers.forEach(([user, count]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";
                row.innerHTML = `
              <td class="padding-8 text-align-center" style="font-weight: bold;">${count}</td>
              <td class="padding-8" style="word-break: break-word;">
                ${user}
                <button onclick="copyToClipboard('${user.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="margin-left: 8px;">
                  Copy
                </button>
              </td>
            `;
                tbody.appendChild(row);
            });
        }

        // Parse FROM clause to extract bucket.scope.collection
        function parseFromClause(statement) {
            if (!statement) return "_default._default._default";

            try {
                // Remove comments and normalize whitespace
                let cleanStatement = statement
                    .replace(/--.*$/gm, "") // Remove line comments
                    .replace(/\/\*[\s\S]*?\*\//g, "") // Remove block comments
                    .replace(/\s+/g, " ") // Normalize whitespace
                    .trim();

                // Look for the main FROM clause (not subquery FROM)
                // Use a more specific regex that avoids matching FROM inside parentheses
                const fromPattern = /\bFROM\s+([`\w]+(?:\.[`\w]+)*(?:\.[`\w]+)*)/i;
                const fromMatch = cleanStatement.match(fromPattern);

                if (!fromMatch) {
                    // Fallback: try to find any table-like reference after FROM
                    const fallbackPattern = /\bFROM\s+([`\w]+)/i;
                    const fallbackMatch = cleanStatement.match(fallbackPattern);
                    if (!fallbackMatch) return "_default._default._default";

                    const tableRef = fallbackMatch[1].replace(/`/g, "").trim();
                    return `${tableRef}._default._default`;
                }

                const tableRef = fromMatch[1].trim();

                // Handle backticks and clean the reference
                const cleanRef = tableRef.replace(/`/g, "");

                // Skip if it looks like a SQL keyword or function
                if (
                    /^(SELECT|WITH|CASE|WHEN|IF|EXISTS|NOT|AND|OR)$/i.test(cleanRef)
                ) {
                    return "_default._default._default";
                }

                // Split by dots
                const parts = cleanRef.split(".");

                if (parts.length === 1) {
                    // Only bucket specified
                    return `${parts[0]}._default._default`;
                } else if (parts.length === 2) {
                    // Bucket and scope specified
                    return `${parts[0]}.${parts[1]}._default`;
                } else if (parts.length >= 3) {
                    // Full bucket.scope.collection
                    return `${parts[0]}.${parts[1]}.${parts[2]}`;
                }

                return "_default._default._default";
            } catch (error) {
                console.warn("Error parsing FROM clause:", error, statement);
                return "_default._default._default";
            }
        }

        // Generate Index Count Table
        function generateIndexCountTable(requests) {
            const indexData = {};

            requests.forEach((request) => {
                const bucketScopeCollection = parseFromClause(request.statement);

                // Debug problematic parsing
                if (
                    bucketScopeCollection.includes("SELECT") ||
                    bucketScopeCollection.includes("(")
                ) {
                    console.warn("Potentially incorrect bucket parsing:", {
                        statement: request.statement?.substring(0, 100) + "...",
                        parsed: bucketScopeCollection,
                    });
                    // Use default for obviously wrong parsing
                    const correctedBSC = "_default._default._default";

                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, correctedBSC);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                } else {
                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, bucketScopeCollection);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                }
            });

            const sortedIndexes = Object.entries(indexData).sort(
                ([, a], [, b]) => b.count - a.count
            );

            const tbody = document.getElementById("index-count-body");
            tbody.innerHTML = "";

            sortedIndexes.forEach(([indexName, data]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";
                row.innerHTML = `
              <td class="padding-8 text-align-center" style="font-weight: bold;">${data.count
                    }</td>
              <td class="padding-8" style="word-break: break-word;">
                ${indexName}
                <button onclick="copyToClipboard('${indexName.replace(
                        /'/g,
                        "\\'"
                    )}', event)" 
                        class="btn-standard" style="margin-left: 8px;">
                  Copy
                </button>
              </td>
              <td class="padding-8 font-size-12" style="word-break: break-word; font-family: monospace;">
                ${data.bucketScopeCollection}
              </td>
            `;
                tbody.appendChild(row);
            });
        }

        // Recursively extract index names from plan operators with improved error handling
        function extractIndexNames(
            operator,
            indexData,
            bucketScopeCollection,
            depth = 0
        ) {
            if (!operator || !indexData) return;

            // Prevent infinite recursion
            if (depth > 50) {
                console.warn("Maximum recursion depth reached in extractIndexNames");
                return;
            }

            try {
                // Helper function to add index to data, resolving #primary conflicts
                function addIndexToData(indexName) {
                    let resolvedName = indexName;

                    // If this is #primary, try to resolve to actual primary index name
                    if (indexName === "#primary") {
                        const actualPrimary = resolvePrimaryIndexName(
                            bucketScopeCollection || "unknown.unknown.unknown"
                        );
                        if (actualPrimary && actualPrimary !== "#primary") {
                            resolvedName = actualPrimary;
                        }
                    }

                    if (!indexData[resolvedName]) {
                        indexData[resolvedName] = {
                            count: 0,
                            bucketScopeCollection: bucketScopeCollection || "unknown",
                        };
                    }
                    indexData[resolvedName].count++;
                }

                // Check for index name in various operator properties
                if (operator.index && typeof operator.index === "string") {
                    addIndexToData(operator.index);
                }
                if (operator.indexName && typeof operator.indexName === "string") {
                    addIndexToData(operator.indexName);
                }

                // Check for primary scan operators (align with usesPrimaryIndex logic)
                if (
                    operator["#operator"] === "PrimaryScan" ||
                    operator["#operator"] === "PrimaryScan3" ||
                    operator.index === "#primary" ||
                    operator.using === "sequentialscan" ||
                    (operator.spans &&
                        Array.isArray(operator.spans) &&
                        operator.spans.length === 0)
                ) {
                    // Only add #primary if we don't already have the actual index name
                    if (!operator.index || operator.index === "#primary") {
                        addIndexToData("#primary");
                    }
                    // If operator.index exists and is not #primary, it was already added above
                }

                // Recursively check child operators
                if (operator["~child"]) {
                    extractIndexNames(
                        operator["~child"],
                        indexData,
                        bucketScopeCollection,
                        depth + 1
                    );
                }
                if (operator["~children"] && Array.isArray(operator["~children"])) {
                    operator["~children"].forEach((child) =>
                        extractIndexNames(
                            child,
                            indexData,
                            bucketScopeCollection,
                            depth + 1
                        )
                    );
                }
            } catch (e) {
                console.warn("Error in extractIndexNames:", e);
            }
            if (operator.input) {
                extractIndexNames(operator.input, indexData, bucketScopeCollection);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexNames(input, indexData, bucketScopeCollection)
                );
            }
            if (operator.left) {
                extractIndexNames(operator.left, indexData, bucketScopeCollection);
            }
            if (operator.right) {
                extractIndexNames(operator.right, indexData, bucketScopeCollection);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexNames(operator.first, indexData, bucketScopeCollection);
            }
            if (operator.second) {
                extractIndexNames(operator.second, indexData, bucketScopeCollection);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexNames(scan, indexData, bucketScopeCollection)
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexNames(operator.scan, indexData, bucketScopeCollection);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexNames(
                            subquery.executionTimings,
                            indexData,
                            bucketScopeCollection
                        );
                    }
                });
            }
        }

        // Copy to clipboard function with improved fallback and security
        function copyToClipboard(text, button) {
            // Sanitize the text being copied
            const sanitizedText = DOMPurify
                ? DOMPurify.sanitize(text, { ALLOWED_TAGS: [] })
                : text;

            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard
                    .writeText(sanitizedText)
                    .then(() => {
                        const originalText = button.textContent;
                        button.textContent = "Copied!";
                        button.style.background = "#28a745";
                        showToast("Copied to clipboard", "success");
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = "#007bff";
                        }, 1000);
                    })
                    .catch((err) => {
                        console.error("Failed to copy text: ", err);
                        button.textContent = "Erro";
                        button.style.background = "#dc3545";
                        showToast("Falha ao copiar para a área de transferência", "error");
                        setTimeout(() => {
                            button.textContent = "Copiar";
                            button.style.background = "#007bff";
                        }, 1000);
                    });
            } else {
                // Fallback for older browsers or non-secure contexts
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = sanitizedText;
                    textArea.style.cssText =
                        "position: fixed; top: -9999px; left: -9999px;";
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();

                    const successful = document.execCommand("copy");
                    document.body.removeChild(textArea);

                    if (successful) {
                        const originalText = button.textContent;
                        button.textContent = "Copied!";
                        button.style.background = "#28a745";
                        showToast("Copied to clipboard", "success");
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = "#007bff";
                        }, 1000);
                    } else {
                        throw new Error("execCommand failed");
                    }
                } catch (err) {
                    console.error("Failed to copy text (fallback): ", err);
                    button.textContent = "Error";
                    button.style.background = "#dc3545";
                    showToast("Falha ao copiar para a área de transferência", "error");
                    setTimeout(() => {
                        button.textContent = "Copiar";
                        button.style.background = "#007bff";
                    }, 1000);
                }
            }
        }

        // Validate date range for time grouping
        function validateDateRangeForGrouping(startDate, endDate, grouping) {
            if (!startDate || !endDate || grouping === "optimizer")
                return { valid: true };

            const diffMs = endDate.getTime() - startDate.getTime();
            const diffHours = diffMs / (1000 * 60 * 60);
            const diffDays = diffMs / (1000 * 60 * 60 * 24);

            switch (grouping) {
                case "second":
                    if (diffHours > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Second" grouping, please restrict the date range to 1 hour or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "minute":
                    if (diffDays > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Minute" grouping, please restrict the date range to 1 day or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "hour":
                    const diffWeeks = diffDays / 7;
                    if (diffWeeks > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Hour" grouping, please restrict the date range to 1 week or less to avoid chart rendering issues.',
                        };
                    }
                    break;
            }

            return { valid: true };
        }

        // Optimized request data processor
        function processRequestData(item) {
            const request = item.completed_requests || item;

            // Parse and cache plan data immediately
            let plan = null;
            if (item.plan) {
                if (typeof item.plan === "string") {
                    try {
                        plan = JSON.parse(item.plan);
                    } catch (e) {
                        console.warn(`Failed to parse plan JSON for request:`, e.message);
                        showNotification(`JSON parsing error: ${e.message}`, "warning");
                        plan = null;
                    }
                } else {
                    plan = item.plan;
                }
            }

            // Pre-calculate commonly used values
            const processedRequest = {
                ...request,
                plan: plan,
                // Pre-calculate time values
                elapsedTimeMs: parseTime(request.elapsedTime),
                serviceTimeMs: plan ? calculateTotalServiceTime(plan) : parseTime(request.serviceTime || '0ms'),
                kernTimeMs: plan ? calculateTotalKernTime(plan) : 0,
                memoryBytes: request.usedMemory || 0,
                // Pre-calculate boolean flags
                usesPrimary: plan ? usesPrimaryIndex({ plan: plan }) : false,
                // Pre-extract index information
                indexInfo: plan ? extractIndexInfo(plan) : null,
                // Pre-calculate aggregations
                planStats: plan ? extractPlanStats(plan) : null,
                // Ensure we have a statement type (derive if not present)
                statementType: request.statementType || deriveStatementType(request.statement),
            };

            return processedRequest;
        }

        // Fast index information extraction
        function extractIndexInfo(plan) {
            const operators = getOperators(plan);
            const indexes = [];
            const stats = { primaryScan: 0, indexScan: 0, fetch: 0 };

            operators.forEach((operator) => {
                const operatorType = operator["#operator"];
                const operatorStats = operator["#stats"] || {};

                // Extract index names
                if (operator.index) {
                    indexes.push(operator.index);
                }

                // Aggregate stats
                if (
                    operatorType === "PrimaryScan" ||
                    operatorType === "PrimaryScan3"
                ) {
                    stats.primaryScan += operatorStats["#itemsOut"] || 0;
                } else if (
                    operatorType === "IndexScan" ||
                    operatorType === "IndexScan3"
                ) {
                    stats.indexScan += operatorStats["#itemsOut"] || 0;
                } else if (operatorType === "Fetch") {
                    stats.fetch += operatorStats["#itemsOut"] || 0;
                }
            });

            return { indexes, stats };
        }

        // Fast plan stats extraction
        function extractPlanStats(plan) {
            const operators = getOperators(plan);
            let totalItemsIn = 0;
            let totalItemsOut = 0;

            operators.forEach((operator) => {
                const stats = operator["#stats"] || {};
                totalItemsIn += stats["#itemsIn"] || 0;
                totalItemsOut += stats["#itemsOut"] || 0;
            });

            return { totalItemsIn, totalItemsOut };
        }

        // Parse JSON input - Optimized
        function parseJSON() {
            const jsonInput = document.getElementById("json-input").value.trim();
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Reset time grouping to default (By Optimizer) to prevent fine-grain errors
            const timeGroupingSelect = document.getElementById('time-grouping-select');
            if (timeGroupingSelect) {
                timeGroupingSelect.value = 'optimizer';
                // Trigger the change event to update any dependent UI
                changeTimeGrouping();
            }

            // Input validation
            if (!jsonInput) {
                showToast("Please paste your JSON data first", "warning");
                return;
            }

            if (jsonInput.length > 50 * 1024 * 1024) {
                // 50MB limit
                showToast("Input too large. Please use smaller datasets.", "error");
                return;
            }

            try {
                const data = JSON.parse(jsonInput);
                let processData = [];

                if (Array.isArray(data)) {
                    processData = data;
                } else if (data && data.results && Array.isArray(data.results)) {
                    processData = data.results;
                } else {
                    showToast(
                        "Please provide a valid JSON array or object with results.",
                        "error"
                    );
                    return;
                }

                if (processData.length === 0) {
                    showToast("No data found in the JSON", "warning");
                    return;
                }

                if (Array.isArray(processData)) {
                    // Process data in batches to avoid blocking UI
                    const batchSize = 200; // Reduced from 1000 for better responsiveness
                    const processedRequests = [];

                    // Show progress bar
                    document.getElementById("progress-container").style.display =
                        "block";

                    function processBatch(startIndex) {
                        const endIndex = Math.min(
                            startIndex + batchSize,
                            processData.length
                        );

                        for (let i = startIndex; i < endIndex; i++) {
                            try {
                                processedRequests.push(processRequestData(processData[i]));
                            } catch (e) {
                                console.warn(
                                    `Error processing request ${i}:`,
                                    e.message || e
                                );
                                // Continue processing other requests
                            }
                        }

                        // Update progress bar
                        const progress = Math.round(
                            (endIndex / processData.length) * 100
                        );
                        document.getElementById(
                            "progress-bar"
                        ).style.width = `${progress}%`;
                        document.getElementById(
                            "progress-text"
                        ).textContent = `${progress}%`;

                        if (endIndex < processData.length) {
                            // Process next batch asynchronously with optimized timing
                            requestAnimationFrame(() => {
                                setTimeout(() => processBatch(endIndex), 10);
                            });
                        } else {
                            // All batches processed
                            finishProcessing(processedRequests);
                        }
                    }

                    // Start processing
                    processBatch(0);
                } else {
                    showToast("Unexpected data format in JSON", "error");
                }
            } catch (e) {
                console.error("JSON parsing error:", e);
                showToast(`Error parsing JSON: ${e.message}`, "error");
                document.getElementById("progress-container").style.display = "none";
            }
        }

        // Toast notification system
        function showToast(message, type = "info") {
            // Remove any existing toasts
            const existingToasts = document.querySelectorAll(".toast");
            existingToasts.forEach((toast) => toast.remove());

            const toast = document.createElement("div");
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 20px;
          border-radius: 4px;
          color: white;
          font-weight: bold;
          z-index: 10000;
          max-width: 300px;
          word-wrap: break-word;
          opacity: 0;
          transition: opacity 0.3s ease;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;

            if (type === "error") {
                toast.style.backgroundColor = "#f44336";
            } else if (type === "warning") {
                toast.style.backgroundColor = "#ff9800";
            } else if (type === "success") {
                toast.style.backgroundColor = "#4caf50";
            } else {
                toast.style.backgroundColor = "#2196f3";
            }

            document.body.appendChild(toast);

            // Fade in
            setTimeout(() => (toast.style.opacity = "1"), 10);

            // Remove after 4 seconds
            setTimeout(() => {
                toast.style.opacity = "0";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 4000);
        }

        // Finish processing after all batches are done
        function finishProcessing(allRequests) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Hide progress bar and reset placeholder
            document.getElementById("progress-container").style.display = "none";
            document.getElementById("progress-bar").style.width = "0%";
            document.getElementById("progress-text").textContent = "0%";
            document.getElementById("json-input").placeholder =
                "Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests;";

            // Clear normalize cache if it gets too large to prevent memory issues
            if (normalizeCache.size > 5000) {
                normalizeCache.clear();
            }

            // Apply global system query filtering
            const filteredAllRequests = filterSystemQueries(allRequests);

            // If this is the first parse (no date filters set), populate date range
            if (
                !startDateInput.value &&
                !endDateInput.value &&
                filteredAllRequests.length > 0
            ) {
                originalRequests = filteredAllRequests;
                const dates = filteredAllRequests
                    .map((r) => parseCouchbaseDateTime(r.requestTime))
                    .filter((d) => d && !isNaN(d.getTime()))
                    .sort((a, b) => a - b);

                if (dates.length > 0) {
                    const minDate = dates[0];
                    const maxDate = dates[dates.length - 1];

                    // Add 1-minute buffer to ensure edge records aren't excluded by minute rounding
                    const startWithBuffer = new Date(minDate.getTime() - 60000); // -1 minute
                    const endWithBuffer = new Date(maxDate.getTime() + 60000); // +1 minute

                    originalStartDate = minDate;
                    originalEndDate = maxDate;
                    startDateInput.value = toDateTimeLocal(startWithBuffer);
                    endDateInput.value = toDateTimeLocal(endWithBuffer);
                }
            } else {
                // Use existing originalRequests if available, otherwise use current data
                if (originalRequests.length === 0) {
                    originalRequests = filteredAllRequests;
                }
            }

            // Apply date filtering
            const startDate = startDateInput.value
                ? new Date(startDateInput.value)
                : null;
            const endDate = endDateInput.value
                ? new Date(endDateInput.value)
                : null;

            const filteredRequests = filterRequestsByDateRange(
                filteredAllRequests,
                startDate,
                endDate
            );

            // Store filtered requests globally for Index/Query Flow tab activation
            window.filteredRequests = filteredRequests;

            // Validate date range for current time grouping
            const grouping = getTimeGrouping();
            const validation = validateDateRangeForGrouping(
                startDate,
                endDate,
                grouping
            );
            if (!validation.valid) {
                alert(validation.message);
                // Still continue with table generation, just skip charts
                updateFilterInfo(filteredAllRequests.length, filteredRequests.length);
                generateTable(filteredRequests);
                generateAnalysisTable(filteredRequests);
                buildIndexQueryFlow(filteredRequests);
                // Only reset flow diagram if no query was previously selected
                const flowDiagramValidation = document.getElementById("flow-diagram");
                if (!flowDiagramValidation.hasChildNodes() || flowDiagramValidation.children.length === 0) {
                    flowDiagramValidation.innerHTML = "Select a query from the table to view the flow diagram.";
                }
                return;
            }

            // Update UI with filtered data
            updateFilterInfo(filteredAllRequests.length, filteredRequests.length);
            try {
                generateTable(filteredRequests);
                generateAnalysisTable(filteredRequests);
                updateOptimizerLabel(filteredRequests);
                generateOperationsChart(filteredRequests);
                generateFilterChart(filteredRequests);
                generateTimelineChart(filteredRequests);
                generateDashboardCharts(filteredRequests);
                buildIndexQueryFlow(filteredRequests);

                // Extract used indexes from the query data
                extractUsedIndexes(filteredRequests);

                // Also parse index data if available
                parseIndexJSON();
            } catch (e) {
                console.error("Error generating charts:", e);
                alert(
                    "Error generating charts. Try reducing the date range or selecting a coarser time grouping."
                );
            }
            // Only reset flow diagram if no query was previously selected
            const flowDiagram = document.getElementById("flow-diagram");
            if (!flowDiagram.hasChildNodes() || flowDiagram.children.length === 0) {
                flowDiagram.innerHTML = "Select a query from the table to view the flow diagram.";
            }
        }

        // Modal event listeners
        const planModal = document.getElementById("plan-modal");
        const planCloseBtn = planModal.querySelector(".close");
        planCloseBtn.addEventListener("click", () => {
            planModal.style.display = "none";
        });
        planModal.addEventListener("click", (event) => {
            if (event.target === planModal) {
                planModal.style.display = "none";
            }
        });

        const operatorModal = document.getElementById("operator-modal");
        const operatorCloseBtn = operatorModal.querySelector(".close");
        operatorCloseBtn.addEventListener("click", () => {
            operatorModal.style.display = "none";
        });
        operatorModal.addEventListener("click", (event) => {
            if (event.target === operatorModal) {
                operatorModal.style.display = "none";
            }
        });

        // Function to set time range based on button selection
        function setTimeRange(type) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            if (type === "original") {
                if (originalStartDate && originalEndDate) {
                    startDateInput.value = toDateTimeLocal(originalStartDate);
                    endDateInput.value = toDateTimeLocal(originalEndDate);
                }
            } else if (type === "1day" || type === "1hour" || type === "1week") {
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : new Date();
                const startDate = new Date(endDate);

                if (type === "1day") {
                    startDate.setDate(startDate.getDate() - 1);
                } else if (type === "1hour") {
                    startDate.setHours(startDate.getHours() - 1);
                } else if (type === "1week") {
                    startDate.setDate(startDate.getDate() - 7);
                }

                startDateInput.value = toDateTimeLocal(startDate);
            }

            // Trigger filtering with new date range
            if (originalRequests.length > 0) {
                const startDate = startDateInput.value
                    ? new Date(startDateInput.value)
                    : null;
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : null;
                const filteredRequests = filterRequestsByDateRange(
                    originalRequests,
                    startDate,
                    endDate
                );

                updateFilterInfo(originalRequests.length, filteredRequests.length);
                generateTable(filteredRequests);
                generateTimeline(filteredRequests);
                generateAnalysis(filteredRequests);
                buildIndexQueryFlow(filteredRequests);
            }
        }

        // Track which tabs have been loaded
        let loadedTabs = new Set();

        // Initialize jQuery UI Tabs with lazy loading
        $(function () {
            $("#tabs").tabs({
                activate: function (event, ui) {
                    const tabId = ui.newPanel.attr("id");

                    // Lazy load charts when tabs are first activated
                    if (!loadedTabs.has(tabId)) {
                        loadedTabs.add(tabId);

                        if (tabId === "timeline" && originalRequests.length > 0) {
                            // Generate timeline charts only when tab is activated
                            generateTimelineChart(originalRequests);
                        } else if (tabId === "dashboard" && originalRequests.length > 0) {
                            // Generate dashboard charts only when tab is activated
                            generateDashboardCharts(originalRequests);
                        }
                    }

                    // Always check Index/Query Flow tab (not just first time)
                    if (tabId === "index-query-flow" && originalRequests.length > 0) {
                        console.log("🎯 Index/Query Flow tab activated (always rebuild)");
                        console.log("🎯 indexQueryFlowData.indexes size:", indexQueryFlowData.indexes.size);
                        console.log("🎯 indexQueryFlowData.queries size:", indexQueryFlowData.queries.size);

                        // Full render from existing indexQueryFlowData (create DIVs + SVG)
                        setTimeout(() => {
                            console.log("🔄 Tab activation: Full render from existing indexQueryFlowData");
                            console.log("🔄 Tab activation timeout - about to render");

                            // Convert indexQueryFlowData back to arrays for renderIndexQueryFlow
                            const indexes = Array.from(indexQueryFlowData.indexes.values());
                            const queries = Array.from(indexQueryFlowData.queries.values());

                            console.log("  📊 Rendering with - Indexes:", indexes.length, "Queries:", queries.length);

                            // Do full render (creates DIVs and SVG)
                            renderIndexQueryFlow(indexes, queries);
                            console.log("✅ Index/Query Flow full render complete");
                        }, 150);
                    }
                },
            });
        });

        // Index/Query Flow functionality
        let indexQueryFlowData = {
            indexes: new Map(),
            queries: new Map(),
            connections: new Map(),
        };

        // Clear all Index/Query Flow content
        function clearIndexQueryFlow() {
            // Clear the flow elements container
            const flowElements = document.getElementById("flow-elements");
            if (flowElements) {
                flowElements.innerHTML = "";
            }

            // Clear the SVG connections
            const svg = document.getElementById("flow-svg");
            if (svg) {
                svg.innerHTML = "";
            }

            // Clear data structures
            if (indexQueryFlowData) {
                indexQueryFlowData.indexes.clear();
                indexQueryFlowData.queries.clear();
                indexQueryFlowData.connections.clear();
            }
        }

        // Process Index/Query data without DOM rendering (for hidden tabs)
        function processIndexQueryData(requests) {
            console.log("📊 Processing Index/Query data structures only (no DOM rendering)");
            console.log("📊 processIndexQueryData received requests:", requests?.length || 0);

            // Clear and rebuild data structures
            indexQueryFlowData.indexes.clear();
            indexQueryFlowData.queries.clear();
            indexQueryFlowData.connections.clear();

            // Copy exact logic from buildIndexQueryFlow but skip DOM rendering
            const requestIndexMap = new Map();
            const allIndexes = new Map();
            const queryGroups = new Map();

            let requestsWithPlans = 0;
            let requestsWithOperators = 0;

            requests.forEach((request, requestIndex) => {
                requestIndexMap.set(requestIndex, new Set());
                if (request.plan) {
                    requestsWithPlans++;
                    const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;

                    if (planObj && planObj["#operator"]) {
                        requestsWithOperators++;
                        const statement = request.preparedText || request.statement || "";
                        let bucketScopeCollection = "unknown.unknown.unknown";

                        const fromMatch = statement.match(/FROM\s+([^\s\n\r\t]+)/i);
                        if (fromMatch) {
                            const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                            const parts = target.split(".");
                            if (parts.length === 1) {
                                bucketScopeCollection = `${parts[0]}._default._default`;
                            } else if (parts.length === 2) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                            } else if (parts.length >= 3) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                            }
                        }

                        extractIndexUsage(planObj, requestIndex, requestIndexMap, bucketScopeCollection);
                    }
                }

                // Group queries by normalized statement  
                const stmt = request.preparedText || request.statement;
                if (stmt) {
                    const normalized = normalizeStatement(stmt);
                    if (!queryGroups.has(normalized)) {
                        queryGroups.set(normalized, {
                            normalizedStatement: normalized,
                            statement: stmt, // Add original statement for createQueryDiv
                            count: 0,
                            totalDuration: 0, // Add totalDuration calculation
                            requests: []
                        });
                    }
                    const group = queryGroups.get(normalized);
                    group.count++;
                    // Use same logic as Analysis tab: serviceTime converted to ms
                    const durationMs = parseTime(request.serviceTime);
                    group.totalDuration += isNaN(durationMs) ? 0 : durationMs;
                    group.requests.push(request);
                }
            });

            // Build allIndexes from requestIndexMap (same as main function)
            requestIndexMap.forEach((indexSet, requestIndex) => {
                indexSet.forEach((indexName) => {
                    if (!allIndexes.has(indexName)) {
                        const isPrimaryCheck = indexName === "#primary" ||
                            indexName.includes("#primary") ||
                            indexName.includes("primary") ||
                            indexName.endsWith("_primary");

                        console.log(`🔍 processIndexQueryData - Index "${indexName}": isPrimary check = ${isPrimaryCheck}`);

                        allIndexes.set(indexName, {
                            name: indexName,
                            requests: [],
                            totalUsage: 0,
                            isPrimary: isPrimaryCheck,
                            scanTimes: [],
                            itemsScanned: [],
                            itemsFetched: []
                        });
                    }
                    const indexObj = allIndexes.get(indexName);
                    indexObj.requests.push(requests[requestIndex]);
                    indexObj.totalUsage++;

                    // Collect statistics from the request
                    const request = requests[requestIndex];
                    if (request) {
                        console.log("DEBUG: request keys:", Object.keys(request));
                        console.log("DEBUG: request.plan exists:", !!request.plan);
                        console.log("DEBUG: typeof request.plan:", typeof request.plan);
                        // Extract actual index scan service time and items data from plan data  
                        const indexData = extractIndexScanDataFromPlan(request.plan, indexName);
                        if (indexData.scanTime > 0) {
                            indexObj.scanTimes.push(indexData.scanTime);
                        }
                        if (indexData.itemsScanned > 0) {
                            indexObj.itemsScanned.push(indexData.itemsScanned);
                        }
                        if (indexData.itemsFetched > 0) {
                            indexObj.itemsFetched.push(indexData.itemsFetched);
                        }
                    }
                });
            });

            // CRITICAL: Populate indexQueryFlowData with processed data for SVG rendering
            // Sort indexes by totalUsage (descending) to match full rendering behavior
            const sortedIndexes = Array.from(allIndexes.values()).sort((a, b) => b.totalUsage - a.totalUsage);
            const sortedQueries = Array.from(queryGroups.values()).sort((a, b) => b.count - a.count);

            indexQueryFlowData.indexes = new Map(sortedIndexes.map(idx => [idx.name, idx]));
            indexQueryFlowData.queries = new Map(sortedQueries.map(q => [q.normalizedStatement, q]));

            console.log("📊 processIndexQueryData: Sorted indexes by totalUsage");
            console.log("📊 processIndexQueryData: Sorted queries by count");

            // Rebuild connections data
            requestIndexMap.forEach((indexSet, requestIndex) => {
                const request = requests[requestIndex];
                const stmt = request.preparedText || request.statement;
                if (stmt) {
                    const normalized = normalizeStatement(stmt);
                    indexSet.forEach((indexName) => {
                        const connectionKey = `${normalized}::${indexName}`;
                        if (!indexQueryFlowData.connections.has(connectionKey)) {
                            indexQueryFlowData.connections.set(connectionKey, {
                                queryStatement: normalized,
                                indexName: indexName,
                                count: 0,
                            });
                        }
                        indexQueryFlowData.connections.get(connectionKey).count++;
                    });
                }
            });

            // Update counts with correct data
            const indexCountEl = document.getElementById("index-count");
            const queryCountEl = document.getElementById("query-count");
            if (indexCountEl) indexCountEl.textContent = allIndexes.size;
            if (queryCountEl) queryCountEl.textContent = queryGroups.size;

            console.log("📊 Updated counts - Indexes:", allIndexes.size, "Queries:", queryGroups.size);
            console.log("📊 Populated indexQueryFlowData for SVG rendering");
        }

        // Helper function to resolve #primary to actual primary index name
        function resolvePrimaryIndexName(bucketScopeCollection) {
            // Look through indexData to find the actual primary index for this collection
            for (const index of indexData) {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                    const isPrimary =
                        index.name.includes("primary") ||
                        index.name.includes("#primary") ||
                        index.name.endsWith("_primary");

                    if (isPrimary && targetString === bucketScopeCollection) {
                        return index.name;
                    }
                }
            }
            // If no actual primary index found, keep #primary
            return "#primary";
        }

        function buildIndexQueryFlow(requests = null) {
            // Use provided requests or fall back to original requests
            const requestsToUse = requests || originalRequests;

            console.log("🔧 buildIndexQueryFlow called with requests:", requestsToUse?.length || 0);
            console.log("🔧 buildIndexQueryFlow called from:", new Error().stack.split('\n')[1]);

            if (!requestsToUse || requestsToUse.length === 0) {
                console.log("❌ No requests available for Index/Query Flow");
                return;
            }

            // Check if Index/Query Flow tab is currently visible using jQuery UI tabs
            const activeTabIndex = $("#tabs").tabs("option", "active");
            const indexQueryFlowTabIndex = 4; // Index/Query Flow is the 5th tab (0-indexed)

            console.log(`📊 Active tab index: ${activeTabIndex}, Index/Query Flow tab index: ${indexQueryFlowTabIndex}`);

            // Always clear first to ensure clean state
            clearIndexQueryFlow();

            // Process data but skip DOM rendering when tab is hidden
            if (activeTabIndex !== indexQueryFlowTabIndex) {
                console.log("⏸️ Index/Query Flow tab hidden, processing data only - CALLING processIndexQueryData");
                processIndexQueryData(requestsToUse);
                return;
            }

            console.log("✅ Index/Query Flow tab is visible, proceeding with FULL rendering");

            // Step 1: Track which indexes each request uses (by request index)
            const requestIndexMap = new Map(); // requestIndex -> Set of index names

            let requestsWithPlans = 0;
            let requestsWithOperators = 0;
            requestsToUse.forEach((request, requestIndex) => {
                requestIndexMap.set(requestIndex, new Set());
                if (request.plan) {
                    requestsWithPlans++;

                    // Debug: Show the actual plan structure
                    if (requestIndex < 3) {
                        if (typeof request.plan === "string") {
                            try {
                                const parsedPlan = JSON.parse(request.plan);
                            } catch (e) { }
                        }
                    }

                    // Parse the plan JSON string if needed (same as Dashboard logic)
                    const planObj =
                        typeof request.plan === "string"
                            ? JSON.parse(request.plan)
                            : request.plan;

                    if (planObj && planObj["#operator"]) {
                        requestsWithOperators++;

                        // Get bucket.scope.collection from the statement for primary index resolution
                        const statement = request.preparedText || request.statement || "";
                        let bucketScopeCollection = "unknown.unknown.unknown";

                        const fromMatch = statement.match(/FROM\s+([^\s\n\r\t]+)/i);
                        if (fromMatch) {
                            const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                            const parts = target.split(".");
                            if (parts.length === 1) {
                                bucketScopeCollection = `${parts[0]}._default._default`;
                            } else if (parts.length === 2) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                            } else if (parts.length >= 3) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                            }
                        }

                        extractIndexUsage(
                            planObj,
                            requestIndex,
                            requestIndexMap,
                            bucketScopeCollection
                        );
                    }
                }
            });

            // Step 2: Build query groups and track which request indices belong to each group
            const queryGroups = new Map();
            requestsToUse.forEach((request, requestIndex) => {
                const stmt = request.preparedText || request.statement;
                const normalizedStatement = normalizeStatement(stmt);
                if (!queryGroups.has(normalizedStatement)) {
                    queryGroups.set(normalizedStatement, {
                        statement: stmt,
                        normalizedStatement,
                        count: 0,
                        totalDuration: 0,
                        requestIndices: [],
                    });
                }
                const group = queryGroups.get(normalizedStatement);
                group.count++;
                // Use same logic as Analysis tab: serviceTime converted to ms
                const durationMs = parseTime(request.serviceTime);

                group.totalDuration += isNaN(durationMs) ? 0 : durationMs;
                group.requestIndices.push(requestIndex);
            });

            // Step 3: Build final index data and connections using request indices
            const allIndexes = new Map();
            let connectionCount = 0;

            queryGroups.forEach((queryGroup, queryKey) => {
                queryGroup.requestIndices.forEach((requestIndex) => {
                    const indexesForRequest = requestIndexMap.get(requestIndex);

                    if (indexesForRequest && indexesForRequest.size > 0) {
                        indexesForRequest.forEach((indexName) => {
                            // Track index usage
                            if (!allIndexes.has(indexName)) {
                                const isPrimaryCheck = indexName === "#primary" ||
                                    indexName.includes("#primary") ||
                                    indexName.includes("primary") ||
                                    indexName.endsWith("_primary");

                                console.log(`🔍 Index "${indexName}": isPrimary check = ${isPrimaryCheck}`);

                                allIndexes.set(indexName, {
                                    name: indexName,
                                    totalUsage: 0,
                                    isPrimary: isPrimaryCheck,
                                    scanTimes: [],
                                    itemsScanned: [],
                                    itemsFetched: [],
                                });
                            }

                            const indexObj = allIndexes.get(indexName);
                            indexObj.totalUsage++;

                            // Collect statistics from the request
                            const request = requestsToUse[requestIndex];
                            if (request) {
                                // Extract actual index scan service time and items data from plan data
                                console.log(`Processing request for index ${indexName}:`, typeof request.plan);
                                const indexData = extractIndexScanDataFromPlan(request.plan, indexName);
                                console.log(`Index: ${indexName}, Scan Time: ${indexData.scanTime}ms, Items: ${indexData.itemsScanned}`);
                                if (indexData.scanTime > 0) {
                                    indexObj.scanTimes.push(indexData.scanTime);
                                }
                                if (indexData.itemsScanned > 0) {
                                    indexObj.itemsScanned.push(indexData.itemsScanned);
                                }
                                if (indexData.itemsFetched > 0) {
                                    indexObj.itemsFetched.push(indexData.itemsFetched);
                                }
                            }

                            // Track connection
                            const connectionKey = `${queryGroup.normalizedStatement}::${indexName}`;
                            if (!indexQueryFlowData.connections.has(connectionKey)) {
                                indexQueryFlowData.connections.set(connectionKey, {
                                    queryStatement: queryGroup.normalizedStatement,
                                    indexName: indexName,
                                    count: 0,
                                });
                            }
                            indexQueryFlowData.connections.get(connectionKey).count++;
                            connectionCount++;
                        });
                    }
                });
            });

            // Convert to sorted arrays
            const sortedIndexes = Array.from(allIndexes.values()).sort(
                (a, b) => b.totalUsage - a.totalUsage
            );
            const sortedQueries = Array.from(queryGroups.values()).sort(
                (a, b) => b.count - a.count
            );



            indexQueryFlowData.queries = new Map(
                sortedQueries.map((q) => [q.normalizedStatement, q])
            );

            console.log("🚀 About to call renderIndexQueryFlow with:");
            console.log("  📋 sortedIndexes:", sortedIndexes.length);
            console.log("  📋 sortedQueries:", sortedQueries.length);
            console.log("  📋 indexQueryFlowData.connections:", indexQueryFlowData.connections.size);

            renderIndexQueryFlow(sortedIndexes, sortedQueries);
        }

        // Extract the actual service time and items data for a specific index from the plan JSON
        function extractIndexScanDataFromPlan(planString, indexName) {
            if (!planString || !indexName) return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };

            try {
                // Handle both cases: plan as string (needs parsing) or plan as object (already parsed)
                let plan;
                if (typeof planString === 'string') {
                    plan = JSON.parse(planString);
                } else if (typeof planString === 'object' && planString !== null) {
                    plan = planString; // Already parsed
                } else {
                    return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };
                }

                let result = { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };

                function searchOperatorForIndex(operator) {
                    if (!operator) return;

                    const opType = operator["#operator"];

                    // Check if this operator uses the target index
                    const operatorIndex = operator.index || operator.indexName;

                    if (operatorIndex === indexName ||
                        (indexName.includes("primary") && operatorIndex === "#primary") ||
                        (indexName === "def_primary" && operatorIndex === "#primary")) {

                        // Extract servTime and items data from this operator's stats
                        if (operator["#stats"]) {
                            const stats = operator["#stats"];
                            if (stats["servTime"]) {
                                result.scanTime = parseTime(stats["servTime"]);
                                console.log(`Found matching operator for ${indexName}: servTime = ${stats["servTime"]}`);
                            }
                            if (stats["#itemsOut"]) {
                                result.itemsScanned = stats["#itemsOut"];
                                console.log(`Found items scanned for ${indexName}: ${stats["#itemsOut"]}`);
                            }
                            if (stats["#itemsIn"]) {
                                result.itemsFetched = stats["#itemsIn"];
                            }
                        }
                    }

                    // Recursively search child operators
                    if (operator["~child"]) {
                        searchOperatorForIndex(operator["~child"]);
                    }

                    if (operator["~children"]) {
                        for (const child of operator["~children"]) {
                            searchOperatorForIndex(child);
                        }
                    }
                }

                searchOperatorForIndex(plan);
                return result;
            } catch (e) {
                console.warn("Failed to process plan data:", e);
                console.warn("Plan type:", typeof planString);
                console.warn("Plan is null:", planString === null);
                return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };
            }
        }

        function extractIndexUsage(
            operator,
            requestIndex,
            requestIndexMap,
            bucketScopeCollection = "unknown.unknown.unknown"
        ) {
            if (!operator) {
                return;
            }

            // Function to record index usage for this request
            function recordIndexUsage(indexName) {
                // If this is #primary, try to resolve to actual primary index name
                if (indexName === "#primary") {
                    const resolved = resolvePrimaryIndexName(bucketScopeCollection);
                    indexName = resolved;
                }
                requestIndexMap.get(requestIndex).add(indexName);
            }

            const opType = operator["#operator"];

            // Check for IndexScan operators
            if (
                opType === "IndexScan" ||
                opType === "IndexScan2" ||
                opType === "IndexScan3"
            ) {
                if (operator.index) {
                    recordIndexUsage(operator.index);
                }
                if (operator.indexName) {
                    recordIndexUsage(operator.indexName);
                }
            }

            // Check for PrimaryScan operators
            if (
                opType === "PrimaryScan" ||
                opType === "PrimaryScan2" ||
                opType === "PrimaryScan3"
            ) {
                // For primary scans, prefer resolved name over operator.index to avoid duplicates
                let resolvedName = resolvePrimaryIndexName(bucketScopeCollection);
                if (resolvedName && resolvedName !== "#primary") {
                    recordIndexUsage(resolvedName);
                } else if (operator.index) {
                    recordIndexUsage(operator.index);
                } else {
                    recordIndexUsage("#primary");
                }
            }

            // Check for sequential scan
            if (operator.using === "sequentialscan") {
                recordIndexUsage("#sequentialscan");
            }

            // Recursively check child operators (same as Dashboard logic)
            if (operator["~child"]) {
                extractIndexUsage(
                    operator["~child"],
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                operator["~children"].forEach((child) =>
                    extractIndexUsage(
                        child,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            if (operator.input) {
                extractIndexUsage(
                    operator.input,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexUsage(
                        input,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            if (operator.left) {
                extractIndexUsage(
                    operator.left,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.right) {
                extractIndexUsage(
                    operator.right,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexUsage(
                    operator.first,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.second) {
                extractIndexUsage(
                    operator.second,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexUsage(
                        scan,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexUsage(
                    operator.scan,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexUsage(
                            subquery.executionTimings,
                            requestIndex,
                            requestIndexMap,
                            bucketScopeCollection
                        );
                    }
                });
            }
        }

        function renderIndexQueryFlow(indexes, queries) {
            console.log("🎨 renderIndexQueryFlow called with:");
            console.log("  📋 Indexes:", indexes.length, "items");
            console.log("  📋 Queries:", queries.length, "items");
            console.log("  📋 indexQueryFlowData.connections size:", indexQueryFlowData.connections.size);
            console.log("🎨 renderIndexQueryFlow called from:", new Error().stack.split('\n')[1]);

            const flowElements = document.getElementById("flow-elements");

            if (!flowElements) {
                console.error("flow-elements container not found");
                return;
            }

            // Update counts in summary
            const indexCountEl = document.getElementById("index-count");
            const queryCountEl = document.getElementById("query-count");
            if (indexCountEl) indexCountEl.textContent = indexes.length;
            if (queryCountEl) queryCountEl.textContent = queries.length;

            // Clear container
            flowElements.innerHTML = "";

            if (indexes.length === 0) {
                flowElements.innerHTML =
                    '<div style="padding: 20px; text-align: center; color: #666; font-style: italic;">No index usage found in the queries.<br><br>This could mean:<br>• Queries use sequential scans<br>• Index information not in execution plans<br>• All queries are prepared statements without index details</div>';
                return;
            }

            // Generate colors for indexes
            const colors = generateColors(indexes.length);

            // Calculate layout - indexes on left, queries on right
            const canvasWidth = flowElements.offsetWidth || 1200;
            const indexItemHeight = 144; // Index spacing
            const queryItemHeight = 173; // Query spacing with additional 20% (144 * 1.2)
            const canvasHeight = Math.max(
                indexes.length * indexItemHeight,
                queries.length * queryItemHeight,
                400
            );

            // Set container height
            flowElements.style.height = canvasHeight + "px";

            // Position indexes on the left
            const indexPositions = [];
            indexes.forEach((index, i) => {
                const x = 50;
                const y = 50 + i * indexItemHeight;
                const indexDiv = createIndexDiv(index, colors[i], x, y);
                flowElements.appendChild(indexDiv);
                indexPositions.push({
                    element: indexDiv,
                    x: x + 150,
                    y: y + 40,
                    index: index,
                }); // right edge + center
            });

            // Position queries on the right
            const queryPositions = [];
            queries.forEach((query, queryIndex) => {
                const x = canvasWidth - 380;
                const y = 50 + queryIndex * queryItemHeight;
                const queryDiv = createQueryDiv(query, queryIndex, x, y);
                flowElements.appendChild(queryDiv);
                queryPositions.push({
                    element: queryDiv,
                    x: x,
                    y: y + 40,
                    query: query,
                }); // left edge + center
            });

            // Draw connections after elements are positioned
            // Use multiple attempts with increasing delays to ensure layout is complete
            setTimeout(() => {
                drawSimpleConnections(indexPositions, queryPositions, colors);
            }, 100);

            // Additional redraw after longer delay to ensure correct positioning
            setTimeout(() => {
                redrawConnectionsAfterDrag();
            }, 300);
        }

        function createIndexDiv(index, color, x, y) {
            console.log(`🎨 createIndexDiv for "${index.name}": isPrimary=${index.isPrimary}, totalUsage=${index.totalUsage}`);

            const div = document.createElement("div");
            let className = "index-item";
            if (index.isPrimary) className += " primary";
            if (index.name === "#sequentialscan") className += " sequential-scan";

            console.log(`🎨 createIndexDiv className: "${className}"`);

            div.className = className;
            div.style.borderColor = color;
            div.style.position = "absolute";
            div.style.left = x + "px";
            div.style.top = y + "px";
            div.style.width = "280px";
            div.style.margin = "0"; // Override CSS margin for absolute positioning

            // Add orange background for sequential scan
            if (index.name === "#sequentialscan") {
                div.style.backgroundColor = "#fff3cd";
                div.style.borderColor = "#ff9800";
            }

            div.draggable = true;
            div.dataset.indexName = index.name;

            const stats = calculateIndexStats(index);

            // Check if avg scan time >= 10 seconds for red/bold styling
            const scanTimes = index.scanTimes || [];
            const avgScanTimeMs = scanTimes.length
                ? scanTimes.reduce((a, b) => a + b, 0) / scanTimes.length
                : 0;
            const avgScanTimeSeconds = avgScanTimeMs / 1000;
            const avgScanTimeStyle =
                avgScanTimeSeconds >= 10 ? "font-weight: bold; color: red;" : "";

            div.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="font-weight: bold; font-size: 14px; color: #333;">${index.name
                } | Scanned: ${index.totalUsage}</div>
            <button onclick="copyIndexName('${index.name.replace(
                    /'/g,
                    "\\'"
                )}', event)" class="btn-standard" style="font-size: 11px;">Copiar</button>
          </div>
          <div class="index-stats" style="font-size: 13px; margin-top: 8px;">
            Avg Scan Time: <span style="${avgScanTimeStyle}">${stats.avgScanTime
                }</span><br>
            Avg Items Scanned: ${stats.avgItemsScanned}<br>
            Avg Items Fetched: ${stats.avgItemsFetched}<br>
            Min/Max Scan Time: ${stats.minScanTime} / ${stats.maxScanTime}<br>
            Min/Max Items: ${stats.minItems} / ${stats.maxItems}
          </div>
        `;

            makeDraggable(div);
            return div;
        }

        function createQueryDiv(query, queryIndex, x, y) {
            const div = document.createElement("div");
            div.className = "query-item";
            div.style.position = "absolute";
            div.style.left = x + "px";
            div.style.top = y + "px";
            div.style.width = "320px";
            div.style.margin = "0"; // Override CSS margin for absolute positioning
            div.draggable = true;
            div.dataset.queryId = `query-${queryIndex}`;
            div.dataset.queryStatement = query.normalizedStatement;

            const avgDuration = query.totalDuration / query.count;
            const avgDurationSeconds = avgDuration / 1000;

            // Check for USE KEYS in the statement
            const hasUseKeys = query.statement.includes("USE KEYS");
            const useKeysIndicator = hasUseKeys
                ? ' <span style="color: orange; font-weight: bold;">(USE KEYS)</span>'
                : "";

            // Check if avg duration >= 60 seconds for red/bold styling
            const avgDurationStyle =
                avgDurationSeconds >= 60 ? "font-weight: bold; color: red;" : "";

            div.innerHTML = `
          <div style="font-weight: bold; font-size: 14px; color: #333;">Executions: ${query.count
                }${useKeysIndicator}</div>
          <div style="font-size: 12px; color: #666; margin: 4px 0;">Avg Duration: <span style="${avgDurationStyle}">${formatTime(
                    avgDuration
                )}</span></div>
          <div class="query-text" id="query-text-${query.normalizedStatement.replace(
                    /[^a-zA-Z0-9]/g,
                    ""
                )}">
            ${query.statement}
          </div>
          <div class="query-controls">
            <button onclick="toggleQueryText('${query.normalizedStatement.replace(
                    /[^a-zA-Z0-9]/g,
                    ""
                )}')" class="btn-standard">Mostrar Mais</button>
            <button class="btn-standard query-copy-btn" data-query-statement="${encodeURIComponent(
                    query.statement
                )}">Copiar</button>
          </div>
        `;

            // Add event listener for copy button
            const copyBtn = div.querySelector(".query-copy-btn");
            if (copyBtn) {
                copyBtn.addEventListener("click", function (e) {
                    e.stopPropagation(); // Prevent drag from starting
                    const statement = decodeURIComponent(this.dataset.queryStatement);
                    copyQueryText(statement, e);
                });
            }

            makeDraggable(div);
            return div;
        }

        function calculateIndexStats(index) {
            const scanTimes = index.scanTimes || [];
            const itemsScanned = index.itemsScanned || [];
            const itemsFetched = index.itemsFetched || [];

            return {
                avgScanTime: scanTimes.length
                    ? formatTime(
                        scanTimes.reduce((a, b) => a + b, 0) / scanTimes.length
                    )
                    : "N/A",
                minScanTime: scanTimes.length
                    ? formatTime(Math.min(...scanTimes))
                    : "N/A",
                maxScanTime: scanTimes.length
                    ? formatTime(Math.max(...scanTimes))
                    : "N/A",
                avgItemsScanned: itemsScanned.length
                    ? Math.round(
                        itemsScanned.reduce((a, b) => a + b, 0) / itemsScanned.length
                    )
                    : "N/A",
                avgItemsFetched: itemsFetched.length
                    ? Math.round(
                        itemsFetched.reduce((a, b) => a + b, 0) / itemsFetched.length
                    )
                    : "N/A",
                minItems: itemsScanned.length ? Math.min(...itemsScanned) : "N/A",
                maxItems: itemsScanned.length ? Math.max(...itemsScanned) : "N/A",
            };
        }

        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = ((i * 360) / count) % 360;
                colors.push(`hsl(${hue}, 70%, 50%)`);
            }
            return colors;
        }

        function drawSimpleConnections(indexPositions, queryPositions, colors) {
            const svg = document.getElementById("flow-svg");
            if (!svg) {
                console.error("SVG element not found");
                return;
            }

            svg.innerHTML = "";

            // Create maps for easy lookup
            const indexMap = new Map();
            indexPositions.forEach((pos, i) => {
                indexMap.set(pos.index.name, { ...pos, color: colors[i] });
            });

            const queryMap = new Map();
            queryPositions.forEach((pos) => {
                queryMap.set(pos.query.normalizedStatement, pos);
            });

            let connectionsDrawn = 0;

            indexQueryFlowData.connections.forEach((connection) => {
                const indexPos = indexMap.get(connection.indexName);
                const queryPos = queryMap.get(connection.queryStatement);

                if (indexPos && queryPos) {
                    drawSimpleConnection(svg, indexPos, queryPos, connection.count);
                    connectionsDrawn++;
                }
            });
        }

        function drawSimpleConnection(svg, indexPos, queryPos, count) {
            const startX = indexPos.x;
            const startY = indexPos.y;
            const endX = queryPos.x;
            const endY = queryPos.y;

            // Calculate line thickness (scale between 2 and 12 pixels)
            const maxCount = Math.max(
                ...Array.from(indexQueryFlowData.connections.values()).map(
                    (c) => c.count
                )
            );
            const thickness = Math.max(
                2,
                Math.min(12, (count / maxCount) * 10 + 2)
            );

            // Create curved path instead of straight line
            const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
            );

            // Calculate control points for the curve
            const curveAmount = Math.abs(endX - startX) * 0.4; // Curve intensity based on distance

            // Create a smooth S-curve
            const d = `M ${startX} ${startY} C ${startX + curveAmount} ${startY}, ${endX - curveAmount
                } ${endY}, ${endX} ${endY}`;

            path.setAttribute("d", d);
            path.setAttribute("stroke", indexPos.color);
            path.setAttribute("stroke-width", thickness);
            path.setAttribute("opacity", "0.7");
            path.setAttribute("fill", "none");

            // Create usage count label
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;

            const rect = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
            );
            const text = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
            );

            text.setAttribute("x", midX);
            text.setAttribute("y", midY + 4);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("font-size", "11");
            text.setAttribute("font-weight", "bold");
            text.setAttribute("fill", "#333");
            text.textContent = count;

            // Estimate text dimensions
            const textWidth = count.toString().length * 7;
            rect.setAttribute("x", midX - textWidth / 2 - 3);
            rect.setAttribute("y", midY - 7);
            rect.setAttribute("width", textWidth + 6);
            rect.setAttribute("height", 14);
            rect.setAttribute("fill", "white");
            rect.setAttribute("stroke", "#333");
            rect.setAttribute("stroke-width", "1");
            rect.setAttribute("rx", "3");

            svg.appendChild(path);
            svg.appendChild(rect);
            svg.appendChild(text);
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            element.addEventListener("mousedown", function (e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // Get current position relative to the container, not viewport
                const container = document.getElementById("flow-elements");
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();

                startLeft = elementRect.left - containerRect.left;
                startTop = elementRect.top - containerRect.top;

                element.style.position = "absolute";
                element.style.zIndex = "1000";
                e.preventDefault();
            });

            document.addEventListener("mousemove", function (e) {
                if (!isDragging) return;
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                element.style.left = startLeft + deltaX + "px";
                element.style.top = startTop + deltaY + "px";

                // Redraw connections during drag for smooth following
                if (
                    document.getElementById("index-query-flow").style.display !== "none"
                ) {
                    redrawConnectionsAfterDrag();
                }
            });

            document.addEventListener("mouseup", function () {
                if (isDragging) {
                    isDragging = false;
                    element.style.zIndex = "";
                    // Redraw connections after drag
                    setTimeout(() => {
                        if (
                            document.getElementById("index-query-flow").style.display !==
                            "none"
                        ) {
                            redrawConnectionsAfterDrag();
                        }
                    }, 50);
                }
            });
        }

        function redrawConnectionsAfterDrag() {
            // Get current positions of all elements
            const indexElements = document.querySelectorAll("[data-index-name]");
            const queryElements = document.querySelectorAll("[data-query-id]");

            const indexPositions = [];
            const queryPositions = [];
            const colors = generateColors(indexElements.length);

            // Build current index positions
            indexElements.forEach((element, i) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document
                    .getElementById("flow-elements")
                    .getBoundingClientRect();
                const indexName = element.dataset.indexName;

                // Create a minimal index object with just the name
                const indexObj = { name: indexName };

                indexPositions.push({
                    element: element,
                    x: rect.right - containerRect.left, // right edge
                    y: rect.top - containerRect.top + rect.height / 2, // center
                    index: indexObj,
                });
            });

            // Build current query positions
            queryElements.forEach((element) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document
                    .getElementById("flow-elements")
                    .getBoundingClientRect();
                const queryStatement = element.dataset.queryStatement;

                // Create a minimal query object with just the normalized statement
                const queryObj = { normalizedStatement: queryStatement };

                queryPositions.push({
                    element: element,
                    x: rect.left - containerRect.left, // left edge
                    y: rect.top - containerRect.top + rect.height / 2, // center
                    query: queryObj,
                });
            });

            // Redraw connections with current positions
            drawSimpleConnections(indexPositions, queryPositions, colors);
        }

        function toggleQueryText(id) {
            const element = document.getElementById(`query-text-${id}`);
            const button = element.nextElementSibling.firstElementChild;

            if (element.classList.contains("expanded")) {
                element.classList.remove("expanded");
                button.textContent = "Mostrar Mais";
            } else {
                element.classList.add("expanded");
                button.textContent = "Ocultar";
            }
        }

        function copyQueryText(text, event) {
            navigator.clipboard.writeText(text).then(() => {
                // Brief visual feedback
                const button = event ? event.target : window.event.target;
                const originalText = button.textContent;
                button.textContent = "Copied!";
                button.style.backgroundColor = "#4CAF50";
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = "";
                }, 1000);
            });
        }

        function copyIndexName(indexName, event) {
            navigator.clipboard.writeText(indexName).then(() => {
                // Brief visual feedback
                const button = event.target;
                const originalText = button.textContent;
                const originalBg = button.style.backgroundColor;
                button.textContent = "Copied!";
                button.style.backgroundColor = "#4CAF50";
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = originalBg;
                }, 1000);
            });
        }

        // Copy to clipboard function for indexes and keys
        function copyToClipboard(text, event) {
            navigator.clipboard.writeText(text).then(() => {
                // Brief visual feedback
                const button = event.target;
                const originalText = button.textContent;
                const originalBg = button.style.backgroundColor;
                button.textContent = "Copied!";
                button.style.backgroundColor = "#28a745";
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = originalBg;
                }, 1000);
            });
        }

        // Toggle USE KEYS visibility
        function toggleUseKeys() {
            const hiddenKeys = document.querySelectorAll(".hidden-key");
            const toggleBtn = document.getElementById("toggle-keys-btn");

            if (hiddenKeys.length > 0) {
                const isHidden = hiddenKeys[0].style.display === "none";

                if (isHidden) {
                    // Show hidden keys
                    hiddenKeys.forEach((key) => (key.style.display = "block"));
                    toggleBtn.textContent = "Ocultar Chaves";
                } else {
                    // Hide keys
                    hiddenKeys.forEach((key) => (key.style.display = "none"));
                    toggleBtn.textContent = `Mostrar ${hiddenKeys.length} Chaves`;
                }
            }
        }

        // Hook removed - buildIndexQueryFlow will be called directly after data processing

        // Version management
        const APP_VERSION = "3.8.0";
        const LAST_UPDATED = "2025-08-27";

        function getVersionInfo() {
            return {
                version: APP_VERSION,
                lastUpdated: LAST_UPDATED,
                features: [
                    "Global system query exclusion",
                    "Enhanced accessibility (ARIA)",
                    "Chart performance optimizations",
                    "Time range filtering with buffers",
                    "Index/Query Flow analysis",
                    "Toast notification system",
                ],
            };
        }

        // Initialize the application
        // Index Analysis Variables
        let indexData = [];
        let filteredIndexData = [];
        let usedIndexes = new Set(); // Store indexes found in query data

        // Calculate human-readable time difference
        function getTimeSince(dateString) {
            if (!dateString || dateString === "Never") return "";

            const now = new Date();
            const past = new Date(dateString);
            const diffMs = now - past;

            const minutes = Math.floor(diffMs / 60000);
            const hours = Math.floor(diffMs / 3600000);
            const days = Math.floor(diffMs / 86400000);
            const weeks = Math.floor(days / 7);
            const months = Math.floor(days / 30);
            const years = Math.floor(days / 365);

            if (years > 0) return `(${years} year${years > 1 ? "s" : ""} ago)`;
            if (months > 0) return `(${months} month${months > 1 ? "s" : ""} ago)`;
            if (weeks > 0) return `(${weeks} week${weeks > 1 ? "s" : ""} ago)`;
            if (days > 0) return `(${days} day${days > 1 ? "s" : ""} ago)`;
            if (hours > 0) return `(${hours} hour${hours > 1 ? "s" : ""} ago)`;
            if (minutes > 0)
                return `(${minutes} minute${minutes > 1 ? "s" : ""} ago)`;
            return "(just now)";
        }

        // Create state badge HTML
        function createStateBadge(state) {
            const stateClass =
                state === "online"
                    ? "state-online"
                    : state === "offline"
                        ? "state-offline"
                        : state === "building"
                            ? "state-building"
                            : "state-offline";
            return `<span class="state-badge ${stateClass}">${state || "unknown"
                }</span>`;
        }

        // Extract and store all indexes used in queries
        function extractUsedIndexes(requests) {
            usedIndexes.clear();

            let totalIndexReferences = 0;

            requests.forEach((request, index) => {
                // Handle different JSON structures
                let actualRequest = request;
                if (request.completed_requests) {
                    // User's format: { completed_requests: {...}, plan: "..." }
                    actualRequest = {
                        ...request.completed_requests,
                        plan: request.plan,
                    };
                } else {
                }

                if (actualRequest.plan) {
                }

                // Create a copy of the request with parsed plan
                const processedRequest = { ...actualRequest };

                // Parse the plan if it's a string
                if (typeof processedRequest.plan === "string") {
                    try {
                        processedRequest.plan = JSON.parse(processedRequest.plan);
                    } catch (e) {
                        console.warn(
                            `⚠️ Failed to parse plan JSON for request: ${processedRequest.clientContextID ||
                            processedRequest.requestId ||
                            "unknown"
                            }`,
                            e
                        );
                        return; // Skip this request if plan can't be parsed
                    }
                } else if (processedRequest.plan) {
                } else {
                    console.warn(`⚠️ No plan found in request`);
                    return;
                }

                const indexesAndKeys = extractIndexesAndKeys(processedRequest);

                // Get bucket.scope.collection from the statement
                const statement =
                    actualRequest.preparedText || actualRequest.statement || "";

                let bucketScopeCollection = "unknown.unknown.unknown";

                // Try to extract FROM clause to get bucket.scope.collection
                const fromMatch = statement.match(/FROM\s+([^\s\n\r\t]+)/i);
                if (fromMatch) {
                    const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                    const parts = target.split(".");
                    if (parts.length === 1) {
                        bucketScopeCollection = `${parts[0]}._default._default`;
                    } else if (parts.length === 2) {
                        bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                    } else if (parts.length >= 3) {
                        bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                    }
                }

                // Add each index with its bucket.scope.collection
                indexesAndKeys.indexes.forEach((indexName) => {
                    const indexKey = `${indexName}|${bucketScopeCollection}`;
                    usedIndexes.add(indexKey);
                    totalIndexReferences++;
                });
            });

            console.log(
                `✅ Index extraction complete: ${usedIndexes.size} unique indexes, ${totalIndexReferences} total references`
            );
        }

        // Calculate and update index statistics
        function updateIndexStats() {
            const buckets = new Set();
            const scopes = new Set();
            const collections = new Set();
            let primaryCount = 0;
            let withReplicasCount = 0;
            let noReplicasCount = 0;
            let neverScannedCount = 0;
            let usedCount = 0;
            let mobileIndexCount = 0;

            filteredIndexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    buckets.add(target.bucket);
                    scopes.add(target.scope);
                    collections.add(target.collection);
                }

                // Check if primary
                if (
                    index.name.includes("primary") ||
                    index.name.includes("#primary")
                ) {
                    primaryCount++;
                }

                // Check replicas
                const replica = index.metadata?.num_replica || 0;
                if (replica > 0) {
                    withReplicasCount++;
                } else {
                    noReplicasCount++;
                }

                // Check if never scanned
                const lastScan = index.metadata?.last_scan_time;
                if (!lastScan || lastScan === "Never") {
                    neverScannedCount++;
                }

                // Check if used in queries
                const target = parseIndexTarget(index.indexString);
                const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");

                const exactKey = `${index.name}|${targetString}`;
                const primaryKey = `#primary|${targetString}`;

                if (
                    usedIndexes.has(exactKey) ||
                    (isPrimary && usedIndexes.has(primaryKey))
                ) {
                    usedCount++;
                }

                // Check if mobile/sync gateway index
                if (index.name.startsWith("sg_")) {
                    mobileIndexCount++;
                }
            });

            // Update stats display
            document.getElementById("stat-indexes").textContent =
                filteredIndexData.length;
            document.getElementById("stat-buckets").textContent = buckets.size;
            document.getElementById("stat-scopes").textContent = scopes.size;
            document.getElementById("stat-collections").textContent =
                collections.size;

            const primaryElement = document.getElementById("stat-primary");
            primaryElement.textContent = primaryCount;
            primaryElement.className = primaryCount > 0 ? "primary-warning" : "";

            const replicaInfoElement = document.getElementById("stat-replica-info");
            replicaInfoElement.innerHTML = `<span class="${noReplicasCount > 0 ? "replica-zero" : ""
                }">${noReplicasCount}</span>/${withReplicasCount}`;

            document.getElementById("stat-never-scanned").textContent =
                neverScannedCount;
            document.getElementById(
                "stat-used-total"
            ).textContent = `${usedCount}/${filteredIndexData.length}`;
            document.getElementById("stat-mobile-indexes").textContent =
                mobileIndexCount;
        }

        // Parse and process index JSON data
        function parseIndexJSON() {
            const indexJsonInput = document
                .getElementById("indexJsonInput")
                .value.trim();

            if (!indexJsonInput) {
                indexData = [];
                displayIndexResults();
                return;
            }

            try {
                const parsedData = JSON.parse(indexJsonInput);
                indexData = Array.isArray(parsedData) ? parsedData : [parsedData];

                // Extract unique buckets, scopes, collections
                updateFilterDropdowns();

                // Apply current filters and display
                applyIndexFilters();
            } catch (error) {
                document.getElementById("indexResults").innerHTML = `
                    <div class="text-align-center" style="color: #dc3545; margin-top: 50px;">
                        <strong>Invalid JSON Format</strong><br>
                        Please check your JSON syntax: ${error.message}
                    </div>
                `;
            }
        }

        // Extract bucket, scope, collection from indexString
        function parseIndexTarget(indexString) {
            const match = indexString.match(/\bON\s+([^\s(;]+)/i);
            if (!match)
                return { bucket: "unknown", scope: "unknown", collection: "unknown" };

            // Clean up the target string - remove backticks, leading dots, trailing semicolons
            let target = match[1]
                .replace(/`/g, "")
                .replace(/^\.+/, "")
                .replace(/;+$/, "");
            const parts = target.split(".").filter((part) => part.length > 0);

            if (parts.length === 1) {
                return {
                    bucket: parts[0],
                    scope: "_default",
                    collection: "_default",
                };
            } else if (parts.length === 2) {
                return { bucket: parts[0], scope: parts[1], collection: "_default" };
            } else if (parts.length >= 3) {
                return { bucket: parts[0], scope: parts[1], collection: parts[2] };
            }

            return {
                bucket: parts[0] || "unknown",
                scope: parts[1] || "unknown",
                collection: parts[2] || "unknown",
            };
        }

        // Update filter dropdowns with available options
        function updateFilterDropdowns() {
            const buckets = new Set();

            indexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    buckets.add(target.bucket);
                }
            });

            updateDropdown("bucketFilter", Array.from(buckets).sort());

            // Update scopes and collections based on selected filters
            updateCascadingDropdowns();
        }

        // Update scopes and collections based on selected bucket/scope
        function updateCascadingDropdowns() {
            const selectedBucket = document.getElementById("bucketFilter").value;
            const selectedScope = document.getElementById("scopeFilter").value;

            const scopes = new Set();
            const collections = new Set();

            indexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);

                    // If bucket is selected, only show scopes for that bucket
                    if (
                        selectedBucket === "(ALL)" ||
                        target.bucket === selectedBucket
                    ) {
                        scopes.add(target.scope);

                        // If scope is also selected, only show collections for that bucket.scope
                        if (selectedScope === "(ALL)" || target.scope === selectedScope) {
                            collections.add(target.collection);
                        }
                    }
                }
            });

            updateDropdown("scopeFilter", Array.from(scopes).sort());
            updateDropdown("collectionFilter", Array.from(collections).sort());
        }

        function updateDropdown(selectId, options) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;

            // Clear existing options except (ALL)
            select.innerHTML = '<option value="(ALL)">(ALL)</option>';

            // Add new options
            options.forEach((option) => {
                const optionElement = document.createElement("option");
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });

            // Restore previous selection if it still exists
            if (options.includes(currentValue)) {
                select.value = currentValue;
            }
        }

        // Apply current filter settings
        function applyIndexFilters() {
            const bucketFilter = document.getElementById("bucketFilter").value;
            const scopeFilter = document.getElementById("scopeFilter").value;
            const collectionFilter =
                document.getElementById("collectionFilter").value;
            const searchTerm =
                document.getElementById("indexSearch")?.value.toLowerCase().trim() ||
                "";

            // Get checkbox filter states
            const filterPrimary =
                document.getElementById("filter-primary")?.checked || false;
            const filterUsed =
                document.getElementById("filter-used")?.checked || false;
            const filterNoReplica =
                document.getElementById("filter-no-replica")?.checked || false;
            const filterNeverScanned =
                document.getElementById("filter-never-scanned")?.checked || false;
            const filterExcludeMobile =
                document.getElementById("filter-exclude-mobile")?.checked || false;

            filteredIndexData = indexData.filter((index) => {
                if (!index.indexString) return false;

                const target = parseIndexTarget(index.indexString);

                // Basic dropdown filters
                const passesDropdownFilters =
                    (bucketFilter === "(ALL)" || target.bucket === bucketFilter) &&
                    (scopeFilter === "(ALL)" || target.scope === scopeFilter) &&
                    (collectionFilter === "(ALL)" ||
                        target.collection === collectionFilter);

                if (!passesDropdownFilters) return false;

                // Search filter
                if (searchTerm) {
                    const indexName = index.name.toLowerCase();
                    const indexString = index.indexString?.toLowerCase() || "";
                    const matchesSearch =
                        indexName.includes(searchTerm) ||
                        indexString.includes(searchTerm);
                    if (!matchesSearch) return false;
                }

                // Checkbox filters
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");
                if (filterPrimary && !isPrimary) return false;

                // Check if used in queries
                if (filterUsed) {
                    const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                    const exactKey = `${index.name}|${targetString}`;
                    const primaryKey = `#primary|${targetString}`;
                    const isUsed =
                        usedIndexes.has(exactKey) ||
                        (isPrimary && usedIndexes.has(primaryKey));
                    if (!isUsed) return false;
                }

                // Check replicas
                if (filterNoReplica) {
                    const replica = index.metadata?.num_replica || 0;
                    if (replica !== 0) return false;
                }

                // Check never scanned
                if (filterNeverScanned) {
                    const lastScan = index.metadata?.last_scan_time;
                    if (lastScan && lastScan !== "Never") return false;
                }

                // Exclude Sync Gateway/Mobile indexes (sg_ prefixed)
                if (filterExcludeMobile) {
                    if (index.name.startsWith("sg_")) return false;
                }

                return true;
            });

            updateIndexStats();
            displayIndexResults();

            // Count and log matches
            let matchedCount = 0;
            filteredIndexData.forEach((index) => {
                const target = parseIndexTarget(index.indexString);
                const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");

                const exactKey = `${index.name}|${targetString}`;
                const primaryKey = `#primary|${targetString}`;

                if (
                    usedIndexes.has(exactKey) ||
                    (isPrimary && usedIndexes.has(primaryKey))
                ) {
                    matchedCount++;
                }
            });

            console.log(
                `📊 Matching summary: ${matchedCount}/${filteredIndexData.length} indexes found in query data`
            );
        }

        // Display filtered index results
        function displayIndexResults() {
            const resultsContainer = document.getElementById("indexResults");
            const sortBy = document.getElementById("sortBy").value;

            if (filteredIndexData.length === 0) {
                if (indexData.length === 0) {
                    // No index data loaded - show instructions
                    resultsContainer.innerHTML = `
                        <div class="text-align-center" style="margin-top: 30px;">
                            <h4 style="color: #495057; margin-bottom: 20px;">No Index Data Loaded</h4>
                            <p style="color: #666; margin-bottom: 20px;">
                                To analyze indexes, run this query in your Couchbase Query Workbench and paste the results in the second textarea above:
                            </p>
                            <div class="sql-query-box">
                                <button class="btn-standard sql-copy-btn" onclick="copyIndexQuery(event)">Copiar Consulta</button>
                                <pre>SELECT 
 s.name,
 s.id,
 s.metadata,
 s.state,
 s.num_replica,
CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
FROM system:indexes AS s
LET bid = CONCAT("", s.bucket_id, ""),
    sid = CONCAT("", s.scope_id, ""),
    kid = CONCAT("", s.keyspace_id, ""),
    k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
    ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
    w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
    p = CASE WHEN s.\`partition\` IS NOT NULL THEN " PARTITION BY " || s.\`partition\` ELSE "" END
;</pre>
                            </div>
                            <p style="color: #666; font-size: 13px; margin-top: 15px;">
                                <strong>Steps:</strong><br>
                                1. Copy the query above<br>
                                2. Run it in Couchbase Query Workbench<br>
                                3. Copy the JSON results<br>
                                4. Paste into the second textarea at the top<br>
                                5. Click "Parse JSON" again
                            </p>
                        </div>
                    `;
                } else {
                    // Index data loaded but filtered out
                    resultsContainer.innerHTML = `
                        <p style="color: #666; text-align: center; margin-top: 50px;">
                            No indexes match the current filters.
                        </p>
                    `;
                }
                return;
            }

            console.log(
                `🔄 Displaying ${filteredIndexData.length} indexes and checking for query matches...`
            );

            let html = "";

            if (sortBy === "Bucket") {
                // Group by bucket
                const grouped = {};
                filteredIndexData.forEach((index) => {
                    const target = parseIndexTarget(index.indexString);
                    if (!grouped[target.bucket]) grouped[target.bucket] = [];
                    grouped[target.bucket].push(index);
                });

                Object.keys(grouped)
                    .sort()
                    .forEach((bucket) => {
                        html += `<div class="bucket-group">`;
                        html += `<h3 style="font-size: 24px;">${bucket}</h3>`;
                        grouped[bucket]
                            .sort((a, b) => a.name.localeCompare(b.name))
                            .forEach((index) => {
                                html += createIndexHTML(index);
                            });
                        html += `</div>`;
                    });
            } else if (sortBy === "LastScanned") {
                // Sort by last scanned time (newest first)
                const sorted = [...filteredIndexData].sort((a, b) => {
                    const aLastScan = a.metadata?.last_scan_time || 0;
                    const bLastScan = b.metadata?.last_scan_time || 0;

                    // Handle 'Never' scanned cases (put them at the end)
                    if (aLastScan === 0 && bLastScan === 0)
                        return a.name.localeCompare(b.name);
                    if (aLastScan === 0) return 1;
                    if (bLastScan === 0) return -1;

                    // Sort by timestamp (newest first)
                    return new Date(bLastScan) - new Date(aLastScan);
                });
                sorted.forEach((index) => {
                    html += createIndexHTML(index);
                });
            } else {
                // Sort by name (default)
                const sorted = [...filteredIndexData].sort((a, b) =>
                    a.name.localeCompare(b.name)
                );
                sorted.forEach((index) => {
                    html += createIndexHTML(index);
                });
            }

            resultsContainer.innerHTML = html;
        }

        function createIndexHTML(index) {
            const target = parseIndexTarget(index.indexString);
            const isPrimary =
                index.name.includes("primary") || index.name.includes("#primary");
            const lastScan = index.metadata?.last_scan_time || "Never";
            const replica = index.metadata?.num_replica || 0;
            const state = index.state || "unknown";
            const timeSince = getTimeSince(lastScan);
            const lastScanFormatted =
                lastScan === "Never" ? "Never" : new Date(lastScan).toLocaleString();
            const replicaClass = replica === 0 ? "replica-zero" : "";

            // Check if this index is used in the parsed query data
            const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
            let isUsed = false;

            // First try exact match
            const exactKey = `${index.name}|${targetString}`;
            if (usedIndexes.has(exactKey)) {
                isUsed = true;
                console.log(
                    `✅ Exact match found: "${index.name}" on ${targetString}`
                );
            }

            // If not found and this is a primary index, also check for #primary match
            if (!isUsed && isPrimary) {
                const primaryKey = `#primary|${targetString}`;
                if (usedIndexes.has(primaryKey)) {
                    isUsed = true;
                    console.log(
                        `✅ Primary match found: "${index.name}" matches "#primary" on ${targetString}`
                    );
                }
            }

            const usedBadge = isUsed ? '<span class="used-badge">Used</span>' : "";

            return `
                <div class="index-item ${isPrimary ? "primary" : ""}">
                    <h4>${index.name} ${usedBadge}</h4>
                    <div class="index-details">
                        <strong>Target:</strong> ${target.bucket}.${target.scope
                }.${target.collection}<br>
                        <strong>State:</strong> ${createStateBadge(
                    state
                )} | <strong>Replicas:</strong> <span class="${replicaClass}">${replica}</span> | <strong>Last Scan:</strong> ${lastScanFormatted} ${timeSince}
                    </div>
                    <div class="index-statement">
                        ${index.indexString}
                        <button class="btn-standard copy-btn" onclick="copyIndexDefinition('${index.indexString.replace(
                    /'/g,
                    "\\'"
                )}', event)">Copiar</button>
                    </div>
                </div>
            `;
        }

        // Copy index definition to clipboard
        function copyIndexDefinition(indexString, event) {
            navigator.clipboard
                .writeText(indexString)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.style.backgroundColor = "#28a745";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "#007bff";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy: ", err);
                });
        }

        // Copy index query to clipboard
        function copyIndexQuery(event) {
            const query = `SELECT 
 s.name,
 s.id,
 s.metadata,
 s.state,
 s.num_replica,
CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
FROM system:indexes AS s
LET bid = CONCAT("", s.bucket_id, ""),
    sid = CONCAT("", s.scope_id, ""),
    kid = CONCAT("", s.keyspace_id, ""),
    k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
    ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
    w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
    p = CASE WHEN s.\`partition\` IS NOT NULL THEN " PARTITION BY " || s.\`partition\` ELSE "" END
;`;

            navigator.clipboard
                .writeText(query)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.style.backgroundColor = "#28a745";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "#007bff";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy query: ", err);
                });
        }

        // Initialize index analysis functionality
        function initializeIndexAnalysis() {
            const indexJsonInput = document.getElementById("indexJsonInput");
            const bucketFilter = document.getElementById("bucketFilter");
            const scopeFilter = document.getElementById("scopeFilter");
            const collectionFilter = document.getElementById("collectionFilter");
            const sortBy = document.getElementById("sortBy");

            // Add event listeners
            if (indexJsonInput)
                indexJsonInput.addEventListener("input", parseIndexJSON);
            if (bucketFilter) {
                bucketFilter.addEventListener("change", () => {
                    // Reset scope and collection when bucket changes
                    document.getElementById("scopeFilter").value = "(ALL)";
                    document.getElementById("collectionFilter").value = "(ALL)";
                    updateCascadingDropdowns();
                    applyIndexFilters();
                });
            }
            if (scopeFilter) {
                scopeFilter.addEventListener("change", () => {
                    // Reset collection when scope changes
                    document.getElementById("collectionFilter").value = "(ALL)";
                    updateCascadingDropdowns();
                    applyIndexFilters();
                });
            }
            if (collectionFilter)
                collectionFilter.addEventListener("change", applyIndexFilters);
            if (sortBy) sortBy.addEventListener("change", applyIndexFilters);

            // Add search input event listener with debouncing
            const indexSearch = document.getElementById("indexSearch");
            if (indexSearch) {
                let searchTimeout;
                indexSearch.addEventListener("input", () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(applyIndexFilters, 300); // 300ms debounce
                });
            }

            // Add checkbox event listeners
            const filterCheckboxes = [
                "filter-primary",
                "filter-used",
                "filter-no-replica",
                "filter-never-scanned",
                "filter-exclude-mobile",
            ];

            filterCheckboxes.forEach((id) => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener("change", applyIndexFilters);
                }
            });

            console.log("✅ Index analysis initialized");
        }

        document.addEventListener("DOMContentLoaded", function () {
            console.log("🚀 Initializing Couchbase Query Analyzer...");
            console.log(`📦 Version: ${APP_VERSION} (Updated: ${LAST_UPDATED})`);
            console.log("🔧 Features:", getVersionInfo().features.join(", "));

            // Initialize theme from localStorage

            // Enhance keyboard navigation
            enhanceKeyboardNavigation();

            // Initialize tabs with enhanced accessibility
            $("#tabs").tabs({
                activate: function (event, ui) {
                    // Announce tab change to screen readers
                    const tabName = ui.newTab.find("a").text();
                    showToast(`Switched to ${tabName}`, "info");
                },
            });

            // Add event listener for system query exclusion checkbox
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            if (excludeCheckbox) {
                excludeCheckbox.addEventListener("change", function () {
                    console.log(`System query exclusion changed to: ${this.checked}`);
                    // Only reprocess if we have JSON data
                    const jsonInput = document.getElementById("json-input").value;
                    if (jsonInput.trim()) {
                        // Clear existing processed data AND date inputs to force complete reparse
                        originalRequests = [];
                        const startDateInput = document.getElementById("start-date");
                        const endDateInput = document.getElementById("end-date");
                        startDateInput.value = "";
                        endDateInput.value = "";
                        console.log(
                            "Clearing existing data, date filters, and reprocessing..."
                        );
                        parseJSON();
                    }
                });
            }

            console.log("✅ Query Analyzer initialized successfully");

            // Initialize index analysis
            initializeIndexAnalysis();

            // Make version info globally accessible
            window.QueryAnalyzer = {
                version: getVersionInfo,
                about: () => {
                    const info = getVersionInfo();
                    console.log(`
🔍 Couchbase Query Analyzer v${info.version}
📅 Last Updated: ${info.lastUpdated}
🎯 Purpose: Analyze Couchbase N1QL query performance from system:completed_requests
                    
🚀 Features:
${info.features.map((f) => `   • ${f}`).join("\n")}

💡 Usage: Type QueryAnalyzer.version() for version info
                    `);
                },
            };

            console.log("💡 Tip: Type QueryAnalyzer.about() for full app info");
        });
    </script>
</body>

</html>