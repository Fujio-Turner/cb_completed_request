<!DOCTYPE html>
<html lang="en">
<!--
    Couchbase Query Analyzer
    Version: 3.16.3
    Last Updated: 2025-09-29
    
    🤖 AI AGENT NOTE: When updating versions, follow the detailed guide in settings/VERSION_UPDATE_GUIDE.md
    This guide covers all HTML elements, JavaScript variables, and documentation files that need updating.
    Load and do what the AGENT.md file before working on this file.

    Use semantic versioning: MAJOR.MINOR.PATCH
    - MAJOR: Breaking changes or complete rewrites
    - MINOR: New features, significant enhancements  
    - PATCH: Bug fixes, small improvements
    
-->

<head>
    <meta charset="UTF-8" />
    <meta name="version" content="3.16.3" />
    <meta name="last-updated" content="2025-09-29" />
    <title>Query Analyzer v3.16.3</title>
    <!-- Include jQuery UI CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.14.1/themes/base/jquery-ui.min.css" integrity="sha512-TFee0335YRJoyiqz8hA8KV3P0tXa5CpRBSoM0Wnkn7JoJx1kaq1yXL/rb8YFpWXkMOjRcv5txv+C6UluttluCQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Include Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js" integrity="sha512-6HrPqAvK+lZElIZ4mZ64fyxIBTsaX5zAFZg2V/2WT+iKPrFzTzvx6QAsLW2OaLwobhMYBog/+bvmIEEGXi0p1w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> 
    
    <!-- Include Chart.js datetime adapter -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js" integrity=" sha512-VPUN3sK5Jce8lVuVWfTZolO+BDodUHFq1QsNHmszMbKpYrQzjCxvC0FDG7igWCYBcsFDpqhcVq4sQ851OqhAPg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
      
    <!-- Include Chart.js zoom plugin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.2.0/chartjs-plugin-zoom.min.js" integrity="sha512-FRGbE3pigbYamZnw4+uT4t63+QJOfg4MXSgzPn2t8AWg9ofmFvZ/0Z37ZpCawjfXLBSVX2p2CncsmUH2hzsgJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <!-- Include Hammer.js for touch/gesture support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js" integrity="sha512-UXumZrZNiOwnTcZSHLOfcTs0aos2MzBWHXOHOuB0J/R44QB0dwY5JgfbvljXcklVf65Gc4El6RjZ+lnwd2az2g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <!-- Include DOMPurify for security -->
    <!-- OLD <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js?v=362"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.6/purify.min.js" integrity="sha512-YlctBG9PGZIhh9keoqI3eZkQM9T8QUbiBi7qNYAO/TUEo8jqWX5pLp5+x1cKRQDRzJ/lyGyJ9WUVNIRduxIIFw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Include Panzoom, jQuery, and jQuery UI -->
    <script src="https://cdn.jsdelivr.net/npm/panzoom@9.4.3/dist/panzoom.min.js" integrity="sha256-EXkj2hNRjkwrQpvsP/7ePHObzow5rTByiCRLFIWCE/Y=" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    
    <style>
body{font-family:Arial, sans-serif;display:flex;flex-direction:column;height:100vh;margin:0;padding:20px;background-color:#f5f5f5}#input-section,.bucket-group,.margin-bottom-20{margin-bottom:10px}textarea{width:100%;height:50px;margin-bottom:10px}#tabs{flex:1;overflow:auto}#every-query,#analysis{display:flex;flex-direction:column;height:100%}#flow-diagram-section,#charts-placeholder{flex:0 0 250px;overflow:auto;margin-bottom:20px;border:1px solid #ccc;padding:10px;background-color:#fff}#flow-diagram{display:flex;flex-wrap:wrap;gap:10px;align-items:center}.step-bubble{border:1px solid #000;border-radius:10px;padding:10px;text-align:center;box-shadow:2px 2px 5px rgba(0, 0, 0, 0.1);cursor:pointer}.step-bubble p{margin:5px 0;line-height:1}.index-item{background:#fff;border:1px solid #ddd;border-radius:6px;padding:12px;margin-bottom:8px;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1)}.index-item.primary{background:#ffe6e6;border-color:#ff9999}.index-item h4{margin:0 0 8px 0;font-size:14px;font-weight:bold;color:#333}.index-item .index-details{font-size:12px;color:#666;margin-bottom:8px}.index-item .index-statement{font-family:monospace;font-size:11px;background:#f5f5f5;padding:8px;border-radius:4px;border-left:3px solid #007bff;word-wrap:break-word;position:relative}.bucket-group h3{background:#e9ecef;padding:8px 12px;margin:0 0 10px 0;border-radius:4px;font-size:16px;font-weight:bold;color:#495057}.state-badge{padding:2px 8px;border-radius:12px;font-size:11px;font-weight:bold;text-transform:uppercase}.state-online{background:#d4edda;color:#155724}.state-offline{background:#f8d7da;color:#721c24}.state-building{background:#fff3cd;color:#856404}.replica-zero,.primary-warning,.warning-text-highlight{color:#dc3545;font-weight:bold}.copy-btn{position:absolute;top:4px;right:4px;background:#007bff;color:white;border:none;border-radius:3px;padding:4px 8px;font-size:10px;cursor:pointer}.copy-btn:hover,.sql-copy-btn:hover,.btn-standard:hover{background:#0056b3}.used-badge{background:#28a745;color:white;padding:2px 6px;border-radius:10px;font-size:10px;font-weight:bold;margin-left:8px;text-transform:uppercase}.sql-query-box{background:#f8f9fa;border:1px solid #dee2e6;border-radius:6px;padding:15px;margin:15px 0;position:relative}.sql-query-box pre{background:#ffffff;border:1px solid #e9ecef;border-radius:4px;padding:10px;margin:10px 0;font-family:monospace;font-size:12px;overflow-x:auto}.sql-copy-btn{position:absolute;top:10px;right:10px;background:#007bff;color:white;border:none;border-radius:4px;padding:6px 12px;font-size:11px;cursor:pointer}.green{background-color:#d4edda}.yellow{background-color:#fff3cd}.orange{background-color:#ffe5d0}.red{background-color:#f8d7da}.connector{width:20px;height:2px;background-color:#000}.index-item,.query-item{border:2px solid #007bff;border-radius:12px;padding:12px;margin:10px 40px 10px 0;background:white;box-shadow:0 2px 8px rgba(0, 0, 0, 0.1);cursor:move;position:relative;transition:transform 0.2s, box-shadow 0.2s}.index-item:hover,.query-item:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0, 0, 0, 0.15)}.index-item.primary{background-color:#ffebee;border-color:#f44336}.index-stats{font-size:11px;color:#666;margin-top:8px;line-height:1.3}.query-text{font-family:monospace;font-size:12px;background:#f8f9fa;padding:8px;border-radius:4px;margin:8px 0;max-height:60px;overflow:hidden;position:relative}.query-text.expanded{max-height:none}.query-controls{margin-top:8px;display:flex;gap:8px}.query-controls button:not(.btn-standard){padding:4px 8px;border:1px solid #ddd;background:white;border-radius:3px;cursor:pointer;font-size:11px}.query-controls button:not(.btn-standard):hover{background:#f0f0f0}.usage-count{background:white;border:1px solid #333;padding:2px 6px;font-size:11px;font-weight:bold;border-radius:3px;position:absolute;transform:translate(-50%, -50%);z-index:10}#table-section,#analysis-table-section{flex:1;overflow-y:auto}#table-container,#analysis-table-container{overflow-x:auto}table{width:100%;border-collapse:collapse;background-color:#fff}th,td{border:1px solid #ddd;padding:8px;text-align:center}th{background-color:#f2f2f2;cursor:pointer;user-select:none}th:hover{background-color:#e8e8e8}.sort-arrow{margin-left:5px;font-size:12px;color:#666}tr:hover{background-color:#f1f1f1;cursor:pointer}.primary-scan-yes{font-weight:bold !important;color:red !important}.fatal-state{font-weight:bold;color:red}.modal{display:none;position:fixed;z-index:1;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:rgba(0, 0, 0, 0.4)}.modal-content{background-color:#fefefe;margin:15% auto;padding:20px;border:1px solid #888;width:80%;max-height:80vh;overflow-y:auto;user-select:text;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text}.close{color:#aaa;float:right;font-size:28px;font-weight:bold}.close:hover,.close:focus{color:black;text-decoration:none;cursor:pointer}#plan-modal-body ul{list-style-type:none;padding-left:20px}#plan-modal-body li,.margin-bottom-5{margin-bottom:5px}#operator-modal-body dl,.margin-0{margin:0}#operator-modal-body dt,.font-bold{font-weight:bold}#operator-modal-body dd,.margin-left-20{margin-left:20px}#operator-modal-body,#plan-modal-body,#operator-modal-body *,#plan-modal-body *{user-select:text;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text}.btn-standard{background:#007bff;color:white;border:none;border-radius:3px;padding:4px 8px;font-size:12px;cursor:pointer;margin:2px;font-weight:normal;text-transform:none}.btn-standard:active{background:#004494}.toast{position:fixed;bottom:20px;right:20px;background:#28a745;color:white;padding:12px 20px;border-radius:5px;box-shadow:0 4px 12px rgba(0, 0, 0, 0.15);z-index:1001;opacity:0;transform:translateY(100%);transition:all 0.3s ease}.toast.show{opacity:1;transform:translateY(0)}.toast.error{background:#dc3545}.version-info{position:fixed;bottom:10px;left:10px;background:rgba(0, 0, 0, 0.1);color:#333;padding:4px 8px;border-radius:4px;font-size:0.75em;font-family:monospace;z-index:999;opacity:0.7;transition:opacity 0.3s ease}.version-info:hover{opacity:1;background:rgba(0, 0, 0, 0.2)}.dashboard-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;grid-template-rows:300px}.dashboard-tables-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px}.chart-container{background:white;padding:15px;border:1px solid #ccc;border-radius:5px;height:400px;overflow:hidden;position:relative;}.chart-drag-handle{position:absolute;top:5px;right:5px;width:20px;height:20px;cursor:move;background:#f0f0f0;border:1px solid #ccc;border-radius:3px;display:flex;align-items:center;justify-content:center;font-size:12px;color:#666;user-select:none;z-index:1000;}.chart-drag-handle:hover{background:#e0e0e0;border-color:#999;}.chart-container.ui-draggable-dragging{opacity:0.7;z-index:1001;transform:rotate(2deg);}.chart-drop-zone{border:2px dashed #007bff;background:rgba(0, 123, 255, 0.1);}#charts-grid{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;gap:20px;margin-bottom:20px;}.draggable-chart{min-height:400px;}.chart-container.with-margin-top-20{margin-top:20px}.table-container{background:white;padding:15px;border:1px solid #ccc;border-radius:5px}.table-container.with-margin-top-40{margin-top:40px}.chart-title{margin-top:0;margin-bottom:10px;text-align:center}.chart-title.fixed-height{height:30px}.table-scroll{height:250px;overflow-y:auto;border:1px solid #eee}.table-header{padding:8px;text-align:center;border-bottom:1px solid #ddd;width:80px}.note-text,.table-subheader{font-size:12px;color:#666;margin-bottom:10px;text-align:center;font-style:italic}.input-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}.button-row{margin:10px 0;display:flex;align-items:center;gap:10px;flex-wrap:wrap}.progress-container{background-color:#f0f0f0;border:1px solid #ccc;border-radius:5px;height:20px;width:200px;overflow:hidden;position:relative}.progress-bar{background-color:#007bff;height:100%;width:0%;transition:width 0.3s ease}.progress-text{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-size:12px;font-weight:bold;color:#333}.flex-row{display:flex;align-items:center;gap:8px}.flex-row-small{display:flex;align-items:center;gap:4px;font-size:11px}.flex-row-5px{display:flex;gap:5px;align-items:center}.flex-row-20px{display:flex;gap:20px;margin-bottom:20px}.height-250-relative,.chart-card-content{height:250px;position:relative}.height-400-flex,.flex-1-height-400{flex:1;height:400px;position:relative}.flex-1{flex:1}.margin-top-5{margin-top:5px}.margin-top-5-right-5{margin-top:5px;margin-right:5px}.margin-left-10{margin-left:10px}.margin-bottom-30{margin-bottom:30px}.font-bold-block{font-weight:bold;display:block;margin-bottom:5px}.font-bold-margin-right{font-weight:bold;margin-right:5px}.text-muted{color:#6c757d;font-weight:500}.input-full{width:100%;padding:8px;border:1px solid #ccc;border-radius:4px}.input-250,.form-input{width:250px;padding:5px;border:1px solid #ccc;border-radius:3px}.input-200,.form-input-small{width:200px;padding:5px;border:1px solid #ccc;border-radius:3px}.btn-small{padding:4px 8px;font-size:0.8em}.card-white{background:white;padding:6px 10px;border-radius:4px;border:1px solid #e9ecef}.table-full{width:100%;border-collapse:collapse}.text-center-margin-top-30{text-align:center;margin-top:30px}.label-flex{display:flex;align-items:center;gap:5px;margin-left:15px}.chart-flex-container{display:flex;height:250px;gap:15px}#progress-container{display:none;margin:10px 15px}#filter-info{color:#666;font-size:0.9em}.progress-background{background-color:#f0f0f0;border-radius:5px;height:20px;position:relative}.progress-bar-fill{background-color:#4caf50;height:100%;border-radius:5px;width:0%;transition:width 0.3s ease}.progress-text{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);font-size:16px;font-weight:bold}.checkbox-label-text{font-size:0.9em;user-select:none;cursor:pointer}.warning-box{flex:0 0 200px;background:#fff3cd;border:2px solid #ffeaa7;border-radius:8px;padding:15px;display:none;flex-direction:column;justify-content:center}.warning-title{text-align:center;color:#ff6b35;font-weight:bold;font-size:16px;margin-bottom:10px}.warning-text{color:#333;font-size:13px;line-height:1.4;text-align:center}.warning-link-container{margin-top:10px;text-align:center}.warning-link{color:#007bff;text-decoration:none;font-size:12px;font-weight:bold}.pattern-analysis-grid{display:grid;grid-template-columns:1fr;gap:20px;margin-bottom:20px;grid-template-rows:400px}.height-350-relative{height:350px;position:relative}.sticky-header{position:sticky;top:0;background:#f5f5f5}.table-header-cell{font-weight:bold;text-align:center;padding:12px 8px;background:#f8f9fa;border:1px solid #dee2e6;user-select:none;cursor:pointer}.padding-8{padding:8px}.padding-5{padding:5px}.padding-15{padding:15px}.border-bottom{border-bottom:1px solid #ddd}.text-align-center{text-align:center}.width-100{width:100%}.width-80px{width:80px}.width-300px{width:300px}.position-sticky-top{position:sticky;top:0}.background-f5{background:#f5f5f5}.overflow-hidden{overflow:hidden}.cursor-pointer{cursor:pointer}.user-select-none{user-select:none}.font-size-12{font-size:12px}.font-size-11{font-size:11px}.margin-bottom-15{margin-bottom:15px}.margin-bottom-10{margin-bottom:10px}.margin-right-10{margin-right:10px}.vertical-align-top{vertical-align:top}.display-none{display:none}.max-width-500{max-width:500px}.background-white{background:white}.border-none{border:none}.border-radius-3{border-radius:3px}.color-666{color:#666}.gap-10{gap:10px}.gap-15{gap:15px}.gap-20{gap:20px}.margin-left-8{margin-left:8px}.margin-left-30{margin-left:30px}.overflow-auto{overflow:auto}.position-relative{position:relative}.display-flex{display:flex}.display-flex-center{display:flex;align-items:center}.display-flex-wrap{display:flex;flex-wrap:wrap}.height-100{height:100%}.height-300{height:300px}.height-400{height:400px}.width-90{width:90%}.width-250{width:250px}.width-200{width:200px}.btn-gray{padding:5px 15px;background:#6c757d;color:white}.background-f8{background:#f8f9fa}.border-radius-8{border-radius:8px}.border-radius-6{border-radius:6px}.border-radius-4{border-radius:4px}.z-index-1{z-index:1}.z-index-2{z-index:2}.z-index-3{z-index:3}.padding-10-20{padding:10px 20px}.padding-4-8{padding:4px 8px}.font-size-14{font-size:14px}.font-size-0-8em{font-size:0.8em}.calc-height-minus-50{height:calc(100% - 50px)}.position-absolute{position:absolute}.top-0{top:0}.left-0{left:0}.pointer-events-none{pointer-events:none}.border-1-ddd{border:1px solid #ddd}.border-1-ccc{border:1px solid #ccc}.justify-space-between{justify-content:space-between}.align-center{align-items:center}.color-333{color:#333}.grid-2-col{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:300px}.chart-card{background:white;padding:15px;border:1px solid #ccc;border-radius:5px;height:300px;overflow:hidden}.chart-card-header{margin-top:0;margin-bottom:10px;text-align:center;height:30px}#parse-json-btn{font-size:18px !important;padding:12px 24px !important;font-weight:bold !important;background:#28a745 !important;color:white !important;border:none !important;border-radius:8px !important;cursor:pointer !important;transition:all 0.3s ease !important;}#parse-json-btn:hover{background:#1e7e34 !important;transform:translateY(-1px) !important;box-shadow:0 4px 8px rgba(0, 0, 0, 0.2) !important;}#parse-json-btn:active{transform:translateY(0) !important;box-shadow:0 2px 4px rgba(0, 0, 0, 0.2) !important;}table td,table th{user-select:text !important;-webkit-user-select:text !important;-moz-user-select:text !important;-ms-user-select:text !important;}table tr{cursor:pointer;}table tr:hover{background-color:#f1f1f1;}.sample-queries-table{width:100%;border-collapse:collapse;margin-top:10px;font-size:12px;}.sample-queries-table th{background-color:#f8f9fa;padding:8px;text-align:center;border:1px solid #ddd;font-weight:bold;}.sample-queries-table td{padding:6px;border:1px solid #ddd;vertical-align:top;}.sample-queries-table tr:hover{background-color:#f8f9fa;}.statement-cell{max-width:400px;word-wrap:break-word;text-align:left;}.grid-3-col{display:grid;grid-template-columns:repeat(3, 1fr);}.insight-category{margin-bottom:40px;scroll-margin-top:20px;}.category-title{color:#343a40;font-size:22px;font-weight:700;margin:0 0 20px 0;padding-bottom:10px;border-bottom:3px solid #007bff;display:flex;align-items:center;gap:10px;}.insight-item{background:#f8f9fa;border:1px solid #dee2e6;border-radius:8px;padding:20px;margin-bottom:15px;border-left:4px solid #007bff;}.insight-title{color:#495057;font-size:16px;font-weight:600;margin:0 0 12px 0;}.insight-description{color:#6c757d;font-size:14px;line-height:1.6;margin:0 0 10px 0;}.highlight-number{background:linear-gradient(135deg, #ffd700, #ffed4e);color:#5a5a00;padding:2px 6px;border-radius:4px;font-weight:700;font-size:13px;border:1px solid #e6c300;display:inline-block;margin:0 2px;}.learn-more-section{background:#e3f2fd;border:1px solid #90caf9;border-radius:6px;padding:15px;margin-top:15px;}.learn-more-item{display:flex;align-items:flex-start;gap:8px;margin-bottom:8px;font-size:13px;line-height:1.4;}.learn-more-item:last-child,.index-breakdown-item:last-child{margin-bottom:0;}.learn-more-icon{font-size:14px;margin-top:1px;flex-shrink:0;}.insight-link{color:#1565c0;text-decoration:none;font-weight:600;border-bottom:1px dotted #1565c0;}.insight-link:hover{color:#0d47a1;text-decoration:none;border-bottom:1px solid #0d47a1;}.fatal-count{font-weight:bold;color:#dc3545;}.live-badge{background:#28a745;color:white;padding:2px 6px;border-radius:12px;font-size:10px;font-weight:bold;text-transform:uppercase;margin-left:8px;display:inline-block;}.dev-badge{background:#fd7e14;color:white;padding:2px 6px;border-radius:12px;font-size:10px;font-weight:bold;text-transform:uppercase;margin-left:8px;display:inline-block;}.beta-badge{background:#007bff;color:white;padding:2px 6px;border-radius:12px;font-size:10px;font-weight:bold;text-transform:uppercase;margin-left:8px;display:inline-block;}.category-title{cursor:pointer;transition:all 0.3s ease;position:relative;padding-right:30px;}.category-title:hover{background:rgba(0, 123, 255, 0.1);border-radius:6px;padding:10px;margin:-10px 0 10px -10px;}.category-title::after{content:"▼";position:absolute;right:10px;top:50%;transform:translateY(-50%);transition:transform 0.3s ease;font-size:16px;}.category-title.collapsed::after,.insight-title.collapsed::after{transform:translateY(-50%) rotate(-90deg);}.insight-category-content,.insight-content{overflow:hidden;transition:max-height 0.3s ease;}.insight-category-content.collapsed{max-height:0 !important;}.insight-title{cursor:pointer;position:relative;padding-right:30px;transition:all 0.3s ease;}.insight-title:hover{background:rgba(0, 123, 255, 0.05);border-radius:4px;padding:5px;margin:-5px;}.insight-title::after{content:"▼";position:absolute;right:10px;top:50%;transform:translateY(-50%);transition:transform 0.3s ease;font-size:12px;color:#666;}.insight-content.collapsed{max-height:0 !important;padding:0 !important;margin:0 !important;}.index-breakdown{margin:15px 0;padding-left:30px;}.index-breakdown-item{margin-bottom:12px;padding:8px 0;line-height:1.4;}
    </style>
    <style>
        /* Align stacked date pickers: equal label width and input width */
        .date-range-stack > div > label { display: inline-block; width: 48px; text-align: right; }
        #start-date, #end-date { width: 280px; box-sizing: border-box; }
        /* Preset select vertical layout */
        .preset-stack { display: flex; flex-direction: column; gap: 2px; }
        .preset-label { font-weight: bold; color: #495057; font-size: 12px; }
        .preset-help { font-size: 10px; color: #6c757d; margin-top: 2px; }
        .filter-stack { display: flex; flex-direction: column; gap: 2px; }
        .filter-label { font-weight: bold; color: #495057; font-size: 12px; }
        .filter-help { font-size: 10px; color: #6c757d; margin-top: 2px; }

        /* Reduce padding on chart containers to save vertical space and allow scrolling */
        .chart-container { padding: 5px !important; overflow: auto !important; }
        /* Ensure consistent vertical spacing for standalone charts */
        .with-margin-top-20 { margin-top: 20px !important; }
        .with-margin-top-40 { margin-top: 40px !important; }
        .with-margin-bottom-20 { margin-bottom: 20px !important; }
        /* Ensure gap above Query Pattern Features matches below */
        .pattern-analysis-grid { display: grid !important; grid-template-columns: 1fr; grid-template-rows: 400px; gap: 20px; margin-top: 20px !important; margin-bottom: 0; clear: both !important; position: relative; z-index: 0; }
        /* Remove inflated min-height on draggable tiles in dashboard */
        #dashboard .draggable-chart { min-height: 0 !important; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.14.1/jquery-ui.min.js" integrity="sha512-MSOo1aY+3pXCOCdGAYoBZ6YGI0aragoQsg1mKKBHXCYPIWxamwOE7Drh+N5CPgGI5SA9IEKJiPjdfqWFWmZtRA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Global Constants for Internationalization -->
    <script>
        // Global text constants - modify these for different languages
        const TEXT_CONSTANTS = {
        // Performance and logging messages
        PARSE_PERFORMANCE: "Parse performance:",
         PREPARED_TEXT: "Prepared:",
        CACHE_STATS: "Cache stats - parseTime:",
        ALL_CACHES_CLEARED: "All caches cleared for new JSON parse",
        LAZY_LOADED_TAB: "Lazy loaded",
        CHART_SAMPLING: "Chart sampling: Using",
        TIMELINE_CHARTS_USING: "Timeline charts: Using",
        REQUESTS_FOR_PERFORMANCE: "requests for performance",
        FILTERED_OUT_EARLY: "filtered out early",

        // Error messages
        JSON_PARSING_ERROR: "JSON parsing error:",
        ERROR_PROCESSING_REQUEST: "Error processing request",
        ERROR_GENERATING_UI: "Error generating UI:",
        ERROR_LAZY_LOADING: "Error lazy loading",

        // User messages and toasts
        PASTE_JSON_FIRST: "Please paste your JSON data first",
        INPUT_TOO_LARGE: "Input too large. Please use smaller datasets.",
        VALID_JSON_REQUIRED: "Please provide a valid JSON array or object with results.",
        NO_DATA_FOUND: "No data found in the JSON",
        UNEXPECTED_DATA_FORMAT: "Unexpected data format in JSON",
        ERROR_PARSING_JSON: "Error parsing JSON:",
        FILTERS_CHANGED_REMINDER: "⚠️ Filters changed. Click \"Parse JSON\" to apply changes.",

        // Chart and table captions
        SHOWING_TOP: "Showing top",
        OF_TOTAL: "of",
        USERS: "users",
        INDEXES: "indexes",
        REQUESTS: "requests",
        MS_FOR: "ms for",

        // Progress and status
        TAB_IN: "tab in",
        MS: "ms",

        // Operator modal and UI elements
        UNKNOWN: "Unknown",
        OPERATOR_LABEL: "Operator:",
        COPY_STATS: "Copy Stats",
        INDEX_USED: "Index Used:",
        COPY: "Copy",
        COPY_ALL: "Copy All",
        SHOW_MORE: "Show More",
        HIDE: "Hide",
        RESET_ZOOM: "Reset Zoom",

        // User interface messages
        COPIED_CLIPBOARD: "Copied to clipboard!",
        FAILED_COPY_CLIPBOARD: "Failed to copy to clipboard",
        COPIED: "Copied!",
        NO_EXECUTION_PLAN: "No execution plan available.",
        NO_OPERATORS_FOUND: "No operators found in the execution plan.",
        SELECT_QUERY_FLOW: "Select a query from the table to view the flow diagram.",
        STATEMENT_NOT_FOUND: "Statement not found",

        // Modal and plan display headers
        VIEW_DETAILED_PLAN: "View Detailed Execution Plan & Indexes/Keys Used",
        INDEXES_USED_HEADER: "📋 Indexes Used:",
        USE_KEYS_HEADER: "🔑 USE KEYS:",
        EXECUTION_PLAN_HEADER: "⚙️ Execution Plan:",
        KEYS_NOT_EXTRACTED: "Keys could not be extracted from the query",
        
        // Sample queries functionality
        SHOW_SAMPLE_QUERIES: "Show Sample Queries",
        HIDE_SAMPLE_QUERIES: "Hide Sample Queries",
        REQUEST_DATE: "Request Date",
        STATEMENT: "Statement",
        STATEMENT_UNIQUE: "Statement (unique)",

        // Console log messages
        COLLECTED_INDEX_DATA: "Collected index data for timing analysis:",
        INDEX_ANALYSIS_INITIALIZED: "✅ Index analysis initialized",
        INITIALIZING_ANALYZER: "🚀 Initializing Couchbase Query Analyzer...",
        FEATURES: "🔧 Features:",
        ANALYZER_INITIALIZED: "✅ Query Analyzer initialized successfully",
        TIP_ABOUT: "💡 Tip: Type QueryAnalyzer.about() for full app info",

        // Chart and table labels
        QUERY_DURATION_CHART_TITLE: "Query Duration by Statement Type (Bubble Size = Query Count)",
        USER_COUNT: "user: (count)",
        STATE_FATAL: "state\nfatal",
        COUNT_LABEL: "Count:",
        AVG_LABEL: "Avg:",
        MIN_LABEL: "Min:",
        MAX_LABEL: "Max:",
        FATAL_LABEL: "Fatal:",
        ELAPSED_LABEL: "Elapsed:",
        SWITCHED_TO: "Switched to",
        QUERY_GROUP_PHASE_TIMES_TITLE: "Phase Times by Query Group (avg)",
        PHASE_AUTHORIZE: "Authorize",
        PHASE_PARSE: "Parse",
        PHASE_PLAN: "Plan",
        PHASE_INDEX_SCAN: "Index Scan",
        PHASE_FETCH: "Doc Fetch",
        PHASE_FILTER: "Filter",
        PHASE_JOIN: "JOIN",
        PHASE_PROJECT: "Project",
        PHASE_DELETE_UPDATE: "DELETE / UPDATE",
        PHASE_DELETE: "DELETE",
        PHASE_UPDATE: "UPDATE",
        PHASE_INSERT: "INSERT",
        PHASE_STREAM: "Stream",
                PHASE_SORT: "ORDER BY",
        PHASE_GROUP_AGG: "GROUP BY",
        PHASE_LIMIT: "LIMIT",
        PHASE_NEST: "Nest/Unnest",
        AXIS_QUERY_PHASE: "Query Phase",
        AXIS_TIME_MS: "Time (ms)",

        // Phase timeline note (approximate)
        PHASE_TIMELINE_NOTE: "Approximate phase positions: many steps run concurrently and asynchronously; bars show average timing, not exact start times.",
 
            // Technical constants (DO NOT TRANSLATE - used in logic checks)
                N_A: "N/A",
                NO_DATA: "No data",
                LOADING: "Loading...",

            // Input panel toggle
                SHOW_INPUT_PANEL: "Show",
                HIDE_INPUT_PANEL: "Hide",

            // Help badge
                HELP_DEBUG_TIPS: "NEED HELP? Debugging + Tool Tips — Click Here",

            // Bug report CTA
                BUG_REPORT_CTA: "Report a Bug Click Here",

            // File upload UI + messages
                UPLOAD_JSON: "Upload .json",
                INVALID_FILE_TYPE: "Please select a .json file",
                FILE_READ_ERROR: "Error reading file",
                PASTE_OVERRIDES_UPLOAD: "Pasted JSON overrides uploaded file; cleared file selection",
                OR_LABEL: "OR",

            // Input section headers
            COMPLETED_JSON_HEADER: "Completed Requests JSON (system:completed_requests)",
            INDEXES_JSON_HEADER: "Indexes JSON (system:indexes output)",

                        // New features (v3.16.0+)
                WHOLE_RECORD: "Whole Record",
                REQUEST_ID: "Request ID",
                ENTER_REQUEST_ID: "Enter requestId",
                LOAD: "Load",
                RECORD_NOT_FOUND: "Request ID not found",
                VIEW_WHOLE_RECORD: "View Whole Record",
                COPY_REQUEST_ID: "Copy Request ID"
            };
    </script>
<style>
/* Report Mode + Print styles (Phase 1) */
.report-mode body, .report-mode { background: #fff !important; }
/* Preview (screen) should not use flex/100vh to allow natural scroll */
.report-mode { display: block !important; height: auto !important; overflow: visible !important; }
.report-mode #tabs { height: auto !important; overflow: visible !important; display: block !important; }
.report-mode .chart-container { overflow: visible !important; }
.report-mode .version-info, .report-mode .bug-report-link, .report-mode #input-section, .report-mode .ui-tabs-nav, .report-mode footer, .report-mode .beta-badge, .report-mode .dev-badge, .report-mode .live-badge, .report-mode #analysis-search-controls { display: none !important; }
.report-mode .ui-tabs-panel { display: none !important; }
.report-mode .ui-tabs-panel.report-visible { display: block !important; }
.report-mode #report-header { position: sticky; top: 0; background: #fff; z-index: 10001; display: block !important; box-shadow: 0 2px 6px rgba(0,0,0,0.06); }

/* Unclamp scroll areas for printing */
.print-unclamp, .report-mode .print-unclamp { overflow: visible !important; max-height: none !important; height: auto !important; }

/* Table print helpers + layout overrides */
@media print {
html, body { -webkit-print-color-adjust: exact; print-color-adjust: exact; background: #fff !important; }
body { display: block !important; height: auto !important; overflow: visible !important; padding: 12mm !important; }
#tabs { height: auto !important; overflow: visible !important; display: block !important; }
.ui-tabs-panel { display: block; }
/* Ensure panels expand naturally for print */
#dashboard, #insights, #timeline, #analysis, #every-query, #index-query-flow, #indexes { height: auto !important; overflow: visible !important; }
#index-query-flow .height-100 { height: auto !important; }
#timeline .chart-container, .chart-container { overflow: visible !important; }
#flow-canvas, #flow-elements, #flow-svg { transform: none !important; width: auto !important; height: auto !important; overflow: visible !important; }
/* In report mode, only show selected panels */
.report-mode .ui-tabs-panel { display: none !important; }
.report-mode .ui-tabs-panel.report-visible { display: block !important; }
/* Unclamp previously fixed-height areas */
#table-section, #analysis-table-section, #table-container, #analysis-table-container, #flow-canvas, #indexResults { height: auto !important; overflow: visible !important; }

/* Hide sticky header by default in print; only show when explicitly enabled */
#report-header { display: none !important; position: static !important; box-shadow: none !important; }
#report-header.print-visible { display: block !important; }
/* Ensure cover stays on a single page and forces a break after */
#report-cover { page-break-after: always; page-break-inside: avoid; min-height: 100vh; }

.version-info, .bug-report-link, #input-section, .ui-tabs-nav, footer, .modal, .toast { display: none !important; }
/* Hide analysis/every-query search controls and timeline controls in report */
#analysis-search-controls, #search-controls, #timeline-controls { display: none !important; }
/* Only print selected sections */
.report-mode [data-report-section]:not(.report-visible) { display: none !important; }
  .report-visible { display: block !important; }
  thead { display: table-header-group; }
  tfoot { display: table-footer-group; }
  table, tr, td, th { page-break-inside: avoid; }
  .chart-container, .table-container, .chart-card, .insight-category, .insight-item { page-break-inside: avoid; }

  /* Fit Dashboard tables side-by-side in Chrome */
  #dashboard .dashboard-tables-grid { display: grid !important; grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) !important; column-gap: 10px !important; }
  #dashboard .dashboard-tables-grid > .table-container { box-sizing: border-box !important; padding: 4px !important; margin: 0 !important; }
  #dashboard .dashboard-tables-grid table { table-layout: fixed !important; font-size: 11px !important; }
  #dashboard .dashboard-tables-grid th, #dashboard .dashboard-tables-grid td { padding: 6px !important; word-break: break-word !important; }
  #dashboard .dashboard-tables-grid button { display: none !important; }


  .page-break { display: block !important; break-before: page !important; page-break-before: always !important; height: 0; }
}

/* Report header */
#report-header { display: none; padding: 12px 16px; border-bottom: 1px solid #ddd; margin-bottom: 16px; position: relative; }
#report-header h1 { margin: 0 0 6px 0; font-size: 18px; }
#report-header .meta { color: #666; font-size: 12px; }
#report-header .report-exit-btn { position: absolute; right: 12px; top: 12px; }

/* Cover page */
#report-cover { display: none; background: #fff; padding: 24px; border: 1px solid #eee; border-radius: 6px; margin-bottom: 18px; min-height: 80vh; }
#report-cover h1 { margin: 0 0 10px 0; font-size: 26px; font-weight: 700; }
#report-cover .line { color: #555; margin: 4px 0; font-size: 13px; }
#report-cover .section { margin-top: 16px; }
#report-cover .section h3 { margin: 0 0 6px 0; font-size: 16px; font-weight: 600; }
#report-cover ul { margin: 6px 0 0 18px; }
/* Cover layout + cards */
#report-cover .cover-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
@media (min-width: 900px) { #report-cover .cover-grid { grid-template-columns: 1fr 1fr; } }
#report-cover .cover-card { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 12px 14px; box-shadow: 0 1px 3px rgba(0,0,0,0.04); }
#report-cover .cover-card h4 { margin: 0 0 6px 0; font-size: 14px; color: #343a40; }
#report-cover .cover-card h5 { margin: 8px 0 4px 0; font-size: 13px; color: #495057; }
#report-cover .muted { color: #6c757d; }
#report-cover .badge { display: inline-block; padding: 2px 6px; font-size: 10px; border-radius: 10px; font-weight: 700; }
#report-cover .badge.live { background: #28a745; color: #fff; }
#report-cover .badge.beta { background: #007bff; color: #fff; }
#report-cover .emoji-title { display: inline-flex; align-items: center; gap: 6px; }
#report-cover .list-tight { margin: 6px 0 0 18px; }
#report-cover .callout { background: #e9f7ef; border-left: 4px solid #28a745; padding: 8px 10px; border-radius: 6px; color: #155724; font-size: 12px; }


/* Floating Exit button for preview */
.report-exit-btn { position: fixed; top: 12px; right: 12px; z-index: 10002; background: #d9534f; color: #fff; border: none; border-radius: 6px; padding: 10px 14px; font-weight: 800; letter-spacing: 0.5px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer; }
.report-exit-btn:hover { background: #c9302c; }
@media print { .report-exit-btn { display: none !important; } }

/* Chart image replacement */
.chart-print-img { max-width: 100%; height: auto; display: block; }

/* Page break helper visible only in print */
.page-break { display: none; }
</style>
<script>
// Extend TEXT_CONSTANTS with Report Maker strings (Phase 1)
if (window.TEXT_CONSTANTS) {
  Object.assign(TEXT_CONSTANTS, {
  REPORT_MAKER: "Report Maker",
  SELECT_SECTIONS: "Select sections",
  SELECT_TIMELINE_CHARTS: "Select Timeline charts",
  INCLUDE_HEADER_SUMMARY: "Include header summary",
  INCLUDE_FILTERS: "Include filters applied",
  FLATTEN_TABLES_FOR_PRINT: "Flatten scrollable tables for print",
  CONVERT_CHARTS_TO_IMAGES: "Convert charts to images for printing",
  PREVIEW_REPORT: "Preview Report",
  PRINT_SAVE_PDF: "Print / Save PDF",
  EXIT_REPORT_MODE: "Exit Report Mode",
  LOAD_TEST_SAMPLE: "Load test sample JSON",
  REPORT_GENERATED_AT: "Generated at",
  REPORT_TIME_RANGE: "Range",
  REPORT_FILTERS_APPLIED: "Filter",
  REPORT_OPTIONS: "Options",
  EXIT_REPORT_PREVIEW: "EXIT REPORT PREVIEW",
  COVER_TITLE: "Couchbase Query Analysis Report",
  COVER_SECTIONS_INCLUDED: "Sections included",
  COVER_TIMELINE_CHARTS: "Timeline charts",
  COVER_FILTERS_APPLIED: "Filters applied",
  COVER_TIME_RANGE: "Time range",
  COVER_DATA_COUNTS: "Data counts",
  COVER_NOTES: "Notes",
  COVER_BETA_NOTE: "Some charts marked Beta/Dev may display incomplete or placeholder content.",

    // Cover page rich content blocks (English)
     COVER_BLOCK_DASHBOARD_HTML: "<div class=\"section\"><h3>📊 Dashboard</h3><p>High-level overview with draggable charts showing query duration distribution, index type usage, scan consistency patterns, result size analysis, and system health metrics. Perfect for at-a-glance performance monitoring.</p></div>",
     COVER_BLOCK_INSIGHTS_HTML: "<div class=\"section\"><h3>💡 Insights Tab</h3><p>The Insights tab provides automated analysis organized into three main categories, each with expandable insights and live metrics based on your parsed query data:</p><h4>📊 Analysis Categories</h4><div><h5>🔍 Index Performance Issues</h5><ul><li>Inefficient Index Scans - Identifies queries with poor selectivity ratios</li><li>Slow Index Scan Times - Flags indexes taking 2+ seconds to scan</li><li>Primary Index Over-Usage - Detects reliance on expensive primary indexes</li><li>ORDER BY / LIMIT / OFFSET Index Over-Scan - Highlights over-scanning due to pagination patterns (Beta)</li></ul><h5>⚡ Resource Utilization Issues</h5><ul><li>High Kernel Time in Queries - CPU scheduling overhead analysis</li><li>High Memory Usage Detected - Memory-intensive query identification</li><li>Slow USE KEY Queries - KV service bottleneck detection</li></ul><h5>🔄 Query Pattern Analysis</h5><ul><li>Missing WHERE Clauses - Identifies full collection scans</li><li>Inefficient LIKE Operations - Detects leading wildcard usage</li><li>SELECT * Usage - Finds queries returning entire documents (Live)</li></ul><h5>🚀 Performance Optimization Opportunities</h5><ul><li>Large Payload Streaming - Identifies queries with heavy network usage</li><li>Large Result Set Queries - Flags memory and bandwidth intensive operations</li><li>Timeout-Prone Queries - Detects queries approaching timeout limits</li></ul></div><p><strong>💡 Live Data:</strong> Insights marked with Live analyze your actual parsed data, while Beta insights are experimental and may show false positives.</p></div>",
     COVER_BLOCK_TIMELINE_DESC: "Chronological analysis with zoomable time-series charts. Track query patterns by time grouping (seconds to days), analyze duration buckets, operation types, result counts, and memory usage trends over time with dual Y-axis support.",
     COVER_BLOCK_QUERY_GROUPS_HTML: "<div class=\"section\"><h3>🔍 Query Groups</h3><p>Analyze similar queries grouped by normalized patterns. Compare aggregated statistics, identify frequently executed query types, and optimize query families that share similar execution characteristics and performance profiles.</p></div>",
     COVER_BLOCK_EVERY_QUERY_HTML: "<div class=\"section\"><h3>📋 Every Query</h3><p>Detailed tabular view of individual query executions with sorting, filtering, and search capabilities. Drill down into specific query metrics, execution plans, and performance details for granular analysis and debugging.</p></div>",
     COVER_BLOCK_FLOW_HTML: "<div class=\"section\"><h3>🌊 Index/Query Flow</h3><p>Interactive visual flow diagram showing the relationship between indexes and queries. See which indexes are used by which queries, identify index usage patterns, and optimize index coverage with drag-and-pan visualization.</p></div>",
     COVER_BLOCK_INDEXES_HTML: "<div class=\"section\"><h3>🗂️ Indexes</h3><p>Comprehensive index management with filtering by bucket/scope/collection. Analyze index performance metrics, memory residency, scan times, and usage patterns. Includes search and sorting capabilities for large index inventories.</p></div>"

   });
}
</script>
    <style>
      /* Insight state: gray by default; blue when active (issues found) */
      .insight-item { border-left: 4px solid #dee2e6 !important; }
      .insight-item.active { border-left-color: #007bff !important; }

      /* Bug report floating link */
      .bug-report-link { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.1); color: #333; padding: 4px 8px; border-radius: 4px; font-size: 0.75em; font-family: monospace; z-index: 999; opacity: 0.7; text-decoration: none; transition: opacity 0.3s ease, background 0.3s ease; }
      .bug-report-link:hover { opacity: 1; background: rgba(0,0,0,0.2); }
    </style>
</head>

<body>
    <!-- Version info -->
    <div class="version-info" title="Couchbase Query Analyzer Version">
        v3.16.3
    </div>

    <!-- Bug report link (bottom-right) -->
    <a id="bug-report-link" class="bug-report-link" href="https://github.com/Fujio-Turner/cb_completed_request/issues" target="_blank" rel="noopener noreferrer">Report a Bug Click Here</a>
    <script>
      (function(){
        var setBugText = function(){
          var el = document.getElementById('bug-report-link');
          try {
            if (!el) return;
            if (typeof TEXT_CONSTANTS !== 'undefined' && TEXT_CONSTANTS.BUG_REPORT_CTA) {
              el.textContent = TEXT_CONSTANTS.BUG_REPORT_CTA;
            }
          } catch (e) { /* no-op */ }
        };
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', setBugText);
        } else {
          setBugText();
        }
      })();
    </script>

    <style>
      /* Side-by-side upload vs textarea layout */
      .input-source-grid { display: flex; gap: 16px; align-items: flex-start; }
      .source-section { flex: 1; }
      .section-title { font-size: 14px; font-weight: 700; color: #343a40; margin: 0 0 6px 0; }
      .input-source-row { display: flex; gap: 12px; align-items: stretch; margin-bottom: 10px; }
      .upload-box, .textarea-box { flex: 1; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 8px; }
      .or-divider { align-self: center; color: #6c757d; font-weight: 700; }
      .file-name { font-size: 11px; color: #6c757d; margin-top: 6px; }
    </style>
 
     <!-- Input Section (outside tabs) -->
    <div id="input-section">
        <div class="input-grid">
            <div class="input-source-grid">
                <div class="source-section" aria-labelledby="completed-section-title">
                    <div id="completed-section-title" class="section-title"></div>
                    <div class="input-source-row">
                        <div class="upload-box">
                            <button type="button" id="upload-completed-btn" class="btn-standard" title="Upload JSON for completed_requests"></button>
                            <input type="file" id="completed-requests-file" accept=".json,application/json" style="display:none" aria-label="Upload Completed Requests JSON file" />
                            <div id="completed-file-name" class="file-name"></div>
                        </div>
                        <div class="or-divider"><span id="or-label-1">OR</span></div>
                        <div class="textarea-box">
                            <textarea id="json-input"
                                placeholder="Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests LIMIT 2000;"
                                aria-label="JSON input field for Couchbase query data" role="textbox"></textarea>
                        </div>
                    </div>
                </div>
                <div class="source-section" aria-labelledby="indexes-section-title">
                    <div id="indexes-section-title" class="section-title"></div>
                    <div class="input-source-row">
                        <div class="upload-box">
                            <button type="button" id="upload-indexes-btn" class="btn-standard" title="Upload JSON for indexes"></button>
                            <input type="file" id="indexes-file" accept=".json,application/json" style="display:none" aria-label="Upload Indexes JSON file" />
                            <div id="indexes-file-name" class="file-name"></div>
                        </div>
                        <div class="or-divider"><span id="or-label-2">OR</span></div>
                        <div class="textarea-box">
                            <textarea id="indexJsonInput"
                                placeholder="Click the 'Indexes' tab below to get the SQL query to run. Paste the results here..."
                                aria-label="Index JSON input field" role="textbox"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div style="margin: 10px 0; display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
            <!-- Parse Button and Progress (Left Side) -->
            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="parse-json-btn" onclick="parseJSON()" aria-label="Parse and analyze JSON data" tabindex="0"
                    role="button">
                    Parse JSON
                </button>
                <div id="progress-container">
                    <div class="progress-background">
                        <div id="progress-bar" class="progress-bar-fill"></div>
                        <span id="progress-text" class="progress-text">0%</span>
                    </div>
                </div>
            </div>

            <!-- Filtering Controls Group -->
            <div
                style="display: flex; flex-wrap: wrap; align-items: flex-start; gap: 12px; background: #f8f9fa; padding: 8px 12px; border-radius: 6px; border: 1px solid #dee2e6; max-width: 1320px; flex: 0 1 auto;">
                <div class="preset-stack margin-left-0">
                    <label for="time-range-select" class="preset-label">Presets</label>
                    <select id="time-range-select" onchange="setTimeRange(this.value)" title="Quickly set From/To date range" aria-describedby="preset-help"
                        style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px;">
                        <option value="original">Original (full data)</option>
                        <option value="1week">Last 1 Week</option>
                        <option value="1day">Last 1 Day</option>
                        <option value="1hour">Last 1 Hour</option>
                    </select>
                    <div id="preset-help" class="preset-help">Sets From/To automatically</div>
                </div>

                <div class="date-range-stack" style="display: flex; flex-direction: column; gap: 4px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label for="start-date" style="font-size: 12px; color: #6c757d;">From:</label>
                        <input type="datetime-local" id="start-date" step="1" title="Start date/time for filtering"
                            style="font-size: 11px; padding: 2px 4px;" />
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label for="end-date" style="font-size: 12px; color: #6c757d;">To:</label>
                        <input type="datetime-local" id="end-date" step="1" title="End date/time for filtering"
                            style="font-size: 11px; padding: 2px 4px;" />
                    </div>
                </div>

                <div class="filter-stack" style="margin-left: 15px; display: grid; grid-template-columns: 300px 200px auto; align-items: end; column-gap: 12px; row-gap: 0;">
                    <div style="display: flex; flex-direction: column; padding: 6px 8px;">
                        <label for="sql-statement-filter" class="filter-label">SQL++ Statement Filter</label>
                        <input type="text" id="sql-statement-filter" placeholder="e.g., FROM bucket WHERE type = 'order'"
                            title="Enter part of a SQL++ statement to filter results (contains match)"
                            style="width: 100%; max-width: 100%; font-size: 11px; padding: 4px 6px;" />
                    </div>

                    <div style="display: flex; flex-direction: column; padding: 6px 8px;">
                        <label for="elapsed-time-filter" class="filter-label">Elapsed Time Filter</label>
                        <input type="text" id="elapsed-time-filter" placeholder="e.g., >500ms, >=1s, 100-500ms, 0.5s-2s"
                            title="Filter by elapsedTime; supports >, >=, <, <=, = or ranges like 100-500ms"
                            style="width: 100%; max-width: 100%; font-size: 11px; padding: 4px 6px;" />
                    </div>

                    <label class="label-flex margin-top-5" style="margin: 0; display: flex; align-items: center; gap: 6px; padding: 6px 8px;">
                        <input type="checkbox" id="exclude-system-queries" checked
                            title="Excludes INFER, ADVISE, CREATE, ALTER INDEX statements and queries from system: keyspaces"
                            aria-label="Exclude system queries from analysis" />
                        <span class="checkbox-label-text"
                            title="Excludes INFER, ADVISE, CREATE, ALTER INDEX statements and queries from system: keyspaces"
                            style="font-size: 12px;">
                            Exclude System
                        </span>
                    </label>
                </div>
            </div>


            <span id="filter-info" style="font-size: 12px; color: #6c757d;"></span>


        </div>
    </div>

    <!-- Tabs Container -->
    <div id="tabs" role="tabpanel" aria-label="Query analysis tabs">
        <!-- Tab Headers -->
        <ul role="tablist" aria-label="Analysis views">
            <li role="tab">
                <a href="#dashboard" aria-controls="dashboard" tabindex="0">Dashboard</a>
            </li>
            <li role="tab">
                <a href="#insights" aria-controls="insights" tabindex="0">Insights <span
                        class="beta-badge">Beta</span></a>
            </li>
            <li role="tab">
                <a href="#timeline" aria-controls="timeline" tabindex="0">Timeline</a>
            </li>
            <li role="tab">
                <a href="#analysis" aria-controls="analysis" tabindex="0">Query Groups</a>
            </li>
            <li role="tab">
                <a href="#every-query" aria-controls="every-query" tabindex="0">Every Query</a>
            </li>
            <li role="tab">
                <a href="#index-query-flow" aria-controls="index-query-flow" tabindex="0">Index/Query Flow</a>
            </li>
            <li role="tab">
                <a href="#indexes" aria-controls="indexes" tabindex="0">Indexes</a>
            </li>
            <li role="tab">
                <a href="#whole-record" aria-controls="whole-record" tabindex="0">Raw Record</a>
            </li>
            <li role="tab">
                <a href="#report-maker" aria-controls="report-maker" tabindex="0">Report Maker <span
                        class="beta-badge">Beta</span></a>
            </li>
        </ul>

        <!-- Dashboard Tab Content -->
        <div id="dashboard" data-report-section="dashboard">
            <div class="dashboard-grid">
                <!-- Elapsed Time Distribution Bar Chart -->
                <div class="chart-container height-300 draggable-chart" data-chart-id="elapsed-time" data-position="dashboard-1">
                    <h3 class="chart-title fixed-height">
                        Query Duration Distribution
                    </h3>
                    <div class="height-250-relative">
                        <canvas id="elapsed-time-chart"></canvas>
                    </div>
                </div>
                <!-- Primary Index(es) Scan Used Chart -->
                <div class="chart-container height-300 draggable-chart" data-chart-id="primary-scan" data-position="dashboard-2">
                    <h3 class="chart-title fixed-height">Index Type Usage</h3>
                    <div class="chart-flex-container">
                        <div class="flex-1 position-relative">
                            <canvas id="primary-scan-chart"></canvas>
                        </div>
                        <div id="primary-scan-warning" class="warning-box">
                            <div class="warning-title">⚠️ WARNING ⚠️</div>
                            <div class="warning-text">
                                Primary index scans in production can cause full bucket scans
                                leading to
                                <span class="warning-text-highlight">severe performance issues</span>
                            </div>
                            <div class="warning-link-container">
                                <a href="https://www.couchbase.com/blog/primary-uses-for-couchbase-primary-index/"
                                    target="_blank" class="warning-link">
                                    📖 Learn More
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Query Pattern Analysis Row -->
            <div class="pattern-analysis-grid">
                <!-- Query Pattern Features Bar Chart -->
                <div class="chart-container with-margin-top-20 draggable-chart" data-chart-id="query-pattern" data-position="dashboard-3">
                    <h3 class="chart-title fixed-height">Query Pattern Features</h3>
                    <div class="height-350-relative">
                        <canvas id="query-pattern-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Data Tables Row -->
            <div class="dashboard-tables-grid">
                <!-- User Query Count Table -->
                <div class="table-container with-margin-top-40">
                    <h3 class="chart-title">Users by Query Count</h3>
                    <div class="table-scroll">
                        <table id="user-count-table" class="table-full">
                            <thead class="sticky-header">
                                <tr>
                                    <th class="width-80px">Count</th>
                                    <th>User</th>
                                </tr>
                            </thead>
                            <tbody id="user-count-body"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Index Usage Count Table -->
                <div class="table-container with-margin-top-40">
                    <h3 class="chart-title">Index Usage Count</h3>
                    <div class="table-subheader">
                        Note: #primary count shows total operations, not unique queries
                    </div>
                    <div class="table-scroll">
                        <table id="index-count-table" class="table-full">
                            <thead class="sticky-header">
                                <tr>
                                    <th class="padding-8 text-align-center border-bottom width-80px">
                                        Count
                                    </th>
                                    <th class="padding-8 text-align-center border-bottom">
                                        Index Name
                                    </th>
                                    <th class="padding-8 text-align-center border-bottom">
                                        Bucket.Scope.Collection
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="index-count-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="grid-3-col gap-20 margin-bottom-20">
                <!-- Statement Type Pie Chart -->
                <div class="chart-card">
                    <h3 class="chart-card-header">Statement Type</h3>
                    <div class="chart-card-content">
                        <canvas id="statement-type-chart"></canvas>
                    </div>
                </div>

                <!-- Query State Pie Chart -->
                <div class="chart-card">
                    <h3 class="chart-card-header">Query State</h3>
                    <div class="chart-card-content">
                        <canvas id="state-chart"></canvas>
                    </div>
                </div>

                <!-- Scan Consistency Pie Chart -->
                <div class="chart-card">
                    <h3 class="chart-card-header">Index Scan Consistency</h3>
                    <div class="chart-card-content">
                        <canvas id="scan-consistency-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Insights Tab Content -->
        <div id="insights" data-report-section="insights">
            <div
                style="padding: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; margin-bottom: 20px;">
                <h2 style="color: #856404; margin-top: 0; font-size: 24px; font-weight: bold; text-align: center;">
                    🚧 INSIGHTS IN DEVELOPMENT 🚧
                </h2>
                <p style="color: #856404; text-align: center; margin: 0;">
                    Some insights show <span
                        style="background: #28a745; color: white; padding: 2px 6px; border-radius: 12px; font-size: 10px; font-weight: bold;">LIVE</span>
                    data, <span
                        style="background: #007bff; color: white; padding: 2px 6px; border-radius: 12px; font-size: 10px; font-weight: bold;">BETA</span>
                    insights are work in progress (might have false positives), others display placeholder content.
                </p>
            </div>

            <div style="background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">



                <!-- Indexes Category -->
                <div id="index-issues" class="insight-category">
                    <h3 class="category-title" onclick="toggleCategory('index-issues')">🔍 Index Performance Issues</h3>
                    <div class="insight-category-content" id="index-issues-content">

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('inefficient-index-scans')">Inefficient
                                Index Scans<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="inefficient-index-scans-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="inefficient-index-scans-count">0 queries</span> (<span class="highlight-number" id="inefficient-index-scans-percent">0%</span>)
                                    scan an average of <span class="highlight-number" id="avg-scan-count">0</span> index
                                    entries but returned back an avg <span class="highlight-number"
                                        id="avg-result-count">0</span> records per query or a selectivity of <span
                                        class="highlight-number" id="avg-selectivity">0%</span> (excluding aggregate
                                    functions like COUNT(), AVG(), MIN(), MAX(), and mutation statements (MERGE, DELETE, INSERT, UPDATE, UPSERT).
                                </p>

                                   <button id="toggle-sample-queries-btn" onclick="toggleSampleQueries()" class="btn-standard">
                                       <span id="sample-queries-btn-text">Show Sample Queries</span>
                                   </button>
                                   <div id="sample-queries-container" style="display: none; margin-top: 10px;">
                                       <table class="sample-queries-table">
                                           <thead>
                                               <tr>
                                                   <th>Request Date</th>
                                                   <th>Statement (unique)</th>
                                                   
                                               </tr>
                                           </thead>
                                           <tbody id="sample-queries-tbody">
                                           </tbody>
                                       </table>
                                   </div> 

                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Consider creating more selective indexes to reduce scan overhead <a
                                            href="https://cb.fuj.io/analysis_hub.html#indexes"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('slow-index-scan-times')">Slow Index Scan
                                Times<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="slow-index-scan-times-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="total-indexes-count">0</span> total indexes:
                                </p>
                                <div class="index-breakdown">
                                    <div class="index-breakdown-item">
                                        <span class="highlight-number" id="slow-indexes-2-10s">0</span> indexes with an
                                        avg scan time between 2-10 seconds
                                    </div>
                                    <div class="index-breakdown-item">
                                        <span class="highlight-number" id="slow-indexes-10s-plus">0</span> indexes with
                                        an avg scan time of 10+ seconds
                                    </div>
                                    <div class="index-breakdown-item">
                                        <span class="highlight-number" id="slow-primary-indexes">0</span> #primary
                                        indexes with an avg scan time of 2+ seconds
                                    </div>
                                    To see identified index(es) go to the "Index/Query Flow" tab.
                                </div>
                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Check kernel time on index nodes - high kernel time may indicate resource
                                        contention <a href="https://cb.fuj.io/analysis_hub.html#systemMetrics"
                                            class="insight-link">Learn more</a>
                                    </div>
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Index returning millions of records? Create more selective compound indexes <a
                                            href="https://cb.fuj.io/analysis_hub.html#indexes"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('primary-index-over-usage')">Primary Index
                                Over-Usage<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="primary-index-over-usage-content">
                                <p class="insight-description">
                                    Primary indexes on avg are scanning <span class="highlight-number"
                                        id="primary-avg-items-scanned">0</span> items with an avg scan time of <span
                                        class="highlight-number" id="primary-avg-scan-time">0ms</span>. These could
                                    benefit from secondary indexes.
                                </p>
                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Review your indexing strategy - create selective secondary indexes <a
                                            href="https://cb.fuj.io/analysis_hub.html#optimizer"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('pagination-index-overfetch')">ORDER BY / LIMIT / OFFSET Index Over-Scan<span class="beta-badge">Beta</span></h4>
                            <div class="insight-content" id="pagination-index-overfetch-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="pagination-overfetch-count">0 queries</span> (<span class="highlight-number" id="pagination-overfetch-percent">0%</span>) with `ORDER BY` + `LIMIT ` + `OFFSET ` scanned an Avg of <span id="pagination-overfetch-avg-items">0</span> items from the index(es).
                                </p>

                                <button id="toggle-pagination-index-overfetch-sample-queries-btn" onclick="toggleInsightSampleQueries('pagination-index-overfetch')" class="btn-standard">
                                    <span id="pagination-index-overfetch-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="pagination-index-overfetch-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                                
                                            </tr>
                                        </thead>
                                        <tbody id="pagination-index-overfetch-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>

                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Consider an index that satisfies the ORDER BY to only scan needed rows/items
                                        <a href="https://cb.fuj.io/analysis_hub.html#optimizer" class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Resources Category -->
                <div id="resource-issues" class="insight-category">
                    <h3 class="category-title" onclick="toggleCategory('resource-issues')">⚡ Resource Utilization Issues
                    </h3>
                    <div class="insight-category-content" id="resource-issues-content">

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('high-kernel-time-queries')">High Kernel
                                Time in Queries<span class="beta-badge">Beta</span></h4>
                            <div class="insight-content" id="high-kernel-time-queries-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="high-kernel-time-queries-count">0 queries</span> (<span class="highlight-number" id="high-kernel-time-queries-percent">0%</span>)
                                    whose average percentage of sum of their <b
                                        title="Sum of all execTime minus Stream's execTime">core execTime</b> / kernTime
                                    is <span class="highlight-number" id="avg-core-kernel-ratio">0%</span>.
                                </p>

                                <button id="toggle-high-kernel-time-queries-sample-queries-btn" onclick="toggleInsightSampleQueries('high-kernel-time-queries')" class="btn-standard">
                                    <span id="high-kernel-time-queries-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="high-kernel-time-queries-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                                
                                            </tr>
                                        </thead>
                                        <tbody id="high-kernel-time-queries-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>

                                <div class="insight-note" style="background:#f0f9ff; border-left:4px solid #3b82f6; padding:10px 12px; border-radius:6px; margin:10px 0; color:#1e3a8a;">
                                    <strong>What high kernTime means:</strong> kernTime is time spent waiting to be scheduled on CPU. If it dominates ServiceTime and/or Execution Time (e.g., ~99%), the node is CPU-bound and the query spends most of its life paused, not doing useful work. Look for high request.active.count, cpu.user.percent, or gc.pause.percent. Actions: reduce concurrency, add query nodes, or separate services.
                                </div>

                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Is the Query Service co-located with other services? <a
                                            href="https://cb.fuj.io/analysis_hub.html#kernTime"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('high-memory-usage')">High Memory Usage
                                Detected<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="high-memory-usage-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="high-memory-count">0 queries</span> (<span class="highlight-number" id="high-memory-percent">0%</span>) are using avg
                                    <span class="highlight-number" id="avg-memory-usage">0GB</span> of memory each,
                                    indicating potential memory optimization opportunities.
                                </p>

                                <button id="toggle-high-memory-usage-sample-queries-btn" onclick="toggleInsightSampleQueries('high-memory-usage')" class="btn-standard">
                                    <span id="high-memory-usage-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="high-memory-usage-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                                
                                            </tr>
                                        </thead>
                                        <tbody id="high-memory-usage-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>

                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Consider increasing query memory limits or optimizing queries <a
                                            href="https://cb.fuj.io/analysis_hub.html#usedMemory"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('slow-use-key-queries')">Slow USE KEY
                                Queries<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="slow-use-key-queries-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="slow-use-keys-count">0 USE KEY queries</span> (<span class="highlight-number" id="slow-use-keys-percent">0%</span>)
                                    with avg query time of <span class="highlight-number"
                                        id="avg-use-keys-time">0ms</span>, suggesting potential KV service bottlenecks.
                                </p>

                                <button id="toggle-slow-use-key-queries-sample-queries-btn" onclick="toggleInsightSampleQueries('slow-use-key-queries')" class="btn-standard">
                                    <span id="slow-use-key-queries-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="slow-use-key-queries-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                                
                                            </tr>
                                        </thead>
                                        <tbody id="slow-use-key-queries-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>

                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Is the Data Service and/or Query Service co-located with other services? <a
                                            href="https://cb.fuj.io/analysis_hub.html#systemMetrics"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Query Patterns Category -->
                <div id="pattern-analysis" class="insight-category">
                    <h3 class="category-title" onclick="toggleCategory('pattern-analysis')">🔄 Query Pattern Analysis
                    </h3>
                    <div class="insight-category-content" id="pattern-analysis-content">

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('missing-where-clauses')">Missing WHERE
                                Clauses<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="missing-where-clauses-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="missing-where-count">0 queries</span> (<span
                                        class="highlight-number" id="missing-where-percent">0%</span>) lack WHERE
                                    clauses, potentially scanning entire collections unnecessarily. <em>possibly a query with `USE KEYS()`</em>
                                </p>

                                <button id="toggle-missing-where-clauses-sample-queries-btn" onclick="toggleInsightSampleQueries('missing-where-clauses')" class="btn-standard">
                                    <span id="missing-where-clauses-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="missing-where-clauses-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                                
                                            </tr>
                                        </thead>
                                        <tbody id="missing-where-clauses-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('complex-join-operations')">Complex JOIN
                                Operations<span class="dev-badge">Dev</span></h4>
                            <div class="insight-content" id="complex-join-operations-content">
                                <p class="insight-description">
                                    <span class="highlight-number">0 JOIN queries</span> are taking an average of <span
                                        class="highlight-number">0 seconds</span> each, with <span
                                        class="highlight-number">0%</span> showing suboptimal join patterns.
                                </p>
                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Consider denormalizing frequently joined data <a
                                            href="https://cb.fuj.io/analysis_hub.html#bestPractices"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('inefficient-like-operations')">Inefficient
                                LIKE Operations<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="inefficient-like-operations-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="inefficient-like-count">0 queries</span> (<span class="highlight-number" id="inefficient-like-percent">0%</span>) use LIKE
                                    operations with leading wildcards (<code>%text</code>), preventing index usage and
                                    causing full scans.
                                </p>

                                <button id="toggle-inefficient-like-operations-sample-queries-btn" onclick="toggleInsightSampleQueries('inefficient-like-operations')" class="btn-standard">
                                    <span id="inefficient-like-operations-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="inefficient-like-operations-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                                
                                            </tr>
                                        </thead>
                                        <tbody id="inefficient-like-operations-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('select-star-usage')">SELECT * Usage<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="select-star-usage-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="select-star-count">0 queries</span> (<span class="highlight-number" id="select-star-percent">0%</span>) use SELECT * which returns entire documents and can increase network I/O and memory. Prefer selecting only needed fields.
                                </p>

                                <button id="toggle-select-star-usage-sample-queries-btn" onclick="toggleInsightSampleQueries('select-star-usage')" class="btn-standard">
                                    <span id="select-star-usage-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="select-star-usage-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                                
                                            </tr>
                                        </thead>
                                        <tbody id="select-star-usage-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Performance Category -->
                <div id="performance-opportunities" class="insight-category">
                    <h3 class="category-title" onclick="toggleCategory('performance-opportunities')">🚀 Performance
                        Optimization Opportunities</h3>
                    <div class="insight-category-content" id="performance-opportunities-content">

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('large-payload-streaming')">Large Payload
                                Streaming<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="large-payload-streaming-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="large-payload-count">0 queries</span> (<span class="highlight-number" id="large-payload-percent">0%</span>) with avg
                                    size: <span class="highlight-number" id="avg-payload-size">0MB</span> with <span
                                        class="highlight-number" id="avg-stream-ratio">0%</span> of the time of the
                                    query was streaming data out to the application.
                                </p>

                                <button id="toggle-large-payload-streaming-sample-queries-btn" onclick="toggleInsightSampleQueries('large-payload-streaming')" class="btn-standard">
                                    <span id="large-payload-streaming-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="large-payload-streaming-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                            </tr>
                                        </thead>
                                        <tbody id="large-payload-streaming-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>

                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Consider implementing pagination for large result sets <a
                                            href="https://cb.fuj.io/analysis_hub.html#practicalAnalysis"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('large-result-set-queries')">Large Result
                                Set Queries<span class="live-badge">Live</span></h4>
                            <div class="insight-content" id="large-result-set-queries-content">
                                <p class="insight-description">
                                    <span class="highlight-number" id="large-results-count">0 queries</span> (<span class="highlight-number" id="large-results-percent">0%</span>) return
                                    result sets with avg size of <span class="highlight-number"
                                        id="avg-large-result-size">0MB</span>, which can consume significant memory and
                                    network resources.
                                </p>

                                <button id="toggle-large-result-set-queries-sample-queries-btn" onclick="toggleInsightSampleQueries('large-result-set-queries')" class="btn-standard">
                                    <span id="large-result-set-queries-sample-queries-btn-text">Show Sample Queries</span>
                                </button>
                                <div id="large-result-set-queries-sample-queries-container" style="display: none; margin-top: 10px;">
                                    <table class="sample-queries-table">
                                        <thead>
                                            <tr>
                                                <th>Request Date</th>
                                                <th>Statement (unique)</th>
                                            </tr>
                                        </thead>
                                        <tbody id="large-result-set-queries-sample-queries-tbody">
                                        </tbody>
                                    </table>
                                </div>

                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Large result sets can impact performance and resource usage <a
                                            href="https://cb.fuj.io/analysis_hub.html#practicalAnalysis"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('timeout-prone-queries')">Timeout-Prone
                                Queries<span class="beta-badge">Beta</span></h4>
                            <div class="insight-content" id="timeout-prone-queries-content">

                            </div>
                        </div>

                        <div class="insight-item">
                            <h4 class="insight-title" onclick="toggleInsight('concurrent-query-conflicts')">Concurrent
                                Query Conflicts<span class="dev-badge">Dev</span></h4>
                            <div class="insight-content" id="concurrent-query-conflicts-content">
                                <p class="insight-description">
                                    <span class="highlight-number">0 queries</span> show evidence of resource
                                    contention, with execution times varying by more than <span
                                        class="highlight-number">0%</span> during peak hours.
                                </p>
                                <div class="learn-more-section">
                                    <div class="learn-more-item">
                                        <span class="learn-more-icon">💡</span>
                                        Review query scheduling and resource allocation <a
                                            href="https://cb.fuj.io/analysis_hub.html#elapsedTime"
                                            class="insight-link">Learn more</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Tab Content -->
        <div id="timeline" data-report-section="timeline">
            <div id="timeline-controls" class="margin-bottom-10">
                <button id="reset-zoom-btn" onclick="resetTimelineZoom()"
                    class="cursor-pointer border-none border-radius-3 btn-gray">
                    Reset Zoom
                </button>
                <div class="margin-left-20"
                    style="display: inline-block; background: #f8f9fa; padding: 6px 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                    <label style="font-weight: bold; margin-right: 8px; color: #495057;">Y-Axis Scale:</label>
                    <label><input type="radio" name="yScale" value="linear" checked onchange="changeYAxisScale()" />
                        Linear</label>
                    <label class="margin-left-10"><input type="radio" name="yScale" value="logarithmic"
                            onchange="changeYAxisScale()" />
                        Logarithmic</label>
                </div>
                <span class="margin-left-30">
                    <label style="font-weight: bold; margin-right: 8px; color: #495057;">Time Grouping:</label>
                    <select id="time-grouping-select" onchange="changeTimeGrouping()"
                        style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px;">
                        <option value="optimizer">By Optimizer (...)</option>
                        <option value="day">By Day</option>
                        <option value="hour">By Hour</option>
                        <option value="5min">By 5 Minutes</option>
                        <option value="minute">By Minute</option>
                        <option value="second">By Second</option>
                    </select>
                </span>
                <span class="color-666 font-size-12 margin-left-20">
                    Drag box to zoom area
                </span>
                <button id="use-time-range-btn" onclick="useCurrentTimeRange()"
                    class="margin-left-20 cursor-pointer border-none border-radius-3 btn-gray">
                    Use Charts Current X-Axis Date Range
                </button>
            </div>
            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="duration-buckets" data-position="timeline-1">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="duration-buckets-chart"></canvas>
                </div>
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="query-types" data-position="timeline-2">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="query-types-chart"></canvas>
                </div>
            </div>

            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="operations" data-position="timeline-3">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="operations-chart"></canvas>
                </div>
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="filter" data-position="timeline-4">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="filter-chart"></canvas>
                </div>
            </div>

            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="result-count" data-position="timeline-5">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="result-count-chart"></canvas>
                </div>
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="result-size" data-position="timeline-6">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="result-size-chart"></canvas>
                </div>
            </div>

            <div class="display-flex gap-20 margin-bottom-20">
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="timeline" data-position="timeline-7">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="timeline-chart"></canvas>
                </div>
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="memory" data-position="timeline-8">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="memory-chart"></canvas>
                </div>
            </div>

            <!-- Execution Analysis Charts - Draggable Grid -->
            <div id="charts-grid" class="display-flex gap-20 margin-bottom-20" style="flex-wrap: wrap;">
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="exec-vs-kernel" data-position="top-left">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="exec-vs-kernel-chart"></canvas>
                </div>
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="exec-vs-serv" data-position="top-right">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="exec-vs-serv-chart"></canvas>
                </div>
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="exec-vs-elapsed" data-position="bottom-left">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="exec-vs-elapsed-chart"></canvas>
                </div>
                <div class="flex-1-height-400 chart-container draggable-chart" data-chart-id="cpu-time" data-position="bottom-right">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="cpu-time-chart"></canvas>
                </div>
            </div>

            <!-- Enhanced Operations Chart - Full Width -->
            <div class="display-flex gap-20 margin-bottom-20">
                <div style="width: 100%; height: 400px;" class="chart-container draggable-chart" data-chart-id="enhanced-operations" data-position="bottom-full">
                    <div class="chart-drag-handle" title="Drag to reposition">⋮⋮</div>
                    <canvas id="enhanced-operations-chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Analysis Tab Content -->
        <div id="analysis" data-report-section="analysis">
            <!--
        <div id="charts-placeholder">
          *Future charts and visualizations will be displayed here.
          <canvas id="analysis-chart" width="10" height="10"></canvas>
        </div>
      -->
            <!-- Query Group Phase Times Chart -->
            <div id="analysis-phase-times-section" class="margin-bottom-20">
                <div class="chart-container" style="height:340px;">
                    <div style="height: auto;">
                        <div id="query-group-phase-times-note" style="font-size: 12px; color: #495057; font-weight: 600; margin-bottom: 6px;"></div>
                        <canvas id="query-group-phase-times-chart" style="width:100%;height:900px;"></canvas>
                    </div>
                </div>
            </div>

            <div id="analysis-table-section">
                <!-- Search Controls for Analysis Table -->
                <div id="analysis-search-controls"
                    class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                    <div class="gap-15 display-flex-center display-flex-wrap">
                        <div>
                            <label for="analysis-statement-search" class="font-bold-margin-right">Search
                                Statement:</label>
                            <input type="text" id="analysis-statement-search"
                                placeholder="Search in SQL++ statements..." class="form-input" />
                        </div>
                        <div>
                            <label for="analysis-username-search" class="font-bold-margin-right">Search
                                Username:</label>
                            <input type="text" id="analysis-username-search" placeholder="Search usernames..."
                                class="form-input-small" />
                        </div>
                        <button id="analysis-clear-search" class="cursor-pointer border-none border-radius-3 btn-gray">
                            Clear All
                        </button>
                        <div id="analysis-search-results-info" class="color-666 font-bold"></div>
                    </div>
                </div>
                <div id="analysis-table-container">
                    <table id="analysis-table">
                        <thead id="analysis-table-header"></thead>
                        <tbody id="analysis-table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Every Query Tab Content -->
        <div id="every-query" data-report-section="every-query">
            <div id="flow-diagram-section">
                <div id="flow-diagram"></div>
            </div>
            <div id="table-section">
                <!-- Search Controls -->
                <div id="search-controls"
                    class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                    <div class="gap-15 display-flex-center display-flex-wrap">
                        <div>
                            <label for="statement-search" class="font-bold-margin-right">Search Statement:</label>
                            <input type="text" id="statement-search" placeholder="Search in SQL++ statements..."
                                class="form-input" />
                        </div>
                        <div>
                            <label for="username-search" class="font-bold-margin-right">Search Username:</label>
                            <input type="text" id="username-search" placeholder="Search usernames..."
                                class="form-input-small" />
                        </div>
                        <button id="clear-search" class="cursor-pointer border-none border-radius-3 btn-gray">
                            Clear All
                        </button>
                        <div id="search-results-info" class="color-666 font-bold"></div>
                    </div>
                </div>
                <div id="table-container">
                    <table id="query-table">
                        <thead id="table-header"></thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Index/Query Flow Tab Content -->
        <div id="index-query-flow" data-report-section="index-query-flow">
            <div class="height-100 position-relative background-f8 border-radius-8 overflow-hidden">
                <!-- Summary counts above the flow chart -->
                <div id="flow-summary"
                    class="position-relative z-index-3 background-white padding-10-20 border-bottom display-flex justify-space-between align-center">
                    <div class="font-bold color-333">
                        Indexes Used: <span id="index-count">0</span>
                    </div>
                    <div class="font-bold color-333">
                        Queries Executed: <span id="query-count">0</span>
                    </div>
                </div>
                <div id="flow-canvas" class="width-100 calc-height-minus-50 position-relative overflow-auto">
                    <svg id="flow-svg"
                        class="width-100 height-100 position-absolute top-0 left-0 pointer-events-none z-index-1"></svg>
                    <div id="flow-elements" class="position-relative z-index-2 padding-20"></div>
                </div>
            </div>
        </div>

        <!-- Indexes Tab Content -->
        <div id="indexes" data-report-section="indexes">
            <!-- Filter Controls -->
            <div class="margin-bottom-20 padding-15 background-f8 border-radius-6">
                <!-- First row: Search, Bucket, Scope, Collection, Sort -->
                <div class="gap-15 margin-bottom-15" style="display: grid; grid-template-columns: repeat(5, 1fr)">
                    <div>
                        <label for="indexSearch" class="margin-bottom-5 font-bold-block">Search:</label>
                        <input type="text" id="indexSearch" placeholder="Search indexes..."
                            class="width-90 padding-8 border-radius-4 font-size-14" style="border: 1px solid #ccc" />
                    </div>
                    <div>
                        <label for="bucketFilter" class="margin-bottom-5 font-bold-block">Bucket:</label>
                        <select id="bucketFilter" class="width-100 padding-8 border-radius-4"
                            style="border: 1px solid #ccc">
                            <option value="(ALL)">(ALL)</option>
                        </select>
                    </div>
                    <div>
                        <label for="scopeFilter" class="margin-bottom-5 font-bold-block">Scope:</label>
                        <select id="scopeFilter" class="width-100 padding-8 border-radius-4"
                            style="border: 1px solid #ccc">
                            <option value="(ALL)">(ALL)</option>
                        </select>
                    </div>
                    <div>
                        <label for="collectionFilter" class="margin-bottom-5 font-bold-block">Collection:</label>
                        <select id="collectionFilter" class="width-100 padding-8 border-radius-4"
                            style="border: 1px solid #ccc">
                            <option value="(ALL)">(ALL)</option>
                        </select>
                    </div>
                    <div>
                        <label for="sortBy" class="margin-bottom-5 font-bold-block">Sort By:</label>
                        <select id="sortBy" class="width-100 padding-8 border-radius-4" style="border: 1px solid #ccc">
                            <option value="Name">Name</option>
                            <option value="Bucket">Bucket</option>
                            <option value="LastScanned">Last Scanned</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Stats Panel -->
            <div id="indexStats" style="
            margin-bottom: 15px;
            padding: 12px;
            background: #e7f3ff;
            border: 1px solid #b3d7ff;
            border-radius: 6px;
            font-size: 13px;
          ">
                <div style="
              display: grid;
              grid-template-columns: repeat(4, 1fr);
              gap: 15px;
            ">
                    <div>
                        <strong>Total Indexes:</strong> <span id="stat-indexes">0</span>
                    </div>
                    <div>
                        <strong>Buckets:</strong> <span id="stat-buckets">0</span>
                    </div>
                    <div><strong>Scopes:</strong> <span id="stat-scopes">0</span></div>
                    <div>
                        <strong>Collections:</strong> <span id="stat-collections">0</span>
                    </div>
                </div>
                <div style="
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
                margin-top: 8px;
                ">
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Primary Indexes:</strong>
                            <span id="stat-primary">0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-primary" style="margin: 0" />
                            Primary Only
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Used/Total Indexes:</strong>
                            <span id="stat-used-total">0/0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-used" style="margin: 0" />
                            Used Only
                        </label>
                    </div>
                    </div>
                    <div style="
                    display: grid;
                    grid-template-columns: repeat(3, 1fr);
                    gap: 15px;
                    margin-top: 8px;
                    ">
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Without/With Replica:</strong>
                            <span id="stat-replica-info">0/0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-no-replica" style="margin: 0" />
                            No Replicas Only
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Index Type:</strong></span>
                        <label style="display:flex; align-items:center; gap:4px; font-size:11px;">
                            <input type="radio" name="indexTypeFilter" value="all" id="filter-type-all" checked style="margin:0" />
                            All Indexes
                        </label>
                        <label style="display:flex; align-items:center; gap:4px; font-size:11px;">
                            <input type="radio" name="indexTypeFilter" value="gsi" id="filter-type-gsi" style="margin:0" />
                            GSI Only
                        </label>
                        <label style="display:flex; align-items:center; gap:4px; font-size:11px;">
                            <input type="radio" name="indexTypeFilter" value="fts" id="filter-type-fts" style="margin:0" />
                            FTS Only
                        </label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Never Scanned Indexes:</strong>
                            <span id="stat-never-scanned">0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-never-scanned" style="margin: 0" />
                            Never Scanned Only
                        </label>
                    </div>
                </div>
                <div style="
              display: grid;
              grid-template-columns: repeat(2, 1fr);
              gap: 15px;
              margin-top: 8px;
            ">
                    <div style="display: flex; align-items: center; gap: 8px">
                        <span><strong>Sync Gateway Indexes:</strong>
                            <span id="stat-mobile-indexes">0</span></span>
                        <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 11px;
                ">
                            <input type="checkbox" id="filter-exclude-mobile" style="margin: 0" />
                            Exclude Mobile Indexes
                        </label>
                    </div>
                    <div></div>
                </div>
            </div>

            <!-- Results Panel -->
            <div id="indexResults" class="background-white padding-15" style="
            overflow-y: auto;
            height: calc(100% - 120px);
            border: 1px solid #ccc;
            border-radius: 4px;
          ">
                <div class="text-align-center" style="margin-top: 30px">
                    <h4 style="color: #495057; margin-bottom: 20px">
                        No Index Data Loaded
                    </h4>
                    <p class="color-666" style="margin-bottom: 20px">
                        To analyze indexes, run this query in your Couchbase Query
                        Workbench and paste the results in the second textarea above:
                    </p>
                    <div class="sql-query-box">
                        <button class="btn-standard sql-copy-btn" onclick="copyIndexQuery(event)">
                            Copy Query
                        </button>
                        <pre>
                          SELECT 
                            s.name,
                            s.id,
                            s.metadata,
                            s.state,
                            s.num_replica,
                            s.`using` AS indexType,
                            CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
                            FROM system:indexes AS s
                            LET bid = CONCAT("", s.bucket_id, ""),
                                sid = CONCAT("", s.scope_id, ""),
                                kid = CONCAT("", s.keyspace_id, ""),
                                k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
                                ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
                                w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
                                p = CASE WHEN s.`partition` IS NOT NULL THEN " PARTITION BY " || s.`partition` ELSE "" END;
                      </pre>
                    </div>
                    <p style="color: #666; font-size: 13px; margin-top: 15px">
                        <strong>Steps:</strong><br />
                        1. Copy the query above<br />
                        2. Run it in Couchbase Query Workbench<br />
                        3. Copy the JSON results<br />
                        4. Paste into the second textarea ,on the right, at the top<br />
                        5. Click "Parse JSON" again
                    </p>
                </div>
            </div>
        </div>
    <!-- Whole Record Tab Content -->
        <div id="whole-record" data-report-section="whole-record" style="padding: 15px;">
            <div class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                <label for="whole-record-request-id-input" class="font-bold-margin-right" style="margin-right:8px;">Request ID</label>
                <input type="text" id="whole-record-request-id-input" placeholder="" class="form-input" style="width:320px;" />
                <button id="whole-record-load-btn" class="btn-standard" onclick="loadWholeRecordFromInput()">Load</button>
                <span class="color-666 font-size-12 margin-left-10">Tip: To get a requestId, go to the "Every Query" tab and look at the far-right column. Copy the requestId and paste it here. You can also open with #requestId=... in the URL.</span>
            </div>
            <div class="background-white padding-15 border-1-ddd" style="min-height:200px; overflow-x:auto; overflow-y:auto;">
                <pre id="whole-record-json" style="white-space: pre-wrap; word-break: break-word; margin:0; overflow-x:auto; overflow-y:auto;"></pre>
            </div>
        </div>

        <!-- Report Maker Tab Content -->
       <div id="report-maker" data-report-section="report-maker" style="padding: 15px;">
            <!-- Report Maker banner at top of tab -->
            <div style="padding: 16px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; margin: 0 0 14px;">
                <h3 style="color: #856404; margin: 0 0 6px 0; font-size: 18px; font-weight: bold; text-align: center;">🚧 REPORT MAKER IN DEVELOPMENT 🚧</h3>
                <p style="color: #856404; text-align: center; margin: 0; font-size: 13px;">
                    Some insights show <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 12px; font-size: 10px; font-weight: bold;">LIVE</span>
                    data, <span style="background: #007bff; color: white; padding: 2px 6px; border-radius: 12px; font-size: 10px; font-weight: bold;">BETA</span>
                    insights are work in progress (might have false positives), others display placeholder content.
                </p>
            </div>
            <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin-bottom: 12px;">
                <button id="btn-preview-report" class="btn-standard" style="background:#0d6efd;color:#fff"></button>
                <button id="btn-print-report" class="btn-standard"></button>
                <button id="btn-exit-report" class="btn-standard"></button>
            </div>
            <div class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                <h3 id="rm-select-sections-title" style="margin:0 0 8px 0;"></h3>
                <div id="report-sections" style="display:flex; gap: 16px; flex-wrap: wrap;">
                    <label><input type="checkbox" data-section="dashboard" checked> Dashboard</label>
                    <label><input type="checkbox" data-section="insights" checked> Insights</label>
                    <label><input type="checkbox" data-section="timeline" checked> Timeline</label>
                    <label><input type="checkbox" data-section="analysis" checked> Query Groups</label>
                    <label><input type="checkbox" data-section="every-query"> Every Query</label>
                    <label><input type="checkbox" data-section="index-query-flow"> Index/Query Flow</label>
                    <label><input type="checkbox" data-section="indexes"> Indexes</label>
                </div>
            </div>
            <div class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                <h3 id="rm-select-timeline-title" style="margin:0 0 8px 0;"></h3>
                <div id="report-timeline-charts" style="display:flex; gap: 16px; flex-wrap: wrap;"></div>
            </div>
            <div class="background-f5 padding-15 margin-bottom-10 border-radius-5 border-1-ddd">
                <h3 id="rm-options-title" style="margin:0 0 8px 0;"></h3>
                <label style="margin-right:16px;"><input type="checkbox" id="opt-include-header" checked> <span id="rm-opt-include-header"></span></label>
                <label style="margin-right:16px;"><input type="checkbox" id="opt-include-filters" checked> <span id="rm-opt-include-filters"></span></label>
                <label style="margin-right:16px;"><input type="checkbox" id="opt-flatten-tables" checked> <span id="rm-opt-flatten-tables"></span></label>
                <label style="margin-right:16px;"><input type="checkbox" id="opt-charts-as-images" checked> <span id="rm-opt-charts-as-images"></span></label>
            </div>
            <div class="report-tip" style="margin-top:8px; margin-bottom:12px;">
                <div class="tip-text" style="font-size:16px; font-weight:700; color:#343a40;">Pro Tip: Use SQL++ query segment filter ,above, to show case a spacifc query and/or date range first, then preview and print.</div>
                <img src="https://cb.fuj.io/img/sql_string_filter_and_exclude_system_example.png" alt="Report Maker filters and exclude system example" style="margin-top:8px; max-width:100%; height:auto; border:1px solid #dee2e6; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.06);" loading="lazy">
            </div>
        </div>
    </div>
     <!-- Modals (outside tabs) -->
    <div id="plan-modal" class="modal">
        <div class="modal-content">
            <span class="close">×</span>
            <div id="plan-modal-body"></div>
        </div>
    </div>
    <div id="operator-modal" class="modal">
        <div class="modal-content">
            <span class="close">×</span>
            <div id="operator-modal-body"></div>
        </div>
    </div>

    <script>
        // Disable Chart.js animations globally for better performance
        Chart.defaults.animation = false;
        Chart.defaults.animations = false;
        Chart.defaults.responsive = true;
        Chart.defaults.maintainAspectRatio = false;

        // Register the zoom plugin
        try {
            if (window.ChartZoom) {
                Chart.register(window.ChartZoom);
            } else if (window.chartjsPluginZoom) {
                Chart.register(window.chartjsPluginZoom);
            } else if (window.zoomPlugin) {
                Chart.register(window.zoomPlugin);
            }
        } catch (error) {
            // Silent fallback
        }

        // Global variables for time range tracking
        let originalTimeRange = { min: null, max: null };
        let currentTimeRange = { min: null, max: null };
        let isZoomSyncing = false;

        // Sync zoom across all timeline charts
        function syncChartZoom(sourceChart, xMin, xMax) {
            if (isZoomSyncing) return;
            isZoomSyncing = true;

            const charts = [
                window.operationsChart,
                window.filterChart,
                window.timelineChart,
                window.queryTypesChart,
                window.durationBucketsChart,
                window.memoryChart,
                window.resultCountChart,
                window.resultSizeChart,
                window.cpuTimeChart,
                window.execVsKernelChart,
                window.execVsServChart,
                window.execVsElapsedChart,
                window.enhancedOperationsChart,
            ];

            charts.forEach((chart) => {
                if (chart && chart !== sourceChart) {
                    chart.zoomScale("x", { min: xMin, max: xMax }, "none");
                }
            });

            setTimeout(() => {
                isZoomSyncing = false;
            }, 100);
        }

        // Toast notification system


        // Enhanced clipboard copy function


        // Keyboard navigation enhancement
        function enhanceKeyboardNavigation() {
            // Add keyboard support for tab elements
            document.addEventListener("keydown", function (e) {
                if (e.key === "Enter" || e.key === " ") {
                    const target = e.target;
                    if (
                        target.matches('a[href^="#"]') ||
                        target.matches(".step-bubble")
                    ) {
                        e.preventDefault();
                        target.click();
                    }
                }
            });
        }

        // Chart optimization utilities




        // Memory cleanup for charts
        function destroyAllCharts() {
            const chartNames = [
                "operationsChart",
                "filterChart",
                "timelineChart",
                "queryTypesChart",
                "durationBucketsChart",
                "memoryChart",
                "resultCountChart",
                "resultSizeChart",
                "primaryScanChart",
                "stateChart",
                "statementTypeChart",
                "elapsedTimeChart",
                "queryPatternChart",
                "cpuTimeChart",
                "execVsKernelChart",
                "execVsServChart",
                "execVsElapsedChart",
                "enhancedOperationsChart",
            ];

            chartNames.forEach((chartName) => {
                if (window[chartName]) {
                    // Remove event listeners if they exist
                    if (window[chartName]._crosshairHandlers && window[chartName].canvas) {
                        const canvas = window[chartName].canvas;
                        const handlers = window[chartName]._crosshairHandlers;
                        canvas.removeEventListener('mousemove', handlers.mousemove);
                        canvas.removeEventListener('mouseleave', handlers.mouseleave);
                    }

                    window[chartName].destroy();
                    window[chartName] = null;
                }
            });

            // Clear timeline charts array
            timelineCharts.length = 0;
        }

        // Global system query filtering
        function shouldExcludeSystemQuery(request) {
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            const isChecked = excludeCheckbox ? excludeCheckbox.checked : false;

            // If checkbox doesn't exist or is unchecked, don't exclude anything
            if (!excludeCheckbox || !excludeCheckbox.checked) {
                return false;
            }

            const stmt = request.statement || request.preparedText;
            if (!stmt) {
                return false;
            }

            const upperStmt = stmt.toUpperCase();

            // Apply same filtering logic as Query Groups tab
            // Get derived statement type and normalize underscores to spaces
            const statementType = request.statementType || deriveStatementType(request.statement || request.preparedText) || "";
            const normalizedType = statementType.replace(/_/g, " ").toUpperCase();

            // Define system query patterns (both with and without underscores)
            const systemPatterns = [
                "INFER", "ADVISE", "CREATE", "ALTER", "DROP", "BUILD", "EXPLAIN"
            ];

            const shouldExclude =
                upperStmt.startsWith("INFER ") ||
                upperStmt.startsWith("ADVISE ") ||
                upperStmt.startsWith("CREATE ") ||
                upperStmt.startsWith("ALTER ") ||
                upperStmt.startsWith("DROP ") ||
                upperStmt.startsWith("BUILD ") ||
                upperStmt.startsWith("EXPLAIN ") ||
                upperStmt.includes(" SYSTEM:") ||
                // Check normalized statement type for any system operation with underscores
                systemPatterns.some(pattern => normalizedType.startsWith(pattern + " "));

            return shouldExclude;
        }

        // Filter requests based on system query exclusion setting and SQL statement filter
        function filterSystemQueries(requests) {
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            const isExcluding = excludeCheckbox && excludeCheckbox.checked;

            // Get SQL statement filter
            const sqlFilter = document.getElementById("sql-statement-filter");
            const sqlFilterText = sqlFilter ? sqlFilter.value.trim().toLowerCase() : "";

            // Get elapsed time filter predicate (if any)
            const elapsedFilterInput = document.getElementById("elapsed-time-filter");
            const elapsedFilterText = elapsedFilterInput ? elapsedFilterInput.value.trim() : "";
            const elapsedPredicate = makeElapsedFilterPredicate(elapsedFilterText);

            const filtered = requests.filter((request) => {
                // Apply system query exclusion first
                if (isExcluding && shouldExcludeSystemQuery(request)) {
                    return false;
                }

                // Apply SQL statement filtering only if filter text is not empty
                if (sqlFilterText && sqlFilterText.length > 0) {
                    const statement = (request.statement || request.preparedText || "").toLowerCase().replace(/\s+/g, ' ').trim();
                    const filterText = sqlFilterText.replace(/\s+/g, ' ').trim();
                    if (!statement.includes(filterText)) {
                        return false;
                    }
                }

                // Apply elapsedTime filter if provided
                if (elapsedPredicate) {
                    const ms = parseTime(request.elapsedTime || "");
                    if (!elapsedPredicate(ms)) {
                        return false;
                    }
                }

                return true;
            });


            return filtered;
        }

        // Parse time strings to milliseconds (with caching)
        // HTML escape utility function
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Strip presentational tags that sometimes appear around preparedText
        function stripEmTags(text) {
            if (text == null) return "";
            return String(text)
                .replace(/<\/?em>/gi, "")
                .replace(/<\/?ud>/gi, "");
        }

        // Detect if this request executed a prepared statement
        function isPreparedExecution(request) {
            if (!request) return false;
            const hasPrepared = typeof request.preparedText === 'string' && request.preparedText.trim().length > 0;
            const type = (request.statementType || '').toUpperCase();
            const stmt = (request.statement || '').toUpperCase().trim();
            const hasExecute = type === 'EXECUTE' || stmt.startsWith('EXECUTE ');
            return hasPrepared && hasExecute;
        }

        // Get a cleaned prepared text sample when applicable
        function getPreparedSample(request) {
            if (!isPreparedExecution(request)) return "";
            const txt = stripEmTags(request.preparedText || "");
            return txt.trim();
        }

        function parseTime(timeStr) {
            if (!timeStr) {
                return 0;
            }

            // Handle empty or invalid strings
            timeStr = timeStr.trim();
            if (!timeStr) {
                return 0;
            }

            // Check cache first
            if (parseTimeCache.has(timeStr)) {
                return parseTimeCache.get(timeStr);
            }

            // Try different regex patterns for different time formats

            // Pattern 1: Handle ms, ns, µs, us formats like "681.413039ms", "250ns", "146.266µs"
            const simplePattern = /^(\d+\.?\d*)(ms|ns|µs|us)$/;
            let simpleMatch = timeStr.match(simplePattern);

            if (simpleMatch) {
                const value = parseFloat(simpleMatch[1]);
                const unit = simpleMatch[2];

                let totalMs = 0;
                if (unit === "ms") {
                    totalMs = value;
                } else if (unit === "ns") {
                    totalMs = value / 1000000; // nanoseconds to milliseconds
                } else if (unit === "µs" || unit === "us") {
                    totalMs = value / 1000; // microseconds to milliseconds
                }

                return totalMs;
            }

            // Pattern 2: Handle complex formats like "1h4m17.8098098s" or "4m17.8098098s" or "1h"
            const complexPattern = /(?:(\d+)h)?(?:(\d+)m)?(?:(\d+\.?\d*)s)?/;
            const complexMatch = timeStr.match(complexPattern);

            if (
                !complexMatch ||
                (complexMatch[1] === undefined &&
                    complexMatch[2] === undefined &&
                    complexMatch[3] === undefined)
            ) {
                return 0;
            }

            let totalMs = 0;
            const hours = parseInt(complexMatch[1] || 0); // Hours (optional)
            const minutes = parseInt(complexMatch[2] || 0); // Minutes (optional)
            const seconds = parseFloat(complexMatch[3] || 0); // Seconds (optional, including decimals)

            // Convert to milliseconds
            totalMs += hours * 60 * 60 * 1000; // Hours to milliseconds
            totalMs += minutes * 60 * 1000; // Minutes to milliseconds
            totalMs += seconds * 1000; // Seconds to milliseconds

            // Cache the result before returning
            parseTimeCache.set(timeStr, totalMs);
            return totalMs;
        }

        // Format time in standardized mm:ss.sss format
        function formatTime(milliseconds) {
            if (!milliseconds || isNaN(milliseconds) || milliseconds <= 0) {
                return "00:00.000";
            }

            // Handle very small values (less than 1ms) by rounding to nearest millisecond
            // but ensuring they show as at least 0.001 if they're greater than 0
            if (milliseconds < 1) {
                milliseconds = Math.max(0.001, Math.round(milliseconds * 1000) / 1000);
            }

            const totalSeconds = Math.floor(milliseconds / 1000);
            const remainingMs = milliseconds % 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;

            // Format with leading zeros
            const formattedMinutes = minutes.toString().padStart(2, "0");
            const formattedSeconds = seconds.toString().padStart(2, "0");

            // Format milliseconds as 3-digit integer (rounded)
            formattedMs = Math.round(remainingMs).toString().padStart(3, "0");

            return `${formattedMinutes}:${formattedSeconds}.${formattedMs}`;
        }

        // Format original time value for tooltip display
        function formatTimeTooltip(timeStr, milliseconds) {
            if (!timeStr || timeStr === "N/A") {
                return "";
            }

            // If it's a very small value, show the original string for precision
            if (milliseconds < 1) {
                return `Original: ${timeStr}`;
            }

            // For larger values, show both formatted time and original
            const formatted = formatTime(milliseconds);
            if (timeStr !== formatted) {
                return `Original: ${timeStr}`;
            }

            return "";
        }



        // Cache for normalized statements with size limit
        const normalizeCache = new Map();
        const MAX_CACHE_SIZE = 5000;

        // Normalize statement by replacing literals and numbers with "?" (with improved caching)
        function normalizeStatement(statement) {
            if (!statement) return "";

            // Check both caches (legacy and new)
            if (normalizeCache.has(statement)) {
                return normalizeCache.get(statement);
            }
            if (normalizeStatementCache.has(statement)) {
                return normalizeStatementCache.get(statement);
            }

            let normalized = statement
                .replace(/"(?:[^"\\]|\\.)*"/g, "?")
                .replace(/'(?:[^'\\]|\\.)*'/g, "?")
                .replace(/\b\d+\.?\d*\b/g, "?");

            // Cache the result with size management
            if (normalizeCache.size >= MAX_CACHE_SIZE) {
                // Remove oldest entries (LRU-like behavior)
                const firstKey = normalizeCache.keys().next().value;
                normalizeCache.delete(firstKey);
            }
            normalizeCache.set(statement, normalized);

            // Also cache in the new cache
            normalizeStatementCache.set(statement, normalized);

            return normalized;
        }

        // Check if a query statement has filtering mechanism (WHERE clause or USE KEYS)
        function hasFilteringMechanism(statement) {
            if (!statement) return false;
            const upperStatement = statement.toUpperCase();
            // Check for WHERE clause or USE KEYS using word boundaries for precise matching
            return /\bWHERE\b/.test(upperStatement) || /\bUSE\s+KEYS\b/.test(upperStatement);
        }

        // Get color class based on percentage
        function getColorClass(percentage) {
            if (percentage === "N/A" || isNaN(percentage)) return "green";
            if (percentage < 25) return "green";
            if (percentage < 50) return "yellow";
            if (percentage < 75) return "orange";
            return "red";
        }

        // Get percentage-based background color for bubble
        function getPercentageColor(percentage) {
            if (percentage === "N/A" || isNaN(percentage)) {
                return { bg: "#d4edda", border: "#28a745" }; // Light green
            }

            const percent = parseFloat(percentage);

            if (percent <= 33) {
                // 0-33%: Light to darker green
                const intensity = Math.min(percent / 33, 1);
                // Start with very light green and go to medium green
                const red = Math.floor(212 - (84 * intensity)); // 212 to 128
                const green = Math.floor(237 - (18 * intensity)); // 237 to 219  
                const blue = Math.floor(218 - (90 * intensity)); // 218 to 128
                return {
                    bg: `rgb(${red}, ${green}, ${blue})`,
                    border: "#28a745"
                };
            } else if (percent <= 90) {
                // 33-90%: Light orange to hard orange
                const intensity = (percent - 33) / 57; // 0 to 1
                const red = Math.floor(255);
                const green = Math.floor(193 - (67 * intensity)); // 193 to 126
                const blue = Math.floor(7 + (93 * intensity)); // 7 to 100, then back to 7
                return {
                    bg: `rgb(${red}, ${green}, 7)`,
                    border: "#fd7e14"
                };
            } else {
                // 90-100%: Light red to darker red (less bright for readability)
                const intensity = (percent - 90) / 10; // 0 to 1
                const red = Math.floor(220 - (20 * intensity)); // 220 to 200 (less bright)
                const green = Math.floor(180 - (120 * intensity)); // 180 to 60
                const blue = Math.floor(180 - (120 * intensity)); // 180 to 60
                return {
                    bg: `rgb(${red}, ${green}, ${blue})`,
                    border: "#dc3545"
                };
            }
        }

        // Caches for performance optimization to avoid reprocessing
        const operatorsCache = new WeakMap();
        const parseTimeCache = new Map();
        const normalizeStatementCache = new Map();
        const planStatsCache = new WeakMap();
        const timeUnitCache = new WeakMap(); // Cache optimal time units per request array
        const timestampRoundingCache = new Map(); // Cache rounded timestamps

        // Clear caches to prevent memory leaks and stale data between parses
        function clearCaches() {
            parseTimeCache.clear();
            normalizeStatementCache.clear();
            timestampRoundingCache.clear(); // Critical for Timeline tab performance
            // WeakMaps (operatorsCache, planStatsCache, timeUnitCache) clean themselves automatically
            console.log(TEXT_CONSTANTS.ALL_CACHES_CLEARED);
        }

        // Performance benchmarking helper
        function logCacheStats() {
            console.log(`${TEXT_CONSTANTS.CACHE_STATS} ${parseTimeCache.size}, normalizeStatement: ${normalizeStatementCache.size}, timestampRounding: ${timestampRoundingCache.size}`);
        }

        // Recursively extract operators from the plan
        function getOperators(
            operator,
            operators = [],
            visited = new WeakSet(),
            depth = 0
        ) {
            if (!operator) return operators;

            // Check cache first for the root operator
            if (depth === 0 && operatorsCache.has(operator)) {
                return operatorsCache.get(operator);
            }

            // Prevent infinite recursion by tracking visited objects
            if (visited.has(operator)) {
                return operators;
            }
            visited.add(operator);

            // Add depth limit as additional safety
            if (depth > 50) {
                return operators;
            }

            if (operator["#operator"]) {
                operators.push(operator);
            }
            if (operator["~child"]) {
                getOperators(operator["~child"], operators, visited, depth + 1);
            } else if (operator["~children"]) {
                operator["~children"].forEach((child, i) => {
                    getOperators(child, operators, visited, depth + 1);
                });
            }
            // Check for input/inputs
            if (operator.input) {
                getOperators(operator.input, operators, visited, depth + 1);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input, i) => {
                    getOperators(input, operators, visited, depth + 1);
                });
            }
            // Check for left/right (binary operations)
            if (operator.left) {
                getOperators(operator.left, operators, visited, depth + 1);
            }
            if (operator.right) {
                getOperators(operator.right, operators, visited, depth + 1);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                getOperators(operator.first, operators, visited, depth + 1);
            }
            if (operator.second) {
                getOperators(operator.second, operators, visited, depth + 1);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan, i) => {
                    getOperators(scan, operators, visited, depth + 1);
                });
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                getOperators(operator.scan, operators, visited, depth + 1);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery, i) => {
                    if (subquery.executionTimings) {
                        getOperators(
                            subquery.executionTimings,
                            operators,
                            visited,
                            depth + 1
                        );
                    }
                });
            }

            // Cache the result for root operator
            if (depth === 0) {
                operatorsCache.set(operator, operators);
            }

            return operators;
        }

        // Calculate the maximum of all kernTimes (optimized with cache)
        function calculateTotalKernTime(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).maxKernTime;
            }

            // Fallback to original calculation if not cached
            const operators = getOperators(plan);
            let maxKernTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const kernTime = parseTime(stats.kernTime);
                if (!isNaN(kernTime)) {
                    maxKernTime = Math.max(maxKernTime, kernTime);
                }
            });
            return maxKernTime;
        }



        // Calculate the total memory usage from all operators in the plan (optimized with cache)
        function calculateTotalMemoryUsage(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).totalMemoryUsage;
            }

            // Fallback to original calculation
            const operators = getOperators(plan);
            let totalMemory = 0;

            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const usedMemory = stats.usedMemory || 0;
                if (!isNaN(usedMemory)) {
                    totalMemory += usedMemory;
                }
            });
            return totalMemory;
        }

        // Calculate the sum of all execution times for percentage calculation (optimized with cache)
        function calculateTotalExecTime(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).totalExecTime;
            }

            // Fallback to original calculation if not cached
            const operators = getOperators(plan);
            let totalExecTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const execTime = parseTime(stats.execTime);
                if (!isNaN(execTime)) {
                    totalExecTime += execTime;
                }
            });
            return totalExecTime;
        }

        // Calculate the sum of all service times from all operators in the plan (optimized with cache)
        function calculateTotalServiceTime(plan) {
            // Try to get from cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).totalServiceTime;
            }

            // Fallback to original calculation if not cached
            const operators = getOperators(plan);
            let totalServiceTime = 0;
            operators.forEach((operator, index) => {
                const stats = operator["#stats"] || {};
                const servTime = parseTime(stats.servTime);
                if (!isNaN(servTime)) {
                    totalServiceTime += servTime;
                }
            });
            return totalServiceTime;
        }

        // Build operator stats for modal
        function buildOperatorStats(operator) {
            const operatorType = operator["#operator"] || TEXT_CONSTANTS.UNKNOWN;
            let html = `<h3>${TEXT_CONSTANTS.OPERATOR_LABEL} ${operatorType}</h3>`;

            // Add copy button
            html += `<button class="btn-standard" onclick="copyOperatorStats(this)">${TEXT_CONSTANTS.COPY_STATS}</button>`;

            // Show index name for specific operators
            if (
                (operatorType === "PrimaryScan3" ||
                    operatorType === "IndexFtsSearch" ||
                    operatorType === "IndexScan3") &&
                operator.index
            ) {
                html += `<p><strong>${TEXT_CONSTANTS.INDEX_USED} ${operator.index}</strong></p>`;
            }

            if (operator["#stats"]) {
                html += "<dl>";
                for (const [key, value] of Object.entries(operator["#stats"])) {
                    let formattedValue = value;
                    // Format time fields with tooltips
                    if (
                        key === "execTime" ||
                        key === "kernTime" ||
                        key === "servTime"
                    ) {
                        const timeMs = parseTime(value);
                        if (timeMs > 0) {
                            const tooltip = formatTimeTooltip(value, timeMs);
                            formattedValue = tooltip ?
                                `<span title="${tooltip}">${formatTime(timeMs)}</span>` :
                                formatTime(timeMs);
                        }
                    }
                    html += `<dt>${key}</dt><dd>${formattedValue}</dd>`;
                }
                html += "</dl>";
            } else {
                html += "<p>No stats available.</p>";
            }
            return html;
        }

        // Function to copy operator stats to clipboard
        function copyOperatorStats(button) {
            const modalBody = document.getElementById("operator-modal-body");
            const text = modalBody.innerText || modalBody.textContent;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard
                    .writeText(text)
                    .then(() => {
                        button.textContent = TEXT_CONSTANTS.COPIED;
                        setTimeout(() => {
                            button.textContent = TEXT_CONSTANTS.COPY_STATS;
                        }, 2000);
                    })
                    .catch((err) => {
                        console.error("Failed to copy: ", err);
                        fallbackCopyTextToClipboard(text, button);
                    });
            } else {
                fallbackCopyTextToClipboard(text, button);
            }
        }

        // Fallback copy function for older browsers
        function fallbackCopyTextToClipboard(text, button) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.top = "-1000px";
            textArea.style.left = "-1000px";
            textArea.setAttribute("aria-hidden", "true");
            textArea.setAttribute("tabindex", "-1");

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand("copy");
                if (successful) {
                    showToast(TEXT_CONSTANTS.COPIED_CLIPBOARD);
                } else {
                    showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                }
            } catch (err) {
                console.error("Fallback: Oops, unable to copy", err);
                showToast("Failed to copy to clipboard", "error");
            }

            document.body.removeChild(textArea);
        }

        // Generate flow diagram
        function generateFlowDiagram(request) {
            const flowDiagram = document.getElementById("flow-diagram");
            flowDiagram.innerHTML = "";
            if (!request || !request.plan) {
                flowDiagram.textContent = TEXT_CONSTANTS.NO_EXECUTION_PLAN;
                return;
            }

            const totalKernTime = calculateTotalKernTime(request.plan);
            // Use overall query elapsed time instead of summing operator exec times
            const totalElapsedTimeMs = request.elapsedTimeMs || parseTime(request.elapsedTime) || 0;
            const allOperators = getOperators(request.plan);
            // Filter out Sequence operators (they're just orchestration, not real work)
            const operators = allOperators.filter(op => op["#operator"] !== "Sequence");

            if (operators.length === 0) {
                flowDiagram.textContent = TEXT_CONSTANTS.NO_OPERATORS_FOUND;
                return;
            }

            operators.forEach((operator, index) => {
                const operatorName = operator["#operator"] || "Unknown Operator";
                const stats = operator["#stats"] || {};
                const kernTime = stats.kernTime || "N/A";
                const execTime = stats.execTime || "N/A";
                const servTime = stats.servTime || "N/A";
                const itemsIn =
                    stats["#itemsIn"] !== undefined ? stats["#itemsIn"] : "-";
                const itemsOut =
                    stats["#itemsOut"] !== undefined ? stats["#itemsOut"] : "-";

                const kernTimeMs = parseTime(kernTime);
                const execTimeMs = parseTime(execTime);
                const servTimeMs = parseTime(servTime);

                // Calculate percentage based on servTime when available (actual bottleneck), fallback to execTime
                const timeForPercentage = !isNaN(servTimeMs) && servTimeMs > 0 ? servTimeMs : execTimeMs;
                const percentage =
                    totalElapsedTimeMs > 0 && !isNaN(timeForPercentage) && timeForPercentage > 0
                        ? ((timeForPercentage / totalElapsedTimeMs) * 100).toFixed(2)
                        : "N/A";

                const bubble = document.createElement("div");
                bubble.className = "step-bubble";

                // Use percentage-based colors to draw attention to performance issues
                const percentageColors = getPercentageColor(percentage);
                bubble.style.backgroundColor = percentageColors.bg;
                bubble.style.borderColor = percentageColors.border;
                bubble.style.borderWidth = "2px";

                // Still add performance-based class as fallback for other styling
                const colorClass = getColorClass(parseFloat(percentage));
                bubble.classList.add(colorClass);

                // Build the HTML content with timing information
                const execTimeTooltip = formatTimeTooltip(execTime, execTimeMs);
                let bubbleContent = `
                    <h4>${operatorName}</h4>
                    <p><span title="${execTimeTooltip}">${formatTime(execTimeMs)}</span> (${percentage}%)</p>`;

                // Add servTime if available
                if (servTime !== "N/A" && !isNaN(servTimeMs) && servTimeMs > 0) {
                    const servTimeTooltip = formatTimeTooltip(servTime, servTimeMs);
                    bubbleContent += `<p><span title="${servTimeTooltip}">${formatTime(servTimeMs)}</span> servTime</p>`;
                }

                // Only show in/out line if both values are present and not "-"
                if (itemsIn !== "-" && itemsOut !== "-") {
                    bubbleContent += `<p>${itemsIn} in / ${itemsOut} out</p>`;
                }

                bubble.innerHTML = bubbleContent;
                bubble.addEventListener("click", () => {
                    const statsHtml = buildOperatorStats(operator);
                    document.getElementById("operator-modal-body").innerHTML =
                        statsHtml;
                    document.getElementById("operator-modal").style.display = "block";
                });
                flowDiagram.appendChild(bubble);

                if (index < operators.length - 1) {
                    const connector = document.createElement("div");
                    connector.className = "connector";
                    flowDiagram.appendChild(connector);
                }
            });

            if (request.plan) {
                const viewPlanButton = document.createElement("button");
                viewPlanButton.textContent = TEXT_CONSTANTS.VIEW_DETAILED_PLAN;
                viewPlanButton.style.marginTop = "10px";
                viewPlanButton.addEventListener("click", () => {
                    const indexesAndKeys = extractIndexesAndKeys(request);
                    const planTreeHtml = buildEnhancedPlanModal(
                        request.plan,
                        indexesAndKeys
                    );
                    document.getElementById("plan-modal-body").innerHTML = planTreeHtml;
                    document.getElementById("plan-modal").style.display = "block";
                });
                flowDiagram.appendChild(viewPlanButton);
            }

            panzoom(flowDiagram, { smoothScroll: false });
        }

        // Extract indexes and USE KEYS from request
        function extractIndexesAndKeys(request) {
            const indexes = new Set();
            const useKeys = [];
            let hasUseKeys = false;

            // Get bucket.scope.collection from the statement for primary index resolution
            const requestStatement =
                (request.statement || stripEmTags(request.preparedText || "") || "");
            let bucketScopeCollection = "unknown.unknown.unknown";

            const fromMatch = requestStatement.match(/FROM\s+([^\s\n\r\t]+)/i);
            if (fromMatch) {
                const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                const parts = target.split(".");
                if (parts.length === 1) {
                    bucketScopeCollection = `${parts[0]}._default._default`;
                } else if (parts.length === 2) {
                    bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                } else if (parts.length >= 3) {
                    bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                }
            }

            // Extract indexes from plan
            if (request.plan) {
                const operators = getOperators(request.plan);

                operators.forEach((operator, opIndex) => {
                    const opType = operator["#operator"];

                    if (
                        opType === "IndexScan" ||
                        opType === "IndexScan2" ||
                        opType === "IndexScan3"
                    ) {
                        if (operator.index) {
                            indexes.add(operator.index);
                        }
                    }

                    if (
                        opType === "PrimaryScan" ||
                        opType === "PrimaryScan2" ||
                        opType === "PrimaryScan3"
                    ) {
                        try {
                            // First try to resolve #primary to actual name
                            let resolvedName = resolvePrimaryIndexName(
                                bucketScopeCollection
                            );

                            // If we got a real index name (not #primary), use it
                            if (resolvedName && resolvedName !== "#primary") {
                                indexes.add(resolvedName);
                            }
                            // If operator has explicit index name, use that instead
                            else if (operator.index) {
                                indexes.add(operator.index);
                            }
                            // Fallback to #primary
                            else {
                                indexes.add("#primary");
                            }
                        } catch (error) {
                            // Fallback to operator.index if available
                            if (operator.index) {
                                indexes.add(operator.index);
                            } else {
                                indexes.add("#primary");
                            }
                        }
                    }
                });
            }

            // Extract USE KEYS from statement
            if (requestStatement.includes("USE KEYS")) {
                hasUseKeys = true;

                // Handle all USE KEYS formats:
                // USE KEYS(["key1","key2"]) or USE KEYS ["key1","key2"]
                // USE KEYS(['key1','key2']) or USE KEYS ['key1','key2']
                // USE KEYS("key1") or USE KEYS "key1"
                // USE KEYS('key1') or USE KEYS 'key1'

                let match;

                // Extract array format with double quotes: USE KEYS(?)["key1","key2"]
                const arrayDoubleQuotes = /USE\s+KEYS\s*\(?\s*\[(.*?)\]\s*\)?/gi;
                while ((match = arrayDoubleQuotes.exec(requestStatement)) !== null) {
                    // Split by comma and clean up each key, handle both single and double quotes
                    const keys = match[1]
                        .split(",")
                        .map((key) => {
                            return key.trim().replace(/^['"]|['"]$/g, ""); // Remove leading/trailing quotes
                        })
                        .filter((key) => key.length > 0);
                    useKeys.push(...keys);
                }

                // Reset regex for single key formats
                arrayDoubleQuotes.lastIndex = 0;

                // Extract single key format: USE KEYS(?) "key" or USE KEYS(?) 'key'
                // This should not match array formats, so we exclude those with brackets
                const singleKeyRegex =
                    /USE\s+KEYS\s*\(?\s*([^[\],]+?)\s*\)?(?:\s+WHERE|\s*$)/gi;
                while ((match = singleKeyRegex.exec(requestStatement)) !== null) {
                    const key = match[1].trim().replace(/^['"]|['"]$/g, ""); // Remove leading/trailing quotes
                    if (key && !key.includes("[") && !key.includes("]")) {
                        useKeys.push(key);
                    }
                }
            }

            return {
                indexes: Array.from(indexes),
                useKeys: [...new Set(useKeys)], // Remove duplicates
                hasUseKeys,
            };
        }

        // Build enhanced plan modal with indexes and keys
        function buildEnhancedPlanModal(plan, indexesAndKeys) {
            let html = '<div style="margin-bottom: 20px;">';

            // Indexes section
            if (indexesAndKeys.indexes.length > 0) {
                html += '<div style="margin-bottom: 15px;">';
                html +=
                    '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                html += `<h3 style="margin: 0; color: #333; font-size: 16px;">${TEXT_CONSTANTS.INDEXES_USED_HEADER}</h3>`;
                const allIndexes = indexesAndKeys.indexes.join(", ");
                html += `<button onclick="copyToClipboard('${allIndexes.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="background: #4CAF50;">${TEXT_CONSTANTS.COPY_ALL}</button>`;
                html += "</div>";
                html += '<div style="display: flex; flex-wrap: wrap; gap: 10px;">';
                indexesAndKeys.indexes.forEach((index) => {
                    html += `<div style="background: #f0f8ff; padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd;">
                        <code style="font-family: monospace; color: #333;">${index}</code>
                    </div>`;
                });
                html += "</div></div>";
            }

            // USE KEYS section
            if (indexesAndKeys.hasUseKeys) {
                html += '<div style="margin-bottom: 15px;">';

                if (indexesAndKeys.useKeys.length > 0) {
                    // Header with Copy All button
                    html +=
                        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                    html += `<h3 style="margin: 0; color: #333; font-size: 16px;">${TEXT_CONSTANTS.USE_KEYS_HEADER}</h3>`;
                    const allKeys = indexesAndKeys.useKeys.join(", ");
                    html += `<button onclick="copyToClipboard('${allKeys.replace(
                        /'/g,
                        "\\'"
                    )}', event)" 
                            class="btn-standard" style="background: #ff9800;">${TEXT_CONSTANTS.COPY_ALL}</button>`;
                    html += "</div>";

                    const maxKeysToShow = 15;
                    const shouldTruncate =
                        indexesAndKeys.useKeys.length > maxKeysToShow;

                    // Keys display container
                    html +=
                        '<div id="keys-container" style="display: flex; flex-wrap: wrap; gap: 8px;">';

                    // Show initial set of keys
                    const keysToShow = shouldTruncate
                        ? indexesAndKeys.useKeys.slice(0, maxKeysToShow)
                        : indexesAndKeys.useKeys;
                    keysToShow.forEach((key) => {
                        html += `<div style="background: #fff3cd; padding: 4px 8px; border-radius: 4px; border: 1px solid #ffeaa7;">
                            <code class="font-size-12" style="font-family: monospace; color: #856404;">${key}</code>
                        </div>`;
                    });

                    // Hidden keys (if truncated)
                    if (shouldTruncate) {
                        const remainingKeys = indexesAndKeys.useKeys.slice(maxKeysToShow);
                        remainingKeys.forEach((key) => {
                            html += `<div class="hidden-key display-none" style="background: #fff3cd; padding: 4px 8px; border-radius: 4px; border: 1px solid #ffeaa7;">
                                <code class="font-size-12" style="font-family: monospace; color: #856404;">${key}</code>
                            </div>`;
                        });
                    }

                    html += "</div>";

                    // Show more/hide button
                    if (shouldTruncate) {
                        const remainingCount =
                            indexesAndKeys.useKeys.length - maxKeysToShow;
                        html += `<div style="margin-top: 10px;">`;
                        html += `<button id="toggle-keys-btn" onclick="toggleUseKeys()" 
                                style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500;">
                                Show ${remainingCount} more keys
                            </button>`;
                        html += `</div>`;
                    }

                    // Summary info
                    html += `<div style="margin-top: 8px; font-size: 11px; color: #666; font-style: italic;">
                        Total: ${indexesAndKeys.useKeys.length} key${indexesAndKeys.useKeys.length !== 1 ? "s" : ""
                        }
                    </div>`;
                } else {
                    html += `<h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">${TEXT_CONSTANTS.USE_KEYS_HEADER}</h3>`;
                    html += `<div style="color: #666; font-style: italic;">${TEXT_CONSTANTS.KEYS_NOT_EXTRACTED}</div>`;
                }
                html += "</div>";
            }

            html += "</div>";

            // Execution plan section
            html += '<div style="border-top: 1px solid #ddd; padding-top: 15px;">';
            html +=
                `<h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">${TEXT_CONSTANTS.EXECUTION_PLAN_HEADER}</h3>`;
            html += "<ul>" + buildPlanTree(plan) + "</ul>";
            html += "</div>";

            return html;
        }

        // Get operator icon and color based on type
        function getOperatorStyle(operatorName) {
            const styles = {
                Authorize: { icon: "🔐", color: "#6f42c1", bg: "#f8f7ff" },
                Sequence: { icon: "📋", color: "#856404", bg: "#fff3cd" },
                IndexScan: { icon: "🔍", color: "#007bff", bg: "#e7f3ff" },
                IndexScan2: { icon: "🔍", color: "#007bff", bg: "#e7f3ff" },
                IndexScan3: { icon: "🔍", color: "#007bff", bg: "#e7f3ff" },
                PrimaryScan: { icon: "🔑", color: "#dc3545", bg: "#fff5f5" },
                PrimaryScan3: { icon: "🔑", color: "#dc3545", bg: "#fff5f5" },
                Fetch: { icon: "📥", color: "#28a745", bg: "#f1f8e9" },
                Filter: { icon: "🔧", color: "#fd7e14", bg: "#fff4e6" },
                InitialGroup: { icon: "📊", color: "#20c997", bg: "#e6fffa" },
                IntermediateGroup: { icon: "📈", color: "#20c997", bg: "#e6fffa" },
                FinalGroup: { icon: "🎯", color: "#20c997", bg: "#e6fffa" },
                InitialProject: { icon: "📋", color: "#6f42c1", bg: "#f8f7ff" },
                Stream: { icon: "🌊", color: "#17a2b8", bg: "#e2f7fa" },
                Sort: { icon: "🔄", color: "#ffc107", bg: "#fff8e1" },
                Limit: { icon: "✂️", color: "#e83e8c", bg: "#fce4ec" },
                Offset: { icon: "⏭️", color: "#6c757d", bg: "#f8f9fa" },
                Union: { icon: "🔗", color: "#795548", bg: "#f3e5f5" },
                Join: { icon: "🤝", color: "#9c27b0", bg: "#f3e5f5" },
            };

            return (
                styles[operatorName] || {
                    icon: "⚙️",
                    color: "#6c757d",
                    bg: "#f8f9fa",
                }
            );
        }

        // Format time values for better readability
        function formatTimeValue(timeStr) {
            if (!timeStr || timeStr === "N/A")
                return '<span style="color: #999;">N/A</span>';

            // Parse time and check if it's a high value (potential bottleneck)
            const timeMs = parseTime(timeStr);
            const isBottleneck = timeMs > 60000; // > 1 minute
            const isWarning = timeMs > 10000; // > 10 seconds

            let color = "#333";
            let bgColor = "transparent";
            let fontWeight = "normal";

            if (isBottleneck) {
                color = "#dc3545";
                bgColor = "#fff5f5";
                fontWeight = "bold";
            } else if (isWarning) {
                color = "#fd7e14";
                bgColor = "#fff4e6";
                fontWeight = "bold";
            }

            return `<span style="color: ${color}; background: ${bgColor}; font-weight: ${fontWeight}; padding: 1px 4px; border-radius: 3px;">${timeStr}</span>`;
        }

        // Format item count with color coding
        function formatItemCount(count) {
            if (count === undefined || count === null)
                return '<span style="color: #999;">N/A</span>';

            const numCount = typeof count === "number" ? count : parseInt(count);
            let color = "#333";
            let icon = "";

            if (numCount > 1000000) {
                color = "#dc3545";
                icon = "⚠️ ";
            } else if (numCount > 100000) {
                color = "#fd7e14";
                icon = "⚡ ";
            } else if (numCount > 10000) {
                color = "#ffc107";
            }

            return `<span style="color: ${color};">${icon}${numCount.toLocaleString()}</span>`;
        }

        // Build plan tree for modal with enhanced formatting
        function buildPlanTree(operator) {
            if (!operator) return "";

            const operatorName = operator["#operator"] || "Unknown Operator";
            const style = getOperatorStyle(operatorName);

            let html = `<li style="margin: 8px 0; padding: 12px; border-left: 4px solid ${style.color}; background: ${style.bg}; border-radius: 6px;">`;

            // Operator header with icon and name
            html += `<div style="display: flex; align-items: center; margin-bottom: 8px;">`;
            html += `<span style="font-size: 18px; margin-right: 8px;">${style.icon}</span>`;
            html += `<strong style="color: ${style.color}; font-size: 16px;">${operatorName}</strong>`;
            html += `</div>`;

            // Statistics section
            if (operator["#stats"]) {
                const stats = operator["#stats"];
                html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; margin: 8px 0; font-size: 13px;">`;

                // Items In/Out
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">📥 Items In:</span> ${formatItemCount(
                    stats["#itemsIn"]
                )}`;
                html += `</div>`;

                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">📤 Items Out:</span> ${formatItemCount(
                    stats["#itemsOut"]
                )}`;
                html += `</div>`;

                // Execution Time
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">⏱️ Exec Time:</span> ${formatTimeValue(
                    stats.execTime
                )}`;
                html += `</div>`;

                // Kernel Time
                html += `<div style="background: white; padding: 6px 10px; border-radius: 4px; border: 1px solid #e9ecef;">`;
                html += `<span style="color: #6c757d; font-weight: 500;">🔧 Kern Time:</span> ${formatTimeValue(
                    stats.kernTime
                )}`;
                html += `</div>`;

                html += `</div>`;

                // Efficiency indicator
                const itemsIn = stats["#itemsIn"];
                const itemsOut = stats["#itemsOut"];
                if (itemsIn !== undefined && itemsOut !== undefined && itemsIn > 0) {
                    const efficiency = (itemsOut / itemsIn) * 100;
                    let efficiencyColor = "#28a745";
                    let efficiencyIcon = "✅";

                    if (efficiency < 50) {
                        efficiencyColor = "#dc3545";
                        efficiencyIcon = "⚠️";
                    } else if (efficiency < 80) {
                        efficiencyColor = "#ffc107";
                        efficiencyIcon = "⚡";
                    }

                    html += `<div style="margin-top: 6px; font-size: 12px;">`;
                    html += `<span style="color: ${efficiencyColor};">${efficiencyIcon} Efficiency: ${efficiency.toFixed(
                        1
                    )}%</span>`;
                    html += `</div>`;
                }
            }

            // Child operations
            const childContainerStyle =
                "margin-top: 10px; margin-left: 20px; border-left: 2px dashed #dee2e6; padding-left: 15px;";

            if (operator["~child"]) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator["~child"]) +
                    "</ul>";
            } else if (operator["~children"]) {
                html += `<ul style="${childContainerStyle}">`;
                operator["~children"].forEach((child) => {
                    html += buildPlanTree(child);
                });
                html += "</ul>";
            }

            // Handle other child properties
            if (operator.input) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.input) +
                    "</ul>";
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                html += `<ul style="${childContainerStyle}">`;
                operator.inputs.forEach((input) => {
                    html += buildPlanTree(input);
                });
                html += "</ul>";
            }
            if (operator.left) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.left) +
                    "</ul>";
            }
            if (operator.right) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.right) +
                    "</ul>";
            }
            if (operator.first) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.first) +
                    "</ul>";
            }
            if (operator.second) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.second) +
                    "</ul>";
            }
            if (operator.scans && Array.isArray(operator.scans)) {
                html += `<ul style="${childContainerStyle}">`;
                operator.scans.forEach((scan) => {
                    html += buildPlanTree(scan);
                });
                html += "</ul>";
            }
            if (operator.scan) {
                html +=
                    `<ul style="${childContainerStyle}">` +
                    buildPlanTree(operator.scan) +
                    "</ul>";
            }
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                html += `<ul style="${childContainerStyle}">`;
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        html += buildPlanTree(subquery.executionTimings);
                    }
                });
                html += "</ul>";
            }

            html += "</li>";
            return html;
        }

        // Sorting functionality
        let currentSortColumn = null;
        let currentSortDirection = "asc";
        let currentTableType = "every-query"; // 'every-query' or 'analysis'
        let everyQueryData = [];
        let analysisData = [];

        // Pagination variables
        let currentPage = 1;
        const pageSize = 50; // Records per page

        // Search/filter variables
        let filteredEveryQueryData = [];
        let currentStatementFilter = "";
        let currentUsernameFilter = "";

        // Analysis table search/filter variables
        let filteredAnalysisData = [];
        let currentAnalysisStatementFilter = "";
        let currentAnalysisUsernameFilter = "";

        // Enhanced time parsing for sorting (handles various units and mm:ss.sss format)
        function parseTimeForSorting(timeStr) {
            if (!timeStr || timeStr === "N/A" || timeStr === "-") return 0;

            // Check if it's in mm:ss.sss format
            const mmssMatch = timeStr.match(/^(\d+):(\d{2})\.(\d{3})$/);
            if (mmssMatch) {
                const minutes = parseInt(mmssMatch[1]);
                const seconds = parseInt(mmssMatch[2]);
                const milliseconds = parseInt(mmssMatch[3]);
                return minutes * 60000 + seconds * 1000 + milliseconds;
            }

            // Handle legacy formats
            const match = timeStr
                .replace(/(\d+\.?\d*)(\D+)/, "$1 $2")
                .match(/(\d+\.?\d*)\s*(\D+)/);
            if (!match) return 0;
            const value = parseFloat(match[1]);
            const unit = match[2].toLowerCase().trim();
            // Convert everything to milliseconds for consistent sorting
            if (unit === "h" || unit === "hour" || unit === "hours")
                return value * 3600000;
            if (
                unit === "m" ||
                unit === "min" ||
                unit === "minute" ||
                unit === "minutes"
            )
                return value * 60000;
            if (
                unit === "s" ||
                unit === "sec" ||
                unit === "second" ||
                unit === "seconds"
            )
                return value * 1000;
            if (unit === "ms" || unit === "millisecond" || unit === "milliseconds")
                return value;
            if (
                unit === "us" ||
                unit === "µs" ||
                unit === "microsecond" ||
                unit === "microseconds"
            )
                return value / 1000;
            if (unit === "ns" || unit === "nanosecond" || unit === "nanoseconds")
                return value / 1000000;
            return value;
        }

        // Get sortable value for a column
        function getSortableValue(item, column) {
            let value;

            // Handle special nested data fields first
            if (column === "scanConsistency") {
                value = item.request && item.request.scanConsistency ? item.request.scanConsistency : "N/A";
            } else {
                value = item[column];
            }



            // Handle columns with newlines in their names
            const cleanColumn = column.replace(/\n/g, " ");

            // Handle special columns for Every Query table
            if (column === "#") {
                // "#" column is calculated dynamically, use a default sort order
                return parseInt(item.rowIndex) || 0;
            }
            if (column === "requestTime" || cleanColumn === "request Time") {
                return new Date(value).getTime() || 0;
            }
            if (
                ["elapsedTime", "kernTime", "cpuTime", "serviceTime"].includes(
                    column
                ) ||
                ["elapsed Time", "kern Time", "cpu Time", "service Time"].includes(
                    cleanColumn
                )
            ) {
                return parseTimeForSorting(value);
            }
            if (column === "KernTime %" || cleanColumn === "KernTime %") {
                const numStr = String(value).replace("%", "");
                return parseFloat(numStr) || 0;
            }
            if (column === "memory (MB)" || cleanColumn === "memory (MB)") {
                return parseFloat(value) || 0;
            }
            if (
                [
                    "resultCount",
                    "resultSize",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                ].includes(column) ||
                [
                    "result Count",
                    "result Size",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                ].includes(cleanColumn)
            ) {
                return parseInt(value) || 0;
            }
            if (
                column === "Primary Scan Used" ||
                cleanColumn === "Primary Scan Used"
            ) {
                return value === "Yes" ? 1 : 0;
            }
            if (column === "statementType" || cleanColumn === "statement Type") {
                return String(value || "").toLowerCase();
            }
            if (column === "state") {
                // Sort fatal states first, then by alphabetical order
                if (value === "fatal") return "aaa_fatal";
                if (value === "completed") return "bbb_completed";
                return String(value || "zzz_unknown").toLowerCase();
            }
            if (column === "scanConsistency" || column === "Scan\nConsistency" || cleanColumn === "Scan Consistency") {
                // Handle scan consistency values - data is nested under request object
                const scanValue = item.request && item.request.scanConsistency ? item.request.scanConsistency : (value || "N/A");
                return String(scanValue).toLowerCase();
            }
            if (column === "statement") {
                return String(value || "").toLowerCase();
            }
            if (column === "users") {
                return String(value || "").toLowerCase();
            }

            // Handle Analysis table columns
            if (
                [
                    "min_duration_in_seconds",
                    "max_duration_in_seconds",
                    "avg_duration_in_seconds",
                    "median_duration_in_seconds",
                ].includes(column)
            ) {
                return parseTimeForSorting(value);
            }
            if (
                [
                    "total_count",
                    "avg_fetch",
                    "avg_primaryScan",
                    "avg_indexScan",
                ].includes(column)
            ) {
                return parseFloat(value) || 0;
            }

            // Default: string comparison
            return String(value || "").toLowerCase();
        }

        // Sort data
        function sortData(data, column, direction) {
            return [...data].sort((a, b) => {
                const aVal = getSortableValue(a, column);
                const bVal = getSortableValue(b, column);

                let comparison = 0;
                if (aVal < bVal) comparison = -1;
                else if (aVal > bVal) comparison = 1;

                return direction === "asc" ? comparison : -comparison;
            });
        }

        // Update sort arrows in headers
        function updateSortArrows(tableHeaderId, column, direction) {
            const headers = document.querySelectorAll(`#${tableHeaderId} th`);
            headers.forEach((th) => {
                // Remove existing sort indicators
                const existingArrow = th.querySelector(".sort-arrow");
                const existingSortHint = th.querySelector(".sort-hint");
                if (existingArrow) existingArrow.remove();
                if (existingSortHint) existingSortHint.remove();

                // Handle multi-line headers by removing newlines for comparison
                const headerText = th.innerHTML
                    .replace(/<br>/g, " ")
                    .replace(/<[^>]*>/g, "")
                    .replace(/\s+/g, " ")
                    .trim();
                const columnText = column.replace(/\n/g, " ").trim();

                if (headerText === columnText) {
                    // Remove the old sort hint and add prominent arrow
                    const oldHint = th.querySelector("div");
                    if (oldHint && oldHint.textContent === "↕ Sort") {
                        oldHint.remove();
                    }

                    const arrow = document.createElement("div");
                    arrow.className = "sort-arrow";
                    arrow.style.fontSize = "14px";
                    arrow.style.color = "#0066cc";
                    arrow.style.fontWeight = "bold";
                    arrow.style.marginTop = "2px";

                    if (direction === "asc") {
                        arrow.textContent = "▲ ASC";
                        arrow.style.color = "#28a745";
                    } else {
                        arrow.textContent = "▼ DESC";
                        arrow.style.color = "#dc3545";
                    }

                    th.appendChild(arrow);
                } else {
                    // Add back the sort hint for non-active columns
                    const sortHint = document.createElement("div");
                    sortHint.className = "sort-hint";
                    sortHint.style.fontSize = "10px";
                    sortHint.style.color = "#6c757d";
                    sortHint.style.fontWeight = "normal";
                    sortHint.style.marginTop = "2px";
                    sortHint.textContent = "↕ Sort";
                    th.appendChild(sortHint);
                }
            });
        }

        // Map display column names to data field names
        function getDataFieldName(displayColumn) {
            // Map display names back to data field names (same logic as in populateEveryQueryTable)
            if (displayColumn === "request\nTime") return "requestTime";
            else if (displayColumn === "statement\nType") return "statementType";
            else if (displayColumn === "elapsed\nTime") return "elapsedTime";
            else if (displayColumn === "service\nTime") return "serviceTime";
            else if (displayColumn === "kern\nTime") return "kernTime";
            else if (displayColumn === "KernTime\n%") return "KernTime %";
            else if (displayColumn === "cpu\nTime") return "cpuTime";
            else if (displayColumn === "memory\n(MB)") return "memory (MB)";
            else if (displayColumn === "result\nCount") return "resultCount";
            else if (displayColumn === "result\nSize") return "resultSize";
            else if (displayColumn === "Items from\nIndex Scan")
                return "Items from Index Scan";
            else if (displayColumn === "Doc Fetch\nCount") return "Doc Fetch Count";
            else if (displayColumn === "Primary Scan\nUsed")
                return "Primary Scan Used";
            else if (displayColumn === "Scan\nConsistency")
                return "scanConsistency";
            else return displayColumn; // For columns without newlines like "#", "state", "statement", "users"
        }

        // Handle column sort click
        function handleColumnSort(column, tableType) {
            // Map display column to data field
            const dataField = getDataFieldName(column);

            if (currentSortColumn === column && currentTableType === tableType) {
                currentSortDirection =
                    currentSortDirection === "asc" ? "desc" : "asc";
            } else {
                currentSortColumn = column;
                currentSortDirection = "asc";
                currentTableType = tableType;
            }

            if (tableType === "every-query") {
                currentPage = 1; // Reset to first page after sorting

                // Sort using the data field name, not the display name
                const sortedData = sortData(
                    filteredEveryQueryData,
                    dataField,
                    currentSortDirection
                );

                filteredEveryQueryData = sortedData;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSortArrows("table-header", column, currentSortDirection);
            } else if (tableType === "analysis") {
                // Sort the filtered analysis data
                const sortedData = sortData(
                    filteredAnalysisData,
                    column,
                    currentSortDirection
                );
                filteredAnalysisData = sortedData;
                populateAnalysisTable(filteredAnalysisData);
                updateSortArrows(
                    "analysis-table-header",
                    column,
                    currentSortDirection
                );
            }
        }

        // Create pagination controls
        function addPaginationControls(totalRecords) {
            const tableContainer = document.getElementById("table-container");
            let paginationDiv = document.getElementById("pagination");
            if (!paginationDiv) {
                paginationDiv = document.createElement("div");
                paginationDiv.id = "pagination";
                paginationDiv.style.textAlign = "center";
                paginationDiv.style.marginTop = "10px";
                paginationDiv.style.backgroundColor = "#f5f5f5";
                paginationDiv.style.padding = "10px";
                paginationDiv.style.borderTop = "1px solid #ddd";
                tableContainer.appendChild(paginationDiv);
            }
            paginationDiv.innerHTML = "";

            const totalPages = Math.ceil(totalRecords / pageSize);

            // Previous button
            const prevButton = createButton("◀ Prev", () => {
                if (currentPage > 1) {
                    currentPage--;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            prevButton.disabled = currentPage === 1;

            // Next button
            const nextButton = createButton("Next ▶", () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    populateEveryQueryTable(filteredEveryQueryData);
                }
            });
            nextButton.disabled = currentPage === totalPages;

            // Page info
            const pageInfo = document.createElement("span");
            pageInfo.textContent = ` Page ${currentPage} of ${totalPages} (${totalRecords} records) `;
            pageInfo.style.margin = "0 15px";
            pageInfo.style.fontWeight = "bold";

            // Page jump input
            const pageInput = document.createElement("input");
            pageInput.type = "number";
            pageInput.min = "1";
            pageInput.max = totalPages.toString();
            pageInput.value = currentPage.toString();
            pageInput.style.width = "60px";
            pageInput.style.margin = "0 5px";
            pageInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                    const newPage = parseInt(pageInput.value);
                    if (newPage >= 1 && newPage <= totalPages) {
                        currentPage = newPage;
                        populateEveryQueryTable(filteredEveryQueryData);
                    }
                }
            });

            const jumpLabel = document.createElement("span");
            jumpLabel.textContent = "Go to page: ";
            jumpLabel.style.marginLeft = "20px";

            paginationDiv.appendChild(prevButton);
            paginationDiv.appendChild(pageInfo);
            paginationDiv.appendChild(nextButton);
            paginationDiv.appendChild(jumpLabel);
            paginationDiv.appendChild(pageInput);
        }

        function createButton(text, onClick) {
            const btn = document.createElement("button");
            btn.textContent = text;
            btn.style.margin = "0 5px";
            btn.style.padding = "5px 10px";
            btn.style.cursor = "pointer";
            btn.onclick = onClick;
            return btn;
        }

        // Filter data based on search criteria
        function filterEveryQueryData(data) {
            return data.filter((rowData) => {
                // Filter by statement
                if (currentStatementFilter) {
                const combined = (
                    ((rowData.request && rowData.request.statement) || "") +
                " " +
                    ((rowData.request && rowData.request.preparedText) || "")
                    ).toLowerCase();
                    if (!combined.includes(currentStatementFilter.toLowerCase())) {
                        return false;
                    }
                }

                // Filter by username
                if (currentUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update search results info
        function updateSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} records`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} records`;
            }
        }

        // Filter analysis data based on search criteria
        function filterAnalysisData(data) {
            return data.filter((rowData) => {
                // Filter by statement
                if (currentAnalysisStatementFilter) {
                    const combined = (
                        (rowData.statement || "") + " " + (rowData.preparedSample || "")
                    ).toLowerCase();
                    if (
                        !combined.includes(currentAnalysisStatementFilter.toLowerCase())
                    ) {
                        return false;
                    }
                }

                // Filter by username
                if (currentAnalysisUsernameFilter) {
                    const users = (rowData.users || "").toLowerCase();
                    if (!users.includes(currentAnalysisUsernameFilter.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });
        }

        // Update analysis search results info
        function updateAnalysisSearchResultsInfo(filteredCount, totalCount) {
            const infoDiv = document.getElementById("analysis-search-results-info");
            if (filteredCount === totalCount) {
                infoDiv.textContent = `Showing all ${totalCount} groups`;
            } else {
                infoDiv.textContent = `Showing ${filteredCount} of ${totalCount} groups`;
            }
        }

        // Setup analysis search event listeners
        function setupAnalysisSearchListeners() {
            const statementSearch = document.getElementById(
                "analysis-statement-search"
            );
            const usernameSearch = document.getElementById(
                "analysis-username-search"
            );
            const clearButton = document.getElementById("analysis-clear-search");

            function performAnalysisSearch() {
                currentAnalysisStatementFilter = statementSearch.value.trim();
                currentAnalysisUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredAnalysisData = filterAnalysisData(analysisData);

                // Update display
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(
                    filteredAnalysisData.length,
                    analysisData.length
                );
            }

            // Add debouncing to search inputs
            let analysisSearchTimeout;
            function debouncedAnalysisSearch() {
                clearTimeout(analysisSearchTimeout);
                analysisSearchTimeout = setTimeout(performAnalysisSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedAnalysisSearch);
            usernameSearch.addEventListener("input", debouncedAnalysisSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentAnalysisStatementFilter = "";
                currentAnalysisUsernameFilter = "";
                filteredAnalysisData = [...analysisData];
                populateAnalysisTable(filteredAnalysisData);
                updateAnalysisSearchResultsInfo(
                    filteredAnalysisData.length,
                    analysisData.length
                );
            });
        }

        // Setup search event listeners
        function setupSearchListeners() {
            const statementSearch = document.getElementById("statement-search");
            const usernameSearch = document.getElementById("username-search");
            const clearButton = document.getElementById("clear-search");

            function performSearch() {
                currentStatementFilter = statementSearch.value.trim();
                currentUsernameFilter = usernameSearch.value.trim();

                // Filter the data
                filteredEveryQueryData = filterEveryQueryData(everyQueryData);

                // Reset to first page
                currentPage = 1;

                // Update display
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(
                    filteredEveryQueryData.length,
                    everyQueryData.length
                );
            }

            // Add debouncing to search inputs
            let searchTimeout;
            function debouncedSearch() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(performSearch, 300);
            }

            statementSearch.addEventListener("input", debouncedSearch);
            usernameSearch.addEventListener("input", debouncedSearch);

            clearButton.addEventListener("click", () => {
                statementSearch.value = "";
                usernameSearch.value = "";
                currentStatementFilter = "";
                currentUsernameFilter = "";
                filteredEveryQueryData = [...everyQueryData];
                currentPage = 1;
                populateEveryQueryTable(filteredEveryQueryData);
                updateSearchResultsInfo(
                    filteredEveryQueryData.length,
                    everyQueryData.length
                );
            });
        }

        // Generate main table
        function generateTable(requests) {
            const tableHeader = document.getElementById("table-header");
            const tableBody = document.getElementById("table-body");
            tableHeader.innerHTML = "";
            tableBody.innerHTML = "";

            const columns = [
                "#",
                "request\nTime",
                "statement\nType",
                "elapsed\nTime",
                "service\nTime",
                "kern\nTime",
                "KernTime\n%",
                "cpu\nTime",
                "memory\n(MB)",
                "result\nCount",
                "result\nSize",
                "Doc Fetch\nCount",
                "Items from\nIndex Scan",
                "Primary Scan\nUsed",
                "state",
                "statement",
                "Scan\nConsistency",
                "users",
                "requestId",
            ];

            const headerRow = document.createElement("tr");
            columns.forEach((col) => {
                const th = document.createElement("th");
                th.innerHTML = col.replace(/\n/g, "<br>");
                th.style.textAlign = "center";
                th.style.whiteSpace = "nowrap";
                th.style.cursor = "pointer";
                th.style.userSelect = "none";
                th.style.padding = "8px";
                th.style.backgroundColor = "#f8f9fa";
                th.style.border = "1px solid #dee2e6";
                th.style.fontWeight = "bold";
                th.style.position = "relative";

                // Add hover effect
                th.addEventListener("mouseenter", () => {
                    th.style.backgroundColor = "#e9ecef";
                });
                th.addEventListener("mouseleave", () => {
                    th.style.backgroundColor = "#f8f9fa";
                });

                if (col === "statement") {
                    th.style.width = "300px";
                    th.style.maxWidth = "300px";
                }

                // Add sorting indicator text
                const sortHint = document.createElement("div");
                sortHint.className = "sort-hint";
                sortHint.style.fontSize = "10px";
                sortHint.style.color = "#6c757d";
                sortHint.style.fontWeight = "normal";
                sortHint.style.marginTop = "2px";
                sortHint.textContent = "↕ Sort";
                th.appendChild(sortHint);

                th.addEventListener("click", () => {
                    handleColumnSort(col, "every-query");
                });
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);

            // Prepare data with pre-calculated values
            const tableData = requests.map((request, index) => {
                // Use pre-calculated values from processRequestData
                const totalKernTimeMs = request.kernTimeMs || 0;
                const totalMemoryBytes = request.memoryBytes || 0;
                const elapsedTimeMs = request.elapsedTimeMs || 0;

                // Create row data object
                const rowData = {
                    rowIndex: index + 1,
                    request: request, // Keep original request for click handler
                };

                // Add all column values (skip "#" as it's calculated dynamically)
                [
                    "requestTime",
                    "statementType",
                    "elapsedTime",
                    "serviceTime",
                    "kernTime",
                    "KernTime %",
                    "cpuTime",
                    "memory (MB)",
                    "resultCount",
                    "resultSize",
                    "Items from Index Scan",
                    "Doc Fetch Count",
                    "Primary Scan Used",
                    "state",
                    "statement",
                    "users",
                ].forEach((col) => {
                    let value;
                    if (col === "Primary Scan Used") {
                        value = request.usesPrimary ? "Yes" : "No";
                    } else if (col === "Items from Index Scan") {
                        // Use phaseCounts for actual item counts, not operator counts
                        const indexScanCount = request.phaseCounts?.indexScan ||
                            request.phaseCounts?.primaryScan || 0;
                        value = indexScanCount > 0 ? indexScanCount : "N/A";
                    } else if (col === "Doc Fetch Count") {
                        // Use phaseCounts for actual fetch counts
                        const fetchCount = request.phaseCounts?.fetch || 0;
                        value = fetchCount > 0 ? fetchCount : "N/A";
                    } else if (col === "kernTime") {
                        value = totalKernTimeMs > 0 ? formatTime(totalKernTimeMs) : "N/A";
                    } else if (col === "KernTime %") {
                        value =
                            elapsedTimeMs > 0 && totalKernTimeMs > 0
                                ? ((totalKernTimeMs / elapsedTimeMs) * 100).toFixed(2) + "%"
                                : "N/A";
                    } else if (col === "memory (MB)") {
                        value = (request.memoryBytes == null)
                            ? "N/A"
                            : (request.memoryBytes / 1024 / 1024).toFixed(2);
                    } else if (col === "elapsedTime") {
                        value = formatTime(elapsedTimeMs);
                    } else if (col === "cpuTime") {
                        value = formatTime(parseTime(request[col]));
                    } else if (col === "serviceTime") {
                        value = formatTime(request.serviceTimeMs || parseTime(request[col]));
                    } else if (col === "statement") {
                        value = request.statement || request.preparedText || "N/A";
                    } else {
                        value = request[col] || "N/A";
                    }
                    rowData[col] = value;
                });

                return rowData;
            });

            // Sort by elapsedTime by default
            const sortedData = sortData(tableData, "elapsedTime", "desc");
            everyQueryData = sortedData;
            filteredEveryQueryData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "elapsedTime";
            currentSortDirection = "desc";
            currentTableType = "every-query";

            // Reset pagination when new data is loaded
            currentPage = 1;

            // Setup search listeners (only once)
            if (
                !document
                    .getElementById("statement-search")
                    .hasAttribute("data-listeners-added")
            ) {
                setupSearchListeners();
                document
                    .getElementById("statement-search")
                    .setAttribute("data-listeners-added", "true");
            }

            populateEveryQueryTable(filteredEveryQueryData);
            updateSortArrows("table-header", "elapsedTime", "desc");
            updateSearchResultsInfo(
                filteredEveryQueryData.length,
                everyQueryData.length
            );
        }

        // Populate Every Query table body
        function populateEveryQueryTable(data) {
            const tableBody = document.getElementById("table-body");
            tableBody.innerHTML = "";

            // Clear statement store for new data (only for current page)
            statementStore = {};

            const columns = [
                "#",
                "request\nTime",
                "statement\nType",
                "elapsed\nTime",
                "service\nTime",
                "kern\nTime",
                "KernTime\n%",
                "cpu\nTime",
                "memory\n(MB)",
                "result\nCount",
                "result\nSize",
                "Doc Fetch\nCount",
                "Items from\nIndex Scan",
                "Primary Scan\nUsed",
                "state",
                "statement",
                "Scan\nConsistency",
                "users",
                "requestId",
            ];

            // Pagination: get only the current page data
            const start = (currentPage - 1) * pageSize;
            const end = Math.min(start + pageSize, data.length);
            const pageData = data.slice(start, end);

            // Use DocumentFragment for batch DOM insertion
            const fragment = document.createDocumentFragment();

            pageData.forEach((rowData, pageIndex) => {
                const globalIndex = start + pageIndex; // For "#" column and statement IDs
                const row = document.createElement("tr");

                columns.forEach((col) => {
                    const td = document.createElement("td");
                    // Map display names back to data field names
                    let dataField;
                    if (col === "request\nTime") dataField = "requestTime";
                    else if (col === "statement\nType") dataField = "statementType";
                    else if (col === "elapsed\nTime") dataField = "elapsedTime";
                    else if (col === "service\nTime") dataField = "serviceTime";
                    else if (col === "kern\nTime") dataField = "kernTime";
                    else if (col === "KernTime\n%") dataField = "KernTime %";
                    else if (col === "cpu\nTime") dataField = "cpuTime";
                    else if (col === "memory\n(MB)") dataField = "memory (MB)";
                    else if (col === "result\nCount") dataField = "resultCount";
                    else if (col === "result\nSize") dataField = "resultSize";
                    else if (col === "Items from\nIndex Scan")
                        dataField = "Items from Index Scan";
                    else if (col === "Doc Fetch\nCount") dataField = "Doc Fetch Count";
                    else if (col === "Primary Scan\nUsed")
                        dataField = "Primary Scan Used";
                    else if (col === "Scan\nConsistency") dataField = "scanConsistency";
                    else dataField = col;

                    // Use globalIndex for row number to maintain correct numbering across pages
                    let value;
                    if (col === "#") {
                        value = globalIndex + 1;
                    } else if (col === "Scan\nConsistency") {
                        // scanConsistency is nested under request object
                        value = rowData.request && rowData.request.scanConsistency ? rowData.request.scanConsistency : "N/A";
                    } else {
                        value = rowData[dataField];
                    }

                    if (col === "request\nTime") {
                        // Set fixed width for requestTime column to handle long ISO-8601 timestamps
                        td.style.width = "120px";
                        td.style.maxWidth = "120px";
                        td.style.overflow = "hidden";
                        td.style.wordWrap = "break-word";
                        td.style.fontSize = "11px";
                        td.textContent = value || "";
                    } else if (col === "requestId") {
                        const reqId = (rowData.request && rowData.request.requestId) || rowData.requestId || value || "";
                        const safeId = String(reqId);
                        td.style.whiteSpace = 'nowrap';
                        td.innerHTML = `
                          <code style="font-size:11px;">${escapeHtml(safeId)}</code>
                          <button data-id="${escapeHtml(safeId)}" onclick="copyRequestId(this.dataset.id, event)" class="btn-standard" style="margin-left:6px;">${TEXT_CONSTANTS.COPY}</button>
                        `;
                    } else if (col === "statement") {
                        // Set fixed width for statement column
                        td.style.width = "300px";
                        td.style.maxWidth = "300px";
                        td.style.overflow = "hidden";
                        td.style.wordWrap = "break-word";
                        // Handle statement column with truncation and controls
                        const statement = value || "";
                        const statementId = `statement-${globalIndex}`;

                        // Store the statement safely
                        statementStore[statementId] = statement;

                        if (statement.length > 500) {
                            // Create truncated version
                            const truncated = statement.substring(0, 500);
                            const preparedSample = (rowData && rowData.request && isPreparedExecution(rowData.request)) ? getPreparedSample(rowData.request) : "";
                            const preparedSnippet = preparedSample ? `<div style=\"margin-top:6px; color:#555; font-size:12px;\"><strong>${TEXT_CONSTANTS.PREPARED_TEXT || 'Prepared:'}</strong> ${escapeHtml(preparedSample.substring(0, 300))}${preparedSample.length > 300 ? '...' : ''}</div>` : '';

                            td.innerHTML = `
                  <div id="${statementId}-truncated">
                    <span>${truncated}...</span>
                    ${preparedSnippet}
                    <br>
                    <button onclick=\"toggleStatement('${statementId}', true)\" 
                            class=\"btn-standard\" style=\"margin-top: 5px; margin-right: 5px;\">${TEXT_CONSTANTS.SHOW_MORE}</button>
                    <button onclick=\"copyStatement('${statementId}', event)\" 
                            class=\"btn-standard\" style=\"margin-top: 5px;\">${TEXT_CONSTANTS.COPY}</button>
                  </div>
                  <div id="${statementId}-full" style="display: none;">
                    <span>${statement}</span>
                    ${preparedSnippet}
                    <br>
                    <button onclick=\"toggleStatement('${statementId}', false)\" 
                            class=\"btn-standard\" style=\"margin-top: 5px; margin-right: 5px;\">${TEXT_CONSTANTS.HIDE}</button>
                    <button onclick=\"copyStatement('${statementId}', event)\" 
                            class=\"btn-standard\" style=\"margin-top: 5px;\">${TEXT_CONSTANTS.COPY}</button>
                  </div>
                `;
                        } else {
                            // Short statement - just show it with copy button
                            const preparedSample = (rowData && rowData.request && isPreparedExecution(rowData.request)) ? getPreparedSample(rowData.request) : "";
                            const preparedSnippet = preparedSample ? `<div style=\"margin-top:6px; color:#555; font-size:12px;\"><strong>${TEXT_CONSTANTS.PREPARED_TEXT || 'Prepared:'}</strong> ${escapeHtml(preparedSample.substring(0, 300))}${preparedSample.length > 300 ? '...' : ''}</div>` : '';
                            td.innerHTML = `
                  <div>
                    <span>${statement}</span>
                    ${preparedSnippet}
                    <br>
                    <button onclick=\"copyStatement('${statementId}', event)\" 
                            class=\"btn-standard\" style=\"margin-top: 5px;\">${TEXT_CONSTANTS.COPY}</button>
                  </div>
                `;
                        }
                    } else if (
                        ["result\nCount", "result\nSize", "Doc Fetch\nCount", "Items from\nIndex Scan"].includes(col)
                    ) {
                        // Format numeric columns with commas
                        const numValue = Number(value);
                        td.textContent = isNaN(numValue) ? value : numValue.toLocaleString();
                    } else {
                        td.textContent = value;
                    }

                    if (
                        col === "Primary Scan\nUsed" &&
                        (value === "Yes" || value === "True" || value === true)
                    ) {
                        td.classList.add("primary-scan-yes");
                    }

                    if (col === "state" && value === "fatal") {
                        td.classList.add("fatal-state");
                    }
                    row.appendChild(td);
                });

                row.addEventListener("click", (event) => {
                    // Allow text selection - only handle clicks, not text selection
                    if (window.getSelection().toString().length > 0) {
                        return; // User is selecting text, don't handle the click
                    }

                    document
                        .querySelectorAll("tr")
                        .forEach((r) => (r.style.backgroundColor = ""));
                    row.style.backgroundColor = "#e0e0e0";
                    generateFlowDiagram(rowData.request);
                });
                fragment.appendChild(row);
            });

            // Batch insert all rows at once
            tableBody.appendChild(fragment);

            // Auto-render the first row's flow diagram once (initial load or when diagram is empty)
            try {
                const flowEl = document.getElementById("flow-diagram");
                const shouldAuto = flowEl && (!flowEl.hasChildNodes() || flowEl.children.length === 0 || (flowEl.textContent || "").trim() === (TEXT_CONSTANTS.SELECT_QUERY_FLOW || ""));
                if (shouldAuto && pageData.length > 0) {
                    generateFlowDiagram(pageData[0].request);
                    if (tableBody.firstElementChild) {
                        tableBody.firstElementChild.style.backgroundColor = "#e0e0e0";
                    }
                }
            } catch (e) { /* no-op */ }

            // Add pagination controls
            addPaginationControls(data.length);
        }

        // Toggle statement display between truncated and full view
        function toggleStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy statement to clipboard
        function copyStatement(statementId, event) {
            const statement = statementStore[statementId];
            if (!statement) {
                console.error("Statement not found in store:", statementId);
                alert(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                return;
            }

            navigator.clipboard
                .writeText(statement)
                .then(() => {
                    // Show brief feedback
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "copied!";
                    button.style.backgroundColor = "#4CAF50";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy statement:", err);
                    alert(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD);
                });
        }

        // Toggle analysis statement display between truncated and full view
        function toggleAnalysisStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(
                statementId + "-truncated"
            );
            const fullDiv = document.getElementById(statementId + "-full");

            if (showFull) {
                truncatedDiv.style.display = "none";
                fullDiv.style.display = "block";
            } else {
                truncatedDiv.style.display = "block";
                fullDiv.style.display = "none";
            }
        }

        // Copy analysis statement to clipboard
        function copyAnalysisStatement(statementId, event) {
            const statement = analysisStatementStore[statementId];
            if (!statement) {
                console.error("Statement not found in store:", statementId);
                alert(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                return;
            }

            navigator.clipboard
                .writeText(statement)
                .then(() => {
                    // Show brief feedback
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "copied!";
                    button.style.backgroundColor = "#4CAF50";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy statement:", err);
                    alert(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD);
                });
        }

        // Calculate statistics for a group of requests based on SQL++ query logic
        function calculateGroupStats(normalized_statement, groupedRequests) {
            const users_agg = groupedRequests.map((r) => r.users).filter((u) => u);
            const durations = groupedRequests
                .map((r) => {
                    const ms = parseTime(r.serviceTime);
                    return isNaN(ms) ? NaN : ms / 1000; // Convert ms to seconds
                })
                .filter((d) => !isNaN(d));
            const total_count = durations.length;
            if (total_count === 0) return null;

            const min_duration = Math.min(...durations);
            const max_duration = Math.max(...durations);
            const avg_duration =
                durations.reduce((sum, d) => sum + d, 0) / total_count;
            const sorted_durations = [...durations].sort((a, b) => a - b);
            const midFloor = Math.floor(total_count / 2);
            const midCeil = Math.ceil(total_count / 2) - 1;
            const median_duration =
                (sorted_durations[midFloor] + sorted_durations[midCeil]) / 2;

            const fetchValues = groupedRequests.map(
                (r) => r.phaseCounts?.fetch || 0
            );
            const primaryScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.primaryScan || 0
            );
            const indexScanValues = groupedRequests.map(
                (r) => r.phaseCounts?.indexScan || 0
            );
            const avg_fetch =
                fetchValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_primaryScan =
                primaryScanValues.reduce((sum, v) => sum + v, 0) / total_count;
            const avg_indexScan =
                indexScanValues.reduce((sum, v) => sum + v, 0) / total_count;

            // Compute user_query_counts as an object: { user: count }
            const uniqueUsers = [...new Set(users_agg)];
            const user_query_counts = {};
            uniqueUsers.forEach((user) => {
                user_query_counts[user] = users_agg.filter((v) => v === user).length;
            });

            // Calculate status counts
            const status_counts = {
                completed: 0,
                fatal: 0,
                cancelled: 0,
                other: 0
            };

            groupedRequests.forEach((r) => {
                const state = r.state ? r.state.toLowerCase() : 'completed';
                if (state === 'completed') {
                    status_counts.completed++;
                } else if (state === 'fatal') {
                    status_counts.fatal++;
                } else if (state === 'cancelled') {
                    status_counts.cancelled++;
                } else {
                    status_counts.other++;
                }
            });

            // Build average/min/max phase times (ms) for timeline chart
            function phaseStats(keys) {
                const keysArr = Array.isArray(keys) ? keys : [keys];
                const values = groupedRequests.map(r => {
                    const pt = r.phaseTimes || {};
                    let v = 0;
                    keysArr.forEach((k) => { if (pt && pt[k]) v += parseTime(pt[k]) || 0; });
                    return v;
                });
                const valid = values.filter(v => typeof v === 'number');
                const cnt = valid.length;
                if (cnt === 0) return { avg: 0, min: 0, max: 0 };
                const sum = valid.reduce((a,b)=>a+b,0);
                return { avg: sum/cnt, min: Math.min(...valid), max: Math.max(...valid) };
            }

            const s_authorize = phaseStats('authorize');
            const s_parse = phaseStats('parse');
            const s_plan = phaseStats('plan');
            const s_index = phaseStats(['indexScan','primaryScan','primaryScan.GSI']);
            const s_fetch = phaseStats('fetch');
            const s_join = phaseStats(['hashJoin','nestedLoopJoin']);
            const s_nest = phaseStats(['nest','unnest']);
            const s_filter = phaseStats('filter');
            const s_group = phaseStats(['group','aggregate']);
            const s_sort = phaseStats('sort');
            const s_limit = phaseStats('limit');
            const s_project = phaseStats('project');
            const s_delete = phaseStats('delete');
            const s_update = phaseStats('update');
            const s_insert = phaseStats('insert');
            const s_stream = phaseStats('stream');

            const avgPhaseTimeline = [
                { id: 'authorize', label: TEXT_CONSTANTS.PHASE_AUTHORIZE || 'authorize', avgMs: s_authorize.avg, minMs: s_authorize.min, maxMs: s_authorize.max },
                { id: 'parse', label: TEXT_CONSTANTS.PHASE_PARSE, avgMs: s_parse.avg, minMs: s_parse.min, maxMs: s_parse.max },
                { id: 'plan', label: TEXT_CONSTANTS.PHASE_PLAN, avgMs: s_plan.avg, minMs: s_plan.min, maxMs: s_plan.max },
                { id: 'indexScan', label: TEXT_CONSTANTS.PHASE_INDEX_SCAN || 'index scan', avgMs: s_index.avg, minMs: s_index.min, maxMs: s_index.max },
                { id: 'fetch', label: TEXT_CONSTANTS.PHASE_FETCH || 'fetch data', avgMs: s_fetch.avg, minMs: s_fetch.min, maxMs: s_fetch.max },
                { id: 'join', label: TEXT_CONSTANTS.PHASE_JOIN || 'JOIN', avgMs: s_join.avg, minMs: s_join.min, maxMs: s_join.max },
                { id: 'nest', label: TEXT_CONSTANTS.PHASE_NEST || 'Nest/Unnest', avgMs: s_nest.avg, minMs: s_nest.min, maxMs: s_nest.max },
                { id: 'filter', label: TEXT_CONSTANTS.PHASE_FILTER, avgMs: s_filter.avg, minMs: s_filter.min, maxMs: s_filter.max },
                { id: 'groupAgg', label: TEXT_CONSTANTS.PHASE_GROUP_AGG, avgMs: s_group.avg, minMs: s_group.min, maxMs: s_group.max },
                { id: 'sort', label: TEXT_CONSTANTS.PHASE_SORT, avgMs: s_sort.avg, minMs: s_sort.min, maxMs: s_sort.max },
                { id: 'limit', label: TEXT_CONSTANTS.PHASE_LIMIT || 'limit', avgMs: s_limit.avg, minMs: s_limit.min, maxMs: s_limit.max },
                { id: 'project', label: TEXT_CONSTANTS.PHASE_PROJECT, avgMs: s_project.avg, minMs: s_project.min, maxMs: s_project.max },
                { id: 'delete', label: TEXT_CONSTANTS.PHASE_DELETE || 'DELETE', avgMs: s_delete.avg, minMs: s_delete.min, maxMs: s_delete.max },
                { id: 'update', label: TEXT_CONSTANTS.PHASE_UPDATE || 'UPDATE', avgMs: s_update.avg, minMs: s_update.min, maxMs: s_update.max },
                { id: 'insert', label: TEXT_CONSTANTS.PHASE_INSERT || 'INSERT', avgMs: s_insert.avg, minMs: s_insert.min, maxMs: s_insert.max },
                { id: 'stream', label: TEXT_CONSTANTS.PHASE_STREAM || 'return results', avgMs: s_stream.avg, minMs: s_stream.min, maxMs: s_stream.max },
            ].filter(p => p.avgMs > 0);

            return {
                normalized_statement,
                user_query_counts,
                total_count,
                min_duration_in_seconds: min_duration,
                max_duration_in_seconds: max_duration,
                avg_duration_in_seconds: avg_duration,
                median_duration_in_seconds: median_duration,
                avg_fetch: Math.round(avg_fetch),
                avg_primaryScan: Math.round(avg_primaryScan),
                avg_indexScan: Math.round(avg_indexScan),
                status_counts,
                // for chart rendering on row click
                avgPhaseTimeline
            };
        }

        // Generate analysis table based on SQL++ query logic
        function generateAnalysisTable(requests) {
            const analysisTableHeader = document.getElementById(
                "analysis-table-header"
            );
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableHeader.innerHTML = "";
            analysisTableBody.innerHTML = "";

            // Group requests by normalized_statement
            const groups = {};
            requests.forEach((request) => {
                const stmt = request.statement || request.preparedText;
                if (!stmt) return;
                // Note: System query filtering is now handled globally in parseJSON()
                const normalized = normalizeStatement(stmt);
                if (!groups[normalized]) {
                    groups[normalized] = [];
                }
                groups[normalized].push(request);
            });

            // Calculate stats for each group
            const groupData = Object.keys(groups)
                .map((key) => calculateGroupStats(key, groups[key]))
                .filter((data) => data !== null);
            groupData.sort((a, b) => b.total_count - a.total_count);

            // Initialize phase times chart with the first group (if present)
            if (groupData.length > 0) {
                renderQueryGroupPhaseTimesChart(groupData[0]);
            }

            // Define table columns
            const analysisColumns = [
                "total_count",
                "min_duration_in_seconds",
                "max_duration_in_seconds",
                "avg_duration_in_seconds",
                "median_duration_in_seconds",
                "avg_fetch",
                "avg_primaryScan",
                "avg_indexScan",
                "status_counts",
                "normalized_statement",
                "user_query_counts",
            ];

            // Create header row
            const headerRow = document.createElement("tr");
            analysisColumns.forEach((col) => {
                const th = document.createElement("th");
                let displayName = col
                    .replace(/_/g, " ")
                    .replace("in seconds", " (mm:ss.sss)");
                if (col === "user_query_counts") {
                    displayName = TEXT_CONSTANTS.USER_COUNT;
                }
                if (col === "status_counts") {
                    displayName = TEXT_CONSTANTS.STATE_FATAL;
                }
                th.textContent = displayName;
                th.style.textAlign = "center";
                th.addEventListener("click", () => handleColumnSort(col, "analysis"));
                headerRow.appendChild(th);
            });
            analysisTableHeader.appendChild(headerRow);

            // Prepare table data
            const analysisTableData = groupData.map((group) => {
                const rowData = {};
                analysisColumns.forEach((col) => {
                    let value;
                    if (col === "user_query_counts") {
                        value = Object.entries(group.user_query_counts)
                            .map(([user, count]) => `${user}: (${count})`)
                            .join(", ");
                    } else if (col === "status_counts") {
                        const counts = group.status_counts;
                        value = counts.fatal;
                    } else if (col === "total_count") {
                        value = group.total_count;
                    } else if (
                        [
                            "min_duration_in_seconds",
                            "max_duration_in_seconds",
                            "avg_duration_in_seconds",
                            "median_duration_in_seconds",
                        ].includes(col)
                    ) {
                        value = isNaN(group[col])
                            ? "N/A"
                            : formatTime(Number(group[col]) * 1000);
                    } else if (
                        ["avg_fetch", "avg_primaryScan", "avg_indexScan"].includes(col)
                    ) {
                        value = isNaN(group[col]) ? "N/A" : Number(group[col]).toLocaleString();
                    } else {
                        value = group[col] || "N/A";
                    }
                    rowData[col] = value;
                });

                // Add fields for search filtering and prepared sample
                rowData.statement = group.normalized_statement || "";
                // Use first request of this group to derive a prepared statement sample
                try {
                const sampleList = groups && groups[group.normalized_statement];
                if (Array.isArray(sampleList) && sampleList.length > 0) {
                const sampleReq = sampleList[0] || {};
                rowData.preparedSample = isPreparedExecution(sampleReq) ? getPreparedSample(sampleReq) : "";
                } else {
                rowData.preparedSample = "";
                }
                } catch (e) { rowData.preparedSample = ""; }
                rowData.users = Object.keys(group.user_query_counts || {}).join(", ");
                // Attach original group for chart rendering on row click
                rowData.groupRef = group;

                return rowData;
            });

            // Sort by total_count by default
            const sortedData = sortData(analysisTableData, "total_count", "desc");
            analysisData = sortedData;
            filteredAnalysisData = [...sortedData]; // Initialize filtered data
            currentSortColumn = "total_count";
            currentSortDirection = "desc";
            currentTableType = "analysis";

            // Setup search listeners (only once)
            if (
                !document
                    .getElementById("analysis-statement-search")
                    .hasAttribute("data-listeners-added")
            ) {
                setupAnalysisSearchListeners();
                document
                    .getElementById("analysis-statement-search")
                    .setAttribute("data-listeners-added", "true");
            }

            populateAnalysisTable(filteredAnalysisData);
            updateSortArrows("analysis-table-header", "total_count", "desc");
            updateAnalysisSearchResultsInfo(
                filteredAnalysisData.length,
                analysisData.length
            );
        }

        // Populate Analysis table body
        function populateAnalysisTable(data) {
            const analysisTableBody = document.getElementById(
                "analysis-table-body"
            );
            analysisTableBody.innerHTML = "";

            // Clear statement store for new data
            analysisStatementStore = {};

            const analysisColumns = [
                "total_count",
                "min_duration_in_seconds",
                "max_duration_in_seconds",
                "avg_duration_in_seconds",
                "median_duration_in_seconds",
                "avg_fetch",
                "avg_primaryScan",
                "avg_indexScan",
                "status_counts",
                "normalized_statement",
                "user_query_counts",
            ];

            // Use DocumentFragment for smooth table rendering with batching
            const batchSize = 50; // Process rows in batches for large datasets
            const fragment = document.createDocumentFragment();
            let processed = 0;

            function processBatch(startIndex) {
                const endIndex = Math.min(startIndex + batchSize, data.length);

                for (let index = startIndex; index < endIndex; index++) {
                    const rowData = data[index];
                    const row = document.createElement("tr");

                    analysisColumns.forEach((col) => {
                        const td = document.createElement("td");
                        let value = rowData[col];

                        // Apply thresholding for extreme values
                        if (typeof value === 'number' && value > 1000000) {
                            value = `${Math.round(value / 1000000)}M+`;
                        }

                        if (col === "normalized_statement") {
                            // Handle normalized_statement column with truncation and controls
                            const statement = value || "";
                            const statementId = `analysis-statement-${index}`;

                            // Optionally show a sample prepared statement below, if available
                            const preparedSample = (rowData && rowData.preparedSample) ? String(rowData.preparedSample) : "";
                            const preparedSnippet = preparedSample ? `<div style=\"margin-top:6px; color:#555; font-size:12px;\"><strong>${TEXT_CONSTANTS.PREPARED_TEXT || 'Prepared:'}</strong> ${escapeHtml(preparedSample.substring(0, 300))}${preparedSample.length > 300 ? '...' : ''}</div>` : '';

                            // Store the statement safely
                            analysisStatementStore[statementId] = statement;

                            if (statement.length > 500) {
                                // Create truncated version
                                const truncated = statement.substring(0, 500);

                                td.innerHTML = `
                    <div id="${statementId}-truncated">
                      <span>${truncated}...</span>
                      ${preparedSnippet}
                      <br>
                      <button onclick="toggleAnalysisStatement('${statementId}', true)" 
                              class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                      <button onclick="copyAnalysisStatement('${statementId}', event)" 
                              class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                    <div id="${statementId}-full" style="display: none;">
                      <span>${statement}</span>
                      ${preparedSnippet}
                      <br>
                      <button onclick="toggleAnalysisStatement('${statementId}', false)" 
                              class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                      <button onclick="copyAnalysisStatement('${statementId}', event)" 
                              class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                  `;
                            } else {
                                // Short statement - just show it with copy button
                                td.innerHTML = `
                    <div>
                      <span>${statement}</span>
                      ${preparedSnippet}
                      <br>
                      <button onclick="copyAnalysisStatement('${statementId}', event)" 
                              class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                  `;
                            }
                        } else if (col === "user_query_counts") {
                            // Bold the counts in parentheses
                            const formattedValue = value.replace(/\((\d+)\)/g, "<b>($1)</b>");
                            td.innerHTML = formattedValue;
                        } else if (col === "status_counts") {
                            // Show fatal count, make it bold and red if > 0
                            if (value > 0) {
                                td.innerHTML = `<span class="fatal-count">${value}</span>`;
                            } else {
                                td.textContent = value;
                            }
                        } else if (col === "total_count") {
                            // Format total_count with commas, cap at 999K+
                            const numValue = Number(value);
                            if (!isNaN(numValue)) {
                                if (numValue > 999999) {
                                    td.textContent = "999K+";
                                } else {
                                    td.textContent = numValue.toLocaleString();
                                }
                            } else {
                                td.textContent = value;
                            }
                        } else {
                            td.textContent = value;
                        }

                        // Style avg primaryScan when > 0 (red and bold)
                        if (col === "avg_primaryScan") {
                            // Handle comma-formatted numbers by removing commas first
                            const cleanValue = String(value).replace(/,/g, '');
                            const originalValue = Number(cleanValue);
                            if (!isNaN(originalValue) && originalValue > 0) {
                                td.classList.add("primary-scan-yes");
                            }
                        }

                        row.appendChild(td);
                    });
                    // On row click, render the per-group phase timeline chart
                    row.addEventListener('click', () => {
                        if (rowData.groupRef) {
                            renderQueryGroupPhaseTimesChart(rowData.groupRef);
                        }
                    });
                    fragment.appendChild(row);
                }

                // Append batch to DOM
                if (endIndex >= data.length) {
                    analysisTableBody.appendChild(fragment);
                } else {
                    // Process next batch asynchronously
                    analysisTableBody.appendChild(fragment);
                    setTimeout(() => processBatch(endIndex), 0);
                }
            }

            // Start batch processing if we have data
            if (data.length > 0) {
                processBatch(0);
            }
        }

        // Helper function to get time grouping settings
        function getTimeGrouping() {
            const dropdown = document.getElementById('time-grouping-select');
            return dropdown ? dropdown.value : "optimizer";
        }

        // Helper function to round timestamp based on grouping and optimal unit
        function roundTimestamp(timestamp, grouping, requests) {
            // Create cache key for this specific timestamp+grouping combination
            const cacheKey = `${timestamp.getTime()}-${grouping}`;
            if (timestampRoundingCache.has(cacheKey)) {
                return timestampRoundingCache.get(cacheKey);
            }

            const date = new Date(timestamp);

            // Determine actual unit to use with caching
            let actualUnit;
            if (grouping === "optimizer") {
                // Cache the optimal unit per request array to avoid repeated analysis
                if (timeUnitCache.has(requests)) {
                    actualUnit = timeUnitCache.get(requests);
                } else {
                    actualUnit = getOptimalTimeUnit(requests);
                    timeUnitCache.set(requests, actualUnit);
                }
            } else {
                // Use exactly what the user selected
                actualUnit = grouping;
            }

            // Round based on actual unit
            switch (actualUnit) {
                case "second":
                    date.setMilliseconds(0);
                    break;
                case "5min":
                    const minutes5 = Math.floor(date.getMinutes() / 5) * 5;
                    date.setMinutes(minutes5, 0, 0);
                    break;
                case "minute":
                    date.setSeconds(0, 0);
                    break;
                case "hour":
                    date.setMinutes(0, 0, 0);
                    break;
                case "day":
                    date.setHours(0, 0, 0, 0);
                    break;
                case "week":
                    const dayOfWeek = date.getDay();
                    date.setDate(date.getDate() - dayOfWeek);
                    date.setHours(0, 0, 0, 0);
                    break;
                case "month":
                    date.setDate(1);
                    date.setHours(0, 0, 0, 0);
                    break;
                case "year":
                    date.setMonth(0, 1);
                    date.setHours(0, 0, 0, 0);
                    break;
                default:
                    date.setSeconds(0, 0);
            }

            // Cache the result
            timestampRoundingCache.set(cacheKey, date);
            return date;
        }

        // Helper function to automatically determine optimal time unit based on data span
        function getOptimalTimeUnit(requests) {
            if (!requests || requests.length === 0) return "minute";

            const times = requests
                .map((r) => new Date(r.requestTime))
                .filter((t) => !isNaN(t));
            if (times.length === 0) return "minute";

            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            const timeSpanMs = maxTime - minTime;
            const timeSpanHours = timeSpanMs / (1000 * 60 * 60);
            const timeSpanDays = timeSpanHours / 24;

            // Choose time unit based on span to keep Chart.js happy
            if (timeSpanDays > 365) {
                return "year";
            } else if (timeSpanDays > 60) {
                return "month";
            } else if (timeSpanDays > 14) {
                return "week";
            } else if (timeSpanDays > 2) {
                return "day";
            } else if (timeSpanHours > 2) {
                return "hour";
            } else if (timeSpanHours > 0.1) {
                return "minute";
            } else {
                return "second";
            }
        }

// Render horizontal bar chart for Query Groups using avgPhaseTimeline (with specific row ordering)
function renderQueryGroupPhaseTimesChart(group) {
            try {
                const titleEl = document.getElementById('query-group-phase-times-title');
                const subtitleEl = document.getElementById('query-group-phase-times-subtitle');
                const canvas = document.getElementById('query-group-phase-times-chart');
                const noteEl = document.getElementById('query-group-phase-times-note');
                if (!canvas) return;

                if (titleEl) titleEl.textContent = TEXT_CONSTANTS.QUERY_GROUP_PHASE_TIMES_TITLE || 'Phase Times by Query Group (avg)';
                if (subtitleEl && TEXT_CONSTANTS.PHASE_TIMELINE_NOTE) subtitleEl.textContent = TEXT_CONSTANTS.PHASE_TIMELINE_NOTE;
                if (noteEl && TEXT_CONSTANTS.PHASE_TIMELINE_NOTE) noteEl.textContent = TEXT_CONSTANTS.PHASE_TIMELINE_NOTE;

                const ctx = canvas.getContext('2d');
                if (window.queryGroupPhaseTimesChart) {
                    window.queryGroupPhaseTimesChart.destroy();
                }

                const phases = Array.isArray(group.avgPhaseTimeline) ? group.avgPhaseTimeline : [];
                const findStats = (id) => phases.find(p => p.id === id) || { avgMs: 0, minMs: 0, maxMs: 0 };

                // Stats per phase (avg/min/max in ms)
                const authStats    = findStats('authorize');
                const parseStats   = findStats('parse');
                const planStats    = findStats('plan');
                const indexStats   = findStats('indexScan');
                const fetchStats   = findStats('fetch');
                const joinStats    = findStats('join');
                const filterStats  = findStats('filter');
                const nestStats    = findStats('nest');
                const groupStats   = findStats('groupAgg');
                const sortStats    = findStats('sort');
                const limitStats   = findStats('limit');
                const projectStats = findStats('project');
                const deleteStats  = findStats('delete');
                const updateStats  = findStats('update');
                const insertStats  = findStats('insert');
                const streamStats  = findStats('stream');

                // Dynamically build rows (top-down order) and include only if data exists
                const rows = [
                    { key: 'authorize',    label: TEXT_CONSTANTS.PHASE_AUTHORIZE,                         include: !!authStats.avgMs },
                    { key: 'parsePlan',    label: `Parse & Plan`,                                       include: !!parseStats.avgMs || !!planStats.avgMs },
                    { key: 'scanFetch',    label: `Index Scan / Doc Fetch`,                             include: !!indexStats.avgMs || !!fetchStats.avgMs },
                    { key: 'join',         label: TEXT_CONSTANTS.PHASE_JOIN || 'JOIN',                  include: !!joinStats.avgMs },
                    { key: 'nest',         label: TEXT_CONSTANTS.PHASE_NEST || 'Nest/Unnest',           include: !!nestStats.avgMs },
                    { key: 'filter',       label: TEXT_CONSTANTS.PHASE_FILTER,                          include: !!filterStats.avgMs },
                    { key: 'groupAgg',     label: TEXT_CONSTANTS.PHASE_GROUP_AGG,                       include: !!groupStats.avgMs },
                    { key: 'sort',         label: TEXT_CONSTANTS.PHASE_SORT,                            include: !!sortStats.avgMs },
                    { key: 'limit',        label: TEXT_CONSTANTS.PHASE_LIMIT,                           include: !!limitStats.avgMs },
                    { key: 'project',      label: TEXT_CONSTANTS.PHASE_PROJECT,                         include: !!projectStats.avgMs },
                    { key: 'delete',       label: TEXT_CONSTANTS.PHASE_DELETE || 'DELETE',              include: !!deleteStats.avgMs },
                    { key: 'update',       label: TEXT_CONSTANTS.PHASE_UPDATE || 'UPDATE',              include: !!updateStats.avgMs },
                    { key: 'insert',       label: TEXT_CONSTANTS.PHASE_INSERT || 'INSERT',              include: !!insertStats.avgMs },
                    { key: 'stream',       label: TEXT_CONSTANTS.PHASE_STREAM,                          include: !!streamStats.avgMs },
                ];
                const activeRows = rows.filter(r => r.include);
                const labels = activeRows.map(r => r.label);
                const rowIndex = Object.fromEntries(activeRows.map((r, i) => [r.key, i]));

                // Dynamically size chart height based on row count and bar thickness (set parent height for Chart.js sizing)
                try {
                    const barPx = 26; // close to maxBarThickness used elsewhere
                    const rowPadding = 28; // tick + grid spacing
                    const base = 140; // extra space for axes/labels
                    const targetHeight = Math.max(base + labels.length * (barPx + rowPadding), 300);
                    const scaled = Math.max(280, Math.round(targetHeight * 0.75)); // reduce by ~25%
                    const parent = canvas.parentElement; // Chart.js reads parent container size
                    if (parent) parent.style.height = `${scaled}px`;
                    // Also set the canvas as a fallback
                    canvas.style.height = `${scaled}px`;
                } catch (e) { /* no-op */ }

                // Compute sequential offsets. Row 2: parse then plan (in series). Row 3: scan/fetch concurrent.
                let t = 0;
                const authBar    = authStats.avgMs   > 0 ? [t, (t += authStats.avgMs)]      : null;
                const row2Start  = t;
                const parseBar   = parseStats.avgMs  > 0 ? [t, (t += parseStats.avgMs)]     : null;
                const planBar    = planStats.avgMs   > 0 ? [t, (t += planStats.avgMs)]      : null;

                const row3Start  = t; // concurrency start for Index Scan / Fetch
                const scanBar    = indexStats.avgMs  > 0 ? [row3Start, row3Start + indexStats.avgMs] : null;
                // Adjust Doc Fetch to end no earlier than Index Scan if scan is longer.
                let fetchBar = null;
                if (fetchStats.avgMs > 0) {
                    const intrinsicEnd = row3Start + fetchStats.avgMs;
                    const scanEnd = scanBar ? scanBar[1] : intrinsicEnd;
                    const fetchEnd = Math.max(intrinsicEnd, scanEnd);
                    const fetchStart = Math.max(0, fetchEnd - fetchStats.avgMs);
                    fetchBar = [fetchStart, fetchEnd];
                }
                t = Math.max(scanBar ? scanBar[1] : row3Start, fetchBar ? fetchBar[1] : row3Start);

                const joinBar    = joinStats.avgMs   > 0 ? [t, (t += joinStats.avgMs)]      : null;
                // Nest/Unnest bar placement: same policy as Filter
                // - Preserve the average duration as the bar width.
                // - Align END to later of scan/fetch end or its own intrinsic end.
                // - START = end - avg.
                let nestBar = null;
                if (nestStats.avgMs > 0) {
                    const concurrentStart = row3Start;
                    const scanEnd = scanBar ? scanBar[1] : concurrentStart;
                    const fetchEnd = fetchBar ? fetchBar[1] : concurrentStart;
                    const concurrentEnd = Math.max(scanEnd, fetchEnd);
                    const intrinsicEnd = concurrentStart + nestStats.avgMs;
                    const end = Math.max(concurrentEnd, intrinsicEnd);
                    const start = Math.max(0, end - nestStats.avgMs);
                    nestBar = [start, end];
                }

                // Filter bar placement:
                // - Preserve the average duration as the bar width (visual focus on avg time).
                // - Align the bar END to the later of scan/fetch end or its own intrinsic end.
                // - The START is computed as end - avg (does not need to begin with scan/fetch).
                let filterBar = null;
                if (filterStats.avgMs > 0) {
                    const concurrentStart = row3Start;
                    const scanEnd = scanBar ? scanBar[1] : concurrentStart;
                    const fetchEnd = fetchBar ? fetchBar[1] : concurrentStart;
                    const concurrentEnd = Math.max(scanEnd, fetchEnd);
                    const intrinsicEnd = concurrentStart + filterStats.avgMs;
                    const filterEnd = Math.max(concurrentEnd, intrinsicEnd);
                    const filterStart = Math.max(0, filterEnd - filterStats.avgMs);
                    filterBar = [filterStart, filterEnd];
                }
                const groupBar   = groupStats.avgMs  > 0 ? [t, (t += groupStats.avgMs)]     : null;
                const sortBar    = sortStats.avgMs   > 0 ? [t, (t += sortStats.avgMs)]      : null;
                const limitBar   = limitStats.avgMs  > 0 ? [t, (t += limitStats.avgMs)]     : null;
                // Project must occur after Nest/Unnest and Filter (and sequential phases like Group/Sort/Limit).
                // Start Project at the later of: sequential time 't', Filter end, and Nest/Unnest end.
                let projectBar = null;
                if (projectStats.avgMs > 0) {
                    const prevEnd = Math.max(
                        t,
                        filterBar ? filterBar[1] : 0,
                        nestBar ? nestBar[1] : 0
                    );
                    const projectStart = prevEnd;
                    const projectEnd = projectStart + projectStats.avgMs;
                    projectBar = [projectStart, projectEnd];
                }
                const deleteBar  = deleteStats.avgMs > 0 ? [t, (t += deleteStats.avgMs)]     : null;
                const updateBar  = updateStats.avgMs > 0 ? [t, (t += updateStats.avgMs)]     : null;
                const insertBar  = insertStats.avgMs > 0 ? [t, (t += insertStats.avgMs)]     : null;
                // Stream should be the final step: start at the latest end among all other phases
                let streamBar = null;
                if (streamStats.avgMs > 0) {
                const otherEnds = [authBar, parseBar, planBar, scanBar, fetchBar, joinBar, nestBar, filterBar, groupBar, sortBar, limitBar, projectBar, deleteBar, updateBar, insertBar]
                .filter(Boolean)
                .map(b => b[1]);
                const streamStart = otherEnds.length ? Math.max(...otherEnds) : t;
                const streamEnd = streamStart + streamStats.avgMs;
                streamBar = [streamStart, streamEnd];
                }

                // Helper to place a bar on a specific row index
                function mkDataForRow(bar, rowIndex) {
                    return labels.map((_, i) => (i === rowIndex ? bar : null));
                }

                // Build datasets; one dataset per segment. Attach phaseId for tooltip stats.
                const datasets = [];
                if (authBar && rowIndex.authorize !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_AUTHORIZE, phaseId: 'authorize', data: mkDataForRow(authBar, rowIndex.authorize), backgroundColor: 'rgba(102, 126, 234, 0.35)', borderColor: 'rgba(102, 126, 234, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (parseBar && rowIndex.parsePlan !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_PARSE,     phaseId: 'parse',     data: mkDataForRow(parseBar, rowIndex.parsePlan), backgroundColor: 'rgba(66, 133, 244, 0.35)', borderColor: 'rgba(66, 133, 244, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (planBar && rowIndex.parsePlan !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_PLAN,      phaseId: 'plan',      data: mkDataForRow(planBar,  rowIndex.parsePlan), backgroundColor: 'rgba(66, 133, 244, 0.25)', borderColor: 'rgba(66, 133, 244, 0.8)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (scanBar && rowIndex.scanFetch !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_INDEX_SCAN,phaseId: 'indexScan', data: mkDataForRow(scanBar,  rowIndex.scanFetch), backgroundColor: 'rgba(40, 167, 69, 0.35)',  borderColor: 'rgba(40, 167, 69, 0.9)',  borderWidth: 1, borderRadius: 4, barThickness: 10, categoryPercentage: 0.5, barPercentage: 0.5 });
                if (fetchBar && rowIndex.scanFetch !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_FETCH,     phaseId: 'fetch',     data: mkDataForRow(fetchBar, rowIndex.scanFetch), backgroundColor: 'rgba(220, 53, 69, 0.30)',  borderColor: 'rgba(220, 53, 69, 0.9)',  borderWidth: 1, borderRadius: 4, barThickness: 10, categoryPercentage: 0.5, barPercentage: 0.5 });
                if (joinBar && rowIndex.join !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_JOIN || 'JOIN', phaseId: 'join',  data: mkDataForRow(joinBar, rowIndex.join), backgroundColor: 'rgba(255, 159, 64, 0.35)', borderColor: 'rgba(255, 159, 64, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (nestBar && rowIndex.nest !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_NEST || 'Nest/Unnest', phaseId: 'nest', data: mkDataForRow(nestBar,rowIndex.nest), backgroundColor: 'rgba(121, 85, 72, 0.35)',   borderColor: 'rgba(121, 85, 72, 0.9)',   borderWidth: 1, borderRadius: 4, grouped: false });
                if (filterBar && rowIndex.filter !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_FILTER,    phaseId: 'filter',    data: mkDataForRow(filterBar,rowIndex.filter), backgroundColor: 'rgba(255, 193, 7, 0.30)',   borderColor: 'rgba(255, 193, 7, 0.9)',   borderWidth: 1, borderRadius: 4, grouped: false });
                if (groupBar && rowIndex.groupAgg !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_GROUP_AGG, phaseId: 'groupAgg',  data: mkDataForRow(groupBar, rowIndex.groupAgg), backgroundColor: 'rgba(23, 162, 184, 0.30)',  borderColor: 'rgba(23, 162, 184, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (sortBar && rowIndex.sort !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_SORT,      phaseId: 'sort',      data: mkDataForRow(sortBar,  rowIndex.sort), backgroundColor: 'rgba(108, 117, 125, 0.30)', borderColor: 'rgba(108, 117, 125, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (limitBar && rowIndex.limit !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_LIMIT,     phaseId: 'limit',     data: mkDataForRow(limitBar, rowIndex.limit), backgroundColor: 'rgba(153, 102, 255, 0.30)', borderColor: 'rgba(153, 102, 255, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (projectBar && rowIndex.project !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_PROJECT,   phaseId: 'project',   data: mkDataForRow(projectBar,rowIndex.project), backgroundColor: 'rgba(255, 99, 132, 0.25)', borderColor: 'rgba(255, 99, 132, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (deleteBar && rowIndex.delete !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_DELETE || 'DELETE', phaseId: 'delete', data: mkDataForRow(deleteBar, rowIndex.delete), backgroundColor: 'rgba(200, 35, 51, 0.35)', borderColor: 'rgba(200, 35, 51, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (updateBar && rowIndex.update !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_UPDATE || 'UPDATE', phaseId: 'update', data: mkDataForRow(updateBar, rowIndex.update), backgroundColor: 'rgba(0, 150, 136, 0.35)', borderColor: 'rgba(0, 150, 136, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (insertBar && rowIndex.insert !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_INSERT || 'INSERT', phaseId: 'insert', data: mkDataForRow(insertBar, rowIndex.insert), backgroundColor: 'rgba(156, 39, 176, 0.35)', borderColor: 'rgba(156, 39, 176, 0.9)', borderWidth: 1, borderRadius: 4, grouped: false });
                if (streamBar && rowIndex.stream !== undefined)
                    datasets.push({ label: TEXT_CONSTANTS.PHASE_STREAM,    phaseId: 'stream',    data: mkDataForRow(streamBar,rowIndex.stream), backgroundColor: 'rgba(0, 123, 255, 0.20)',  borderColor: 'rgba(0, 123, 255, 0.8)',  borderWidth: 1, borderRadius: 4, grouped: false });

                // Inline plugin to draw avg time labels at end of each bar
                const valueLabelPlugin = {
                    id: 'queryGroupBarValueLabels',
                    afterDatasetsDraw(chart, args, plgOpts) {
                        const { ctx, chartArea } = chart;
                        ctx.save();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        chart.data.datasets.forEach((ds, di) => {
                            const meta = chart.getDatasetMeta(di);
                            if (!meta || meta.hidden) return;
                            const statsForDs = (phaseId) => findStats(phaseId || '');
                            meta.data.forEach((bar, i) => {
                                const raw = ds.data[i];
                                if (!raw || !Array.isArray(raw)) return;
                                const stats = statsForDs(ds.phaseId);
                                const avgMs = (stats && stats.avgMs) ? stats.avgMs : 0;
                                if (!avgMs) return;
                                const label = formatTime(avgMs);
                                const x = Math.max(bar.x, bar.base) + 6;
                                const y = bar.y;
                                const drawX = Math.min(x, chartArea.right - 4);
                                ctx.fillText(label, drawX, y);
                            });
                        });
                        ctx.restore();
                    }
                };

                window.queryGroupPhaseTimesChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    plugins: [valueLabelPlugin],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        layout: { padding: { bottom: 20, top: 0, left: 0, right: 10 } },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        const val = ctx.raw;
                                        const dur = (Array.isArray(val) ? (val[1] - val[0]) : 0);
                                        const ds = ctx.dataset || {};
                                        const phaseId = ds.phaseId || '';
                                        const stats = findStats(phaseId);
                                        const minStr = stats.minMs ? formatTime(stats.minMs) : '00:00.000';
                                        const avgStr = stats.avgMs ? formatTime(stats.avgMs) : '00:00.000';
                                        const maxStr = stats.maxMs ? formatTime(stats.maxMs) : '00:00.000';
                                        return `${ctx.dataset.label}: ${dur.toFixed(2)} ms (min ${minStr} | avg ${avgStr} | max ${maxStr})`;
                                    }
                                }
                            }
                        },
                        datasets: {
                            bar: {
                                barThickness: 20,
                                maxBarThickness: 26,
                                categoryPercentage: 0.9,
                                barPercentage: 0.9,
                            }
                        },
                        scales: {
                            x: {
                                stacked: false,
                                title: { display: true, text: TEXT_CONSTANTS.AXIS_TIME_MS },
                            },
                            y: {
                                stacked: false,
                                offset: true,
                                title: { display: false }
                            }
                        }
                    }
                });
            } catch (err) {
                console.error('Error rendering Query Group Phase Times chart:', err);
            }
        }
        
        // Helper function to get Chart.js time configuration with auto-adjustment
        function getTimeConfig(requestedGrouping, requests) {
            // Use exactly the unit that was requested
            let actualUnit = requestedGrouping;

            // Calculate appropriate stepSize based on data span to prevent Chart.js errors
            let stepSize = 1;
            if (requests && requests.length > 0) {
                const times = requests
                    .map((r) => new Date(r.requestTime))
                    .filter((t) => !isNaN(t));
                if (times.length > 0) {
                    const minTime = Math.min(...times);
                    const maxTime = Math.max(...times);
                    const timeSpanMs = maxTime - minTime;

                    // Calculate stepSize to keep data points reasonable (max ~1000 points)
                    switch (actualUnit) {
                        case "second":
                            stepSize = Math.max(1, Math.ceil(timeSpanMs / (1000 * 1000))); // timeSpanMs / (1000ms * 1000 points)
                            break;
                        case "minute":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (60 * 1000 * 1000))
                            ); // timeSpanMs / (60s * 1000ms * 1000 points)
                            break;
                        case "hour":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (3600s * 1000ms * 1000 points)
                            break;
                        case "day":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (86400s * 1000ms * 1000 points)
                            break;
                        case "week":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (7 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (604800s * 1000ms * 1000 points)
                            break;
                        case "month":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (30 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (~2592000s * 1000ms * 1000 points)
                            break;
                        case "year":
                            stepSize = Math.max(
                                1,
                                Math.ceil(timeSpanMs / (365 * 24 * 60 * 60 * 1000 * 1000))
                            ); // timeSpanMs / (~31536000s * 1000ms * 1000 points)
                            break;
                    }
                }
            }

            // Return appropriate config based on actual unit
            const configs = {
                second: {
                    unit: "second",
                    stepSize: stepSize,
                    displayFormats: { second: "HH:mm:ss" },
                },
                minute: {
                    unit: "minute",
                    stepSize: stepSize,
                    displayFormats: { minute: "MMM dd HH:mm" },
                },
                hour: {
                    unit: "hour",
                    stepSize: stepSize,
                    displayFormats: { hour: "MMM dd HH:mm" },
                },
                day: {
                    unit: "day",
                    stepSize: stepSize,
                    displayFormats: { day: "MMM dd" },
                },
                week: {
                    unit: "week",
                    stepSize: stepSize,
                    displayFormats: { week: "MMM dd" },
                },
                month: {
                    unit: "month",
                    stepSize: stepSize,
                    displayFormats: { month: "MMM yyyy" },
                },
                year: {
                    unit: "year",
                    stepSize: stepSize,
                    displayFormats: { year: "yyyy" },
                },
            };

            return configs[actualUnit] || configs["minute"];
        }

        // Helper function to get current time config with requests data
        function getCurrentTimeConfig(requests) {
            const grouping = getTimeGrouping();
            let actualUnit;
            if (grouping === "optimizer") {
                actualUnit = getOptimalTimeUnit(requests);
            } else {
                actualUnit = grouping;
            }
            return getTimeConfig(actualUnit, requests);
        }

        // Helper function to update the optimizer label
        function updateOptimizerLabel(requests) {
            const optimizedUnit = getOptimalTimeUnit(requests);
            const dropdown = document.getElementById("time-grouping-select");
            if (dropdown) {
                // Update the first option text to show the actual optimized unit
                const optimizerOption = dropdown.querySelector('option[value="optimizer"]');
                if (optimizerOption) {
                    optimizerOption.textContent = `By Optimizer (${optimizedUnit})`;
                }
            }
        }

        // Array to store all timeline charts for synchronization
        const timelineCharts = [];

        // Custom plugin to draw a vertical line on hover
        const verticalLinePlugin = {
            id: 'verticalLine',
            afterInit(chart) {
                chart.verticalLine = { draw: false, x: 0 };
            },
            afterEvent(chart, args) {
                const { inChartArea, event } = args;
                if (chart.verticalLine) {
                    chart.verticalLine.draw = inChartArea;
                    chart.verticalLine.x = event ? event.x : args.x;
                    // Let Chart.js handle the redraw naturally, don't force it
                }
            },
            afterDatasetsDraw(chart) {
                if (!chart.verticalLine || !chart.verticalLine.draw || !chart.verticalLine.x) return;

                const { ctx, chartArea: { top, bottom } } = chart;
                ctx.save();
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#007bff';
                ctx.setLineDash([5, 5]);
                ctx.moveTo(chart.verticalLine.x, top);
                ctx.lineTo(chart.verticalLine.x, bottom);
                ctx.stroke();
                ctx.restore();
            }
        };

        // Function to sync crosshairs across all timeline charts
        function syncTimelineCharts(sourceEvent, activeChart) {
            if (!activeChart || !activeChart.chartArea) return;

            const chartArea = activeChart.chartArea;
            const inChartArea = sourceEvent.x >= chartArea.left && sourceEvent.x <= chartArea.right &&
                sourceEvent.y >= chartArea.top && sourceEvent.y <= chartArea.bottom;

            // Filter out null/destroyed charts and exclude the active chart
            const validCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart !== activeChart &&  // Exclude active chart to prevent flicker
                    chart.canvas &&
                    chart.canvas.getContext &&
                    chart.scales &&
                    chart.scales.x &&
                    chart.chartArea &&
                    !chart.isDestroyed;
            });

            // Update active chart's crosshair state without redrawing
            if (activeChart.verticalLine) {
                activeChart.verticalLine.draw = inChartArea;
                if (inChartArea) {
                    activeChart.verticalLine.x = sourceEvent.x;
                }
            }

            // Sync other charts
            validCharts.forEach(chart => {
                if (!inChartArea) {
                    if (chart.verticalLine && chart.verticalLine.draw) {
                        chart.verticalLine.draw = false;
                        requestAnimationFrame(() => chart.draw());
                    }
                    return;
                }

                try {
                    const xValue = activeChart.scales.x.getValueForPixel(sourceEvent.x);
                    const targetX = chart.scales.x.getPixelForValue(xValue);

                    if (chart.verticalLine && targetX >= chart.chartArea.left && targetX <= chart.chartArea.right) {
                        const wasDrawn = chart.verticalLine.draw;
                        const oldX = chart.verticalLine.x;

                        chart.verticalLine.draw = true;
                        chart.verticalLine.x = targetX;

                        // Only redraw if position changed significantly or wasn't drawn before
                        if (!wasDrawn || Math.abs(oldX - targetX) > 2) {
                            requestAnimationFrame(() => chart.draw());
                        }
                    }
                } catch (error) {
                    // Silently handle errors
                    if (chart.verticalLine) {
                        chart.verticalLine.draw = false;
                    }
                }
            });

            // Update the timelineCharts array to only contain valid charts (including active chart)
            const allValidCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart.canvas &&
                    chart.canvas.getContext &&
                    chart.scales &&
                    chart.scales.x &&
                    chart.chartArea &&
                    !chart.isDestroyed;
            });

            if (allValidCharts.length !== timelineCharts.length) {
                timelineCharts.length = 0;
                timelineCharts.push(...allValidCharts);
            }
        }

        // Clear crosshairs on all timeline charts
        function clearTimelineCrosshairs() {
            // Filter out null/destroyed charts
            const validCharts = timelineCharts.filter(chart => {
                return chart &&
                    chart.canvas &&
                    chart.canvas.getContext &&
                    !chart.isDestroyed &&
                    chart.verticalLine;
            });

            validCharts.forEach(chart => {
                if (chart.verticalLine && chart.verticalLine.draw) {
                    chart.verticalLine.draw = false;
                    requestAnimationFrame(() => chart.draw());
                }
            });

            // Update the timelineCharts array to only contain valid charts
            if (validCharts.length !== timelineCharts.length) {
                timelineCharts.length = 0;
                timelineCharts.push(...validCharts);
            }
        }

        // Helper function to register a chart for crosshair synchronization
        function registerTimelineChart(chart, ctx) {
            if (!chart || !ctx || !ctx.canvas) return;

            // Add to timeline charts array for synchronization
            timelineCharts.push(chart);

            // Throttle mousemove events to prevent excessive redraws
            let mouseMoveTimeout;
            const mouseMoveHandler = (event) => {
                if (mouseMoveTimeout) return;

                mouseMoveTimeout = setTimeout(() => {
                    mouseMoveTimeout = null;

                    const rect = ctx.canvas.getBoundingClientRect();
                    const canvasEvent = {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    };
                    syncTimelineCharts(canvasEvent, chart);
                }, 8); // Throttle to ~120fps
            };

            // Add mouseleave event listener to clear crosshairs
            const mouseLeaveHandler = () => {
                if (mouseMoveTimeout) {
                    clearTimeout(mouseMoveTimeout);
                    mouseMoveTimeout = null;
                }
                clearTimelineCrosshairs();
            };

            ctx.canvas.addEventListener('mousemove', mouseMoveHandler);
            ctx.canvas.addEventListener('mouseleave', mouseLeaveHandler);

            // Store handlers for cleanup if needed
            chart._crosshairHandlers = {
                mousemove: mouseMoveHandler,
                mouseleave: mouseLeaveHandler
            };
        }

        // Generate operations chart showing index scan vs fetch operations
        function generateOperationsChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.operationsChart) {
                window.operationsChart.destroy();
                window.operationsChart = null;
            }

            const canvas = document.getElementById("operations-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalIndexScan: 0,
                        totalFetch: 0,
                        indexScanQueryCount: 0,
                    };
                }

                // Use pre-calculated values from indexInfo
                const indexInfo = request.indexInfo || {
                    stats: { primaryScan: 0, indexScan: 0, fetch: 0 },
                };
                const { primaryScan, indexScan, fetch } = indexInfo.stats;

                timeGroups[key].totalIndexScan += primaryScan + indexScan;
                timeGroups[key].totalFetch += fetch;

                // Count queries that performed index scans
                if (primaryScan > 0 || indexScan > 0) {
                    timeGroups[key].indexScanQueryCount++;
                }
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const indexScanData = sortedData.map((item) => item.totalIndexScan);
            const fetchData = sortedData.map((item) => item.totalFetch);
            const avgIndexScanData = sortedData.map((item) =>
                item.indexScanQueryCount > 0 ? Math.round(item.totalIndexScan / item.indexScanQueryCount) : null
            );

            // Create new side-by-side bar chart
            window.operationsChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Index Scan Items",
                            data: indexScanData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 1, // Blue bars on left
                        },
                        {
                            label: "Fetch Documents",
                            data: fetchData,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2, // Green bars on right
                        },
                        {
                            label: "Avg Index Scans per Query",
                            data: avgIndexScanData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            spanGaps: false,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Database Operations Timeline: Index Scans vs Document Fetches",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Sync pan with other charts
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Operation Count",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg Index Scans per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.operationsChart, ctx);
        }

        // Generate enhanced operations chart with detailed In/Out tracking
        function generateEnhancedOperationsChart(requests) {
            // Destroy existing chart if it exists
            if (window.enhancedOperationsChart) {
                window.enhancedOperationsChart.destroy();
                window.enhancedOperationsChart = null;
            }

            const canvas = document.getElementById("enhanced-operations-chart");
            if (!canvas) return;
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime || !request.plan) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalIndexIn: 0,
                        totalIndexOut: 0,
                        totalFetchIn: 0,
                        totalFetchOut: 0,
                        indexQueryCount: 0,
                        fetchQueryCount: 0,
                    };
                }

                // Extract detailed operator statistics from plan
                try {
                    const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                    const operators = getOperators(planObj);

                    let hasIndexOps = false;
                    let hasFetchOps = false;

                    operators.forEach((operator) => {
                        const operatorType = operator["#operator"];
                        const stats = operator["#stats"] || {};
                        const itemsIn = stats["#itemsIn"] || 0;
                        const itemsOut = stats["#itemsOut"] || 0;

                        if (operatorType === "IndexScan" || operatorType === "IndexScan3" || 
                            operatorType === "PrimaryScan" || operatorType === "PrimaryScan3") {
                            timeGroups[key].totalIndexIn += itemsIn;
                            timeGroups[key].totalIndexOut += itemsOut;
                            hasIndexOps = true;
                        } else if (operatorType === "Fetch") {
                            timeGroups[key].totalFetchIn += itemsIn;
                            timeGroups[key].totalFetchOut += itemsOut;
                            hasFetchOps = true;
                        }
                    });

                    // Count queries that had these operations
                    if (hasIndexOps) {
                        timeGroups[key].indexQueryCount++;
                    }
                    if (hasFetchOps) {
                        timeGroups[key].fetchQueryCount++;
                    }
                } catch (e) {
                    console.warn("Error parsing plan for enhanced operations chart:", e);
                }
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const indexInData = sortedData.map((item) => item.totalIndexIn);
            const indexOutData = sortedData.map((item) => item.totalIndexOut);
            const fetchInData = sortedData.map((item) => item.totalFetchIn);
            const fetchOutData = sortedData.map((item) => item.totalFetchOut);
            
            // Calculate averages for line charts
            const avgIndexInData = sortedData.map((item) =>
                item.indexQueryCount > 0 ? item.totalIndexIn / item.indexQueryCount : null
            );
            const avgFetchOutData = sortedData.map((item) =>
                item.fetchQueryCount > 0 ? item.totalFetchOut / item.fetchQueryCount : null
            );

            // Create inefficiency fill data - only when Index In > Document Out
            const inefficiencyFillData = sortedData.map((item, index) => {
                const indexIn = avgIndexInData[index];
                const fetchOut = avgFetchOutData[index];
                
                // Only show fill area when Index In > Document Out (inefficient scanning)
                if (indexIn !== null && fetchOut !== null && indexIn > fetchOut) {
                    return indexIn; // Fill from Document Out up to Index In
                }
                return null; // No fill when efficient or no data
            });

            // Create enhanced operations chart
            window.enhancedOperationsChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Avg Index In per Query (with inefficiency fill)",
                            data: avgIndexInData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.25)", // Transparent Orange for fill
                            borderColor: "rgba(0, 123, 255, 1)", // Blue border
                            borderWidth: 2,
                            // No borderDash - solid line
                            fill: '+1', // Fill to next dataset (Document Out line)
                            yAxisID: "y1",
                            order: 0,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3, // Show points
                            pointHoverRadius: 5,
                        },
                        {
                            label: "Avg Document Out per Query",
                            data: avgFetchOutData,
                            type: "line",
                            backgroundColor: "rgba(40, 167, 69, 0.8)", // Green
                            borderColor: "rgba(40, 167, 69, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5], // Dotted line
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            spanGaps: false,
                            tension: 0.3,
                            pointRadius: 3, // Show points
                            pointHoverRadius: 5,
                        },
                        {
                            label: "Index In",
                            data: indexInData,
                            backgroundColor: "rgba(173, 216, 230, 0.8)", // Light Blue
                            borderColor: "rgba(135, 206, 235, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 1, // First bar (leftmost)
                        },
                        {
                            label: "Index Out",
                            data: indexOutData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2, // Second bar
                        },
                        {
                            label: "Document Fetch In",
                            data: fetchInData,
                            backgroundColor: "rgba(144, 238, 144, 0.8)", // Light Green
                            borderColor: "rgba(124, 252, 124, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 3, // Third bar
                        },
                        {
                            label: "Document Fetch Out",
                            data: fetchOutData,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 4, // Fourth bar (rightmost)
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Enhanced Database Operations: Detailed In/Out Analysis - (Beta)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Operation Count",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg Items per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.enhancedOperationsChart, ctx);
        }

        // Generate filter chart showing filter efficiency (IN vs OUT)
        function generateFilterChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.filterChart) {
                window.filterChart.destroy();
                window.filterChart = null;
            }

            const canvas = document.getElementById("filter-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime || !request.plan) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        filtersEqual: 0,
                        filtersNotEqual: 0,
                    };
                }

                // Find all Filter operators in the plan
                const operators = getOperators(request.plan);
                operators.forEach((operator) => {
                    if (operator["#operator"] === "Filter") {
                        const stats = operator["#stats"] || {};
                        const itemsIn = stats["#itemsIn"];
                        const itemsOut = stats["#itemsOut"];

                        if (itemsIn !== undefined && itemsOut !== undefined) {
                            if (itemsIn === itemsOut) {
                                timeGroups[key].filtersEqual += itemsOut;
                            } else {
                                timeGroups[key].filtersNotEqual += itemsOut;
                            }
                        }
                    }
                });
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const filtersEqualData = sortedData.map((item) => item.filtersEqual);
            const filtersNotEqualData = sortedData.map(
                (item) => item.filtersNotEqual
            );
            const percentageData = sortedData.map((item) => {
                const total = item.filtersEqual + item.filtersNotEqual;
                return total > 0 ? (item.filtersNotEqual / total) * 100 : 0;
            });

            // Create new mixed chart with bars and line
            window.filterChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Filters: IN = OUT",
                            data: filtersEqualData,
                            backgroundColor: "#007bff", // Blue
                            borderColor: "#0056b3",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                            order: 2,
                        },
                        {
                            label: "Filters: IN ≠ OUT",
                            data: filtersNotEqualData,
                            backgroundColor: "#dc3545", // Red
                            borderColor: "#b02a37",
                            borderWidth: 1,
                            yAxisID: "y",
                            stack: "stack1",
                            order: 3,
                        },
                        {
                            label: "Efficiency %",
                            data: percentageData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            tension: 0.3,
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Filter Operations Timeline: Efficiency Analysis (IN vs OUT)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.durationBucketsChart &&
                                        chart !== window.durationBucketsChart
                                    ) {
                                        window.durationBucketsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Filter Count",
                            },
                            beginAtZero: true,
                            stacked: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Efficiency %",
                            },
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.filterChart, ctx);
        }

        // Generate timeline chart showing kernel time vs execution time performance
        function generateTimelineChart(requests) {
            // Destroy existing chart if it exists - do this first
            if (window.timelineChart) {
                window.timelineChart.destroy();
                window.timelineChart = null;
            }

            const canvas = document.getElementById("timeline-chart");
            const ctx = canvas.getContext("2d");

            // Group requests by selected time unit
            const timeGroups = {};
            const grouping = getTimeGrouping();

            requests.forEach((request) => {
                if (!request.requestTime) return;

                // Parse requestTime and round based on selected grouping
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);

                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        percent0to10: 0,
                        percent10to20: 0,
                        percent20to30: 0,
                        percent30to40: 0,
                        percent40to50: 0,
                        percent50to60: 0,
                        percent60to70: 0,
                        percent70to80: 0,
                        percent80to90: 0,
                        percent90to100: 0,
                        percentOver100: 0,
                    };
                }

                // Use pre-calculated values
                const totalKernTimeMs = request.kernTimeMs || 0;
                const elapsedTimeMs = request.elapsedTimeMs || 0;

                // Calculate percentage of kernTime vs executionTime
                const kernTimePercentage =
                    elapsedTimeMs > 0 ? (totalKernTimeMs / elapsedTimeMs) * 100 : 0;

                // Group by percentage ranges
                if (kernTimePercentage < 10) {
                    timeGroups[key].percent0to10++;
                } else if (kernTimePercentage < 20) {
                    timeGroups[key].percent10to20++;
                } else if (kernTimePercentage < 30) {
                    timeGroups[key].percent20to30++;
                } else if (kernTimePercentage < 40) {
                    timeGroups[key].percent30to40++;
                } else if (kernTimePercentage < 50) {
                    timeGroups[key].percent40to50++;
                } else if (kernTimePercentage < 60) {
                    timeGroups[key].percent50to60++;
                } else if (kernTimePercentage < 70) {
                    timeGroups[key].percent60to70++;
                } else if (kernTimePercentage < 80) {
                    timeGroups[key].percent70to80++;
                } else if (kernTimePercentage < 90) {
                    timeGroups[key].percent80to90++;
                } else if (kernTimePercentage <= 100) {
                    timeGroups[key].percent90to100++;
                } else {
                    timeGroups[key].percentOver100++;
                }
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Set original time range from data
            if (sortedData.length > 0) {
                originalTimeRange.min = sortedData[0].timestamp;
                originalTimeRange.max = sortedData[sortedData.length - 1].timestamp;
                currentTimeRange = { ...originalTimeRange };
                updateTimeRangeDisplay();
            }

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const percent0to10Data = sortedData.map((item) => item.percent0to10);
            const percent10to20Data = sortedData.map((item) => item.percent10to20);
            const percent20to30Data = sortedData.map((item) => item.percent20to30);
            const percent30to40Data = sortedData.map((item) => item.percent30to40);
            const percent40to50Data = sortedData.map((item) => item.percent40to50);
            const percent50to60Data = sortedData.map((item) => item.percent50to60);
            const percent60to70Data = sortedData.map((item) => item.percent60to70);
            const percent70to80Data = sortedData.map((item) => item.percent70to80);
            const percent80to90Data = sortedData.map((item) => item.percent80to90);
            const percent90to100Data = sortedData.map(
                (item) => item.percent90to100
            );
            const percentOver100Data = sortedData.map(
                (item) => item.percentOver100
            );

            // Create new stacked bar chart
            window.timelineChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "0-10%",
                            data: percent0to10Data,
                            backgroundColor: "#28a745", // Green
                            borderColor: "#1e7e34",
                            borderWidth: 1,
                        },
                        {
                            label: "10-20%",
                            data: percent10to20Data,
                            backgroundColor: "#6cb2eb", // Light blue
                            borderColor: "#3490dc",
                            borderWidth: 1,
                        },
                        {
                            label: "20-30%",
                            data: percent20to30Data,
                            backgroundColor: "#a78bfa", // Light purple
                            borderColor: "#8b5cf6",
                            borderWidth: 1,
                        },
                        {
                            label: "30-40%",
                            data: percent30to40Data,
                            backgroundColor: "#34d399", // Light green
                            borderColor: "#10b981",
                            borderWidth: 1,
                        },
                        {
                            label: "40-50%",
                            data: percent40to50Data,
                            backgroundColor: "#fbbf24", // Yellow
                            borderColor: "#f59e0b",
                            borderWidth: 1,
                        },
                        {
                            label: "50-60%",
                            data: percent50to60Data,
                            backgroundColor: "#fb923c", // Orange
                            borderColor: "#ea580c",
                            borderWidth: 1,
                        },
                        {
                            label: "60-70%",
                            data: percent60to70Data,
                            backgroundColor: "#f472b6", // Pink
                            borderColor: "#ec4899",
                            borderWidth: 1,
                        },
                        {
                            label: "70-80%",
                            data: percent70to80Data,
                            backgroundColor: "#a855f7", // Purple
                            borderColor: "#9333ea",
                            borderWidth: 1,
                        },
                        {
                            label: "80-90%",
                            data: percent80to90Data,
                            backgroundColor: "#ef4444", // Red
                            borderColor: "#dc2626",
                            borderWidth: 1,
                        },
                        {
                            label: "90-100%",
                            data: percent90to100Data,
                            backgroundColor: "#991b1b", // Dark red
                            borderColor: "#7f1d1d",
                            borderWidth: 1,
                        },
                        {
                            label: "100%+",
                            data: percentOver100Data,
                            backgroundColor: "#450a0a", // Very dark red
                            borderColor: "#1c0a0a",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        intersect: false,
                        mode: "index",
                    },
                    elements: {
                        point: {
                            radius: 0, // Hide points for better performance
                            hoverRadius: 4,
                        },
                    },
                    scales: {
                        x: {
                            stacked: true,
                            type: "time",
                            time: {
                                displayFormats: {
                                    minute: "HH:mm",
                                    hour: "MM-DD HH:mm",
                                },
                            },
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                        },
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Performance Timeline: KernTime % of ExecutionTime",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range - convert chart scale values to Date objects
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                            stacked: true,
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Query Count",
                            },
                            stacked: true,
                            beginAtZero: true,
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.timelineChart, ctx);

            // Create Query Types Scatter Plot Chart
            createQueryTypesChart(requests, grouping);

            // Create Duration Buckets Chart
            createDurationBucketsChart(requests, grouping);

            // Create Memory Usage Chart
            createMemoryChart(requests, grouping);

            // Create Result Count Chart
            createResultCountChart(requests, grouping);

            // Create Result Size Chart
            createResultSizeChart(requests, grouping);

            // Create CPU/Kernel/Elapsed Time Chart
            createCpuTimeChart(requests, grouping);

            // Create ExecTime vs Kernel Time Chart
            createExecVsKernelChart(requests, grouping);

            // Create ExecTime vs ServTime Chart
            createExecVsServChart(requests, grouping);

            // Create ExecTime vs Elapsed Time Chart
            createExecVsElapsedChart(requests, grouping);

            // Create Enhanced Operations Chart
            generateEnhancedOperationsChart(requests);

            // Initialize drag and drop for execution analysis charts
            setupChartDragAndDrop();
        }

        // Create Query Types Scatter Plot Chart
        function createQueryTypesChart(requests, grouping) {
            const canvas = document.getElementById("query-types-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.queryTypesChart) {
                window.queryTypesChart.destroy();
            }

            // Group requests by time and statement type
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        statementTypes: {},
                        fatalCount: 0,
                    };
                }

                // Track fatal queries separately
                if (request.state && request.state.toLowerCase() === 'fatal') {
                    timeGroups[key].fatalCount++;
                    if (!timeGroups[key].fatalElapsedTimes) {
                        timeGroups[key].fatalElapsedTimes = [];
                    }
                    // Get duration in milliseconds and convert to seconds
                    const elapsedTimeMs = parseTime(request.elapsedTime);
                    const durationSeconds = elapsedTimeMs / 1000;
                    timeGroups[key].fatalElapsedTimes.push(durationSeconds);
                }

                // Use consistent statement type parsing
                let statementType = request.statementType || deriveStatementType(request.statement || request.preparedText) || "UNKNOWN";

                if (!timeGroups[key].statementTypes[statementType]) {
                    timeGroups[key].statementTypes[statementType] = {
                        count: 0,
                        durations: [],
                    };
                }

                timeGroups[key].statementTypes[statementType].count++;

                // Get duration in seconds
                const elapsedTimeMs = parseTime(request.elapsedTime);
                const durationSeconds = elapsedTimeMs / 1000;
                timeGroups[key].statementTypes[statementType].durations.push(
                    durationSeconds
                );
            });

            // Get all unique statement types
            const allStatementTypes = new Set();
            Object.values(timeGroups).forEach((group) => {
                Object.keys(group.statementTypes).forEach((type) => {
                    allStatementTypes.add(type);
                });
            });

            // Log all statement types found (removed for production)

            // Predefined colors for all statement types found
            const colorMap = {
                SELECT: "#007bff", // Blue
                INSERT: "#28a745", // Green
                DELETE: "#dc3545", // Red
                UPSERT: "#6f42c1", // Purple
                CREATE: "#fd7e14", // Orange
                DROP: "#e83e8c", // Pink
                EXPLAIN: "#20c997", // Teal
                ADVISE: "#17a2b8", // Cyan
                INFER: "#ffc107", // Yellow
                WITH: "#6c757d", // Gray
                PREPARE: "#fd7e14", // Orange-red
                EXECUTE: "#6610f2", // Indigo
                "--": "#343a40", // Dark gray (comments)
                UNKNOWN: "#868e96", // Light gray
            };

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.statementTypes).forEach((typeData) => {
                    minCount = Math.min(minCount, typeData.count);
                    maxCount = Math.max(maxCount, typeData.count);
                });
            });

            // Generate datasets for each statement type with variable circle sizes
            const datasets = Array.from(allStatementTypes).map((statementType) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    if (group.statementTypes[statementType]) {
                        const typeData = group.statementTypes[statementType];
                        // Calculate average duration for this time group and statement type
                        const avgDuration =
                            typeData.durations.reduce((sum, d) => sum + d, 0) /
                            typeData.durations.length;

                        // Calculate circle size based on count (3-15 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (typeData.count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 3 + sizeRatio * 12; // Range from 3 to 15 pixels

                        data.push({
                            x: group.timestamp,
                            y: avgDuration,
                            r: circleSize,
                            count: typeData.count,
                            maxDuration: Math.max(...typeData.durations),
                            minDuration: Math.min(...typeData.durations),
                        });
                    }
                });

                return {
                    label: `${statementType} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 50%)`,
                    borderColor:
                        colorMap[statementType] ||
                        `hsl(${(Array.from(allStatementTypes).indexOf(statementType) * 137.5) %
                        360
                        }, 70%, 40%)`,
                    borderWidth: 1,
                };
            });

            // Add fatal queries dataset for right Y-axis
            const fatalData = [];
            let maxFatalCount = 0;

            Object.values(timeGroups).forEach((group) => {
                if (group.fatalCount > 0) {
                    maxFatalCount = Math.max(maxFatalCount, group.fatalCount);
                    // Calculate average elapsed time for fatal queries in this time period
                    const avgElapsedTime = group.fatalElapsedTimes && group.fatalElapsedTimes.length > 0
                        ? group.fatalElapsedTimes.reduce((sum, time) => sum + time, 0) / group.fatalElapsedTimes.length
                        : 0;
                    fatalData.push({
                        x: group.timestamp,
                        y: group.fatalCount,
                        count: group.fatalCount,
                        avgElapsedTime: avgElapsedTime,
                    });
                }
            });

            if (fatalData.length > 0) {
                datasets.push({
                    label: `Fatal Queries (${fatalData.reduce((sum, point) => sum + point.count, 0)} total)`,
                    data: fatalData.map(point => ({
                        x: point.x,
                        y: point.y,
                        count: point.count,
                        avgElapsedTime: point.avgElapsedTime
                    })),
                    type: 'scatter', // Use scatter instead of bubble for different point style
                    backgroundColor: '#FF0000', // Bright red
                    borderColor: '#FF0000', // Red outline to match fatal styling
                    borderWidth: 3,
                    pointRadius: fatalData.map(point => Math.min(20, Math.max(8, point.count * 3))), // Larger and more variable sizing
                    pointStyle: 'crossRot', // X shape instead of circle
                    yAxisID: 'y1', // Use right Y-axis
                    showLine: false, // Don't connect points with lines
                });
            }

            // Create bubble chart
            window.queryTypesChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: TEXT_CONSTANTS.QUERY_DURATION_CHART_TITLE,
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const datasetLabel = context.dataset.label;
                                    const statementType = datasetLabel.split(" (")[0];

                                    // Handle fatal queries dataset differently
                                    if (statementType === "Fatal Queries") {
                                        return [
                                            `${statementType}`,
                                            `${TEXT_CONSTANTS.FATAL_LABEL} ${dataPoint.count}`,
                                            `${TEXT_CONSTANTS.ELAPSED_LABEL} ${dataPoint.avgElapsedTime.toFixed(3)}s`,
                                        ];
                                    } else {
                                        // Handle regular statement type datasets
                                        return [
                                            `${statementType}`,
                                            `${TEXT_CONSTANTS.COUNT_LABEL} ${dataPoint.count}`,
                                            `${TEXT_CONSTANTS.AVG_LABEL} ${dataPoint.y.toFixed(3)}s`,
                                            `${TEXT_CONSTANTS.MIN_LABEL} ${dataPoint.minDuration.toFixed(3)}s`,
                                            `${TEXT_CONSTANTS.MAX_LABEL} ${dataPoint.maxDuration.toFixed(3)}s`,
                                        ];
                                    }
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Average Duration (seconds)",
                            },
                            beginAtZero: true,
                            position: "left",
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Fatal Query Count",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.queryTypesChart, ctx);
        }

        // Create Duration Buckets Chart
        function createDurationBucketsChart(requests, grouping) {
            const canvas = document.getElementById("duration-buckets-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.durationBucketsChart) {
                window.durationBucketsChart.destroy();
            }

            // Group requests by time and duration buckets
            const timeGroups = {};



            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        durationBuckets: {
                            "0-1s": 0,
                            "1-2s": 0,
                            "2-3s": 0,
                            "3-4s": 0,
                            "4-5s": 0,
                            "5-10s": 0,
                            "10-30s": 0,
                            "30-60s": 0,
                            "60-120s": 0,
                            "120-240s": 0,
                            "240-500s": 0,
                            "500-900s": 0,
                            "900s+": 0,
                        },
                    };
                }

                // Get duration in seconds
                const durationMs = parseTime(request.elapsedTime);
                const durationSeconds = durationMs / 1000;

                // Categorize into duration buckets
                if (durationSeconds < 1) {
                    timeGroups[key].durationBuckets["0-1s"]++;
                } else if (durationSeconds < 2) {
                    timeGroups[key].durationBuckets["1-2s"]++;
                } else if (durationSeconds < 3) {
                    timeGroups[key].durationBuckets["2-3s"]++;
                } else if (durationSeconds < 4) {
                    timeGroups[key].durationBuckets["3-4s"]++;
                } else if (durationSeconds < 5) {
                    timeGroups[key].durationBuckets["4-5s"]++;
                } else if (durationSeconds < 10) {
                    timeGroups[key].durationBuckets["5-10s"]++;
                } else if (durationSeconds < 30) {
                    timeGroups[key].durationBuckets["10-30s"]++;
                } else if (durationSeconds < 60) {
                    timeGroups[key].durationBuckets["30-60s"]++;
                } else if (durationSeconds < 120) {
                    timeGroups[key].durationBuckets["60-120s"]++;
                } else if (durationSeconds < 240) {
                    timeGroups[key].durationBuckets["120-240s"]++;
                } else if (durationSeconds < 500) {
                    timeGroups[key].durationBuckets["240-500s"]++;
                } else if (durationSeconds < 900) {
                    timeGroups[key].durationBuckets["500-900s"]++;
                } else {
                    timeGroups[key].durationBuckets["900s+"]++;
                }
            });

            if (Object.keys(timeGroups).length > 0) {
            }

            // Calculate min/max counts for circle sizing
            let minCount = Infinity;
            let maxCount = 0;
            Object.values(timeGroups).forEach((group) => {
                Object.values(group.durationBuckets).forEach((count) => {
                    if (count > 0) {
                        minCount = Math.min(minCount, count);
                        maxCount = Math.max(maxCount, count);
                    }
                });
            });

            // Color mapping for duration buckets - progressive darkness
            const bucketColors = {
                "0-1s": "#28a745", // Green - fast
                "1-2s": "#6cb2eb", // Light blue
                "2-3s": "#ffc107", // Yellow
                "3-4s": "#fd7e14", // Orange
                "4-5s": "#dc3545", // Red
                "5-10s": "#6f42c1", // Purple
                "10-30s": "#495057", // Dark gray
                "30-60s": "#343a40", // Darker gray
                "60-120s": "#721c24", // Dark red
                "120-240s": "#5a1a1a", // Darker red
                "240-500s": "#450a0a", // Very dark red
                "500-900s": "#2d0a0a", // Extremely dark red
                "900s+": "#1a0404", // Nearly black red
            };

            // Generate datasets for each duration bucket
            const datasets = Object.keys(bucketColors).map((bucket) => {
                const data = [];

                Object.values(timeGroups).forEach((group) => {
                    const count = group.durationBuckets[bucket];
                    if (count > 0) {
                        // Calculate circle size based on count (5-20 pixel radius)
                        const sizeRatio =
                            maxCount > minCount
                                ? (count - minCount) / (maxCount - minCount)
                                : 0.5;
                        const circleSize = 5 + sizeRatio * 15; // Range from 5 to 20 pixels

                        // Use bucket midpoint for y-axis position
                        let yPosition;
                        switch (bucket) {
                            case "0-1s":
                                yPosition = 0.5;
                                break;
                            case "1-2s":
                                yPosition = 1.5;
                                break;
                            case "2-3s":
                                yPosition = 2.5;
                                break;
                            case "3-4s":
                                yPosition = 3.5;
                                break;
                            case "4-5s":
                                yPosition = 4.5;
                                break;
                            case "5-10s":
                                yPosition = 7.5;
                                break;
                            case "10-30s":
                                yPosition = 20;
                                break;
                            case "30-60s":
                                yPosition = 45;
                                break;
                            case "60-120s":
                                yPosition = 90;
                                break;
                            case "120-240s":
                                yPosition = 180;
                                break;
                            case "240-500s":
                                yPosition = 370;
                                break;
                            case "500-900s":
                                yPosition = 700;
                                break;
                            case "900s+":
                                yPosition = 1200;
                                break;
                        }

                        data.push({
                            x: group.timestamp,
                            y: yPosition,
                            r: circleSize,
                            count: count,
                        });
                    }
                });

                return {
                    label: `${bucket} (${data.reduce(
                        (sum, point) => sum + point.count,
                        0
                    )} total)`,
                    data: data,
                    backgroundColor: bucketColors[bucket],
                    borderColor: bucketColors[bucket],
                    borderWidth: 1,
                };
            });

            // Create bubble chart
            window.durationBucketsChart = new Chart(ctx, {
                type: "bubble",
                data: {
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Query Duration Distribution by Time Buckets (Bubble Size = Query Count)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataPoint = context.raw;
                                    const bucket = context.dataset.label.split(" (")[0];
                                    return [
                                        `${bucket}`,
                                        `Count: ${dataPoint.count}`,
                                        `${new Date(dataPoint.x).toLocaleString()}`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: {
                                displayFormats: {
                                    millisecond: "HH:mm:ss.SSS",
                                    second: "HH:mm:ss",
                                    minute: "HH:mm",
                                    hour: "HH:mm",
                                    day: "MM/dd",
                                    week: "MM/dd",
                                    month: "MM/yy",
                                    quarter: "MM/yy",
                                    year: "yyyy",
                                },
                            },
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Duration Range (seconds)",
                            },
                            beginAtZero: true,
                            type: "logarithmic",
                            ticks: {
                                callback: function (value) {
                                    if (value === 0.5) return "0-1s";
                                    if (value === 1.5) return "1-2s";
                                    if (value === 2.5) return "2-3s";
                                    if (value === 3.5) return "3-4s";
                                    if (value === 4.5) return "4-5s";
                                    if (value === 7.5) return "5-10s";
                                    if (value === 20) return "10-30s";
                                    if (value === 45) return "30-60s";
                                    if (value === 90) return "60-120s";
                                    if (value === 180) return "120-240s";
                                    if (value === 370) return "240-500s";
                                    if (value === 700) return "500-900s";
                                    if (value === 1200) return "900s+";
                                    return "";
                                },
                            },
                        },
                    },
                    interaction: {
                        mode: "point",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.durationBucketsChart, ctx);
        }

        // Create Memory Usage Chart
        function createMemoryChart(requests, grouping) {
            const canvas = document.getElementById("memory-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.memoryChart) {
                window.memoryChart.destroy();
            }

            // Group requests by time and sum memory usage
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalMemoryBytes: 0,
                        queryCount: 0,
                    };
                }

                // Use pre-calculated memory value
                const usedMemoryBytes = request.memoryBytes || 0;
                timeGroups[key].totalMemoryBytes += usedMemoryBytes;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array and convert bytes to MB
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map((item) => ({
                    timestamp: item.timestamp,
                    totalMemoryMB: item.totalMemoryBytes / (1024 * 1024), // Convert bytes to MB
                    queryCount: item.queryCount,
                }));

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const memoryData = sortedData.map((item) => item.totalMemoryMB);

            // Calculate average memory per query for line chart
            const avgMemoryData = sortedData.map(
                (item) => item.totalMemoryMB / item.queryCount
            );

            // Create memory usage bar chart with line overlay
            window.memoryChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Memory Usage (MB)",
                            data: memoryData,
                            backgroundColor: "#17a2b8", // Info blue-cyan
                            borderColor: "#138496",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg per Query (MB)",
                            data: avgMemoryData,
                            type: "line",
                            backgroundColor: "#fd7e14", // Orange
                            borderColor: "#fd7e14",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            tension: 0.3,
                            order: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: "Total Query Process Memory Usage",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const dataIndex = context.dataIndex;
                                    const memoryMB = context.parsed.y;
                                    const queryCount = sortedData[dataIndex].queryCount;
                                    return [
                                        `Memory Usage: ${memoryMB.toFixed(2)} MB`,
                                        `Queries: ${queryCount}`,
                                        `Avg per Query: ${(memoryMB / queryCount).toFixed(2)} MB`,
                                    ];
                                },
                            },
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();

                                    // Sync pan with other charts
                                    if (
                                        window.operationsChart &&
                                        chart !== window.operationsChart
                                    ) {
                                        window.operationsChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.filterChart && chart !== window.filterChart) {
                                        window.filterChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.timelineChart &&
                                        chart !== window.timelineChart
                                    ) {
                                        window.timelineChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (
                                        window.queryTypesChart &&
                                        chart !== window.queryTypesChart
                                    ) {
                                        window.queryTypesChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                    if (window.memoryChart && chart !== window.memoryChart) {
                                        window.memoryChart.zoomScale(
                                            "x",
                                            { min: chart.scales.x.min, max: chart.scales.x.max },
                                            "none"
                                        );
                                    }
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(
                                        chart,
                                        chart.scales.x.min,
                                        chart.scales.x.max
                                    );
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Memory Usage (MB)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query (MB)",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.memoryChart, ctx);
        }

        // Create Result Count Chart (light green bar + orange line for resultCount/query)
        function createResultCountChart(requests, grouping) {
            const canvas = document.getElementById("result-count-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.resultCountChart) {
                window.resultCountChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalResultCount: 0,
                        queryCount: 0,
                    };
                }

                const resultCount = request.resultCount || 0;
                timeGroups[key].totalResultCount += resultCount;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const resultCountData = sortedData.map((item) => item.totalResultCount);
            const avgResultCountData = sortedData.map((item) =>
                item.queryCount > 0 ? item.totalResultCount / item.queryCount : 0
            );

            window.resultCountChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Total Result Count",
                            data: resultCountData,
                            backgroundColor: "rgba(144, 238, 144, 0.8)", // Light green
                            borderColor: "rgba(144, 238, 144, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Result Count per Query",
                            data: avgResultCountData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Result Count Analysis: Total vs Average per Query",
                        },
                        legend: {
                            display: true,
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Total Result Count",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.resultCountChart, ctx);
        }

        // Create Result Size Chart (dark green bar + orange line for resultSize/query)
        function createResultSizeChart(requests, grouping) {
            const canvas = document.getElementById("result-size-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.resultSizeChart) {
                window.resultSizeChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        totalResultSize: 0,
                        queryCount: 0,
                    };
                }

                const resultSize = request.resultSize || 0;
                timeGroups[key].totalResultSize += resultSize;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array
            const sortedData = Object.values(timeGroups).sort(
                (a, b) => a.timestamp - b.timestamp
            );

            // Prepare chart data (convert bytes to MB)
            const labels = sortedData.map((item) => item.timestamp);
            const resultSizeData = sortedData.map((item) => item.totalResultSize / (1024 * 1024));
            const avgResultSizeData = sortedData.map((item) =>
                item.queryCount > 0 ? (item.totalResultSize / item.queryCount) / (1024 * 1024) : 0
            );

            window.resultSizeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Total Result Size (MB)",
                            data: resultSizeData,
                            backgroundColor: "rgba(0, 100, 0, 0.8)", // Dark green
                            borderColor: "rgba(0, 100, 0, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Result Size per Query (MB)",
                            data: avgResultSizeData,
                            type: "line",
                            backgroundColor: "rgba(255, 165, 0, 0.8)", // Orange
                            borderColor: "rgba(255, 165, 0, 1)",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "Result Size Analysis: Total vs Average per Query",
                        },
                        legend: {
                            display: true,
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Total Result Size (MB)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Avg per Query (MB)",
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.resultSizeChart, ctx);
        }

        // Create CPU/Kernel/Elapsed Time Analysis Chart
        function createCpuTimeChart(requests, grouping) {
            const canvas = document.getElementById("cpu-time-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.cpuTimeChart) {
                window.cpuTimeChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        cpuTimeSum: 0,
                        elapsedTimeSum: 0,
                        kernTimeSum: 0,
                        queryCount: 0,
                    };
                }

                // Parse time values - handle both string and number formats
                const cpuTimeMs = parseTime(request.cpuTime) || 0;
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;

                timeGroups[key].cpuTimeSum += cpuTimeMs;
                timeGroups[key].elapsedTimeSum += elapsedTimeMs;
                timeGroups[key].kernTimeSum += kernTimeMs;
                timeGroups[key].queryCount++;
            });

            // Convert to sorted array and calculate averages
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgCpuTime: item.queryCount > 0 ? item.cpuTimeSum / item.queryCount : 0,
                    avgElapsedTime: item.queryCount > 0 ? item.elapsedTimeSum / item.queryCount : 0,
                    avgKernTime: item.queryCount > 0 ? item.kernTimeSum / item.queryCount : 0,
                }));

            // Prepare chart data
            const labels = sortedData.map((item) => item.timestamp);
            const avgCpuTimeData = sortedData.map((item) => item.avgCpuTime);
            const avgKernTimeData = sortedData.map((item) => item.avgKernTime);
            const avgElapsedTimeData = sortedData.map((item) => item.avgElapsedTime);

            // Calculate percentage data for line graphs
            const cpuKernPercentData = sortedData.map((item) => {
                return item.avgKernTime > 0 ? (item.avgCpuTime / item.avgKernTime) * 100 : 0;
            });

            const cpuElapsedPercentData = sortedData.map((item) => {
                return item.avgElapsedTime > 0 ? (item.avgCpuTime / item.avgElapsedTime) * 100 : 0;
            });

            window.cpuTimeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Avg CPU Time (ms)",
                            data: avgCpuTimeData,
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 1,
                        },
                        {
                            label: "Avg Kernel Time (ms)",
                            data: avgKernTimeData,
                            backgroundColor: "rgba(255, 99, 132, 0.8)", // Red
                            borderColor: "rgba(255, 99, 132, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 2,
                        },
                        {
                            label: "Avg Elapsed Time (ms)",
                            data: avgElapsedTimeData,
                            backgroundColor: "rgba(75, 192, 192, 0.8)", // Teal
                            borderColor: "rgba(75, 192, 192, 1)",
                            borderWidth: 1,
                            yAxisID: "y",
                            order: 3,
                        },
                        {
                            label: "CPU as % of Kernel",
                            data: cpuKernPercentData,
                            type: "line",
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y1",
                            order: 1,
                            tension: 0.3,
                        },
                        {
                            label: "CPU as % of Elapsed (dotted)",
                            data: cpuElapsedPercentData,
                            type: "line",
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5], // Dotted line
                            fill: false,
                            yAxisID: "y1",
                            order: 0,
                            tension: 0.3,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "CPU/Kernel/Elapsed Time Analysis - (Beta)",
                        },
                        legend: {
                            display: true,
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function (tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    return [
                                        `Queries: ${data.queryCount}`,
                                        `CPU: ${data.avgCpuTime.toFixed(2)}ms`,
                                        `Kernel: ${data.avgKernTime.toFixed(2)}ms`,
                                        `Elapsed: ${data.avgElapsedTime.toFixed(2)}ms`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "Time (ms)",
                            },
                            beginAtZero: true,
                        },
                        y1: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "Percentage (%)",
                            },
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 100, // Always show 0-100% range, scale higher if needed
                            grid: {
                                drawOnChartArea: false,
                            },
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            // Register chart for crosshair synchronization
            registerTimelineChart(window.cpuTimeChart, ctx);
        }

        // Create Execution Analysis Chart (ExecTime vs ServTime/KernTime percentages)
        function createExecVsKernelChart(requests, grouping) {
            const canvas = document.getElementById("exec-vs-kernel-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.execVsKernelChart) {
                window.execVsKernelChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        authorizeData: [],
                        parseData: [],
                        planData: [],
                        indexScanData: [],
                        fetchData: [],
                        filterData: [],
                        streamData: [],
                        kernTimeData: [],
                        elapsedTimeData: [],
                        queryCount: 0,
                    };
                }

                timeGroups[key].queryCount++;

                // Extract data from phaseTimes and plan operators
                if (request.phaseTimes) {
                    const parseTimeMs = parseTime(request.phaseTimes.parse) || 0;
                    const planTimeMs = parseTime(request.phaseTimes.plan) || 0;
                    timeGroups[key].parseData.push(parseTimeMs);
                    timeGroups[key].planData.push(planTimeMs);
                }

                // Extract kernel time from plan
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                timeGroups[key].kernTimeData.push(kernTimeMs);

                // Extract elapsed time for ratio calculation
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                timeGroups[key].elapsedTimeData.push(elapsedTimeMs);

                // Extract operator-specific data from plan
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const execTime = parseTime(stats.execTime) || 0;

                            switch (operatorType) {
                                case "Authorize":
                                    timeGroups[key].authorizeData.push({ execTime });
                                    break;
                                case "IndexScan3":
                                    timeGroups[key].indexScanData.push({ execTime });
                                    break;
                                case "Fetch":
                                    timeGroups[key].fetchData.push({ execTime });
                                    break;
                                case "Filter":
                                    timeGroups[key].filterData.push({ execTime });
                                    break;
                                case "Stream":
                                    timeGroups[key].streamData.push({ execTime });
                                    break;
                            }
                        });
                    } catch (e) {
                        console.warn("Error parsing plan for exec analysis:", e);
                    }
                }
            });

            // Convert to sorted array and calculate percentages vs kernel time
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgAuthorizeExecTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length : 0,
                    avgParseTime: item.parseData.length > 0 ? 
                        item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length : 0,
                    avgPlanTime: item.planData.length > 0 ? 
                        item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length : 0,
                    avgIndexScanExecTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length : 0,
                    avgFetchExecTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length : 0,
                    avgFilterExecTime: item.filterData.length > 0 ? 
                        item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length : 0,
                    avgStreamExecTime: item.streamData.length > 0 ? 
                        item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length : 0,
                    avgKernTime: item.kernTimeData.length > 0 ? 
                        item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0,
                }));

            const authorizeVsKernPercentData = sortedData.map((item) => {
                if (item.authorizeData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgAuthorizeExecTime = item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgAuthorizeExecTime / avgKernTime) * 100 : 0;
            });

            const parseVsKernPercentData = sortedData.map((item) => {
                if (item.parseData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgParseTime = item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgParseTime / avgKernTime) * 100 : 0;
            });

            const planVsKernPercentData = sortedData.map((item) => {
                if (item.planData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgPlanTime = item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgPlanTime / avgKernTime) * 100 : 0;
            });

            const indexScanVsKernPercentData = sortedData.map((item) => {
                if (item.indexScanData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgIndexScanExecTime = item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgIndexScanExecTime / avgKernTime) * 100 : 0;
            });

            const fetchVsKernPercentData = sortedData.map((item) => {
                if (item.fetchData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgFetchExecTime = item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgFetchExecTime / avgKernTime) * 100 : 0;
            });

            const filterVsKernPercentData = sortedData.map((item) => {
                if (item.filterData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgFilterExecTime = item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgFilterExecTime / avgKernTime) * 100 : 0;
            });

            const streamVsKernPercentData = sortedData.map((item) => {
                if (item.streamData.length === 0 || item.kernTimeData.length === 0) return 0;
                const avgStreamExecTime = item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length;
                const avgKernTime = item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length;
                return avgKernTime > 0 ? (avgStreamExecTime / avgKernTime) * 100 : 0;
            });

            // Calculate KernTime vs ElapsedTime percentage for new red dotted line
            const kernVsElapsedPercentData = sortedData.map((item) => {
                const avgKernTime = item.kernTimeData.length > 0 ? 
                    item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0;
                const avgElapsedTime = item.elapsedTimeData.length > 0 ? 
                    item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0;
                return avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
            });

            const labels = sortedData.map((item) => item.timestamp);

            window.execVsKernelChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Authorize: ExecTime vs Kernel Time (%)",
                            data: authorizeVsKernPercentData,
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue (matches ServTime chart)
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Parse vs Kernel Time (%)",
                            data: parseVsKernPercentData,
                            backgroundColor: "rgba(255, 99, 132, 0.8)", // Red
                            borderColor: "rgba(255, 99, 132, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Plan vs Kernel Time (%)",
                            data: planVsKernPercentData,
                            backgroundColor: "rgba(75, 192, 192, 0.8)", // Teal
                            borderColor: "rgba(75, 192, 192, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "IndexScan: ExecTime vs Kernel Time (%)",
                            data: indexScanVsKernPercentData,
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow (matches ServTime chart)
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Fetch: ExecTime vs Kernel Time (%)",
                            data: fetchVsKernPercentData,
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple (matches ServTime chart)
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Filter vs Kernel Time (%)",
                            data: filterVsKernPercentData,
                            backgroundColor: "rgba(255, 159, 64, 0.8)", // Orange
                            borderColor: "rgba(255, 159, 64, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Stream vs Kernel Time (%)",
                            data: streamVsKernPercentData,
                            backgroundColor: "rgba(201, 203, 207, 0.8)", // Gray
                            borderColor: "rgba(201, 203, 207, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Kernel vs Elapsed Time (%)",
                            data: kernVsElapsedPercentData,
                            backgroundColor: "rgba(255, 0, 0, 0.8)", // Bright Red
                            borderColor: "rgba(255, 0, 0, 1)",
                            borderWidth: 3,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3], // Custom dash pattern
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0, // No points
                            pointHoverRadius: 0, // No hover points
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "ExecTime vs Highest Kernel Time (%) By Query Steps - (Beta)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                beforeBody: function() {
                                    return 'ExecTime vs Highest Kernel Time (%):';
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value === null || value === undefined) return null;
                                    // Extract just the operator name from various label formats
                                    let operatorName = context.dataset.label;
                                    if (operatorName.includes(':')) {
                                        operatorName = operatorName.split(':')[0];
                                    } else if (operatorName.includes(' vs ')) {
                                        operatorName = operatorName.split(' vs ')[0];
                                    }
                                    return `  ${operatorName}: ${value.toFixed(2)}%`;
                                },
                                afterBody: function(tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    const avgElapsedTime = data.elapsedTimeData.length > 0 ? 
                                        data.elapsedTimeData.reduce((sum, d) => sum + d, 0) / data.elapsedTimeData.length : 0;
                                    const kernElapsedRatio = avgElapsedTime > 0 ? (data.avgKernTime / avgElapsedTime) * 100 : 0;
                                    return [
                                        '',
                                        `Kernel vs Elapsed: ${kernElapsedRatio.toFixed(1)}%`,
                                        `Queries: ${data.queryCount}`,
                                        `Kernel Time: ${data.avgKernTime.toFixed(1)}ms`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync pan with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: {
                                    enabled: false,
                                },
                                pinch: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    // Update current time range
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    // Sync zoom with other charts
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: {
                                display: true,
                                text: "Request Time",
                            },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: { display: true, text: "Percentage (%)" },
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 100,
                        },
                    },
                    interaction: {
                        mode: "index",
                        intersect: false,
                    },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.execVsKernelChart, ctx);
        }

        // Create ExecTime vs ServTime Chart (operators with servTime)
        function createExecVsServChart(requests, grouping) {
            const canvas = document.getElementById("exec-vs-serv-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.execVsServChart) {
                window.execVsServChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        authorizeData: [],
                        indexScanData: [],
                        fetchData: [],
                        kernTimeData: [],
                        elapsedTimeData: [],
                        queryCount: 0,
                    };
                }

                timeGroups[key].queryCount++;

                // Extract kernel and elapsed time for ratio calculation
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                timeGroups[key].kernTimeData.push(kernTimeMs);
                timeGroups[key].elapsedTimeData.push(elapsedTimeMs);

                // Extract operator-specific data from plan
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const execTime = parseTime(stats.execTime) || 0;
                            const servTime = parseTime(stats.servTime) || 0;

                            switch (operatorType) {
                                case "Authorize":
                                    timeGroups[key].authorizeData.push({ execTime, servTime });
                                    break;
                                case "IndexScan3":
                                    timeGroups[key].indexScanData.push({ execTime, servTime });
                                    break;
                                case "Fetch":
                                    timeGroups[key].fetchData.push({ execTime, servTime });
                                    break;
                            }
                        });
                    } catch (e) {
                        console.warn("Error parsing plan for exec vs serv analysis:", e);
                    }
                }
            });

            // Convert to sorted array and calculate percentages vs servTime
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgAuthorizeExecTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length : 0,
                    avgAuthorizeServTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.servTime, 0) / item.authorizeData.length : 0,
                    avgIndexScanExecTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length : 0,
                    avgIndexScanServTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.servTime, 0) / item.indexScanData.length : 0,
                    avgFetchExecTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length : 0,
                    avgFetchServTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.servTime, 0) / item.fetchData.length : 0,
                }));

            const authorizePercentData = sortedData.map((item) => {
                if (item.authorizeData.length === 0) return 0;
                const avgExecTime = item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length;
                const avgServTime = item.authorizeData.reduce((sum, d) => sum + d.servTime, 0) / item.authorizeData.length;
                return avgServTime > 0 ? (avgExecTime / avgServTime) * 100 : 0;
            });

            const indexScanPercentData = sortedData.map((item) => {
                if (item.indexScanData.length === 0) return 0;
                const avgExecTime = item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length;
                const avgServTime = item.indexScanData.reduce((sum, d) => sum + d.servTime, 0) / item.indexScanData.length;
                return avgServTime > 0 ? (avgExecTime / avgServTime) * 100 : 0;
            });

            const fetchPercentData = sortedData.map((item) => {
                if (item.fetchData.length === 0) return 0;
                const avgExecTime = item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length;
                const avgServTime = item.fetchData.reduce((sum, d) => sum + d.servTime, 0) / item.fetchData.length;
                return avgServTime > 0 ? (avgExecTime / avgServTime) * 100 : 0;
            });

            // Calculate KernTime vs ElapsedTime percentage for new red dotted line
            const kernVsElapsedPercentData = sortedData.map((item) => {
                const avgKernTime = item.kernTimeData.length > 0 ? 
                    item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0;
                const avgElapsedTime = item.elapsedTimeData.length > 0 ? 
                    item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0;
                return avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
            });

            const labels = sortedData.map((item) => item.timestamp);

            window.execVsServChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                    {
                    label: "Authorize: ExecTime vs ServTime (%)",
                    data: authorizePercentData,
                    backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue
                    borderColor: "rgba(54, 162, 235, 1)",
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3,
                        yAxisID: 'y'
                    },
                    {
                    label: "IndexScan: ExecTime vs ServTime (%)",
                    data: indexScanPercentData,
                    backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow
                    borderColor: "rgba(255, 206, 86, 1)",
                    borderWidth: 2,
                    fill: false,
                        tension: 0.3,
                        yAxisID: 'y'
                    },
                    {
                    label: "Fetch: ExecTime vs ServTime (%)",
                    data: fetchPercentData,
                    backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple
                    borderColor: "rgba(153, 102, 255, 1)",
                    borderWidth: 2,
                        fill: false,
                            tension: 0.3,
                            yAxisID: 'y'
                        },
                        {
                            label: "Authorize: Avg ServTime (ms)",
                            data: sortedData.map(item => item.avgAuthorizeServTime),
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            yAxisID: 'y1'
                        },
                        {
                            label: "IndexScan: Avg ServTime (ms)",
                            data: sortedData.map(item => item.avgIndexScanServTime),
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            yAxisID: 'y1'
                        },
                        {
                            label: "Fetch: Avg ServTime (ms)",
                            data: sortedData.map(item => item.avgFetchServTime),
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            yAxisID: 'y1'
                        },
                        {
                            label: "Kernel vs Elapsed Time (%)",
                            data: kernVsElapsedPercentData,
                            backgroundColor: "rgba(255, 0, 0, 0.8)", // Bright Red
                            borderColor: "rgba(255, 0, 0, 1)",
                            borderWidth: 3,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3], // Custom dash pattern
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0, // No points
                            pointHoverRadius: 0, // No hover points
                            yAxisID: 'y'
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "ExecTime vs ServTime (%) by Services in Query Execution - (Beta)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                beforeBody: function() {
                                    return 'ExecTime Vs ServTime (%) | Avg ServTime';
                                },
                                label: function(context) {
                                const value = context.parsed.y;
                                if (value === null || value === undefined) return null;
                                    
                                    // Only show labels for percentage datasets, skip service time datasets
                                if (context.dataset.label.includes('Avg ServTime')) return null;
                                
                                const dataIndex = context.dataIndex;
                                const data = sortedData[dataIndex];
                                
                                // Extract just the operator name from various label formats
                                let operatorName = context.dataset.label;
                                if (operatorName.includes(':')) {
                                    operatorName = operatorName.split(':')[0];
                                } else if (operatorName.includes(' vs ')) {
                                operatorName = operatorName.split(' vs ')[0];
                                }
                                
                                    // Get the corresponding service time for this operator
                                     let servTime = 0;
                                     if (operatorName === 'Authorize') {
                                         servTime = data.avgAuthorizeServTime;
                                     } else if (operatorName === 'IndexScan') {
                                         servTime = data.avgIndexScanServTime;
                                     } else if (operatorName === 'Fetch') {
                                         servTime = data.avgFetchServTime;
                                     }
                                     
                                     return `  ${operatorName}: ${value.toFixed(2)}% | ${servTime.toFixed(1)}ms`;
                                 },
                                afterBody: function(tooltipItems) {
                                const dataIndex = tooltipItems[0].dataIndex;
                                const data = sortedData[dataIndex];
                                const avgKernTime = data.kernTimeData.length > 0 ? 
                                    data.kernTimeData.reduce((sum, d) => sum + d, 0) / data.kernTimeData.length : 0;
                                const avgElapsedTime = data.elapsedTimeData.length > 0 ? 
                                    data.elapsedTimeData.reduce((sum, d) => sum + d, 0) / data.elapsedTimeData.length : 0;
                                const kernElapsedRatio = avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
                                return [
                                   '',
                                   `Kernel vs Elapsed: ${kernElapsedRatio.toFixed(1)}%`,
                                   `Queries: ${data.queryCount}`
                                   ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                    x: {
                    type: "time",
                    time: getCurrentTimeConfig(requests),
                    title: { display: true, text: "Request Time" },
                    },
                    y: {
                    type: "linear",
                    position: "left",
                    title: { display: true, text: "Percentage (%)" },
                    beginAtZero: true,
                    suggestedMin: 0,
                    suggestedMax: 100,
                    },
                        y1: {
                             type: "linear",
                             position: "right",
                             title: { display: true, text: "Avg ServTime (ms)" },
                             beginAtZero: true,
                             grid: {
                                 drawOnChartArea: false,
                             },
                         },
                     },
                    interaction: { mode: "index", intersect: false },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.execVsServChart, ctx);
        }

        // Setup chart drag and drop functionality
        function setupChartDragAndDrop() {
            // Chart mapping for swapping - all charts
            const chartMapping = {
                'elapsed-time': () => window.elapsedTimeChart,
                'primary-scan': () => window.primaryScanChart,
                'query-pattern': () => window.queryPatternChart,
                'duration-buckets': () => window.durationBucketsChart,
                'query-types': () => window.queryTypesChart,
                'operations': () => window.operationsChart,
                'filter': () => window.filterChart,
                'result-count': () => window.resultCountChart,
                'result-size': () => window.resultSizeChart,
                'timeline': () => window.timelineChart,
                'memory': () => window.memoryChart,
                'exec-vs-kernel': () => window.execVsKernelChart,
                'exec-vs-serv': () => window.execVsServChart,
                'cpu-time': () => window.cpuTimeChart,
                'exec-vs-elapsed': () => window.execVsElapsedChart,
                'enhanced-operations': () => window.enhancedOperationsChart
            };

            // Make charts draggable (excluding dashboard charts)
            $('.draggable-chart').not('[data-position^="dashboard"]').draggable({
                handle: '.chart-drag-handle',
                revert: 'invalid',
                helper: 'clone',
                opacity: 0.7,
                zIndex: 1000,
                start: function(event, ui) {
                    $(this).addClass('ui-draggable-dragging');
                },
                stop: function(event, ui) {
                    $(this).removeClass('ui-draggable-dragging');
                }
            });

            // Make charts droppable
            $('.draggable-chart').droppable({
                accept: '.draggable-chart',
                hoverClass: 'chart-drop-zone',
                drop: function(event, ui) {
                    const draggedChart = ui.draggable;
                    const targetChart = $(this);
                    
                    // Don't drop on itself
                    if (draggedChart[0] === targetChart[0]) return;

                    // Get chart IDs
                    const draggedId = draggedChart.data('chart-id');
                    const targetId = targetChart.data('chart-id');

                    // Swap positions
                    const draggedPosition = draggedChart.data('position');
                    const targetPosition = targetChart.data('position');

                    // Update data attributes
                    draggedChart.data('position', targetPosition);
                    targetChart.data('position', draggedPosition);

                    // Swap canvas IDs to maintain chart references
                    const draggedCanvas = draggedChart.find('canvas');
                    const targetCanvas = targetChart.find('canvas');
                    
                    const tempId = 'temp-canvas-id';
                    const draggedCanvasId = draggedCanvas.attr('id');
                    const targetCanvasId = targetCanvas.attr('id');
                    
                    draggedCanvas.attr('id', tempId);
                    targetCanvas.attr('id', draggedCanvasId);
                    draggedCanvas.attr('id', targetCanvasId);

                    // Swap the DOM elements
                    const draggedParent = draggedChart.parent();
                    const targetParent = targetChart.parent();
                    
                    // Use jQuery to swap elements
                    const temp = $('<div>');
                    draggedChart.before(temp);
                    targetChart.before(draggedChart);
                    temp.before(targetChart);
                    temp.remove();

                    // Refresh chart sizes after DOM manipulation
                    setTimeout(() => {
                        Object.values(chartMapping).forEach(getChart => {
                            const chart = getChart();
                            if (chart && chart.resize) {
                                chart.resize();
                            }
                        });
                    }, 100);
                }
            });
        }

        // Create ExecTime vs Elapsed Time Chart (copy of ExecVsKernel but vs elapsed time)
        function createExecVsElapsedChart(requests, grouping) {
            const canvas = document.getElementById("exec-vs-elapsed-chart");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            // Destroy existing chart if it exists
            if (window.execVsElapsedChart) {
                window.execVsElapsedChart.destroy();
            }

            // Group requests by time
            const timeGroups = {};

            requests.forEach((request) => {
                const requestDate = new Date(request.requestTime);
                const timeKey = roundTimestamp(requestDate, grouping, requests);
                const key = timeKey.toISOString();

                if (!timeGroups[key]) {
                    timeGroups[key] = {
                        timestamp: timeKey,
                        authorizeData: [],
                        parseData: [],
                        planData: [],
                        indexScanData: [],
                        fetchData: [],
                        filterData: [],
                        streamData: [],
                        kernTimeData: [],
                        elapsedTimeData: [],
                        queryCount: 0,
                    };
                }

                timeGroups[key].queryCount++;

                // Extract data from phaseTimes
                if (request.phaseTimes) {
                    const parseTimeMs = parseTime(request.phaseTimes.parse) || 0;
                    const planTimeMs = parseTime(request.phaseTimes.plan) || 0;
                    timeGroups[key].parseData.push(parseTimeMs);
                    timeGroups[key].planData.push(planTimeMs);
                }

                // Extract kernel and elapsed time
                const kernTimeMs = calculateTotalKernTime(request.plan) || 0;
                const elapsedTimeMs = parseTime(request.elapsedTime) || 0;
                timeGroups[key].kernTimeData.push(kernTimeMs);
                timeGroups[key].elapsedTimeData.push(elapsedTimeMs);

                // Extract operator-specific data from plan
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const operators = getOperators(planObj);

                        operators.forEach((operator) => {
                            const operatorType = operator["#operator"];
                            const stats = operator["#stats"] || {};
                            const execTime = parseTime(stats.execTime) || 0;

                            switch (operatorType) {
                                case "Authorize":
                                    timeGroups[key].authorizeData.push({ execTime });
                                    break;
                                case "IndexScan3":
                                    timeGroups[key].indexScanData.push({ execTime });
                                    break;
                                case "Fetch":
                                    timeGroups[key].fetchData.push({ execTime });
                                    break;
                                case "Filter":
                                    timeGroups[key].filterData.push({ execTime });
                                    break;
                                case "Stream":
                                    timeGroups[key].streamData.push({ execTime });
                                    break;
                            }
                        });
                    } catch (e) {
                        console.warn("Error parsing plan for exec vs elapsed analysis:", e);
                    }
                }
            });

            // Convert to sorted array and calculate percentages vs elapsed time
            const sortedData = Object.values(timeGroups)
                .sort((a, b) => a.timestamp - b.timestamp)
                .map(item => ({
                    ...item,
                    avgAuthorizeExecTime: item.authorizeData.length > 0 ? 
                        item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length : 0,
                    avgParseTime: item.parseData.length > 0 ? 
                        item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length : 0,
                    avgPlanTime: item.planData.length > 0 ? 
                        item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length : 0,
                    avgIndexScanExecTime: item.indexScanData.length > 0 ? 
                        item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length : 0,
                    avgFetchExecTime: item.fetchData.length > 0 ? 
                        item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length : 0,
                    avgFilterExecTime: item.filterData.length > 0 ? 
                        item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length : 0,
                    avgStreamExecTime: item.streamData.length > 0 ? 
                        item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length : 0,
                    avgElapsedTime: item.elapsedTimeData.length > 0 ? 
                        item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0,
                }));

            const authorizeVsElapsedPercentData = sortedData.map((item) => {
                if (item.authorizeData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgAuthorizeExecTime = item.authorizeData.reduce((sum, d) => sum + d.execTime, 0) / item.authorizeData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgAuthorizeExecTime / avgElapsedTime) * 100 : 0;
            });

            const parseVsElapsedPercentData = sortedData.map((item) => {
                if (item.parseData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgParseTime = item.parseData.reduce((sum, d) => sum + d, 0) / item.parseData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgParseTime / avgElapsedTime) * 100 : 0;
            });

            const planVsElapsedPercentData = sortedData.map((item) => {
                if (item.planData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgPlanTime = item.planData.reduce((sum, d) => sum + d, 0) / item.planData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgPlanTime / avgElapsedTime) * 100 : 0;
            });

            const indexScanVsElapsedPercentData = sortedData.map((item) => {
                if (item.indexScanData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgIndexScanExecTime = item.indexScanData.reduce((sum, d) => sum + d.execTime, 0) / item.indexScanData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgIndexScanExecTime / avgElapsedTime) * 100 : 0;
            });

            const fetchVsElapsedPercentData = sortedData.map((item) => {
                if (item.fetchData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgFetchExecTime = item.fetchData.reduce((sum, d) => sum + d.execTime, 0) / item.fetchData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgFetchExecTime / avgElapsedTime) * 100 : 0;
            });

            const filterVsElapsedPercentData = sortedData.map((item) => {
                if (item.filterData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgFilterExecTime = item.filterData.reduce((sum, d) => sum + d.execTime, 0) / item.filterData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgFilterExecTime / avgElapsedTime) * 100 : 0;
            });

            const streamVsElapsedPercentData = sortedData.map((item) => {
                if (item.streamData.length === 0 || item.elapsedTimeData.length === 0) return 0;
                const avgStreamExecTime = item.streamData.reduce((sum, d) => sum + d.execTime, 0) / item.streamData.length;
                const avgElapsedTime = item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length;
                return avgElapsedTime > 0 ? (avgStreamExecTime / avgElapsedTime) * 100 : 0;
            });

            // Calculate KernTime vs ElapsedTime percentage for new red dotted line
            const kernVsElapsedPercentData = sortedData.map((item) => {
                const avgKernTime = item.kernTimeData.length > 0 ? 
                    item.kernTimeData.reduce((sum, d) => sum + d, 0) / item.kernTimeData.length : 0;
                const avgElapsedTime = item.elapsedTimeData.length > 0 ? 
                    item.elapsedTimeData.reduce((sum, d) => sum + d, 0) / item.elapsedTimeData.length : 0;
                return avgElapsedTime > 0 ? (avgKernTime / avgElapsedTime) * 100 : 0;
            });

            const labels = sortedData.map((item) => item.timestamp);

            window.execVsElapsedChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Authorize: ExecTime vs Elapsed Time (%)",
                            data: authorizeVsElapsedPercentData,
                            backgroundColor: "rgba(54, 162, 235, 0.8)", // Blue (matches others)
                            borderColor: "rgba(54, 162, 235, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Parse vs Elapsed Time (%)",
                            data: parseVsElapsedPercentData,
                            backgroundColor: "rgba(255, 99, 132, 0.8)", // Red
                            borderColor: "rgba(255, 99, 132, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Plan vs Elapsed Time (%)",
                            data: planVsElapsedPercentData,
                            backgroundColor: "rgba(75, 192, 192, 0.8)", // Teal
                            borderColor: "rgba(75, 192, 192, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "IndexScan: ExecTime vs Elapsed Time (%)",
                            data: indexScanVsElapsedPercentData,
                            backgroundColor: "rgba(255, 206, 86, 0.8)", // Yellow (matches others)
                            borderColor: "rgba(255, 206, 86, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Fetch: ExecTime vs Elapsed Time (%)",
                            data: fetchVsElapsedPercentData,
                            backgroundColor: "rgba(153, 102, 255, 0.8)", // Purple (matches others)
                            borderColor: "rgba(153, 102, 255, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Filter vs Elapsed Time (%)",
                            data: filterVsElapsedPercentData,
                            backgroundColor: "rgba(255, 159, 64, 0.8)", // Orange
                            borderColor: "rgba(255, 159, 64, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Stream vs Elapsed Time (%)",
                            data: streamVsElapsedPercentData,
                            backgroundColor: "rgba(201, 203, 207, 0.8)", // Gray
                            borderColor: "rgba(201, 203, 207, 1)",
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                        },
                        {
                            label: "Kernel vs Elapsed Time (%)",
                            data: kernVsElapsedPercentData,
                            backgroundColor: "rgba(255, 0, 0, 0.8)", // Bright Red
                            borderColor: "rgba(255, 0, 0, 1)",
                            borderWidth: 3,
                            borderDash: [20, 3, 3, 3, 3, 3, 3, 3], // Custom dash pattern
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0, // No points
                            pointHoverRadius: 0, // No hover points
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: "ExecTime vs Elapsed Time (%) By Query Steps - (Beta)",
                        },
                        legend: {
                            display: true,
                            position: "top",
                        },
                        tooltip: {
                            callbacks: {
                                beforeBody: function() {
                                    return 'ExecTime vs Elapsed Time (%):';
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value === null || value === undefined) return null;
                                    // Extract just the operator name from various label formats
                                    let operatorName = context.dataset.label;
                                    if (operatorName.includes(':')) {
                                        operatorName = operatorName.split(':')[0];
                                    } else if (operatorName.includes(' vs ')) {
                                        operatorName = operatorName.split(' vs ')[0];
                                    }
                                    return `  ${operatorName}: ${value.toFixed(2)}%`;
                                },
                                afterBody: function(tooltipItems) {
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const data = sortedData[dataIndex];
                                    const avgKernTime = data.kernTimeData.length > 0 ? 
                                        data.kernTimeData.reduce((sum, d) => sum + d, 0) / data.kernTimeData.length : 0;
                                    const kernElapsedRatio = data.avgElapsedTime > 0 ? (avgKernTime / data.avgElapsedTime) * 100 : 0;
                                    return [
                                        '',
                                        `Kernel vs Elapsed: ${kernElapsedRatio.toFixed(1)}%`,
                                        `Queries: ${data.queryCount}`,
                                        `Elapsed Time: ${data.avgElapsedTime.toFixed(1)}ms`
                                    ];
                                }
                            }
                        },
                        zoom: {
                            limits: {
                                x: { min: "original", max: "original" },
                                y: { min: "original", max: "original" },
                            },
                            pan: {
                                enabled: true,
                                mode: "xy",
                                onPan: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                            zoom: {
                                wheel: { enabled: false },
                                pinch: { enabled: true },
                                drag: {
                                    enabled: true,
                                    backgroundColor: "rgba(100,100,100,0.4)",
                                    borderColor: "rgba(50,50,50,0.8)",
                                    borderWidth: 2,
                                },
                                mode: "xy",
                                onZoom: function ({ chart }) {
                                    currentTimeRange.min = new Date(chart.scales.x.min);
                                    currentTimeRange.max = new Date(chart.scales.x.max);
                                    updateTimeRangeDisplay();
                                    syncChartZoom(chart, chart.scales.x.min, chart.scales.x.max);
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: getCurrentTimeConfig(requests),
                            title: { display: true, text: "Request Time" },
                        },
                        y: {
                            type: "linear",
                            position: "left",
                            title: { display: true, text: "Percentage (%)" },
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 100,
                        },
                    },
                    interaction: { mode: "index", intersect: false },
                },
                plugins: [verticalLinePlugin]
            });

            registerTimelineChart(window.execVsElapsedChart, ctx);
        }

        // Reset timeline chart zoom
        function resetTimelineZoom() {
            if (window.timelineChart) {
                window.timelineChart.resetZoom();
            }
            if (window.operationsChart) {
                window.operationsChart.resetZoom();
            }
            if (window.filterChart) {
                window.filterChart.resetZoom();
            }
            if (window.queryTypesChart) {
                window.queryTypesChart.resetZoom();
            }
            if (window.durationBucketsChart) {
                window.durationBucketsChart.resetZoom();
            }
            if (window.memoryChart) {
                window.memoryChart.resetZoom();
            }
            if (window.resultCountChart) {
                window.resultCountChart.resetZoom();
            }
            if (window.resultSizeChart) {
                window.resultSizeChart.resetZoom();
            }
            if (window.cpuTimeChart) {
            window.cpuTimeChart.resetZoom();
            }
        if (window.execVsKernelChart) {
          window.execVsKernelChart.resetZoom();
        }
        if (window.execVsServChart) {
          window.execVsServChart.resetZoom();
        }
        if (window.execVsElapsedChart) {
          window.execVsElapsedChart.resetZoom();
        }
        if (window.enhancedOperationsChart) {
          window.enhancedOperationsChart.resetZoom();
        }

            // Reset to original time range
            currentTimeRange = { ...originalTimeRange };
            updateTimeRangeDisplay();
        }

        // Format date to datetime-local format
        function formatDateForInput(date) {
            if (!date) return "";
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            const hours = String(d.getHours()).padStart(2, "0");
            const minutes = String(d.getMinutes()).padStart(2, "0");
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Update the time range display
        function updateTimeRangeDisplay() {
            // Function kept for compatibility but display removed
        }

        // Use current time range in the date pickers
        function useCurrentTimeRange() {
            // Get current x-axis range directly from the chart
            if (
                window.timelineChart &&
                window.timelineChart.scales &&
                window.timelineChart.scales.x
            ) {
                const xScale = window.timelineChart.scales.x;
                const currentMin = new Date(xScale.min);
                const currentMax = new Date(xScale.max);

                const startValue = formatDateForInput(currentMin);
                const endValue = formatDateForInput(currentMax);

                const startInput = document.getElementById("start-date");
                const endInput = document.getElementById("end-date");
                startInput.value = startValue;
                endInput.value = endValue;

                // Always show the filter reminder banner after updating the pickers
                // Consistent with setTimeRange and manual input changes
                showFilterReminder();
            }
        }

        // Change Y-axis scale for both charts
        function changeYAxisScale() {
            const selectedScale = document.querySelector(
                'input[name="yScale"]:checked'
            ).value;
            const scaleType =
                selectedScale === "logarithmic" ? "logarithmic" : "linear";

            // Update operations chart Y-axis scale
            if (window.operationsChart) {
                window.operationsChart.options.scales.y.type = scaleType;
                window.operationsChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.operationsChart.options.scales.y.beginAtZero = false;
                    window.operationsChart.options.scales.y.min = 1; // Avoid log(0)
                    window.operationsChart.options.scales.y1.beginAtZero = false;
                    window.operationsChart.options.scales.y1.min = 0.1; // Avoid log(0)
                } else {
                    window.operationsChart.options.scales.y.beginAtZero = true;
                    window.operationsChart.options.scales.y1.beginAtZero = true;
                    delete window.operationsChart.options.scales.y.min;
                    delete window.operationsChart.options.scales.y1.min;
                }
                window.operationsChart.update();
            }

            // Update filter chart Y-axis scale
            if (window.filterChart) {
                window.filterChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.filterChart.options.scales.y.beginAtZero = false;
                    window.filterChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.filterChart.options.scales.y.beginAtZero = true;
                    delete window.filterChart.options.scales.y.min;
                }
                window.filterChart.update();
            }

            // Update timeline chart Y-axis scale
            if (window.timelineChart) {
                window.timelineChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.timelineChart.options.scales.y.beginAtZero = false;
                    window.timelineChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.timelineChart.options.scales.y.beginAtZero = true;
                    delete window.timelineChart.options.scales.y.min;
                }
                window.timelineChart.update();
            }

            // Update query types chart Y-axis scale
            if (window.queryTypesChart) {
                window.queryTypesChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.queryTypesChart.options.scales.y.beginAtZero = false;
                    window.queryTypesChart.options.scales.y.min = 0.001; // Avoid log(0) for very small durations
                } else {
                    window.queryTypesChart.options.scales.y.beginAtZero = true;
                    delete window.queryTypesChart.options.scales.y.min;
                }
                window.queryTypesChart.update();
            }

            // Update memory chart Y-axis scale
            if (window.memoryChart) {
                window.memoryChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.memoryChart.options.scales.y.beginAtZero = false;
                    window.memoryChart.options.scales.y.min = 0.001; // Avoid log(0) for small memory values
                } else {
                    window.memoryChart.options.scales.y.beginAtZero = true;
                    delete window.memoryChart.options.scales.y.min;
                }
                window.memoryChart.update();
            }



            // Update result count chart Y-axis scale
            if (window.resultCountChart) {
                window.resultCountChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.resultCountChart.options.scales.y.beginAtZero = false;
                    window.resultCountChart.options.scales.y.min = 1; // Avoid log(0)
                } else {
                    window.resultCountChart.options.scales.y.beginAtZero = true;
                    delete window.resultCountChart.options.scales.y.min;
                }
                window.resultCountChart.update();
            }

            // Update result size chart Y-axis scale
            if (window.resultSizeChart) {
                window.resultSizeChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.resultSizeChart.options.scales.y.beginAtZero = false;
                    window.resultSizeChart.options.scales.y.min = 0.001; // Avoid log(0) for small sizes
                } else {
                    window.resultSizeChart.options.scales.y.beginAtZero = true;
                    delete window.resultSizeChart.options.scales.y.min;
                }
                window.resultSizeChart.update();
            }

            // Update CPU time chart Y-axis scale
            if (window.cpuTimeChart) {
                window.cpuTimeChart.options.scales.y.type = scaleType;
                window.cpuTimeChart.options.scales.y1.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.cpuTimeChart.options.scales.y.beginAtZero = false;
                    window.cpuTimeChart.options.scales.y.min = 0.001; // Avoid log(0) for small times
                    window.cpuTimeChart.options.scales.y1.beginAtZero = false;
                    window.cpuTimeChart.options.scales.y1.min = 0.001; // Avoid log(0) for percentages
                } else {
                    window.cpuTimeChart.options.scales.y.beginAtZero = true;
                    window.cpuTimeChart.options.scales.y1.beginAtZero = true;
                    delete window.cpuTimeChart.options.scales.y.min;
                    delete window.cpuTimeChart.options.scales.y1.min;
                }
                window.cpuTimeChart.update();
            }

            // Update execution vs kernel chart Y-axis scale
            if (window.execVsKernelChart) {
                window.execVsKernelChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.execVsKernelChart.options.scales.y.beginAtZero = false;
                    window.execVsKernelChart.options.scales.y.min = 0.001; // Avoid log(0) for small percentages
                } else {
                    window.execVsKernelChart.options.scales.y.beginAtZero = true;
                    delete window.execVsKernelChart.options.scales.y.min;
                }
                window.execVsKernelChart.update();
            }

            // Update execution vs service chart Y-axis scale
            if (window.execVsServChart) {
                window.execVsServChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.execVsServChart.options.scales.y.beginAtZero = false;
                    window.execVsServChart.options.scales.y.min = 0.001; // Avoid log(0) for small percentages
                } else {
                    window.execVsServChart.options.scales.y.beginAtZero = true;
                    delete window.execVsServChart.options.scales.y.min;
                }
                window.execVsServChart.update();
            }

            // Update execution vs elapsed chart Y-axis scale
            if (window.execVsElapsedChart) {
                window.execVsElapsedChart.options.scales.y.type = scaleType;
                if (scaleType === "logarithmic") {
                    window.execVsElapsedChart.options.scales.y.beginAtZero = false;
                    window.execVsElapsedChart.options.scales.y.min = 0.001; // Avoid log(0) for small percentages
                } else {
                    window.execVsElapsedChart.options.scales.y.beginAtZero = true;
                    delete window.execVsElapsedChart.options.scales.y.min;
                }
                window.execVsElapsedChart.update();
            }

        }

        // Change time grouping for all charts
        function changeTimeGrouping() {
            // Use the filtered data if available, otherwise fall back to parsing JSON
            let requests = [];
            if (originalRequests.length > 0) {
                // Apply current date filtering to original data
                const startDateInput = document.getElementById("start-date");
                const endDateInput = document.getElementById("end-date");
                const startDate = startDateInput.value
                    ? new Date(startDateInput.value)
                    : null;
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : null;
                requests = filterRequestsByDateRange(
                    originalRequests,
                    startDate,
                    endDate
                );

                // Apply SQL filter and system query exclusion
                requests = filterSystemQueries(requests);
            } else {
                // Fallback to parsing JSON if no original data
                const jsonInput = document.getElementById("json-input").value;
                if (!jsonInput.trim()) return;

                try {
                    const data = JSON.parse(jsonInput);
                    if (Array.isArray(data)) {
                        requests = data.map((item) => ({
                            ...item.completed_requests,
                            plan: item.plan
                                ? typeof item.plan === "string"
                                    ? JSON.parse(item.plan)
                                    : item.plan
                                : null,
                        }));
                    }

                    // Apply SQL filter and system query exclusion to parsed data
                    requests = filterSystemQueries(requests);
                } catch (e) {
                    console.error("Error parsing JSON for time grouping change:", e);
                    return;
                }
            }

            // Validate date range for the selected grouping
            const grouping = getTimeGrouping();
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");
            const startDate = startDateInput.value
                ? new Date(startDateInput.value)
                : null;
            const endDate = endDateInput.value
                ? new Date(endDateInput.value)
                : null;

            const validation = validateDateRangeForGrouping(
                startDate,
                endDate,
                grouping
            );
            if (!validation.valid) {
                alert(validation.message);
                return;
            }

            try {
                // Update the optimizer label to show current optimization
                updateOptimizerLabel(requests);

                // Regenerate all charts with new time grouping
                generateOperationsChart(requests);
                generateFilterChart(requests);
                generateTimelineChart(requests);
            } catch (e) {
                console.error("Error regenerating charts:", e);
                alert(
                    "Error generating charts. Try reducing the date range or selecting a coarser time grouping."
                );
            }
        }

        // Global variable to store original unfiltered data
        let originalRequests = [];
        let originalStartDate = null;
        let originalEndDate = null;

        // Store statements for safe access without HTML escaping issues
        let statementStore = {};
        let analysisStatementStore = {};

        // Parse Couchbase datetime to JavaScript Date
        function parseCouchbaseDateTime(dateTimeStr) {
            if (!dateTimeStr) return null;
            // Handle various Couchbase datetime formats
            const isoString = dateTimeStr.replace(" ", "T");
            return new Date(isoString);
        }

        // Convert Date to datetime-local input format
        function toDateTimeLocal(date) {
            if (!date || isNaN(date.getTime())) return "";
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            const hours = String(date.getHours()).padStart(2, "0");
            const minutes = String(date.getMinutes()).padStart(2, "0");
            const seconds = String(date.getSeconds()).padStart(2, "0");
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
        }

        // Filter requests by date range
        function filterRequestsByDateRange(requests, startDate, endDate) {
            if (!startDate && !endDate) return requests;

            return requests.filter((request) => {
                const requestDate = parseCouchbaseDateTime(request.requestTime);
                if (!requestDate) return true; // Include requests with invalid dates

                if (startDate && requestDate < startDate) return false;
                if (endDate && requestDate > endDate) return false;
                return true;
            });
        }

        // Update filter info display
        function updateFilterInfo(originalCount, filteredCount) {
            const filterInfo = document.getElementById("filter-info");
            const queriesBadge = document.getElementById("queries-fixed-badge");
            if (originalCount === filteredCount) {
                const html = `Showing all <strong>${originalCount}</strong> queries`;
                if (filterInfo) filterInfo.innerHTML = html;
                if (queriesBadge) queriesBadge.innerHTML = html;
            } else {
                const html = `Showing <strong>${filteredCount}</strong> of <strong>${originalCount}</strong> queries`;
                if (filterInfo) filterInfo.innerHTML = html;
                if (queriesBadge) queriesBadge.innerHTML = html;
            }
        }

        // Generate Dashboard Charts
        function generateDashboardCharts(requests) {
            generatePrimaryScanChart(requests);
            generateStateChart(requests);
            generateStatementTypeChart(requests);
            generateScanConsistencyChart(requests);
            generateElapsedTimeChart(requests);
            generateQueryPatternChart(requests);
            generateUserCountTable(requests);
            generateIndexCountTable(requests);
            updateInsights(requests);
        }

        // Check if a query uses primary index by analyzing the plan (optimized with cache)
        function usesPrimaryIndex(request) {
            if (!request.plan) return false;

            // Check if we have cached metadata first
            if (request._planMetadata) {
                return request._planMetadata.usesPrimary;
            }

            try {
                const planObj =
                    typeof request.plan === "string"
                        ? JSON.parse(request.plan)
                        : request.plan;

                // Check plan cache
                if (planStatsCache.has(planObj)) {
                    return planStatsCache.get(planObj).usesPrimary;
                }

                return checkOperatorForPrimary(planObj);
            } catch (e) {
                return false;
            }
        }

        // Determine the index type used: 'Primary', 'Sequential Scan', or 'GSI'
        function getIndexType(request) {
            if (!request.plan) return 'GSI';

            try {
                const planObj =
                    typeof request.plan === "string"
                        ? JSON.parse(request.plan)
                        : request.plan;
                return checkOperatorForIndexType(planObj);
            } catch (e) {
                return 'GSI';
            }
        }

        // Recursively check operators to determine index type
        function checkOperatorForIndexType(operator) {
            if (!operator) return 'GSI';

            // Check for sequential scan first (most specific)
            if (operator.using === "sequentialscan") {
                return 'Sequential Scan';
            }

            // Check for primary index indicators
            if (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                (operator.spans && operator.spans.length === 0)
            ) {
                return 'Primary';
            }

            // Recursively check child operators
            if (operator["~child"]) {
                const childType = checkOperatorForIndexType(operator["~child"]);
                if (childType !== 'GSI') return childType;
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                for (const child of operator["~children"]) {
                    const childType = checkOperatorForIndexType(child);
                    if (childType !== 'GSI') return childType;
                }
            }
            if (operator.input) {
                const inputType = checkOperatorForIndexType(operator.input);
                if (inputType !== 'GSI') return inputType;
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                for (const input of operator.inputs) {
                    const inputType = checkOperatorForIndexType(input);
                    if (inputType !== 'GSI') return inputType;
                }
            }
            if (operator.left) {
                const leftType = checkOperatorForIndexType(operator.left);
                if (leftType !== 'GSI') return leftType;
            }
            if (operator.right) {
                const rightType = checkOperatorForIndexType(operator.right);
                if (rightType !== 'GSI') return rightType;
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                const firstType = checkOperatorForIndexType(operator.first);
                if (firstType !== 'GSI') return firstType;
            }
            if (operator.second) {
                const secondType = checkOperatorForIndexType(operator.second);
                if (secondType !== 'GSI') return secondType;
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                for (const scan of operator.scans) {
                    const scanType = checkOperatorForIndexType(scan);
                    if (scanType !== 'GSI') return scanType;
                }
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                const scanType = checkOperatorForIndexType(operator.scan);
                if (scanType !== 'GSI') return scanType;
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                for (const subquery of operator["~subqueries"]) {
                    if (subquery.executionTimings) {
                        const subType = checkOperatorForIndexType(subquery.executionTimings);
                        if (subType !== 'GSI') return subType;
                    }
                }
            }

            return 'GSI';
        }

        // Recursively check operators for primary index usage
        function checkOperatorForPrimary(operator) {
            if (!operator) return false;

            // Check for primary index indicators
            if (
                operator["#operator"] === "PrimaryScan" ||
                operator["#operator"] === "PrimaryScan3" ||
                operator.index === "#primary" ||
                operator.using === "sequentialscan" ||
                (operator.spans && operator.spans.length === 0)
            ) {
                return true;
            }

            // Recursively check child operators
            if (operator["~child"] && checkOperatorForPrimary(operator["~child"]))
                return true;
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                for (const child of operator["~children"]) {
                    if (checkOperatorForPrimary(child)) return true;
                }
            }
            if (operator.input && checkOperatorForPrimary(operator.input))
                return true;
            if (operator.inputs && Array.isArray(operator.inputs)) {
                for (const input of operator.inputs) {
                    if (checkOperatorForPrimary(input)) return true;
                }
            }
            if (operator.left && checkOperatorForPrimary(operator.left))
                return true;
            if (operator.right && checkOperatorForPrimary(operator.right))
                return true;
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first && checkOperatorForPrimary(operator.first))
                return true;
            if (operator.second && checkOperatorForPrimary(operator.second))
                return true;
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                for (const scan of operator.scans) {
                    if (checkOperatorForPrimary(scan)) return true;
                }
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan && checkOperatorForPrimary(operator.scan))
                return true;
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                for (const subquery of operator["~subqueries"]) {
                    if (
                        subquery.executionTimings &&
                        checkOperatorForPrimary(subquery.executionTimings)
                    )
                        return true;
                }
            }

            return false;
        }

        // Primary Scan Used Donut Chart
        function generatePrimaryScanChart(requests) {
            const scanCounts = { 'Primary': 0, 'Sequential Scan': 0, 'GSI': 0 };

            requests.forEach((request) => {
                const indexType = getIndexType(request);
                scanCounts[indexType]++;
            });

            const total = scanCounts['Primary'] + scanCounts['Sequential Scan'] + scanCounts['GSI'];

            // Show/hide warning div based on whether primary scans are detected
            const warningDiv = document.getElementById("primary-scan-warning");
            if (scanCounts['Primary'] > 0) {
                warningDiv.style.display = "flex";
            } else {
                warningDiv.style.display = "none";
            }

            const ctx = document
                .getElementById("primary-scan-chart")
                .getContext("2d");
            if (window.primaryScanChart) {
                window.primaryScanChart.destroy();
            }

            window.primaryScanChart = new Chart(ctx, {
                type: "doughnut",
                data: {
                    labels: ["Primary", "Sequential Scan", "GSI"],
                    datasets: [
                        {
                            data: [scanCounts['Primary'], scanCounts['Sequential Scan'], scanCounts['GSI']],
                            backgroundColor: ["#dc3545", "#fd7e14", "#f8f9fa"],
                            borderColor: ["#dc3545", "#fd7e14", "#dee2e6"],
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: "60%",
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const d = chart.data;
                                    return d.labels.map((label, index) => ({
                                        text: label + " (" + (typeof d.datasets[0].data[index] === 'number' ? d.datasets[0].data[index].toLocaleString() : d.datasets[0].data[index]) + ")",
                                        fillStyle: d.datasets[0].backgroundColor[index],
                                        strokeStyle: d.datasets[0].borderColor ? d.datasets[0].borderColor[index] : d.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                        datalabels: {
                            display: true,
                            color: function (context) {
                                // White text for Primary (red) and Sequential Scan (orange), dark text for GSI (light gray)
                                return context.dataIndex <= 1 ? "white" : "#6c757d";
                            },
                            font: {
                                weight: "bold",
                                size: 14,
                            },
                            formatter: function (value, context) {
                                const percent =
                                    total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return percent + "%";
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Query State Pie Chart
        function drawPieLabelsWithLeaders(chart, total, options) {
    const ctx = chart.ctx;
    const dataset = chart.data.datasets[0];
    const meta = chart.getDatasetMeta(0);
    const opts = Object.assign({
        insideThreshold: 10,
        font: 'bold 14px Arial',
        textColor: '#111', // outside label color
        leaderLineLength: 12,
        labelPadding: 4,
        percentDecimals: 1,
        insideTextColor: null, // string or (index, bgColor) => string
    }, options || {});

    function parseRGB(colorStr) {
        if (!colorStr || typeof colorStr !== 'string') return null;
        if (colorStr[0] === '#') {
            let r, g, b;
            if (colorStr.length === 4) {
                r = parseInt(colorStr[1] + colorStr[1], 16);
                g = parseInt(colorStr[2] + colorStr[2], 16);
                b = parseInt(colorStr[3] + colorStr[3], 16);
                return { r, g, b };
            }
            if (colorStr.length === 7) {
                r = parseInt(colorStr.slice(1, 3), 16);
                g = parseInt(colorStr.slice(3, 5), 16);
                b = parseInt(colorStr.slice(5, 7), 16);
                return { r, g, b };
            }
            return null;
        }
        const m = colorStr.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
        if (m) return { r: +m[1], g: +m[2], b: +m[3] };
        return null;
    }

    function getContrastText(bgColor, fallback) {
        const rgb = parseRGB(bgColor);
        if (!rgb) return fallback || '#fff';
        const brightness = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b; // 0..255
        return brightness > 180 ? '#111' : '#fff';
    }

    ctx.save();
    ctx.font = opts.font;

    dataset.data.forEach((value, index) => {
        if (!value || total <= 0) return;
        const percent = (value / total) * 100;
        const metaEntry = meta.data[index];
        if (!metaEntry || typeof metaEntry.getProps !== 'function') return;

        const p = metaEntry.getProps(['x','y','startAngle','endAngle','outerRadius','innerRadius'], true);
        const angle = (p.startAngle + p.endAngle) / 2;
        const midRadius = (p.innerRadius + p.outerRadius) / 2;
        const label = percent.toFixed(opts.percentDecimals) + '%';

        // Resolve slice color for contrast and leader stroke
        const bgColor = Array.isArray(dataset.backgroundColor)
            ? dataset.backgroundColor[index]
            : dataset.backgroundColor;

        if (percent >= opts.insideThreshold) {
            const x = p.x + Math.cos(angle) * midRadius;
            const y = p.y + Math.sin(angle) * midRadius;
            const insideColor = typeof opts.insideTextColor === 'function'
                ? opts.insideTextColor(index, bgColor)
                : (opts.insideTextColor || getContrastText(bgColor, '#fff'));
            ctx.fillStyle = insideColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        } else {
            const r = p.outerRadius;
            const x0 = p.x + Math.cos(angle) * r;
            const y0 = p.y + Math.sin(angle) * r;
            const x1 = p.x + Math.cos(angle) * (r + opts.leaderLineLength);
            const y1 = p.y + Math.sin(angle) * (r + opts.leaderLineLength);
            const alignRight = Math.cos(angle) >= 0;
            const x2 = x1 + (alignRight ? 16 : -16);
            const y2 = y1;

            const strokeStyle = bgColor || '#666';
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.fillStyle = opts.textColor;
            ctx.textAlign = alignRight ? 'left' : 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x2 + (alignRight ? opts.labelPadding : -opts.labelPadding), y2);
        }
    });

    ctx.restore();
}

function generateStateChart(requests) {
            const stateCounts = {};

            requests.forEach((request) => {
                const state = request.state || "Unknown";
                stateCounts[state] = (stateCounts[state] || 0) + 1;
            });

            const total = Object.values(stateCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(stateCounts);
            const data = Object.values(stateCounts);

            // Semantic colors based on query state
            const colors = labels.map(state => {
                const lowerState = state.toLowerCase();
                switch (lowerState) {
                    case "completed":
                    case "success":
                        return "#28a745"; // Green - success
                    case "fatal":
                    case "errors":
                        return "#dc3545"; // Red - error
                    case "timeout":
                        return "#fd7e14"; // Orange - timeout
                    case "stopped":
                    case "cancelled":
                        return "#6c757d"; // Gray - stopped/cancelled
                    case "running":
                        return "#007bff"; // Blue - in progress
                    default:
                        return "#6f42c1"; // Purple - unknown/other
                }
            });

            const ctx = document.getElementById("state-chart").getContext("2d");
            if (window.stateChart) {
                window.stateChart.destroy();
            }

            window.stateChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label + " (" + (typeof data.datasets[0].data[index] === 'number' ? data.datasets[0].data[index].toLocaleString() : data.datasets[0].data[index]) + ")",
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Derive statement type from SQL statement text
        function deriveStatementType(statement) {
            if (!statement || typeof statement !== "string") {
                return "UNKNOWN";
            }

            // Decode any HTML entities and strip any HTML-like tags (e.g., <ud>...)</ud>)
            try {
                const tmp = document.createElement('div');
                tmp.innerHTML = statement;
                statement = (tmp.textContent || tmp.innerText || "");
            } catch (e) { /* no-op */ }
            // Remove any residual tags and collapse whitespace
            const cleaned = statement.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');

            const trimmed = cleaned.trim().toUpperCase();
            if (!trimmed) {
                return "UNKNOWN";
            }

            // Handle common multi-word statement types first
            if (trimmed.startsWith("CREATE INDEX")) return "CREATE_INDEX";
            if (trimmed.startsWith("DROP INDEX")) return "DROP_INDEX";
            if (trimmed.startsWith("ALTER INDEX")) return "ALTER_INDEX";
            if (trimmed.startsWith("BUILD INDEX")) return "BUILD_INDEX";

            // Get first word for other statement types
            const firstWord = trimmed.split(/\s+/)[0];
            return firstWord;
        }

        // Statement Type Pie Chart
        function generateStatementTypeChart(requests) {
            const typeCounts = {};

            requests.forEach((request) => {
                // First try the statementType field, then derive from statement or preparedText
                const type = request.statementType || deriveStatementType(request.statement || request.preparedText) || "UNKNOWN";
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            });

            const total = Object.values(typeCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(typeCounts);
            const data = Object.values(typeCounts);
            const colors = [
                "#ff6384",
                "#36a2eb",
                "#ffce56",
                "#4bc0c0",
                "#9966ff",
                "#ff9f40",
                "#c9cbcf",
                "#4bc0c0",
            ];

            const ctx = document
                .getElementById("statement-type-chart")
                .getContext("2d");
            if (window.statementTypeChart) {
                window.statementTypeChart.destroy();
            }

            window.statementTypeChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors.slice(0, labels.length),
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label + " (" + (typeof data.datasets[0].data[index] === 'number' ? data.datasets[0].data[index].toLocaleString() : data.datasets[0].data[index]) + ")",
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Scan Consistency Pie Chart
        function generateScanConsistencyChart(requests) {
            const consistencyCounts = {};

            requests.forEach((request) => {
                const consistency = request.scanConsistency || "unbounded";
                consistencyCounts[consistency] = (consistencyCounts[consistency] || 0) + 1;
            });

            const total = Object.values(consistencyCounts).reduce(
                (sum, count) => sum + count,
                0
            );
            const labels = Object.keys(consistencyCounts);
            const data = Object.values(consistencyCounts);

            // Specific colors for scan consistency types
            const colors = labels.map(consistency => {
                const lowerConsistency = consistency.toLowerCase();
                switch (lowerConsistency) {
                    case "unbounded":
                        return "#007bff"; // Blue
                    case "scan_plus":
                        return "#28a745"; // Green
                    case "request_plus":
                        return "#fd7e14"; // Orange
                    default:
                        return "#6c757d"; // Gray for unknown
                }
            });

            const ctx = document
                .getElementById("scan-consistency-chart")
                .getContext("2d");
            if (window.scanConsistencyChart) {
                window.scanConsistencyChart.destroy();
            }

            window.scanConsistencyChart = new Chart(ctx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            data: data,
                            backgroundColor: colors,
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: "bottom",
                            labels: {
                                generateLabels: function (chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, index) => ({
                                        text: label + " (" + (typeof data.datasets[0].data[index] === 'number' ? data.datasets[0].data[index].toLocaleString() : data.datasets[0].data[index]) + ")",
                                        fillStyle: data.datasets[0].backgroundColor[index],
                                        strokeStyle: data.datasets[0].backgroundColor[index],
                                        lineWidth: 1,
                                        hidden: false,
                                        index: index,
                                    }));
                                },
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const percent =
                                        total > 0
                                            ? ((context.parsed / total) * 100).toFixed(1)
                                            : 0;
                                    return (
                                        context.label +
                                        ": " +
                                        context.parsed +
                                        " (" +
                                        percent +
                                        "%)"
                                    );
                                },
                            },
                        },
                    },
                },
                plugins: [
                    {
                        afterDatasetsDraw: function (chart) {
                            drawPieLabelsWithLeaders(chart, total, { insideThreshold: 10 });
                        },
                    },
                ],
            });
        }

        // Elapsed Time Distribution Bar Chart
        function drawBarValueLabels(chart, options) {
    const ctx = chart.ctx;
    const dataset = chart.data.datasets[0];
    const meta = chart.getDatasetMeta(0);
    const opts = Object.assign({
        font: 'bold 14px Arial',
        color: '#111',
        yOffset: 4,
        formatter: (v) => (typeof v === 'number' ? v.toLocaleString() : v),
    }, options || {});

    if (!dataset || !meta) return;

    ctx.save();
    ctx.font = opts.font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = opts.color;

    meta.data.forEach((barEl, i) => {
        if (!barEl) return;
        const v = dataset.data[i];
        if (v == null || v === 0) return;
        const p = typeof barEl.getProps === 'function'
            ? barEl.getProps(['x','y','base'], true)
            : { x: barEl.x, y: barEl.y, base: barEl.base };
        const x = p.x;
        const y = Math.min(p.y, p.base) - opts.yOffset; // place above the bar
        const text = opts.formatter(v);
        ctx.fillText(text, x, y);
    });

    ctx.restore();
}

function generateElapsedTimeChart(requests) {
            const timeBuckets = {
                "0-1s": 0,
                "1-2s": 0,
                "2-5s": 0,
                "5-10s": 0,
                "10-20s": 0,
                "20-40s": 0,
                "40-60s": 0,
                "60-90s": 0,
                "90s-5m": 0,
                "5-15m": 0,
                "15-30m": 0,
                "30-60m": 0,
                ">60m": 0,
            };

            requests.forEach((request) => {
                const elapsed = (request.elapsedTimeMs || 0) / 1000; // Convert ms to seconds

                if (elapsed <= 1) timeBuckets["0-1s"]++;
                else if (elapsed <= 2) timeBuckets["1-2s"]++;
                else if (elapsed <= 5) timeBuckets["2-5s"]++;
                else if (elapsed <= 10) timeBuckets["5-10s"]++;
                else if (elapsed <= 20) timeBuckets["10-20s"]++;
                else if (elapsed <= 40) timeBuckets["20-40s"]++;
                else if (elapsed <= 60) timeBuckets["40-60s"]++;
                else if (elapsed <= 90) timeBuckets["60-90s"]++;
                else if (elapsed <= 300) timeBuckets["90s-5m"]++;
                else if (elapsed <= 900) timeBuckets["5-15m"]++;
                else if (elapsed <= 1800) timeBuckets["15-30m"]++;
                else if (elapsed <= 3600) timeBuckets["30-60m"]++;
                else timeBuckets[">60m"]++;
            });

            const ctx = document
                .getElementById("elapsed-time-chart")
                .getContext("2d");
            if (window.elapsedTimeChart) {
                window.elapsedTimeChart.destroy();
            }

            window.elapsedTimeChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(timeBuckets),
                    datasets: [
                        {
                            label: "Query Count",
                            data: Object.values(timeBuckets),
                            backgroundColor: "#36a2eb",
                            borderColor: "#36a2eb",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: { top: 16 }
                    },
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grace: '15%',
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Elapsed Time Range",
                            },
                        },
                    },
                },
                    plugins: [
                            {
                                       afterDatasetsDraw: function (chart) {
                                    drawBarValueLabels(chart, { font: 'bold 14px Arial' });
                        },
                    },
                ],
            });
        }
 
        // Generate Query Pattern Chart
        function generateQueryPatternChart(requests) {
            const patternCounts = {
                // Far left
                WITH: 0,
                EXECUTE: 0,
                "SELECT *": 0,
                COUNT: 0,
                // Left-center
                "USE INDEX": 0,
                "USE KEYS": 0,
                // Center
                "No WHERE": 0,
                // Center-right  
                JOIN: 0,
                NEST: 0,
                UNNEST: 0,
                SEARCH: 0,
                "ARRAY QUERY": 0,
                LIKE: 0,
                REGEX: 0,
                // Far right
                "GROUP BY": 0,
                "ORDER BY": 0,
                LIMIT: 0,
                OFFSET: 0,
            };

            requests.forEach((request) => {
                const statement = request.statement || request.preparedText || "";
                const upperStatement = statement.toUpperCase();

                // No WHERE: if this is an EXECUTE, check the preparedText (actual statement) for WHERE/filters
                const stmtForFilter = (upperStatement.startsWith("EXECUTE") && request.preparedText)
                    ? request.preparedText
                    : statement;
                if (!hasFilteringMechanism(stmtForFilter)) {
                    patternCounts["No WHERE"]++;
                }

                // GROUP BY
                if (upperStatement.includes(" GROUP BY ")) {
                    patternCounts["GROUP BY"]++;
                }

                // ORDER BY
                if (upperStatement.includes(" ORDER BY ")) {
                    patternCounts["ORDER BY"]++;
                }

                // USE INDEX
                if (upperStatement.includes("USE INDEX")) {
                    patternCounts["USE INDEX"]++;
                }

                // USE KEYS
                if (upperStatement.includes("USE KEYS")) {
                    patternCounts["USE KEYS"]++;
                }

                // JOIN
                if (upperStatement.includes(" JOIN ")) {
                    patternCounts["JOIN"]++;
                }

                // NEST
                if (upperStatement.includes(" NEST ")) {
                    patternCounts["NEST"]++;
                }

                // UNNEST
                if (upperStatement.includes(" UNNEST ")) {
                    patternCounts["UNNEST"]++;
                }

                // OFFSET
                if (upperStatement.includes(" OFFSET ")) {
                    patternCounts["OFFSET"]++;
                }

                // SEARCH
                if (upperStatement.includes(" SEARCH(")) {
                    patternCounts["SEARCH"]++;
                }

                // WITH (ensure it's a SQL clause, not a backticked field name)
                if ((upperStatement.startsWith("WITH ") || upperStatement.includes(" WITH ")) && !upperStatement.includes("`WITH`")) {
                    patternCounts["WITH"]++;
                }

                // ARRAY QUERY (has ANY/EVERY + SATISFIES + END)
                if (
                    (upperStatement.includes(" ANY ") || upperStatement.includes(" EVERY ") || upperStatement.includes("ANY AND EVERY")) &&
                    upperStatement.includes(" SATISFIES ") &&
                    (upperStatement.includes(" END ") || upperStatement.endsWith(" END"))
                ) {
                    patternCounts["ARRAY QUERY"]++;
                }

                // SELECT * (only pure SELECT * queries, not qualified wildcards like c.*)
                const selectStarMatch = upperStatement.match(/SELECT\s+\*\s+FROM/);
                if (selectStarMatch) {
                    patternCounts["SELECT *"]++;
                }

                // LIKE (ensure it's an operator, not a backticked field name)
                if (statement.includes(" LIKE ") && !statement.includes("`LIKE`")) {
                    patternCounts["LIKE"]++;
                }

                // COUNT
                if (statement.includes(" COUNT(")) {
                    patternCounts["COUNT"]++;
                }

                // REGEX
                if (statement.includes("REGEXP_") || /REGEX\s*\(/.test(statement)) {
                    patternCounts["REGEX"]++;
                }

                // EXECUTE
                if (statement.startsWith("EXECUTE")) {
                    patternCounts["EXECUTE"]++;
                }

                // LIMIT
                if (statement.includes(" LIMIT ")) {
                    patternCounts["LIMIT"]++;
                }
            });

            const ctx = document
                .getElementById("query-pattern-chart")
                .getContext("2d");
            if (window.queryPatternChart) {
                window.queryPatternChart.destroy();
            }

            // Generate colors based on pattern names
            const colors = Object.keys(patternCounts).map((pattern) => {
                if (pattern === "SELECT *") {
                    return "#dc3545"; // Red
                } else if (
                    pattern === "LIKE" ||
                    pattern === "No WHERE" ||
                    pattern === "REGEX"
                ) {
                    return "#fd7e14"; // Orange
                } else {
                    return "#28a745"; // Green
                }
            });

            window.queryPatternChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: Object.keys(patternCounts),
                    datasets: [
                        {
                            label: "Query Count",
                            data: Object.values(patternCounts),
                            backgroundColor: colors,
                            borderColor: colors,
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: { top: 16 }
                    },
                    plugins: {
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return "Queries: " + context.parsed.y;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grace: '15%',
                            title: {
                                display: true,
                                text: "Number of Queries",
                            },
                        },
                        x: {
                            title: {
                                display: true,
                                text: "Query Pattern Features",
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                            },
                        },
                    },
                },
                    plugins: [
                            {
                                       afterDatasetsDraw: function (chart) {
                                    drawBarValueLabels(chart, { font: 'bold 14px Arial' });
                        },
                    },
                ],
            });
        }
 
        // Generate User Count Table
        function generateUserCountTable(requests) {
            const userCounts = {};

            requests.forEach((request) => {
                const user = request.users || "Unknown";
                userCounts[user] = (userCounts[user] || 0) + 1;
            });

            const sortedUsers = Object.entries(userCounts).sort(
                ([, a], [, b]) => b - a
            );

            const tbody = document.getElementById("user-count-body");
            tbody.innerHTML = "";

            // Use DocumentFragment for smooth rendering with caps
            const fragment = document.createDocumentFragment();
            const maxDisplayUsers = 500; // Cap for performance
            const usersToShow = sortedUsers.slice(0, maxDisplayUsers);

            usersToShow.forEach(([user, count]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";

                // Apply count thresholding
                const displayCount = count > 99999 ? "99K+" : count;

                row.innerHTML = `
              <td class="padding-8 text-align-center" style="font-weight: bold;">${displayCount}</td>
              <td class="padding-8" style="word-break: break-word;">
                ${user}
                <button onclick="copyToClipboard('${user.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="margin-left: 8px;">
                  Copy
                </button>
              </td>
            `;
                fragment.appendChild(row);
            });

            tbody.appendChild(fragment);

            // Add notice if users were capped
            if (sortedUsers.length > maxDisplayUsers) {
                const noticeRow = document.createElement("tr");
                noticeRow.innerHTML = `<td colspan="2" style="text-align: center; color: #666; font-style: italic; padding: 10px;">${TEXT_CONSTANTS.SHOWING_TOP} ${maxDisplayUsers} ${TEXT_CONSTANTS.OF_TOTAL} ${sortedUsers.length} ${TEXT_CONSTANTS.USERS}</td>`;
                tbody.appendChild(noticeRow);
            }
        }

        // Parse FROM clause to extract bucket.scope.collection
        function parseFromClause(statement) {
            if (!statement) return "_default._default._default";

            try {
                // Remove comments and normalize whitespace
                let cleanStatement = statement
                    .replace(/--.*$/gm, "") // Remove line comments
                    .replace(/\/\*[\s\S]*?\*\//g, "") // Remove block comments
                    .replace(/\s+/g, " ") // Normalize whitespace
                    .trim();

                // Look for the main FROM clause (not subquery FROM)
                // Use a more specific regex that avoids matching FROM inside parentheses
                const fromPattern = /\bFROM\s+([`\w]+(?:\.[`\w]+)*(?:\.[`\w]+)*)/i;
                const fromMatch = cleanStatement.match(fromPattern);

                if (!fromMatch) {
                    // Fallback: try to find any table-like reference after FROM
                    const fallbackPattern = /\bFROM\s+([`\w]+)/i;
                    const fallbackMatch = cleanStatement.match(fallbackPattern);
                    if (!fallbackMatch) return "_default._default._default";

                    const tableRef = fallbackMatch[1].replace(/`/g, "").trim();
                    return `${tableRef}._default._default`;
                }

                const tableRef = fromMatch[1].trim();

                // Handle backticks and clean the reference
                const cleanRef = tableRef.replace(/`/g, "");

                // Skip if it looks like a SQL keyword or function
                if (
                    /^(SELECT|WITH|CASE|WHEN|IF|EXISTS|NOT|AND|OR)$/i.test(cleanRef)
                ) {
                    return "_default._default._default";
                }

                // Split by dots
                const parts = cleanRef.split(".");

                if (parts.length === 1) {
                    // Only bucket specified
                    return `${parts[0]}._default._default`;
                } else if (parts.length === 2) {
                    // Bucket and scope specified
                    return `${parts[0]}.${parts[1]}._default`;
                } else if (parts.length >= 3) {
                    // Full bucket.scope.collection
                    return `${parts[0]}.${parts[1]}.${parts[2]}`;
                }

                return "_default._default._default";
            } catch (error) {
                console.warn("Error parsing FROM clause:", error, statement);
                return "_default._default._default";
            }
        }

        // Generate Index Count Table
        function generateIndexCountTable(requests) {
            const indexData = {};

            requests.forEach((request) => {
                const bucketScopeCollection = parseFromClause(request.statement || request.preparedText);

                // Debug problematic parsing
                if (
                    bucketScopeCollection.includes("SELECT") ||
                    bucketScopeCollection.includes("(")
                ) {
                    console.warn("Potentially incorrect bucket parsing:", {
                        statement: (request.statement || request.preparedText)?.substring(0, 100) + "...",
                        parsed: bucketScopeCollection,
                    });
                    // Use default for obviously wrong parsing
                    const correctedBSC = "_default._default._default";

                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, correctedBSC);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                } else {
                    if (request.plan) {
                        try {
                            // Parse the plan JSON string
                            const planObj =
                                typeof request.plan === "string"
                                    ? JSON.parse(request.plan)
                                    : request.plan;

                            if (planObj && planObj["#operator"]) {
                                extractIndexNames(planObj, indexData, bucketScopeCollection);
                            }
                        } catch (e) {
                            console.error("Error parsing plan JSON:", e, request.plan);
                        }
                    }
                }
            });

            const sortedIndexes = Object.entries(indexData).sort(
                ([, a], [, b]) => b.count - a.count
            );

            const tbody = document.getElementById("index-count-body");
            tbody.innerHTML = "";

            // Use DocumentFragment for smooth rendering with caps
            const fragment = document.createDocumentFragment();
            const maxDisplayIndexes = 200; // Cap for performance
            const indexesToShow = sortedIndexes.slice(0, maxDisplayIndexes);

            indexesToShow.forEach(([indexName, data]) => {
                const row = document.createElement("tr");
                row.style.borderBottom = "1px solid #eee";

                // Apply count thresholding
                const displayCount = data.count > 99999 ? "99K+" : data.count;

                row.innerHTML = `
              <td class="padding-8 text-align-center" style="font-weight: bold;">${displayCount}</td>
              <td class="padding-8" style="word-break: break-word;">
                ${indexName}
                <button onclick="copyToClipboard('${indexName.replace(
                    /'/g,
                    "\\'"
                )}', event)" 
                        class="btn-standard" style="margin-left: 8px;">
                  Copy
                </button>
              </td>
              <td class="padding-8 font-size-12" style="word-break: break-word; font-family: monospace;">
                ${data.bucketScopeCollection}
              </td>
            `;
                fragment.appendChild(row);
            });

            tbody.appendChild(fragment);

            // Add notice if indexes were capped
            if (sortedIndexes.length > maxDisplayIndexes) {
                const noticeRow = document.createElement("tr");
                noticeRow.innerHTML = `<td colspan="3" style="text-align: center; color: #666; font-style: italic; padding: 10px;">${TEXT_CONSTANTS.SHOWING_TOP} ${maxDisplayIndexes} ${TEXT_CONSTANTS.OF_TOTAL} ${sortedIndexes.length} ${TEXT_CONSTANTS.INDEXES}</td>`;
                tbody.appendChild(noticeRow);
            }
        }

        // Recursively extract index names from plan operators with improved error handling
        function extractIndexNames(
            operator,
            indexData,
            bucketScopeCollection,
            depth = 0
        ) {
            if (!operator || !indexData) return;

            // Prevent infinite recursion
            if (depth > 50) {
                console.warn("Maximum recursion depth reached in extractIndexNames");
                return;
            }

            try {
                // Helper function to add index to data, resolving #primary conflicts
                function addIndexToData(indexName) {
                    let resolvedName = indexName;

                    // If this is #primary, try to resolve to actual primary index name
                    if (indexName === "#primary") {
                        const actualPrimary = resolvePrimaryIndexName(
                            bucketScopeCollection || "unknown.unknown.unknown"
                        );
                        if (actualPrimary && actualPrimary !== "#primary") {
                            resolvedName = actualPrimary;
                        }
                    }

                    if (!indexData[resolvedName]) {
                        indexData[resolvedName] = {
                            count: 0,
                            bucketScopeCollection: bucketScopeCollection || "unknown",
                        };
                    }
                    indexData[resolvedName].count++;
                }

                // Check for index name in various operator properties
                if (operator.index && typeof operator.index === "string") {
                    addIndexToData(operator.index);
                }
                if (operator.indexName && typeof operator.indexName === "string") {
                    addIndexToData(operator.indexName);
                }

                // Check for primary scan operators (align with usesPrimaryIndex logic)
                if (
                    operator["#operator"] === "PrimaryScan" ||
                    operator["#operator"] === "PrimaryScan3" ||
                    operator.index === "#primary" ||
                    operator.using === "sequentialscan" ||
                    (operator.spans &&
                        Array.isArray(operator.spans) &&
                        operator.spans.length === 0)
                ) {
                    // Only add #primary if we don't already have the actual index name
                    if (!operator.index || operator.index === "#primary") {
                        addIndexToData("#primary");
                    }
                    // If operator.index exists and is not #primary, it was already added above
                }

                // Recursively check child operators
                if (operator["~child"]) {
                    extractIndexNames(
                        operator["~child"],
                        indexData,
                        bucketScopeCollection,
                        depth + 1
                    );
                }
                if (operator["~children"] && Array.isArray(operator["~children"])) {
                    operator["~children"].forEach((child) =>
                        extractIndexNames(
                            child,
                            indexData,
                            bucketScopeCollection,
                            depth + 1
                        )
                    );
                }
            } catch (e) {
                console.warn("Error in extractIndexNames:", e);
            }
            if (operator.input) {
                extractIndexNames(operator.input, indexData, bucketScopeCollection);
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexNames(input, indexData, bucketScopeCollection)
                );
            }
            if (operator.left) {
                extractIndexNames(operator.left, indexData, bucketScopeCollection);
            }
            if (operator.right) {
                extractIndexNames(operator.right, indexData, bucketScopeCollection);
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexNames(operator.first, indexData, bucketScopeCollection);
            }
            if (operator.second) {
                extractIndexNames(operator.second, indexData, bucketScopeCollection);
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexNames(scan, indexData, bucketScopeCollection)
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexNames(operator.scan, indexData, bucketScopeCollection);
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexNames(
                            subquery.executionTimings,
                            indexData,
                            bucketScopeCollection
                        );
                    }
                });
            }
        }

        // Update Insights tab with live data
        function updateInsights(requests) {
            // Reset metrics tracking
            window.inefficientScanMetrics = [];

            // Count queries with no WHERE clauses
            let noWhereCount = 0;
            let slowUseKeysCount = 0;
            let slowUseKeysTotalTime = 0;
            let largeResultsCount = 0;
            let largeResultsTotalMB = 0;
            let inefficientLikeCount = 0;
            let selectStarCount = 0;
            let inefficientIndexScansCount = 0;
            let paginationOverfetchCount = 0;
            let paginationOverfetchTotalScanned = 0;
            let highMemoryCount = 0;
            let highMemoryTotalGB = 0;
            let highKernelTimeQueriesCount = 0;
            let totalCoreKernelRatio = 0;
            let largePayloadStreamingCount = 0;
            let largePayloadTotalResultSize = 0;
            let largePayloadTotalStreamRatio = 0;
            let approachingTimeoutCount = 0;
            let actualTimeoutCount = 0;

            // Sample queries arrays for insights
            let missingWhereClausesSamples = [];
            let slowUseKeyQueriesSamples = [];
            let largeResultSetQueriesSamples = [];
            let inefficientLikeOperationsSamples = [];
            let selectStarUsageSamples = [];
            let highMemoryUsageSamples = [];
            let highKernelTimeQueriesSamples = [];
            let largePayloadStreamingSamples = [];
            let actualTimeoutsSamples = [];
            let approachingTimeoutsSamples = [];
            let paginationOverfetchSamples = [];

            // Configurable threshold for kernel time detection
            const KERNEL_TIME_THRESHOLD_PERCENT = 20;
            const STREAM_KERNEL_THRESHOLD_PERCENT = 10;

            requests.forEach((request) => {
                const statement = (request.statement || request.preparedText || "").toUpperCase();
                const elapsedTime = parseTime(request.elapsedTime);
                const elapsedTimeSeconds = elapsedTime / 1000; // Convert to seconds
                const state = (request.state || "").toLowerCase();

                // Count timeout-prone queries
                // Approaching timeout: 1 minute (60s) to 1m15s (75s) AND state is "completed"
                if (elapsedTimeSeconds >= 60 && elapsedTimeSeconds <= 75 && state === "completed") {
                    approachingTimeoutCount++;
                    if (approachingTimeoutsSamples.length < 5 && 
                        !approachingTimeoutsSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        approachingTimeoutsSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement,
                            elapsedTime: request.elapsedTime
                        });
                    }
                }
                
                // Actual timeout: 1m14s (74s) to 1m16s (76s) AND state is "fatal"  
                if (elapsedTimeSeconds >= 74 && elapsedTimeSeconds <= 76 && state === "fatal") {
                    actualTimeoutCount++;
                    if (actualTimeoutsSamples.length < 5 && 
                        !actualTimeoutsSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        actualTimeoutsSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement,
                            elapsedTime: request.elapsedTime
                        });
                    }
                }

                // Count missing WHERE clauses
                // Use consolidated function to check for filtering mechanisms (WHERE or USE KEYS)
                // If this is EXECUTE, evaluate WHERE on preparedText (actual statement) when present
                const stmtForWhere = (((request.statement || '').toUpperCase().startsWith('EXECUTE')) && request.preparedText)
                    ? request.preparedText
                    : (request.statement || request.preparedText);
                if (!hasFilteringMechanism(stmtForWhere)) {
                    noWhereCount++;
                    if (missingWhereClausesSamples.length < 5 && 
                        !missingWhereClausesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        missingWhereClausesSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Count slow USE KEYS queries (> 1 second)
                if (statement.includes("USE KEYS")) {
                    const elapsedTime = parseTime(request.elapsedTime);
                    if (elapsedTime > 1000) { // 1 second = 1000ms
                        slowUseKeysCount++;
                        slowUseKeysTotalTime += elapsedTime;
                        if (slowUseKeyQueriesSamples.length < 5 && 
                            !slowUseKeyQueriesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                            slowUseKeyQueriesSamples.push({
                                requestTime: request.requestTime,
                                statement: request.preparedText || request.statement
                            });
                        }
                    }
                }

                // Count large result size queries (> 5MB)
                const resultSize = request.resultSize || 0;
                const resultSizeMB = resultSize / (1024 * 1024); // Convert bytes to MB
                if (resultSizeMB > 5) {
                    largeResultsCount++;
                    largeResultsTotalMB += resultSizeMB;
                    if (largeResultSetQueriesSamples.length < 5 && 
                        !largeResultSetQueriesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        largeResultSetQueriesSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Count inefficient LIKE operations with leading wildcards
                if (statement.includes(" LIKE ")) {
                    // Look for patterns like LIKE '%text' or LIKE "%text"
                    const likeMatches = statement.match(/ LIKE\s+['"]%[^'"]*['"]?/g);
                    if (likeMatches && likeMatches.length > 0) {
                        inefficientLikeCount++;
                        if (inefficientLikeOperationsSamples.length < 5 && 
                            !inefficientLikeOperationsSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                            inefficientLikeOperationsSamples.push({
                                requestTime: request.requestTime,
                                statement: request.preparedText || request.statement
                            });
                        }
                    }
                }

                // Count SELECT * usage (pure SELECT * FROM, not qualified wildcards like c.*)
                const selectStarMatch = statement.match(/SELECT\s+\*\s+FROM/);
                if (selectStarMatch) {
                    selectStarCount++;
                    if (selectStarUsageSamples.length < 5 &&
                        !selectStarUsageSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        selectStarUsageSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Count high memory usage queries (>= 1GB)
                const usedMemory = request.usedMemory || 0;
                const usedMemoryGB = usedMemory / (1024 * 1024 * 1024); // Convert bytes to GB
                if (usedMemoryGB >= 1) {
                    highMemoryCount++;
                    highMemoryTotalGB += usedMemoryGB;
                    if (highMemoryUsageSamples.length < 5 && 
                        !highMemoryUsageSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                        highMemoryUsageSamples.push({
                            requestTime: request.requestTime,
                            statement: request.preparedText || request.statement
                        });
                    }
                }

                // Analyze core execTime vs kernel time (two-stage check)
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        const elapsedTimeMs = parseTime(request.elapsedTime);

                        // Stage 1: Check if kernTime is at least 50% of elapsedTime
                        const kernTimeAnalysis = calculateTotalKernTime(request.plan);
                        const kernToElapsedRatio = elapsedTimeMs > 0 ? (kernTimeAnalysis / elapsedTimeMs) * 100 : 0;

                        if (kernToElapsedRatio >= 50) {
                            // Stage 2: Analyze core execTime vs kernel time ratio
                            const coreKernelAnalysis = analyzeCoreExecToKernelRatio(planObj);

                            // If core execTime is 50%+ of kernel time, flag as high kernel time
                            if (coreKernelAnalysis.coreToKernelRatio >= 50) {
                                highKernelTimeQueriesCount++;
                                totalCoreKernelRatio += coreKernelAnalysis.coreToKernelRatio;
                                if (highKernelTimeQueriesSamples.length < 5 && 
                                    !highKernelTimeQueriesSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                                    highKernelTimeQueriesSamples.push({
                                        requestTime: request.requestTime,
                                        statement: request.preparedText || request.statement
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Error parsing plan for kernel time analysis:", e);
                    }
                }

                // Analyze large payload streaming
                const payloadSize = request.resultSize || 0;
                const payloadSizeMB = payloadSize / (1024 * 1024); // Convert to MB

                if (payloadSizeMB >= 1) { // Result size >= 1MB
                    if (request.plan) {
                        try {
                            const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                            const elapsedTimeMs = parseTime(request.elapsedTime);
                            const streamAnalysis = analyzeStreamToElapsedRatio(planObj, elapsedTimeMs, STREAM_KERNEL_THRESHOLD_PERCENT);

                            if (streamAnalysis.qualifies) {
                                largePayloadStreamingCount++;
                                largePayloadTotalResultSize += payloadSizeMB;
                                largePayloadTotalStreamRatio += streamAnalysis.streamRatio;
                                if (largePayloadStreamingSamples.length < 5 && 
                                    !largePayloadStreamingSamples.some(s => s.statement === (request.statement || request.preparedText))) {
                                    largePayloadStreamingSamples.push({
                                        requestTime: request.requestTime,
                                        statement: request.preparedText || request.statement
                                    });
                                }
                            }
                        } catch (e) {
                            console.error("Error analyzing large payload streaming:", e);
                        }
                    }
                }

                // Count inefficient index scans
                // Exclude mutation statements (MERGE, DELETE, INSERT, UPDATE, UPSERT) which may return [] on success
                const stmtType = (request.statementType || deriveStatementType(request.statement || request.preparedText) || '').toUpperCase();
                const isMutationStatement = stmtType === 'MERGE' || stmtType === 'DELETE' || stmtType === 'INSERT' || stmtType === 'UPDATE' || stmtType === 'UPSERT';
                // Check if query has aggregate functions (exclude them)
                const hasAggregates = /\b(COUNT|AVG|MIN|MAX|SUM)\s*\(/i.test(statement);

                if (!isMutationStatement && !hasAggregates) {
                    const resultCount = request.resultCount || 0;
                    const phaseCounts = request.phaseCounts || {};

                    // Check various types of index scans
                    let totalScanned = 0;
                    if (phaseCounts.primaryScan) totalScanned += phaseCounts.primaryScan;
                    if (phaseCounts.indexScan) totalScanned += phaseCounts.indexScan;
                    if (phaseCounts['primaryScan.GSI']) totalScanned += phaseCounts['primaryScan.GSI'];
                    if (phaseCounts['indexScan.GSI']) totalScanned += phaseCounts['indexScan.GSI'];

                    // Check if scanned >= 50,000 and efficiency < 10%
                    if (totalScanned >= 50000) {
                        const efficiency = totalScanned > 0 ? (resultCount / totalScanned) * 100 : 0;
                        if (efficiency < 10) {
                            inefficientIndexScansCount++;
                            // Track metrics for average calculation
                            if (!window.inefficientScanMetrics) window.inefficientScanMetrics = [];
                            window.inefficientScanMetrics.push({
                                scanned: totalScanned,
                                resultCount: resultCount,
                                selectivity: efficiency
                            });
                        }
                    }
                }

                // Detect pagination index over-scan for ORDER BY + LIMIT + OFFSET
                const hasOrderBy = statement.includes(" ORDER BY ");
                const hasLimit = statement.includes(" LIMIT ");
                const hasOffset = statement.includes(" OFFSET ");
                if (hasOrderBy && hasLimit && hasOffset) {
                    const pc = request.phaseCounts || {};
                    const primaryCount = Math.max(pc.primaryScan || 0, pc['primaryScan.GSI'] || 0);
                    const indexCount = Math.max(pc.indexScan || 0, pc['indexScan.GSI'] || 0);
                    const scanned = Math.max(primaryCount, indexCount);
                    if (scanned >= 10000) {
                        paginationOverfetchCount++;
                        paginationOverfetchTotalScanned += scanned;
                        if (paginationOverfetchSamples.length < 5 &&
                            !paginationOverfetchSamples.some(s => s.statement === (request.preparedText || request.statement))) {
                            paginationOverfetchSamples.push({
                                requestTime: request.requestTime,
                                statement: request.preparedText || request.statement
                            });
                        }
                    }
                }
            });

            const totalQueries = requests.length;
            const noWherePercent = totalQueries > 0 ? ((noWhereCount / totalQueries) * 100).toFixed(1) : 0;

            // Update the missing WHERE clauses insight
            const missingWhereCountElement = document.getElementById("missing-where-count");
            const missingWherePercentElement = document.getElementById("missing-where-percent");

            if (missingWhereCountElement && missingWherePercentElement) {
                missingWhereCountElement.textContent = `${noWhereCount} queries`;
                missingWherePercentElement.textContent = `${noWherePercent}%`;

                // Only highlight if there are issues
                if (noWhereCount > 0) {
                    missingWhereCountElement.className = "highlight-number";
                    missingWherePercentElement.className = "highlight-number";
                } else {
                    missingWhereCountElement.className = "";
                    missingWherePercentElement.className = "";
                }
            }

            // Update the slow USE KEYS queries insight
            const slowUseKeysCountElement = document.getElementById("slow-use-keys-count");
            const avgUseKeysTimeElement = document.getElementById("avg-use-keys-time");

            if (slowUseKeysCount > 0) {
                const avgUseKeysTime = slowUseKeysTotalTime / slowUseKeysCount;

                if (slowUseKeysCountElement) {
                    slowUseKeysCountElement.textContent = `${slowUseKeysCount} USE KEY queries`;
                    slowUseKeysCountElement.className = "highlight-number";
                }
                if (avgUseKeysTimeElement) {
                    avgUseKeysTimeElement.textContent = formatTime(avgUseKeysTime);
                    avgUseKeysTimeElement.className = "highlight-number";
                }
                const slowUseKeysPercentElement = document.getElementById("slow-use-keys-percent");
                if (slowUseKeysPercentElement) {
                    const slowUseKeysPercent = totalQueries > 0 ? ((slowUseKeysCount / totalQueries) * 100).toFixed(1) : 0;
                    slowUseKeysPercentElement.textContent = `${slowUseKeysPercent}%`;
                    slowUseKeysPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (slowUseKeysCountElement) {
                    slowUseKeysCountElement.textContent = "0 USE KEY queries";
                    slowUseKeysCountElement.className = "";
                }
                if (avgUseKeysTimeElement) {
                    avgUseKeysTimeElement.textContent = "0ms";
                    avgUseKeysTimeElement.className = "";
                }
                const slowUseKeysPercentElement = document.getElementById("slow-use-keys-percent");
                if (slowUseKeysPercentElement) {
                    slowUseKeysPercentElement.textContent = "0%";
                    slowUseKeysPercentElement.className = "";
                }
            }

            // Update the large result sets insight
            const largeResultsCountElement = document.getElementById("large-results-count");
            const avgLargeResultSizeElement = document.getElementById("avg-large-result-size");

            if (largeResultsCount > 0) {
                const avgLargeResultSize = (largeResultsTotalMB / largeResultsCount).toFixed(1);

                if (largeResultsCountElement) {
                    largeResultsCountElement.textContent = `${largeResultsCount} queries`;
                    largeResultsCountElement.className = "highlight-number";
                }
                if (avgLargeResultSizeElement) {
                    avgLargeResultSizeElement.textContent = `${avgLargeResultSize}MB`;
                    avgLargeResultSizeElement.className = "highlight-number";
                }
                const largeResultsPercentElement = document.getElementById("large-results-percent");
                if (largeResultsPercentElement) {
                    const largeResultsPercent = totalQueries > 0 ? ((largeResultsCount / totalQueries) * 100).toFixed(1) : 0;
                    largeResultsPercentElement.textContent = `${largeResultsPercent}%`;
                    largeResultsPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (largeResultsCountElement) {
                    largeResultsCountElement.textContent = "0 queries";
                    largeResultsCountElement.className = "";
                }
                if (avgLargeResultSizeElement) {
                    avgLargeResultSizeElement.textContent = "0MB";
                    avgLargeResultSizeElement.className = "";
                }
                const largeResultsPercentElement = document.getElementById("large-results-percent");
                if (largeResultsPercentElement) {
                    largeResultsPercentElement.textContent = "0%";
                    largeResultsPercentElement.className = "";
                }
            }

            // Update the large payload streaming insight
            const largePayloadCountElement = document.getElementById("large-payload-count");
            const avgPayloadSizeElement = document.getElementById("avg-payload-size");
            const avgStreamRatioElement = document.getElementById("avg-stream-ratio");

            if (largePayloadStreamingCount > 0) {
                const avgPayloadSize = (largePayloadTotalResultSize / largePayloadStreamingCount).toFixed(1);
                const avgStreamRatio = (largePayloadTotalStreamRatio / largePayloadStreamingCount).toFixed(1);

                if (largePayloadCountElement) {
                    largePayloadCountElement.textContent = `${largePayloadStreamingCount} queries`;
                    largePayloadCountElement.className = "highlight-number";
                }
                if (avgPayloadSizeElement) {
                    avgPayloadSizeElement.textContent = `${avgPayloadSize}MB`;
                    avgPayloadSizeElement.className = "highlight-number";
                }
                if (avgStreamRatioElement) {
                    avgStreamRatioElement.textContent = `${avgStreamRatio}%`;
                    avgStreamRatioElement.className = "highlight-number";
                }
                const largePayloadPercentElement = document.getElementById("large-payload-percent");
                if (largePayloadPercentElement) {
                    const largePayloadPercent = totalQueries > 0 ? ((largePayloadStreamingCount / totalQueries) * 100).toFixed(1) : 0;
                    largePayloadPercentElement.textContent = `${largePayloadPercent}%`;
                    largePayloadPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (largePayloadCountElement) {
                    largePayloadCountElement.textContent = "0 queries";
                    largePayloadCountElement.className = "";
                }
                if (avgPayloadSizeElement) {
                    avgPayloadSizeElement.textContent = "0MB";
                    avgPayloadSizeElement.className = "";
                }
                if (avgStreamRatioElement) {
                    avgStreamRatioElement.textContent = "0%";
                    avgStreamRatioElement.className = "";
                }
                const largePayloadPercentElement = document.getElementById("large-payload-percent");
                if (largePayloadPercentElement) {
                    largePayloadPercentElement.textContent = "0%";
                    largePayloadPercentElement.className = "";
                }
            }

            // Update the inefficient LIKE operations insight
            const inefficientLikeCountElement = document.getElementById("inefficient-like-count");

            if (inefficientLikeCountElement) {
                inefficientLikeCountElement.textContent = `${inefficientLikeCount} queries`;
                inefficientLikeCountElement.className = inefficientLikeCount > 0 ? "highlight-number" : "";
                const inefficientLikePercentElement = document.getElementById("inefficient-like-percent");
                if (inefficientLikePercentElement) {
                    const inefficientLikePercent = totalQueries > 0 ? ((inefficientLikeCount / totalQueries) * 100).toFixed(1) : 0;
                    inefficientLikePercentElement.textContent = `${inefficientLikePercent}%`;
                    inefficientLikePercentElement.className = inefficientLikeCount > 0 ? "highlight-number" : "";
                }
            }

            // Update the SELECT * usage insight
            const selectStarCountElement = document.getElementById("select-star-count");
            if (selectStarCountElement) {
                selectStarCountElement.textContent = `${selectStarCount} queries`;
                selectStarCountElement.className = selectStarCount > 0 ? "highlight-number" : "";
                const selectStarPercentElement = document.getElementById("select-star-percent");
                if (selectStarPercentElement) {
                    const selectStarPercent = totalQueries > 0 ? ((selectStarCount / totalQueries) * 100).toFixed(1) : 0;
                    selectStarPercentElement.textContent = `${selectStarPercent}%`;
                    selectStarPercentElement.className = selectStarCount > 0 ? "highlight-number" : "";
                }
            }

            // Update the high memory usage insight
            const highMemoryCountElement = document.getElementById("high-memory-count");
            const avgMemoryUsageElement = document.getElementById("avg-memory-usage");

            if (highMemoryCount > 0) {
                const avgMemoryGB = (highMemoryTotalGB / highMemoryCount).toFixed(1);

                if (highMemoryCountElement) {
                    highMemoryCountElement.textContent = `${highMemoryCount} queries`;
                    highMemoryCountElement.className = "highlight-number";
                }
                if (avgMemoryUsageElement) {
                    avgMemoryUsageElement.textContent = `${avgMemoryGB}GB`;
                    avgMemoryUsageElement.className = "highlight-number";
                }
                const highMemoryPercentElement = document.getElementById("high-memory-percent");
                if (highMemoryPercentElement) {
                    const highMemoryPercent = totalQueries > 0 ? ((highMemoryCount / totalQueries) * 100).toFixed(1) : 0;
                    highMemoryPercentElement.textContent = `${highMemoryPercent}%`;
                    highMemoryPercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (highMemoryCountElement) {
                    highMemoryCountElement.textContent = "0 queries";
                    highMemoryCountElement.className = "";
                }
                if (avgMemoryUsageElement) {
                    avgMemoryUsageElement.textContent = "0GB";
                    avgMemoryUsageElement.className = "";
                }
                const highMemoryPercentElement = document.getElementById("high-memory-percent");
                if (highMemoryPercentElement) {
                    highMemoryPercentElement.textContent = "0%";
                    highMemoryPercentElement.className = "";
                }
            }

            // Update the high kernel time insight
            const highKernelTimeQueriesCountElement = document.getElementById("high-kernel-time-queries-count");
            const avgCoreKernelRatioElement = document.getElementById("avg-core-kernel-ratio");

            if (highKernelTimeQueriesCount > 0) {
                const avgCoreKernelRatio = (totalCoreKernelRatio / highKernelTimeQueriesCount).toFixed(1);

                if (highKernelTimeQueriesCountElement) {
                    highKernelTimeQueriesCountElement.textContent = `${highKernelTimeQueriesCount} queries`;
                    highKernelTimeQueriesCountElement.className = "highlight-number";
                }
                if (avgCoreKernelRatioElement) {
                    avgCoreKernelRatioElement.textContent = `${avgCoreKernelRatio}%`;
                    avgCoreKernelRatioElement.className = "highlight-number";
                }
                const highKernelTimePercentElement = document.getElementById("high-kernel-time-queries-percent");
                if (highKernelTimePercentElement) {
                    const highKernelPercent = totalQueries > 0 ? ((highKernelTimeQueriesCount / totalQueries) * 100).toFixed(1) : 0;
                    highKernelTimePercentElement.textContent = `${highKernelPercent}%`;
                    highKernelTimePercentElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (highKernelTimeQueriesCountElement) {
                    highKernelTimeQueriesCountElement.textContent = "0 queries";
                    highKernelTimeQueriesCountElement.className = "";
                }
                if (avgCoreKernelRatioElement) {
                    avgCoreKernelRatioElement.textContent = "0%";
                    avgCoreKernelRatioElement.className = "";
                }
                const highKernelTimePercentElement = document.getElementById("high-kernel-time-queries-percent");
                if (highKernelTimePercentElement) {
                    highKernelTimePercentElement.textContent = "0%";
                    highKernelTimePercentElement.className = "";
                }
            }

            // Update the inefficient index scans insight
            const inefficientIndexScansCountElement = document.getElementById("inefficient-index-scans-count");
            const avgScanCountElement = document.getElementById("avg-scan-count");
            const avgResultCountElement = document.getElementById("avg-result-count");
            const avgSelectivityElement = document.getElementById("avg-selectivity");

            // Update pagination over-scan insight
            const paginationOverfetchCountElement = document.getElementById("pagination-overfetch-count");
            const paginationOverfetchAvgElement = document.getElementById("pagination-overfetch-avg-items");
            if (paginationOverfetchCountElement) {
                paginationOverfetchCountElement.textContent = `${paginationOverfetchCount} queries`;
                paginationOverfetchCountElement.className = paginationOverfetchCount > 0 ? "highlight-number" : "";
                const paginationOverfetchPercentElement = document.getElementById("pagination-overfetch-percent");
                if (paginationOverfetchPercentElement) {
                    const paginationOverfetchPercent = totalQueries > 0 ? ((paginationOverfetchCount / totalQueries) * 100).toFixed(1) : 0;
                    paginationOverfetchPercentElement.textContent = `${paginationOverfetchPercent}%`;
                    paginationOverfetchPercentElement.className = paginationOverfetchCount > 0 ? "highlight-number" : "";
                }
            }
            if (paginationOverfetchAvgElement) {
                const avgScanned = paginationOverfetchCount > 0 ? Math.round(paginationOverfetchTotalScanned / paginationOverfetchCount) : 0;
                paginationOverfetchAvgElement.textContent = avgScanned.toLocaleString();
                paginationOverfetchAvgElement.className = paginationOverfetchCount > 0 ? "highlight-number" : "";
            }

            if (inefficientIndexScansCountElement) {
                inefficientIndexScansCountElement.textContent = `${inefficientIndexScansCount} queries`;
                inefficientIndexScansCountElement.className = inefficientIndexScansCount > 0 ? "highlight-number" : "";
                const inefficientIndexScansPercentElement = document.getElementById("inefficient-index-scans-percent");
                if (inefficientIndexScansPercentElement) {
                    const inefficientIndexScansPercent = totalQueries > 0 ? ((inefficientIndexScansCount / totalQueries) * 100).toFixed(1) : 0;
                    inefficientIndexScansPercentElement.textContent = `${inefficientIndexScansPercent}%`;
                    inefficientIndexScansPercentElement.className = inefficientIndexScansCount > 0 ? "highlight-number" : "";
                }
            }

            // Calculate and display averages
            if (window.inefficientScanMetrics && window.inefficientScanMetrics.length > 0) {
                const totalScanned = window.inefficientScanMetrics.reduce((sum, metric) => sum + metric.scanned, 0);
                const totalResults = window.inefficientScanMetrics.reduce((sum, metric) => sum + metric.resultCount, 0);
                const totalSelectivity = window.inefficientScanMetrics.reduce((sum, metric) => sum + metric.selectivity, 0);

                const avgScanned = Math.round(totalScanned / window.inefficientScanMetrics.length);
                const avgResults = Math.round(totalResults / window.inefficientScanMetrics.length);
                const avgSelectivity = (totalSelectivity / window.inefficientScanMetrics.length).toFixed(2);

                if (avgScanCountElement) {
                    avgScanCountElement.textContent = avgScanned.toLocaleString();
                    avgScanCountElement.className = "highlight-number";
                }
                if (avgResultCountElement) {
                    avgResultCountElement.textContent = avgResults.toLocaleString();
                    avgResultCountElement.className = "highlight-number";
                }
                if (avgSelectivityElement) {
                    avgSelectivityElement.textContent = `${avgSelectivity}%`;
                    avgSelectivityElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults when no inefficient queries
                if (avgScanCountElement) {
                    avgScanCountElement.textContent = "0";
                    avgScanCountElement.className = "";
                }
                if (avgResultCountElement) {
                    avgResultCountElement.textContent = "0";
                    avgResultCountElement.className = "";
                }
                if (avgSelectivityElement) {
                    avgSelectivityElement.textContent = "0%";
                    avgSelectivityElement.className = "";
                }
            }

            // Update the timeout-prone queries insight
            const timeoutProneContent = document.getElementById("timeout-prone-queries-content");
            if (timeoutProneContent) {
                const approachingHighlight = approachingTimeoutCount > 0 ? "highlight-number" : "";
                const actualHighlight = actualTimeoutCount > 0 ? "highlight-number" : "";
                const approachingTimeoutPercent = totalQueries > 0 ? ((approachingTimeoutCount / totalQueries) * 100).toFixed(1) : 0;
                const actualTimeoutPercent = totalQueries > 0 ? ((actualTimeoutCount / totalQueries) * 100).toFixed(1) : 0;
                
                timeoutProneContent.innerHTML = `
                    <p class=\"insight-description\">
                        <span id=\"approaching-timeout-count\" class=\"${approachingHighlight}\">${approachingTimeoutCount} queries</span> (<span id=\"approaching-timeout-percent\" class=\"${approachingHighlight}\">${approachingTimeoutPercent}%</span>) are consistently approaching timeout
                        thresholds, with <span id=\"actual-timeout-count\" class=\"${actualHighlight}\">${actualTimeoutCount} queries</span> (<span id=\"actual-timeout-percent\" class=\"${actualHighlight}\">${actualTimeoutPercent}%</span>) actually timing out
                        in the analyzed period. <em>(Default query timeout: 75 seconds / 1m15s)</em>
                    </p>

                    <button id=\"toggle-timeout-prone-queries-sample-queries-btn\" onclick=\"toggleTimeoutQueriesTable()\" class=\"btn-standard\" style=\"margin-top: 10px;\">
                        <span id=\"timeout-prone-queries-sample-queries-btn-text\">Show Sample Queries</span>
                    </button>
                    <div id=\"timeout-prone-queries-sample-queries-container\" style=\"display: none; margin-top: 10px;\">
                        <table class=\"sample-queries-table\">
                            <thead>
                                <tr>
                                    <th>Request Date</th>
                                    <th>Statement (unique)</th>
                                    <th>Elapsed Time</th>
                                </tr>
                            </thead>
                            <tbody id=\"timeout-prone-queries-sample-queries-tbody\">
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // Reset metrics for next parse
            window.inefficientScanMetrics = [];

            // Update slow index scan times insight
            updateSlowIndexScanTimes(requests);

            // Update sample queries for each insight
            updateInsightSampleQueries('missing-where-clauses', missingWhereClausesSamples);
            updateInsightSampleQueries('slow-use-key-queries', slowUseKeyQueriesSamples);
            updateInsightSampleQueries('large-result-set-queries', largeResultSetQueriesSamples);
            updateInsightSampleQueries('inefficient-like-operations', inefficientLikeOperationsSamples);
            updateInsightSampleQueries('select-star-usage', selectStarUsageSamples);
            updateInsightSampleQueries('pagination-index-overfetch', paginationOverfetchSamples);
            updateInsightSampleQueries('high-memory-usage', highMemoryUsageSamples);
            updateInsightSampleQueries('high-kernel-time-queries', highKernelTimeQueriesSamples);
            updateInsightSampleQueries('large-payload-streaming', largePayloadStreamingSamples);

            // Special handling for timeout queries (3-column table with 10 entries)
            updateTimeoutQueriesTable(actualTimeoutsSamples, approachingTimeoutsSamples);

            // Update navigation counts and accordion states
            updateInsightNavigation();
        }

        // Analyze core execTime vs kernel time ratio
        function analyzeCoreExecToKernelRatio(operator) {
            if (!operator) return { coreToKernelRatio: 0 };

            let totalExecTime = 0;
            let streamExecTime = 0;
            let highestKernelTime = 0;

            function sumExecAndKernelTimes(op) {
                if (!op) return;

                if (op["#stats"]) {
                    const stats = op["#stats"];

                    // Sum all execTime
                    if (stats["execTime"]) {
                        const execTime = parseTime(stats["execTime"]);
                        if (!isNaN(execTime)) {
                            totalExecTime += execTime;

                            // Track stream execTime separately
                            if (op["#operator"] === "Stream") {
                                streamExecTime += execTime;
                            }
                        }
                    }

                    // Track highest kernel time
                    if (stats["kernTime"]) {
                        const kernTime = parseTime(stats["kernTime"]);
                        if (!isNaN(kernTime)) {
                            highestKernelTime = Math.max(highestKernelTime, kernTime);
                        }
                    }
                }

                // Recursively check child operators
                if (op["~child"]) {
                    sumExecAndKernelTimes(op["~child"]);
                }
                if (op["~children"]) {
                    for (const child of op["~children"]) {
                        sumExecAndKernelTimes(child);
                    }
                }
            }

            sumExecAndKernelTimes(operator);

            // Calculate core execTime (total minus stream) vs kernel time ratio
            const coreExecTime = totalExecTime - streamExecTime;
            const coreToKernelRatio = highestKernelTime > 0 ? (coreExecTime / highestKernelTime) * 100 : 0;



            return {
                coreToKernelRatio: coreToKernelRatio
            };
        }

        // Analyze stream execution time vs elapsed time
        function analyzeStreamToElapsedRatio(operator, elapsedTimeMs, thresholdPercent) {
            if (!operator) return { qualifies: false, streamRatio: 0 };

            let streamExecTime = 0;

            function findStreamTimes(op) {
                if (!op) return;

                if (op["#stats"]) {
                    const stats = op["#stats"];

                    // Find Stream operations
                    if (op["#operator"] === "Stream" && stats["execTime"]) {
                        const execTime = parseTime(stats["execTime"]);
                        if (!isNaN(execTime)) {
                            streamExecTime += execTime;
                        }
                    }
                }

                // Recursively check child operators
                if (op["~child"]) {
                    findStreamTimes(op["~child"]);
                }
                if (op["~children"]) {
                    for (const child of op["~children"]) {
                        findStreamTimes(child);
                    }
                }
            }

            findStreamTimes(operator);

            // Calculate stream to elapsed time ratio
            const streamRatio = elapsedTimeMs > 0 ? (streamExecTime / elapsedTimeMs) * 100 : 0;
            const qualifies = streamRatio >= thresholdPercent;



            return {
                qualifies: qualifies,
                streamRatio: streamRatio
            };
        }

        // Toggle accordion category
        function toggleCategory(categoryId) {
            const title = document.querySelector(`#${categoryId} .category-title`);
            const content = document.getElementById(`${categoryId}-content`);

            if (title && content) {
                title.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
            }
        }

        // Toggle individual insight
        function toggleInsight(insightId) {
            const title = document.querySelector(`[onclick="toggleInsight('${insightId}')"]`);
            const content = document.getElementById(`${insightId}-content`);

            if (title && content) {
                title.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
            }
        }

        // Update insight accordion states
        function updateInsightNavigation() {
            // Always show all categories and expand them
            const categories = ['index-issues', 'resource-issues', 'pattern-analysis', 'performance-opportunities'];

            categories.forEach(categoryId => {
                const categoryElement = document.getElementById(categoryId);
                const titleElement = categoryElement?.querySelector('.category-title');
                const contentElement = document.getElementById(`${categoryId}-content`);

                // Show category and expand accordion
                if (categoryElement) categoryElement.style.display = 'block';
                if (titleElement) titleElement.classList.remove('collapsed');
                if (contentElement) contentElement.classList.remove('collapsed');
            });

            // Auto-expand individual insights that have issues (non-zero values)
            autoExpandInsightsWithIssues();
        }

        // Auto-expand insights with actual issues found
        function autoExpandInsightsWithIssues() {
            const insights = [
                { id: 'inefficient-index-scans', checkElement: 'inefficient-index-scans-count' },
                { id: 'slow-index-scan-times', checkElements: ['slow-indexes-2-10s', 'slow-indexes-10s-plus', 'slow-primary-indexes'] },
                { id: 'primary-index-over-usage', checkElement: 'primary-avg-items-scanned' },
                { id: 'high-kernel-time-queries', checkElement: 'high-kernel-time-queries-count' },
                { id: 'high-memory-usage', checkElement: 'high-memory-count' },
                { id: 'slow-use-key-queries', checkElement: 'slow-use-keys-count' },
                { id: 'missing-where-clauses', checkElement: 'missing-where-count' },
                { id: 'inefficient-like-operations', checkElement: 'inefficient-like-count' },
                { id: 'select-star-usage', checkElement: 'select-star-count' },
                { id: 'pagination-index-overfetch', checkElement: 'pagination-overfetch-count' },
                { id: 'large-result-set-queries', checkElement: 'large-results-count' },
                { id: 'large-payload-streaming', checkElement: 'large-payload-count' },
                { id: 'timeout-prone-queries', checkElements: ['approaching-timeout-count', 'actual-timeout-count'] }
            ];

            insights.forEach(insight => {
                const titleElement = document.querySelector(`[onclick="toggleInsight('${insight.id}')"]`);
                const contentElement = document.getElementById(`${insight.id}-content`);

                let hasIssues = false;

                // Check if insight has issues (non-zero values)
                if (insight.checkElement) {
                    const element = document.getElementById(insight.checkElement);
                    if (element && element.textContent) {
                        const value = element.textContent.match(/\d+/);
                        hasIssues = value && parseInt(value[0]) > 0;
                    }
                }

                if (insight.checkElements) {
                    hasIssues = insight.checkElements.some(elementId => {
                        const element = document.getElementById(elementId);
                        if (element && element.textContent) {
                            const value = element.textContent.match(/\d+/);
                            return value && parseInt(value[0]) > 0;
                        }
                        return false;
                    });
                }

                // Set accordion state based on whether issues were found
                if (hasIssues) {
                    // Expand insight with issues
                    if (titleElement) titleElement.classList.remove('collapsed');
                    if (contentElement) contentElement.classList.remove('collapsed');
                } else {
                    // Collapse insight with no issues
                    if (titleElement) titleElement.classList.add('collapsed');
                    if (contentElement) contentElement.classList.add('collapsed');
                }

                // Toggle visual active state (blue edge when issues found)
                const card = titleElement ? titleElement.closest('.insight-item') : null;
                if (card) {
                    card.classList.toggle('active', !!hasIssues);
                }
            });

            // Handle dev insights - always collapsed and not active since they don't have real data
            const devInsights = document.querySelectorAll('.insight-item:has(.dev-badge)');
            devInsights.forEach(devInsight => {
                const titleElement = devInsight.querySelector('.insight-title');
                const contentElement = devInsight.querySelector('.insight-content');

                if (titleElement) titleElement.classList.add('collapsed');
                if (contentElement) contentElement.classList.add('collapsed');
                devInsight.classList.remove('active');
            });

            // Handle beta insights - collapsed by default, but can be expanded based on results
            // (Beta insights are included in the main insights array above)
        }

        // Update slow index scan times insight
        function updateSlowIndexScanTimes(requests) {
            const indexData = {};
            let totalIndexes = 0;
            let slowIndexes2to10s = 0;
            let slowIndexes10sPlus = 0;
            let slowPrimaryIndexes = 0;

            // Collect index data using same logic as Index/Query Flow
            requests.forEach((request) => {
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;

                        // Extract index names and collect timing data
                        extractIndexNamesAndData(planObj, (indexName) => {
                            if (!indexData[indexName]) {
                                indexData[indexName] = {
                                    name: indexName,
                                    scanTimes: [],
                                    totalUsage: 0
                                };
                            }

                            const indexScanData = extractIndexScanDataFromPlan(request.plan, indexName);
                            if (indexScanData.scanTime > 0) {
                                indexData[indexName].scanTimes.push(indexScanData.scanTime);
                                indexData[indexName].totalUsage++;
                            }
                        });
                    } catch (e) {
                        console.error("Error parsing plan for index timing:", e);
                    }
                }
            });

            // Helper function to extract index names
            function extractIndexNamesAndData(operator, callback) {
                if (!operator) return;

                const opType = operator["#operator"];

                if ((opType === "IndexScan3" || opType === "PrimaryScan3" || opType === "KeyScan") && operator.index) {
                    callback(operator.index);
                }

                // Recursively search child operators
                if (operator["~child"]) {
                    extractIndexNamesAndData(operator["~child"], callback);
                }
                if (operator["~children"]) {
                    for (const child of operator["~children"]) {
                        extractIndexNamesAndData(child, callback);
                    }
                }
            }

            // Use the same aggregated index data as Index/Query Flow
            updatePrimaryIndexOverUsageFromAggregatedData(requests);

            // Debug: Log the collected index data
            console.log(`${TEXT_CONSTANTS.COLLECTED_INDEX_DATA}`, indexData);

            // Analyze timing data for each index
            Object.values(indexData).forEach((index) => {
                totalIndexes++;

                if (index.scanTimes && index.scanTimes.length > 0) {
                    const avgScanTimeMs = index.scanTimes.reduce((a, b) => a + b, 0) / index.scanTimes.length;
                    const avgScanTimeSeconds = avgScanTimeMs / 1000;

                    if (avgScanTimeSeconds >= 10) {
                        slowIndexes10sPlus++;
                        console.log(`${index.name} is 10+ seconds`);
                    } else if (avgScanTimeSeconds >= 2) {
                        slowIndexes2to10s++;
                        console.log(`${index.name} is 2-10 seconds`);
                    }

                    // Check if it's a primary index with 2+ seconds
                    if ((index.name.includes("primary") || index.name === "#primary" || index.name === "def_primary") && avgScanTimeSeconds >= 2) {
                        slowPrimaryIndexes++;
                        console.log(`${index.name} is a slow primary index`);
                    }
                }
            });



            // Update display elements for slow index scan times
            const totalIndexesElement = document.getElementById("total-indexes-count");
            const slowIndexes2to10sElement = document.getElementById("slow-indexes-2-10s");
            const slowIndexes10sPlusElement = document.getElementById("slow-indexes-10s-plus");
            const slowPrimaryIndexesElement = document.getElementById("slow-primary-indexes");

            if (totalIndexesElement) totalIndexesElement.textContent = totalIndexes;
            if (slowIndexes2to10sElement) slowIndexes2to10sElement.textContent = slowIndexes2to10s;
            if (slowIndexes10sPlusElement) slowIndexes10sPlusElement.textContent = slowIndexes10sPlus;
            if (slowPrimaryIndexesElement) slowPrimaryIndexesElement.textContent = slowPrimaryIndexes;
        }

        // Update Primary Index Over-Usage using same aggregated data as Index/Query Flow
        function updatePrimaryIndexOverUsageFromAggregatedData(requests) {
            const allIndexes = new Map();

            // Use the exact same logic as Index/Query Flow to build aggregated index data
            requests.forEach((request) => {
                if (request.plan) {
                    try {
                        const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;
                        extractIndexNamesForFlow(planObj, allIndexes, request);
                    } catch (e) {
                        console.error("Error parsing plan for aggregated index data:", e);
                    }
                }
            });

            // Helper function (simplified version of existing Index/Query Flow logic)
            function extractIndexNamesForFlow(operator, allIndexes, request) {
                if (!operator) return;

                const opType = operator["#operator"];

                if ((opType === "IndexScan3" || opType === "PrimaryScan3" || opType === "KeyScan") && operator.index) {
                    const indexName = operator.index;

                    if (!allIndexes.has(indexName)) {
                        allIndexes.set(indexName, {
                            name: indexName,
                            totalUsage: 0,
                            scanTimes: [],
                            itemsScanned: [],
                            itemsFetched: []
                        });
                    }

                    const indexObj = allIndexes.get(indexName);
                    indexObj.totalUsage++;

                    // Extract data using same function as Index/Query Flow
                    const indexData = extractIndexScanDataFromPlan(request.plan, indexName);
                    if (indexData.scanTime > 0) {
                        indexObj.scanTimes.push(indexData.scanTime);
                    }
                    if (indexData.itemsScanned > 0) {
                        indexObj.itemsScanned.push(indexData.itemsScanned);
                    }
                    if (indexData.itemsFetched > 0) {
                        indexObj.itemsFetched.push(indexData.itemsFetched);
                    }
                }

                // Recursively search child operators (same as existing logic)
                if (operator["~child"]) {
                    extractIndexNamesForFlow(operator["~child"], allIndexes, request);
                }
                if (operator["~children"]) {
                    for (const child of operator["~children"]) {
                        extractIndexNamesForFlow(child, allIndexes, request);
                    }
                }
            }

            // Now analyze primary indexes using aggregated data
            let totalPrimaryItemsScanned = 0;
            let totalPrimaryScanTime = 0;
            let primaryIndexCount = 0;

            allIndexes.forEach((index) => {
                const isPrimary = index.name.includes("primary") || index.name === "#primary" || index.name === "def_primary";

                if (isPrimary && index.itemsScanned.length > 0) {
                    // Calculate aggregated stats using same logic as Index/Query Flow
                    const avgItemsScanned = Math.round(
                        index.itemsScanned.reduce((a, b) => a + b, 0) / index.itemsScanned.length
                    );
                    const avgScanTime = index.scanTimes.length > 0
                        ? Math.round(index.scanTimes.reduce((a, b) => a + b, 0) / index.scanTimes.length)
                        : 0;

                    if (avgItemsScanned > 10000) {
                        totalPrimaryItemsScanned += avgItemsScanned;
                        totalPrimaryScanTime += avgScanTime;
                        primaryIndexCount++;
                    }
                }
            });

            // Update primary index over-usage insight display
            const primaryAvgItemsScannedElement = document.getElementById("primary-avg-items-scanned");
            const primaryAvgScanTimeElement = document.getElementById("primary-avg-scan-time");

            if (primaryIndexCount > 0) {
                const avgItemsScanned = Math.round(totalPrimaryItemsScanned / primaryIndexCount);
                const avgScanTime = Math.round(totalPrimaryScanTime / primaryIndexCount);

                if (primaryAvgItemsScannedElement) {
                    primaryAvgItemsScannedElement.textContent = avgItemsScanned.toLocaleString();
                    primaryAvgItemsScannedElement.className = "highlight-number";
                }
                if (primaryAvgScanTimeElement) {
                    primaryAvgScanTimeElement.textContent = `${avgScanTime}ms`;
                    primaryAvgScanTimeElement.className = "highlight-number";
                }
            } else {
                // Reset to defaults
                if (primaryAvgItemsScannedElement) {
                    primaryAvgItemsScannedElement.textContent = "0";
                    primaryAvgItemsScannedElement.className = "";
                }
                if (primaryAvgScanTimeElement) {
                    primaryAvgScanTimeElement.textContent = "0ms";
                    primaryAvgScanTimeElement.className = "";
                }
            }
        }

        // Extract index data for timing analysis (simplified version of existing logic)
        function extractIndexDataForTiming(operator, indexData) {
            if (!operator) return;

            const opType = operator["#operator"];

            if ((opType === "IndexScan3" || opType === "PrimaryScan3" || opType === "KeyScan") && operator.index) {
                const indexName = operator.index;

                if (!indexData[indexName]) {
                    indexData[indexName] = {
                        name: indexName,
                        scanTimes: [],
                        totalUsage: 0
                    };
                }

                if (operator["#stats"] && operator["#stats"]["servTime"]) {
                    const scanTime = parseTime(operator["#stats"]["servTime"]);
                    indexData[indexName].scanTimes.push(scanTime);
                    indexData[indexName].totalUsage++;
                }
            }

            // Recursively search child operators
            if (operator["~child"]) {
                extractIndexDataForTiming(operator["~child"], indexData);
            }
            if (operator["~children"]) {
                for (const child of operator["~children"]) {
                    extractIndexDataForTiming(child, indexData);
                }
            }
        }



        // Validate date range for time grouping
        function validateDateRangeForGrouping(startDate, endDate, grouping) {
            if (!startDate || !endDate || grouping === "optimizer" || grouping === "day")
                return { valid: true };

            const diffMs = endDate.getTime() - startDate.getTime();
            const diffHours = diffMs / (1000 * 60 * 60);
            const diffDays = diffMs / (1000 * 60 * 60 * 24);

            switch (grouping) {
                case "second":
                    if (diffHours > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Second" grouping, please restrict the date range to 1 hour or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "minute":
                    if (diffDays > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Minute" grouping, please restrict the date range to 1 day or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "5min":
                    const diffWeeks5min = diffDays / 7;
                    if (diffWeeks5min > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by 5min" grouping, please restrict the date range to 1 week or less to avoid chart rendering issues.',
                        };
                    }
                    break;
                case "hour":
                    const diffWeeks = diffDays / 7;
                    if (diffWeeks > 1) {
                        return {
                            valid: false,
                            message:
                                'For "by Hour" grouping, please restrict the date range to 1 week or less to avoid chart rendering issues.',
                        };
                    }
                    break;
            }

            return { valid: true };
        }

        // Centralized request data processor with single-pass optimization
        function processRequestData(item) {
            const request = item.completed_requests || item;

            // Parse and cache plan data immediately
            let plan = null;
            if (item.plan) {
                if (typeof item.plan === "string") {
                    try {
                        plan = JSON.parse(item.plan);
                    } catch (e) {
                        console.warn(`${TEXT_CONSTANTS.JSON_PARSING_ERROR} plan for request:`, e.message);
                        showSlidingNotification(`${TEXT_CONSTANTS.ERROR_PARSING_JSON} ${e.message}`, "warning");
                        plan = null;
                    }
                } else {
                    plan = item.plan;
                }
            }

            // Get operators once and cache all derived values
            let operators = [];
            let planMetadata = null;

            if (plan) {
                // Check if we already cached the plan stats
                if (planStatsCache.has(plan)) {
                    planMetadata = planStatsCache.get(plan);
                    operators = planMetadata.operators;
                } else {
                    // Single pass through operators to extract all needed data
                    operators = getOperators(plan);

                    // Calculate all time values in one pass
                    let maxKernTime = 0;
                    let totalExecTime = 0;
                    let totalServiceTime = 0;
                    let totalMemoryUsage = 0;
                    let totalItemsIn = 0;
                    let totalItemsOut = 0;
                    let streamTime = 0;
                    let fetchTime = 0;
                    let sortTime = 0;
                    const indexes = [];
                    const stats = { primaryScan: 0, indexScan: 0, fetch: 0 };
                    let usesPrimaryFlag = false;

                    operators.forEach((operator) => {
                        const operatorStats = operator["#stats"] || {};
                        const operatorType = operator["#operator"];

                        // Parse times once
                        const kernTime = parseTime(operatorStats.kernTime);
                        const execTime = parseTime(operatorStats.execTime);
                        const servTime = parseTime(operatorStats.servTime);
                        const usedMemory = operatorStats.usedMemory || 0;

                        // Aggregate times and stats
                        if (!isNaN(kernTime)) maxKernTime = Math.max(maxKernTime, kernTime);
                        if (!isNaN(execTime)) totalExecTime += execTime;
                        if (!isNaN(servTime)) totalServiceTime += servTime;
                        if (!isNaN(usedMemory)) totalMemoryUsage += usedMemory;

                        // Aggregate items in/out
                        totalItemsIn += operatorStats["#itemsIn"] || 0;
                        totalItemsOut += operatorStats["#itemsOut"] || 0;

                        // Extract index information
                        if (operator.index) {
                            indexes.push(operator.index);
                        }

                        // Check for primary index usage
                        if (operatorType === "PrimaryScan" ||
                            operatorType === "PrimaryScan3" ||
                            operator.index === "#primary" ||
                            (operator.spans && operator.spans.length === 0)) {
                            usesPrimaryFlag = true;
                        }

                        // Update stats counters with actual items and extract phase times
                        if (operatorType === "PrimaryScan" || operatorType === "PrimaryScan3") {
                            stats.primaryScan += operatorStats["#itemsOut"] || 0;
                        } else if (operatorType === "IndexScan" || operatorType === "IndexScan3") {
                            stats.indexScan += operatorStats["#itemsOut"] || 0;
                        } else if (operatorType === "Fetch") {
                            stats.fetch += operatorStats["#itemsOut"] || 0;
                            fetchTime += execTime;
                        } else if (operatorType === "Stream") {
                            streamTime += execTime;
                        } else if (operatorType === "Order" || operatorType === "Sort") {
                            sortTime += execTime;
                        }
                    });

                    // Cache all computed values including performance ratios
                    const elapsedTimeMs = parseTime(request.elapsedTime);
                    const streamRatio = elapsedTimeMs > 0 ? (streamTime / elapsedTimeMs) * 100 : 0;
                    const fetchRatio = elapsedTimeMs > 0 ? (fetchTime / elapsedTimeMs) * 100 : 0;

                    planMetadata = {
                        operators: operators,
                        maxKernTime: maxKernTime,
                        totalExecTime: totalExecTime,
                        totalServiceTime: totalServiceTime,
                        totalMemoryUsage: totalMemoryUsage,
                        totalItemsIn: totalItemsIn,
                        totalItemsOut: totalItemsOut,
                        streamTime: streamTime,
                        fetchTime: fetchTime,
                        sortTime: sortTime,
                        streamRatio: streamRatio,
                        fetchRatio: fetchRatio,
                        indexes: indexes,
                        stats: stats,
                        usesPrimary: usesPrimaryFlag,
                        indexInfo: { indexes: indexes, stats: stats }
                    };

                    planStatsCache.set(plan, planMetadata);
                }
            }

            // Pre-calculate commonly used values using cached data
            const elapsedTimeMs = parseTime(request.elapsedTime);
            const processedRequest = {
                ...request,
                plan: plan,
                // Use cached time values or fallback to direct parsing
                elapsedTimeMs: elapsedTimeMs,
                serviceTimeMs: planMetadata ? planMetadata.totalServiceTime : parseTime(request.serviceTime || '0ms'),
                kernTimeMs: planMetadata ? planMetadata.maxKernTime : 0,
                memoryBytes: (typeof request.usedMemory === 'number') ? request.usedMemory : null,
                // Use cached boolean flags
                usesPrimary: planMetadata ? planMetadata.usesPrimary : false,
                // Use cached index information
                indexInfo: planMetadata ? planMetadata.indexInfo : null,
                // Store performance insights
                streamRatio: planMetadata ? planMetadata.streamRatio : 0,
                fetchRatio: planMetadata ? planMetadata.fetchRatio : 0,
                isStreamHeavy: planMetadata ? planMetadata.streamRatio > 50 : false,
                isLargePayload: (request.resultSize || 0) > 50000000 || (request.resultCount || 0) > 10000,
                // Store metadata for quick access
                _planMetadata: planMetadata,
                // Normalize prepared queries: prefer raw statement; fallback to preparedText, and clean for display
                statement: (function(){
                    const raw = request.statement || request.preparedText || '';
                    try {
                        const tmp = document.createElement('div');
                        tmp.innerHTML = raw; // decode entities
                        let txt = (tmp.textContent || tmp.innerText || '');
                        txt = txt.replace(/<[^>]*>/g, ' '); // strip any tags like <ud>
                        return txt.replace(/\s+/g, ' ').trim();
                    } catch (e) { return raw; }
                })(),
                // Ensure we have a statement type (derive if not present)
                statementType: request.statementType || deriveStatementType(request.statement || request.preparedText),
            };

            return processedRequest;
        }

        // Fast index information extraction (optimized with cache)
        function extractIndexInfo(plan) {
            // Check plan cache first
            if (planStatsCache.has(plan)) {
                return planStatsCache.get(plan).indexInfo;
            }

            // Fallback to original calculation
            const operators = getOperators(plan);
            const indexes = [];
            const stats = { primaryScan: 0, indexScan: 0, fetch: 0 };

            operators.forEach((operator) => {
                const operatorType = operator["#operator"];
                const operatorStats = operator["#stats"] || {};

                // Extract index names
                if (operator.index) {
                    indexes.push(operator.index);
                }

                // Aggregate stats
                if (
                    operatorType === "PrimaryScan" ||
                    operatorType === "PrimaryScan3"
                ) {
                    stats.primaryScan += operatorStats["#itemsOut"] || 0;
                } else if (
                    operatorType === "IndexScan" ||
                    operatorType === "IndexScan3"
                ) {
                    stats.indexScan += operatorStats["#itemsOut"] || 0;
                } else if (operatorType === "Fetch") {
                    stats.fetch += operatorStats["#itemsOut"] || 0;
                }
            });

            return { indexes, stats };
        }

        // Fast plan stats extraction
        function extractPlanStats(plan) {
            // Check cache first
            if (planStatsCache.has(plan)) {
                const metadata = planStatsCache.get(plan);
                return { totalItemsIn: metadata.totalItemsIn || 0, totalItemsOut: metadata.totalItemsOut || 0 };
            }

            // Fallback calculation
            const operators = getOperators(plan);
            let totalItemsIn = 0;
            let totalItemsOut = 0;

            operators.forEach((operator) => {
                const stats = operator["#stats"] || {};
                totalItemsIn += stats["#itemsIn"] || 0;
                totalItemsOut += stats["#itemsOut"] || 0;
            });

            return { totalItemsIn, totalItemsOut };
        }



        // Lazy chart loading setup - generate charts only when tabs are activated
        function setupLazyChartLoading(filteredRequests, fullDataset) {
            // Track which tabs have been loaded
            const loadedTabs = new Set();

            // ALWAYS generate dashboard charts immediately after parsing (not lazy)
            // This ensures fresh data every time, regardless of which tab is active
            generateDashboardCharts(fullDataset || filteredRequests);
            loadedTabs.add('dashboard');
            // Initialize drag and drop for dashboard charts
            setTimeout(() => setupChartDragAndDrop(), 100);
            
            // Initialize drag and drop for all charts
            setTimeout(() => setupChartDragAndDrop(), 100);

            // Set up lazy loading for other tabs
            $('#tabs').on('tabsactivate', function (event, ui) {
                const tabId = ui.newPanel.attr('id');

                if (!loadedTabs.has(tabId)) {
                    const loadStart = performance.now();

                    try {
                        switch (tabId) {
                            case 'dashboard':
                                // Dashboard charts are now always generated immediately after parsing
                                // No need to regenerate when switching tabs
                                break;
                            case 'timeline':
                                // For aggregation-based charts (operations, filter), use full data
                                // For timeline chart (individual request visualization), use sampling for performance
                                const sampleSize = Math.min(500, filteredRequests.length);
                                const sampleStep = Math.max(1, Math.floor(filteredRequests.length / sampleSize));
                                const timelineSample = filteredRequests.filter((_, i) => i % sampleStep === 0);

                                console.log(`${TEXT_CONSTANTS.TIMELINE_CHARTS_USING} ${timelineSample.length} ${TEXT_CONSTANTS.OF_TOTAL} ${filteredRequests.length} ${TEXT_CONSTANTS.REQUESTS_FOR_PERFORMANCE}`);

                                // Use full data for aggregation charts that sum/count data
                                generateOperationsChart(filteredRequests);
                                generateFilterChart(filteredRequests);
                                // Use sampled data only for individual request timeline
                                generateTimelineChart(timelineSample);
                                
                                // Re-initialize drag and drop for timeline charts
                                setTimeout(() => setupChartDragAndDrop(), 100);
                                break;
                            case 'index-query-flow':
                                buildIndexQueryFlow(filteredRequests);
                                break;
                            case 'insights':
                                // Insights don't need chart generation, they use cached data
                                break;
                        }

                        loadedTabs.add(tabId);
                        const loadEnd = performance.now();
                        console.log(`${TEXT_CONSTANTS.LAZY_LOADED_TAB} ${tabId} ${TEXT_CONSTANTS.TAB_IN} ${Math.round(loadEnd - loadStart)}${TEXT_CONSTANTS.MS}`);
                    } catch (e) {
                        console.error(`${TEXT_CONSTANTS.ERROR_LAZY_LOADING} ${tabId} ${TEXT_CONSTANTS.TAB_IN}`, e);
                    }
                }
            });

            // Also refresh the currently active tab immediately after parsing (important when Timeline is already open)
            try {
                const $tabs = $('#tabs');
                if ($tabs && $tabs.length) {
                    const activeIndex = $tabs.tabs('option', 'active');
                    const panels = $tabs.find('.ui-tabs-panel');
                    const activePanel = panels && panels.eq ? panels.eq(activeIndex) : null;
                    const activeId = activePanel && activePanel.attr ? activePanel.attr('id') : null;
                    if (activeId && !loadedTabs.has(activeId)) {
                        const loadStart = performance.now();
                        switch (activeId) {
                            case 'dashboard':
                                // Already generated above
                                break;
                            case 'timeline': {
                                // Same logic as tabsactivate handler
                                const sampleSize = Math.min(500, filteredRequests.length);
                                const sampleStep = Math.max(1, Math.floor(filteredRequests.length / sampleSize));
                                const timelineSample = filteredRequests.filter((_, i) => i % sampleStep === 0);
                                console.log(`${TEXT_CONSTANTS.TIMELINE_CHARTS_USING} ${timelineSample.length} ${TEXT_CONSTANTS.OF_TOTAL} ${filteredRequests.length} ${TEXT_CONSTANTS.REQUESTS_FOR_PERFORMANCE}`);
                                generateOperationsChart(filteredRequests);
                                generateFilterChart(filteredRequests);
                                generateTimelineChart(timelineSample);
                                setTimeout(() => setupChartDragAndDrop(), 100);
                                break;
                            }
                            case 'index-query-flow':
                                buildIndexQueryFlow(filteredRequests);
                                break;
                            case 'insights':
                                // nothing
                                break;
                        }
                        loadedTabs.add(activeId);
                        const loadEnd = performance.now();
                        console.log(`${TEXT_CONSTANTS.LAZY_LOADED_TAB} ${activeId} ${TEXT_CONSTANTS.TAB_IN} ${Math.round(loadEnd - loadStart)}${TEXT_CONSTANTS.MS}`);
                    }
                }
            } catch (e) {
                console.error(`${TEXT_CONSTANTS.ERROR_LAZY_LOADING} active-tab`, e);
            }
        }

        // Filter reminder toast notification
        let filterReminderTimeout = null;

        function showFilterReminder() {
            // Clear any existing timeout
            if (filterReminderTimeout) {
                clearTimeout(filterReminderTimeout);
            }

            // Remove any existing filter reminder toasts
            const existingFilterToasts = document.querySelectorAll(".filter-reminder-toast");
            existingFilterToasts.forEach((toast) => toast.remove());

            // Create the toast
            const toast = document.createElement("div");
            toast.className = "filter-reminder-toast";
            toast.textContent = TEXT_CONSTANTS.FILTERS_CHANGED_REMINDER;
            toast.style.cssText = `
                position: fixed;
                top: -50px;
                left: 20px;
                padding: 12px 20px;
                border-radius: 6px;
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                color: #856404;
                font-size: 13px;
                font-weight: 500;
                z-index: 10001;
                max-width: 320px;
                word-wrap: break-word;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                transition: all 0.4s ease-out;
                transform: translateY(0px);
            `;

            document.body.appendChild(toast);

            // Animate slide down from top
            setTimeout(() => {
                toast.style.top = "20px";
                toast.style.transform = "translateY(0px)";
            }, 10);

            // Auto-hide after 10 seconds
            filterReminderTimeout = setTimeout(() => {
                toast.style.opacity = "0";
                toast.style.transform = "translateY(-10px)";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 400);
                filterReminderTimeout = null;
            }, 10000);
        }

        function hideFilterReminder() {
            // Clear timeout and remove any existing filter reminder toasts
            if (filterReminderTimeout) {
                clearTimeout(filterReminderTimeout);
                filterReminderTimeout = null;
            }
            const existingFilterToasts = document.querySelectorAll(".filter-reminder-toast");
            existingFilterToasts.forEach((toast) => {
                toast.style.opacity = "0";
                toast.style.transform = "translateY(-10px)";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 400);
            });
        }

        // Build an elapsedTime filter predicate from user input
        function makeElapsedFilterPredicate(input) {
            try {
                if (!input || !(input = String(input).trim())) return null;
                const s = input.toLowerCase();

                const toMs = (num, unit) => {
                    const v = parseFloat(num);
                    const u = (unit || 'ms').toLowerCase();
                    if (u === 'ms') return v;
                    if (u === 's') return v * 1000;
                    if (u === 'µs' || u === 'us') return v / 1000;
                    // Fallback: attempt parseTime on composed string
                    const ms = parseTime(`${v}${u}`);
                    return isNaN(ms) ? NaN : ms;
                };

                // e.g., "100ms-500ms" or "0.5s - 2s" (inclusive)
                const range = s.match(/^(\d*\.?\d+)\s*(µs|us|ms|s)?\s*-\s*(\d*\.?\d+)\s*(µs|us|ms|s)?$/);
                if (range) {
                    // If only one side has a unit, apply it to both sides for user-friendly behavior (e.g., "3-15s")
                    const inferredUnit = range[2] || range[4] || 'ms';
                    const leftMs = toMs(range[1], range[2] || inferredUnit);
                    const rightMs = toMs(range[3], range[4] || inferredUnit);
                    if (isNaN(leftMs) || isNaN(rightMs)) return null;
                    const min = Math.min(leftMs, rightMs);
                    const max = Math.max(leftMs, rightMs);
                    return (x) => typeof x === 'number' && !isNaN(x) && x >= min && x <= max;
                }

                // e.g., ">=500ms", "<2s", "=150ms"
                const comp = s.match(/^(<=|>=|<|>|=)\s*(\d*\.?\d+)\s*(µs|us|ms|s)?$/);
                if (comp) {
                    const op = comp[1];
                    const valMs = toMs(comp[2], comp[3] || 'ms');
                    if (isNaN(valMs)) return null;
                    return (x) => {
                        if (typeof x !== 'number' || isNaN(x)) return false;
                        if (op === '<') return x < valMs;
                        if (op === '<=') return x <= valMs;
                        if (op === '>') return x > valMs;
                        if (op === '>=') return x >= valMs;
                        return x === valMs; // '='
                    };
                }

                // e.g., "500ms+" (>=)
                const plus = s.match(/^(\d*\.?\d+)\s*(µs|us|ms|s)\s*\+$/);
                if (plus) {
                    const valMs = toMs(plus[1], plus[2]);
                    if (isNaN(valMs)) return null;
                    return (x) => typeof x === 'number' && !isNaN(x) && x >= valMs;
                }

                // Bare number: assume ms and '>=' semantics
                const bare = s.match(/^(\d*\.?\d+)$/);
                if (bare) {
                    const valMs = toMs(bare[1], 'ms');
                    if (isNaN(valMs)) return null;
                    return (x) => typeof x === 'number' && !isNaN(x) && x >= valMs;
                }

                return null;
            } catch (e) { return null; }
        }

        // Parse JSON input - Optimized
        function parseJSON() {
            // Hide filter reminder when parsing
            hideFilterReminder();
            
            // Clear caches at start of new parse to prevent memory leaks
            clearCaches();

            // Start performance timing
            const parseStartTime = performance.now();

            // Prefer uploaded file content (in-memory) over textarea to avoid DOM bloat
            const uploadedRaw = (window._uploadedCompletedJsonRaw && typeof window._uploadedCompletedJsonRaw === 'string') ? window._uploadedCompletedJsonRaw : '';
            const taVal = document.getElementById("json-input").value;
            const jsonInput = (uploadedRaw ? uploadedRaw : taVal).trim();
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Reset time grouping to default (By Optimizer) to prevent fine-grain errors
            const timeGroupingSelect = document.getElementById('time-grouping-select');
            if (timeGroupingSelect) {
                timeGroupingSelect.value = 'optimizer';
                // Trigger the change event to update any dependent UI
                changeTimeGrouping();
            }

            // Input validation
            if (!jsonInput) {
                showToast(TEXT_CONSTANTS.PASTE_JSON_FIRST, "warning");
                return;
            }

            if (jsonInput.length > 50 * 1024 * 1024) {
                // 50MB limit
                showToast(TEXT_CONSTANTS.INPUT_TOO_LARGE, "error");
                return;
            }

            try {
                const data = JSON.parse(jsonInput);
                let processData = [];

                if (Array.isArray(data)) {
                    processData = data;
                } else if (data && data.results && Array.isArray(data.results)) {
                    processData = data.results;
                } else {
                    showToast(TEXT_CONSTANTS.VALID_JSON_REQUIRED, "error");
                    return;
                }

                if (processData.length === 0) {
                    showToast(TEXT_CONSTANTS.NO_DATA_FOUND, "warning");
                    return;
                }

                if (Array.isArray(processData)) {
                    // Process data in smaller batches for maximum UI responsiveness
                    const batchSize = 75; // Further reduced for smoother progress updates
                    const processedRequests = [];
                    let skippedCount = 0; // Track filtered out requests

                    // Show progress bar
                    document.getElementById("progress-container").style.display =
                        "block";

                    // Get filter settings once outside the loop for performance
                    const excludeCheckbox = document.getElementById("exclude-system-queries");
                    const isExcluding = excludeCheckbox && excludeCheckbox.checked;
                    const sqlFilter = document.getElementById("sql-statement-filter");
                    const sqlFilterText = sqlFilter ? sqlFilter.value.trim().toLowerCase() : "";

                    // Get date filter settings
                    const startDateInput = document.getElementById("start-date");
                    const endDateInput = document.getElementById("end-date");
                    const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
                    const endDate = endDateInput.value ? new Date(endDateInput.value) : null;

                    // Get elapsedTime filter predicate
                    const elapsedFilterInput = document.getElementById("elapsed-time-filter");
                    const elapsedFilterText = elapsedFilterInput ? elapsedFilterInput.value.trim() : "";
                    const elapsedPredicate = makeElapsedFilterPredicate(elapsedFilterText);

                    function processBatch(startIndex) {
                        const endIndex = Math.min(
                            startIndex + batchSize,
                            processData.length
                        );

                        for (let i = startIndex; i < endIndex; i++) {
                            try {
                                const item = processData[i];
                                const request = item.completed_requests || item;

                                // Early filtering - skip expensive processing for filtered requests
                                if (isExcluding && shouldExcludeSystemQuery(request)) {
                                    skippedCount++;
                                    continue; // Skip this request
                                }

                                // Apply SQL statement filtering early
                                if (sqlFilterText && sqlFilterText.length > 0) {
                                    const statement = (request.statement || request.preparedText || "").toLowerCase().replace(/\s+/g, ' ').trim();
                                    const filterText = sqlFilterText.replace(/\s+/g, ' ').trim();
                                    if (!statement.includes(filterText)) {
                                        skippedCount++;
                                        continue; // Skip this request
                                    }
                                }

                                // Apply date filtering early
                                if (startDate || endDate) {
                                    const requestDate = parseCouchbaseDateTime(request.requestTime);
                                    if (requestDate) {
                                        if (startDate && requestDate < startDate) {
                                            skippedCount++;
                                            continue;
                                        }
                                        if (endDate && requestDate > endDate) {
                                            skippedCount++;
                                            continue;
                                        }
                                    }
                                }

                                // Apply elapsedTime filter early (based on completed_requests.elapsedTime)
                                if (elapsedPredicate) {
                                    const elapsedMs = parseTime(request.elapsedTime || "");
                                    if (!elapsedPredicate(elapsedMs)) {
                                        skippedCount++;
                                        continue;
                                    }
                                }

                                // Only process requests that pass all filters
                                processedRequests.push(processRequestData(item));

                                // Yield every 25 processed items within batch for ultra-smooth progress
                                if ((i - startIndex) % 25 === 24 && i < endIndex - 1) {
                                    // Update progress more frequently for smoother bar
                                    const currentProgress = Math.round(
                                        ((i + 1) / processData.length) * 100
                                    );
                                    document.getElementById("progress-bar").style.width = `${currentProgress}%`;
                                    document.getElementById("progress-text").textContent = `${currentProgress}%`;
                                }
                            } catch (e) {
                                console.warn(`${TEXT_CONSTANTS.ERROR_PROCESSING_REQUEST} ${i}:`, e.message || e);
                                // Continue processing other requests
                            }
                        }

                        // Update progress bar
                        const progress = Math.round(
                            (endIndex / processData.length) * 100
                        );
                        document.getElementById(
                            "progress-bar"
                        ).style.width = `${progress}%`;
                        document.getElementById(
                            "progress-text"
                        ).textContent = `${progress}%`;

                        if (endIndex < processData.length) {
                            // Process next batch with dual yielding for maximum responsiveness
                            requestAnimationFrame(() => {
                                setTimeout(() => processBatch(endIndex), 5); // Reduced delay for faster processing
                            });
                        } else {
                            // All batches processed
                            const parseEndTime = performance.now();
                            console.log(`${TEXT_CONSTANTS.PARSE_PERFORMANCE} ${Math.round(parseEndTime - parseStartTime)}${TEXT_CONSTANTS.MS_FOR} ${processedRequests.length} ${TEXT_CONSTANTS.REQUESTS} (${skippedCount} ${TEXT_CONSTANTS.FILTERED_OUT_EARLY})`);
                            logCacheStats();
                            finishProcessing(processedRequests);
                        }
                    }

                    // Start processing
                    processBatch(0);
                } else {
                    showToast(TEXT_CONSTANTS.UNEXPECTED_DATA_FORMAT, "error");
                }
            } catch (e) {
                console.error(`${TEXT_CONSTANTS.JSON_PARSING_ERROR}`, e);
                console.log(`${TEXT_CONSTANTS.JSON_PARSING_ERROR}`, e);
                showSlidingNotification(`${TEXT_CONSTANTS.ERROR_PARSING_JSON} ${e.message}`, "error");
                document.getElementById("progress-container").style.display = "none";
            }
        }

        // Toast notification system
        function showToast(message, type = "info") {
            // Remove any existing toasts
            const existingToasts = document.querySelectorAll(".toast");
            existingToasts.forEach((toast) => toast.remove());

            const toast = document.createElement("div");
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 20px;
          border-radius: 4px;
          color: white;
          font-weight: bold;
          z-index: 10000;
          max-width: 300px;
          word-wrap: break-word;
          opacity: 0;
          transition: opacity 0.3s ease;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;

            if (type === "error") {
                toast.style.backgroundColor = "#f44336";
            } else if (type === "warning") {
                toast.style.backgroundColor = "#ff9800";
            } else if (type === "success") {
                toast.style.backgroundColor = "#4caf50";
            } else {
                toast.style.backgroundColor = "#2196f3";
            }

            document.body.appendChild(toast);

            // Fade in
            setTimeout(() => (toast.style.opacity = "1"), 10);

            // Remove after 4 seconds
            setTimeout(() => {
                toast.style.opacity = "0";
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 4000);
            }

            // Sliding notification (upper-left) used for prominent messages
            function showSlidingNotification(message, type = "info", durationMs = 8000) {
                // Remove existing sliding toasts
                const existing = document.querySelectorAll(".sliding-toast");
                existing.forEach(t => t.remove());

                const toast = document.createElement("div");
                toast.className = "sliding-toast";
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    top: -50px;
                    left: 20px;
                    padding: 12px 20px;
                    border-radius: 6px;
                    background: #e3f2fd;
                    border: 1px solid #bbdefb;
                    color: #0d47a1;
                    font-size: 13px;
                    font-weight: 600;
                    z-index: 10001;
                    max-width: 360px;
                    word-wrap: break-word;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    transition: all 0.35s ease-out;
                    transform: translateY(0px);
                `;

                // Color scheme by type
                if (type === "error") {
                    toast.style.background = "#f8d7da";
                    toast.style.border = "1px solid #f5c2c7";
                    toast.style.color = "#842029";
                } else if (type === "warning") {
                    toast.style.background = "#fff3cd";
                    toast.style.border = "1px solid #ffeaa7";
                    toast.style.color = "#856404";
                } else if (type === "success") {
                    toast.style.background = "#d1e7dd";
                    toast.style.border = "1px solid #badbcc";
                    toast.style.color = "#0f5132";
                }

                document.body.appendChild(toast);

                // Slide down
                setTimeout(() => {
                    toast.style.top = "20px";
                    toast.style.transform = "translateY(0px)";
                }, 10);

                // Auto-hide
                setTimeout(() => {
                    toast.style.opacity = "0";
                    toast.style.transform = "translateY(-10px)";
                    setTimeout(() => {
                        if (toast.parentNode) {
                            document.body.removeChild(toast);
                        }
                    }, 400);
                }, durationMs);
            }

            // Input panel auto-hide helpers (Issue #88)
            let _inputHideTimer = null;
            let _inputAutoHideDisabled = false;
            function hideInputSection() {
                const input = document.getElementById('input-section');
                const tab = document.getElementById('toggle-input-tab');
                if (!input) return;
                try {
                    const $input = window.jQuery ? jQuery(input) : null;
                    if ($input && $input.fadeOut) {
                        $input.stop(true, true).fadeOut('slow', () => {
                            if (tab) {
                                tab.setAttribute('aria-expanded', 'false');
                                const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.SHOW_INPUT_PANEL) || 'Show';
                                tab.textContent = '↓';
                                tab.title = label;
                                tab.classList.remove('showing');
                                tab.classList.add('hidden');
                            }
                        });
                    } else {
                        // Fallback if jQuery missing
                        input.style.display = 'none';
                        if (tab) {
                            tab.setAttribute('aria-expanded', 'false');
                            const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.SHOW_INPUT_PANEL) || 'Show';
                            tab.textContent = '↓';
                            tab.title = label;
                            tab.classList.remove('showing');
                            tab.classList.add('hidden');
                        }
                    }
                } catch (e) { /* no-op */ }
            }
            function showInputSection() {
                const input = document.getElementById('input-section');
                const tab = document.getElementById('toggle-input-tab');
                if (!input) return;
                try {
                    const $input = window.jQuery ? jQuery(input) : null;
                    if ($input && $input.fadeIn) {
                        $input.stop(true, true).fadeIn('slow', () => {
                            if (tab) {
                                tab.setAttribute('aria-expanded', 'true');
                                const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.HIDE_INPUT_PANEL) || 'Hide';
                                tab.textContent = '↑';
                                tab.title = label;
                                tab.classList.remove('hidden');
                                tab.classList.add('showing');
                            }
                        });
                    } else {
                        input.style.display = '';
                        if (tab) {
                            tab.setAttribute('aria-expanded', 'true');
                            const label = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.HIDE_INPUT_PANEL) || 'Hide';
                            tab.textContent = '↑';
                            tab.title = label;
                            tab.classList.remove('hidden');
                            tab.classList.add('showing');
                        }
                    }
                } catch (e) { /* no-op */ }
            }
            function toggleInputSection() {
                const input = document.getElementById('input-section');
                if (!input) return;
                // User manually toggled; disable future auto-hide for this session
                _inputAutoHideDisabled = true;
                if (_inputHideTimer) { clearTimeout(_inputHideTimer); _inputHideTimer = null; }
                const cs = window.getComputedStyle ? getComputedStyle(input) : null;
                const isHidden = (
                    (cs && (cs.display === 'none' || cs.visibility === 'hidden' || cs.visibility === 'collapse')) ||
                    input.style.display === 'none' ||
                    input.hidden === true
                );
                if (isHidden) showInputSection(); else hideInputSection();
            }
            function scheduleInputAutoHide(delayMs = 3000) {
                if (_inputAutoHideDisabled) return; // respect user preference
                if (_inputHideTimer) {
                    clearTimeout(_inputHideTimer);
                    _inputHideTimer = null;
                }
                _inputHideTimer = setTimeout(() => {
                    const input = document.getElementById('input-section');
                    if (_inputAutoHideDisabled) return;
                    if (input && input.style.visibility !== 'collapse') {
                        hideInputSection();
                    }
                }, delayMs);
            }

            // Finish processing after all batches are done
        function finishProcessing(allRequests) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            // Hide progress bar and reset placeholder
            document.getElementById("progress-container").style.display = "none";
            document.getElementById("progress-bar").style.width = "0%";
            document.getElementById("progress-text").textContent = "0%";
            document.getElementById("json-input").placeholder =
                "Paste your JSON output from: SELECT * , meta().plan FROM system:completed_requests;";

            // Clear normalize cache if it gets too large to prevent memory issues
            if (normalizeCache.size > 5000) {
                normalizeCache.clear();
            }

            // Filtering now happens during parsing, so we can use requests directly
            const filteredAllRequests = allRequests;

            // If this is the first parse (no date filters set), populate date range
            if (
                !startDateInput.value &&
                !endDateInput.value &&
                filteredAllRequests.length > 0
            ) {
                originalRequests = filteredAllRequests;
                const dates = filteredAllRequests
                    .map((r) => parseCouchbaseDateTime(r.requestTime))
                    .filter((d) => d && !isNaN(d.getTime()))
                    .sort((a, b) => a - b);

                if (dates.length > 0) {
                    const minDate = dates[0];
                    const maxDate = dates[dates.length - 1];

                    // Add 1-minute buffer to ensure edge records aren't excluded by minute rounding
                    const startWithBuffer = new Date(minDate.getTime() - 60000); // -1 minute
                    const endWithBuffer = new Date(maxDate.getTime() + 60000); // +1 minute

                    originalStartDate = minDate;
                    originalEndDate = maxDate;
                    startDateInput.value = toDateTimeLocal(startWithBuffer);
                    endDateInput.value = toDateTimeLocal(endWithBuffer);
                }
            } else {
                // Use existing originalRequests if available, otherwise use current data
                if (originalRequests.length === 0) {
                    originalRequests = filteredAllRequests;
                }
            }

            // Apply date filtering
            const startDate = startDateInput.value
                ? new Date(startDateInput.value)
                : null;
            const endDate = endDateInput.value
                ? new Date(endDateInput.value)
                : null;

            const filteredRequests = filterRequestsByDateRange(
                filteredAllRequests,
                startDate,
                endDate
            );

            // Store filtered requests globally for Index/Query Flow tab activation
            window.filteredRequests = filteredRequests;

            // Validate date range for current time grouping
            const grouping = getTimeGrouping();
            const validation = validateDateRangeForGrouping(
                startDate,
                endDate,
                grouping
            );
            if (!validation.valid) {
                alert(validation.message);
                // Still continue with table generation, just skip charts
                updateFilterInfo(filteredAllRequests.length, filteredRequests.length);
                generateTable(filteredRequests);
                generateAnalysisTable(filteredRequests);
                // buildIndexQueryFlow will be lazy loaded when index-query-flow tab is activated
                // Only reset flow diagram if no query was previously selected
                const flowDiagramValidation = document.getElementById("flow-diagram");
                if (!flowDiagramValidation.hasChildNodes() || flowDiagramValidation.children.length === 0) {
                    flowDiagramValidation.innerHTML = TEXT_CONSTANTS.SELECT_QUERY_FLOW;
                }
                return;
            }

            // Store filtered data globally for lazy loading
            window.currentFilteredRequests = filteredRequests;

            // Update UI with filtered data
            updateFilterInfo(filteredAllRequests.length, filteredRequests.length);
            try {
                // Only generate essential tables immediately - defer charts until tab activation
                generateTable(filteredRequests);
                generateAnalysisTable(filteredRequests);
                updateOptimizerLabel(filteredRequests);

                // Extract used indexes from the query data
                extractUsedIndexes(filteredRequests);

                // Extract sample queries for display
                extractSampleQueries(filteredRequests);

                // Also parse index data if available
                parseIndexJSON();

                // Set up lazy loading for charts with sampling for large datasets
                const sampleRequests = filteredRequests.length > 1000 ?
                    filteredRequests.filter((_, i) => i % Math.ceil(filteredRequests.length / 1000) === 0) :
                    filteredRequests;

                // Show sampling notice if data was sampled for charts
                if (filteredRequests.length > 1000) {
                    console.log(`${TEXT_CONSTANTS.CHART_SAMPLING} ${sampleRequests.length} ${TEXT_CONSTANTS.OF_TOTAL} ${filteredRequests.length} ${TEXT_CONSTANTS.REQUESTS_FOR_PERFORMANCE}`);
                }

                setupLazyChartLoading(sampleRequests, filteredRequests);
            } catch (e) {
                console.error(`${TEXT_CONSTANTS.ERROR_GENERATING_UI}`, e);
                alert(`${TEXT_CONSTANTS.ERROR_GENERATING_UI} Try reducing the date range or selecting a coarser time grouping.`);
            }
            // Only reset flow diagram if no query was previously selected
            const flowDiagram = document.getElementById("flow-diagram");
            if (!flowDiagram.hasChildNodes() || flowDiagram.children.length === 0) {
                flowDiagram.innerHTML = TEXT_CONSTANTS.SELECT_QUERY_FLOW;
            }

            // Schedule auto-hide of input panel after successful processing
            scheduleInputAutoHide(3000);
        }

        // Modal event listeners
        const planModal = document.getElementById("plan-modal");
        const planCloseBtn = planModal.querySelector(".close");
        planCloseBtn.addEventListener("click", () => {
            planModal.style.display = "none";
        });
        planModal.addEventListener("click", (event) => {
            if (event.target === planModal) {
                planModal.style.display = "none";
            }
        });

        const operatorModal = document.getElementById("operator-modal");
        const operatorCloseBtn = operatorModal.querySelector(".close");
        operatorCloseBtn.addEventListener("click", () => {
            operatorModal.style.display = "none";
        });
        operatorModal.addEventListener("click", (event) => {
            if (event.target === operatorModal) {
                operatorModal.style.display = "none";
            }
        });

        // Function to set time range based on button selection
        function setTimeRange(type) {
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");

            if (type === "original") {
                if (originalStartDate && originalEndDate) {
                    startDateInput.value = toDateTimeLocal(originalStartDate);
                    endDateInput.value = toDateTimeLocal(originalEndDate);
                }
            } else if (type === "1day" || type === "1hour" || type === "1week") {
                const endDate = endDateInput.value
                    ? new Date(endDateInput.value)
                    : new Date();
                const startDate = new Date(endDate);

                if (type === "1day") {
                    startDate.setDate(startDate.getDate() - 1);
                } else if (type === "1hour") {
                    startDate.setHours(startDate.getHours() - 1);
                } else if (type === "1week") {
                    startDate.setDate(startDate.getDate() - 7);
                }

                startDateInput.value = toDateTimeLocal(startDate);
            }

            // Show reminder to click Parse JSON
            if (originalRequests.length > 0) {
                showFilterReminder();
            }
        }

        // Sample queries storage
        let sampleQueries = [];
        let sampleQueriesVisible = false;

        // Extract sample queries from requests for display - only inefficient index scan queries
        function extractSampleQueries(requests) {
            sampleQueries = [];
            const seenStatements = new Set();
            
            for (const request of requests) {
                if (sampleQueries.length >= 5) break;
                
                const statement = request.statement || request.preparedText || '';
                if (!statement || seenStatements.has(statement)) continue;
                
                // Apply the same inefficient index scan criteria as the counter
                const hasAggregates = /\b(COUNT|AVG|MIN|MAX|SUM)\s*\(/i.test(statement);
                
                if (!hasAggregates) {
                    const resultCount = request.resultCount || 0;
                    const phaseCounts = request.phaseCounts || {};

                    // Check various types of index scans (same logic as counter)
                    let totalScanned = 0;
                    if (phaseCounts.primaryScan) totalScanned += phaseCounts.primaryScan;
                    if (phaseCounts.indexScan) totalScanned += phaseCounts.indexScan;
                    if (phaseCounts['primaryScan.GSI']) totalScanned += phaseCounts['primaryScan.GSI'];
                    if (phaseCounts['indexScan.GSI']) totalScanned += phaseCounts['indexScan.GSI'];

                    // Only include if scanned >= 50,000 and efficiency < 10%
                    if (totalScanned >= 50000) {
                        const efficiency = totalScanned > 0 ? (resultCount / totalScanned) * 100 : 0;
                        if (efficiency < 10) {
                            seenStatements.add(statement);
                            sampleQueries.push({
                                requestTime: request.requestTime,
                                statement: statement,
                                requestId: request.requestId
                            });
                        }
                    }
                }
            }
            
            // Update the sample queries table
            updateSampleQueriesTable();
        }

        // Toggle sample queries visibility
        function toggleSampleQueries() {
            const container = document.getElementById('sample-queries-container');
            const btnText = document.getElementById('sample-queries-btn-text');
            
            sampleQueriesVisible = !sampleQueriesVisible;
            
            if (sampleQueriesVisible) {
                container.style.display = 'block';
                btnText.textContent = TEXT_CONSTANTS.HIDE_SAMPLE_QUERIES;
            } else {
                container.style.display = 'none';
                btnText.textContent = TEXT_CONSTANTS.SHOW_SAMPLE_QUERIES;
            }
        }

        // Update sample queries table content
        function updateSampleQueriesTable() {
            const tbody = document.getElementById('sample-queries-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            sampleQueries.forEach((query, index) => {
                const formattedDate = query.requestTime || "";
                
                const statementId = `sample-statement-${index}`;
                const isLongStatement = query.statement.length > 500;
                
                const row = document.createElement('tr');
                
                // Create date cell
                const dateCell = document.createElement('td');
                dateCell.style.whiteSpace = 'nowrap';
                dateCell.style.textAlign = 'center';
                dateCell.style.fontSize = '11px';
                dateCell.textContent = formattedDate;
                
                // Create statement cell
                const statementCell = document.createElement('td');
                statementCell.className = 'statement-cell';
                
                if (isLongStatement) {
                    const truncated = query.statement.substring(0, 500);
                    statementCell.innerHTML = `
                        <div id="${statementId}-truncated">
                            <span>${escapeHtml(truncated)}...</span>
                            <br>
                            <button onclick="toggleSampleStatement('${statementId}', true)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                            <button onclick="copySampleStatement('${statementId}', event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                        <div id="${statementId}-full" style="display: none;">
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="toggleSampleStatement('${statementId}', false)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                            <button onclick="copySampleStatement('${statementId}', event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                } else {
                    statementCell.innerHTML = `
                        <div>
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="copySampleStatement('${statementId}', event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                }
                
                row.appendChild(dateCell);
                row.appendChild(statementCell);
                tbody.appendChild(row);
            });
        }

        // Toggle between truncated and full statement view
        function toggleSampleStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(statementId + '-truncated');
            const fullDiv = document.getElementById(statementId + '-full');
            
            if (showFull) {
                truncatedDiv.style.display = 'none';
                fullDiv.style.display = 'block';
            } else {
                truncatedDiv.style.display = 'block';
                fullDiv.style.display = 'none';
            }
        }

        // Copy sample statement to clipboard
        function copySampleStatement(statementId, event) {
            const index = parseInt(statementId.replace('sample-statement-', ''));
            const statement = sampleQueries[index]?.statement;
            
            if (!statement) {
                console.error(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, statementId);
                showToast(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, "error");
                return;
            }
            
            navigator.clipboard.writeText(statement)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = TEXT_CONSTANTS.COPIED;
                    button.style.backgroundColor = '#4CAF50';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 1000);
                })
                .catch((err) => {
                    console.error(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, err);
                    showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                });
        }

        // Storage for insight-specific sample queries
        let insightSampleQueries = {};
        let insightSampleQueriesVisible = {};

        // Toggle insight-specific sample queries visibility
        function toggleInsightSampleQueries(insightId) {
            const container = document.getElementById(`${insightId}-sample-queries-container`);
            const btnText = document.getElementById(`${insightId}-sample-queries-btn-text`);
            
            if (!container || !btnText) return;
            
            const isVisible = insightSampleQueriesVisible[insightId] || false;
            insightSampleQueriesVisible[insightId] = !isVisible;
            
            if (!isVisible) {
                container.style.display = 'block';
                btnText.textContent = TEXT_CONSTANTS.HIDE_SAMPLE_QUERIES;
            } else {
                container.style.display = 'none';
                btnText.textContent = TEXT_CONSTANTS.SHOW_SAMPLE_QUERIES;
            }
        }

        // Update insight-specific sample queries table
        function updateInsightSampleQueries(insightId, queries) {
            const tbody = document.getElementById(`${insightId}-sample-queries-tbody`);
            if (!tbody) return;
            
            tbody.innerHTML = '';
            insightSampleQueries[insightId] = queries;
            
            queries.forEach((query, index) => {
                const formattedDate = query.requestTime || "";
                
                const statementId = `${insightId}-statement-${index}`;
                const isLongStatement = query.statement.length > 500;
                
                const row = document.createElement('tr');
                
                // Create date cell
                const dateCell = document.createElement('td');
                dateCell.style.whiteSpace = 'nowrap';
                dateCell.style.textAlign = 'center';
                dateCell.style.fontSize = '11px';
                dateCell.textContent = formattedDate;
                
                // Create statement cell
                const statementCell = document.createElement('td');
                statementCell.className = 'statement-cell';
                
                if (isLongStatement) {
                    const truncated = query.statement.substring(0, 500);
                    statementCell.innerHTML = `
                        <div id="${statementId}-truncated">
                            <span>${escapeHtml(truncated)}...</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', true)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                            <button onclick="copyInsightStatement('${insightId}', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                        <div id="${statementId}-full" style="display: none;">
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="toggleInsightStatement('${statementId}', false)" 
                                    class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                            <button onclick="copyInsightStatement('${insightId}', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                } else {
                    statementCell.innerHTML = `
                        <div>
                            <span>${escapeHtml(query.statement)}</span>
                            <br>
                            <button onclick="copyInsightStatement('${insightId}', ${index}, event)" 
                                    class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                        </div>
                    `;
                }
                
                row.appendChild(dateCell);
                row.appendChild(statementCell);
                tbody.appendChild(row);
            });
        }

        // Toggle insight statement truncation
        function toggleInsightStatement(statementId, showFull) {
            const truncatedDiv = document.getElementById(statementId + '-truncated');
            const fullDiv = document.getElementById(statementId + '-full');
            
            if (showFull) {
                truncatedDiv.style.display = 'none';
                fullDiv.style.display = 'block';
            } else {
                truncatedDiv.style.display = 'block';
                fullDiv.style.display = 'none';
            }
        }

        // Copy insight statement to clipboard
        function copyInsightStatement(insightId, index, event) {
            const statement = insightSampleQueries[insightId]?.[index]?.statement;
            
            if (!statement) {
                console.error(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                showToast(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, "error");
                return;
            }
            
            navigator.clipboard.writeText(statement)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = TEXT_CONSTANTS.COPIED;
                    button.style.backgroundColor = '#4CAF50';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 1000);
                })
                .catch((err) => {
                    console.error(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, err);
                    showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                });
        }

        // Storage for timeout queries
        let timeoutQueriesData = {
            actualTimeouts: [],
            approachingTimeouts: []
        };
        let timeoutQueriesVisible = false;

        // Toggle timeout queries table visibility
        function toggleTimeoutQueriesTable() {
            const container = document.getElementById('timeout-prone-queries-sample-queries-container');
            const btnText = document.getElementById('timeout-prone-queries-sample-queries-btn-text');
            
            if (!container || !btnText) return;
            
            timeoutQueriesVisible = !timeoutQueriesVisible;
            
            if (timeoutQueriesVisible) {
                container.style.display = 'block';
                btnText.textContent = TEXT_CONSTANTS.HIDE_SAMPLE_QUERIES;
            } else {
                container.style.display = 'none';
                btnText.textContent = TEXT_CONSTANTS.SHOW_SAMPLE_QUERIES;
            }
        }

        // Update timeout queries table with special 3-column format
        function updateTimeoutQueriesTable(actualTimeouts, approachingTimeouts) {
            const tbody = document.getElementById('timeout-prone-queries-sample-queries-tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            timeoutQueriesData.actualTimeouts = actualTimeouts;
            timeoutQueriesData.approachingTimeouts = approachingTimeouts;
            
            // First add actual timeouts (up to 5)
            actualTimeouts.forEach((query, index) => {
                const row = createTimeoutQueryRow(query, index, 'actual');
                row.style.backgroundColor = '#ffebee'; // Light red background for timeouts
                tbody.appendChild(row);
            });
            
            // Then add approaching timeouts (up to 5)
            approachingTimeouts.forEach((query, index) => {
                const row = createTimeoutQueryRow(query, index + actualTimeouts.length, 'approaching');
                row.style.backgroundColor = '#fff3e0'; // Light orange background for approaching
                tbody.appendChild(row);
            });
        }

        // Create a timeout query table row
        function createTimeoutQueryRow(query, index, type) {
            const formattedDate = query.requestTime || "";
            
            const statementId = `timeout-${type}-statement-${index}`;
            const isLongStatement = query.statement.length > 500;
            
            const row = document.createElement('tr');
            
            // Create date cell
            const dateCell = document.createElement('td');
            dateCell.style.whiteSpace = 'nowrap';
            dateCell.style.textAlign = 'center';
            dateCell.style.fontSize = '11px';
            dateCell.textContent = formattedDate;
            
            // Create statement cell
            const statementCell = document.createElement('td');
            statementCell.className = 'statement-cell';
            
            if (isLongStatement) {
                const truncated = query.statement.substring(0, 500);
                statementCell.innerHTML = `
                    <div id="${statementId}-truncated">
                        <span>${escapeHtml(truncated)}...</span>
                        <br>
                        <button onclick="toggleInsightStatement('${statementId}', true)" 
                                class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.SHOW_MORE}</button>
                        <button onclick="copyTimeoutStatement('${type}', ${index}, event)" 
                                class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                    <div id="${statementId}-full" style="display: none;">
                        <span>${escapeHtml(query.statement)}</span>
                        <br>
                        <button onclick="toggleInsightStatement('${statementId}', false)" 
                                class="btn-standard" style="margin-top: 5px; margin-right: 5px;">${TEXT_CONSTANTS.HIDE}</button>
                        <button onclick="copyTimeoutStatement('${type}', ${index}, event)" 
                                class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                `;
            } else {
                statementCell.innerHTML = `
                    <div>
                        <span>${escapeHtml(query.statement)}</span>
                        <br>
                        <button onclick="copyTimeoutStatement('${type}', ${index}, event)" 
                                class="btn-standard" style="margin-top: 5px;">${TEXT_CONSTANTS.COPY}</button>
                    </div>
                `;
            }
            
            // Create elapsed time cell
            const elapsedTimeCell = document.createElement('td');
            elapsedTimeCell.style.whiteSpace = 'nowrap';
            elapsedTimeCell.style.textAlign = 'center';
            elapsedTimeCell.style.fontSize = '11px';
            elapsedTimeCell.textContent = query.elapsedTime || 'N/A';
            if (type === 'actual') {
                elapsedTimeCell.style.fontWeight = 'bold';
                elapsedTimeCell.style.color = '#d32f2f'; // Red for timeouts
            } else {
                elapsedTimeCell.style.color = '#f57c00'; // Orange for approaching
            }
            
            row.appendChild(dateCell);
            row.appendChild(statementCell);
            row.appendChild(elapsedTimeCell);
            
            return row;
        }

        // Copy timeout statement to clipboard
        function copyTimeoutStatement(type, index, event) {
            const statement = type === 'actual' ? 
                timeoutQueriesData.actualTimeouts[index]?.statement : 
                timeoutQueriesData.approachingTimeouts[index - timeoutQueriesData.actualTimeouts.length]?.statement;
            
            if (!statement) {
                console.error(TEXT_CONSTANTS.STATEMENT_NOT_FOUND);
                showToast(TEXT_CONSTANTS.STATEMENT_NOT_FOUND, "error");
                return;
            }
            
            navigator.clipboard.writeText(statement)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = TEXT_CONSTANTS.COPIED;
                    button.style.backgroundColor = '#4CAF50';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 1000);
                })
                .catch((err) => {
                    console.error(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, err);
                    showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD, "error");
                });
        }

        // Track which tabs have been loaded
        let loadedTabs = new Set();

        // Initialize jQuery UI Tabs with lazy loading
        $(function () {
            $("#tabs").tabs({
                activate: function (event, ui) {
                    const tabId = ui.newPanel.attr("id");

                    // Lazy load charts when tabs are first activated
                    if (!loadedTabs.has(tabId)) {
                        loadedTabs.add(tabId);

                        if (tabId === "timeline" && originalRequests.length > 0) {
                            // Generate timeline charts only when tab is activated
                            generateTimelineChart(originalRequests);
                        } else if (tabId === "dashboard" && originalRequests.length > 0) {
                            // Generate dashboard charts only when tab is activated
                            generateDashboardCharts(originalRequests);
                        }
                    }

                    // Always check Index/Query Flow tab (not just first time)
                    if (tabId === "index-query-flow" && originalRequests.length > 0) {
                        // Use current filtered requests, not cached data
                        const currentFilteredRequests = window.filteredRequests || window.currentFilteredRequests || originalRequests;
                        
                        // Rebuild Index/Query Flow with current filtered data
                        buildIndexQueryFlow(currentFilteredRequests);
                    }
                },
            });
        });

        // Whole Record feature (Issue #110)
        function setWholeRecordTexts() {
            try {
                var loadBtn = document.getElementById('whole-record-load-btn');
                if (loadBtn && window.TEXT_CONSTANTS) {
                    loadBtn.textContent = TEXT_CONSTANTS.LOAD || 'Load';
                }
                var label = document.querySelector('label[for="whole-record-request-id-input"]');
                if (label && window.TEXT_CONSTANTS) {
                    label.textContent = TEXT_CONSTANTS.REQUEST_ID || 'Request ID';
                }
                var input = document.getElementById('whole-record-request-id-input');
                if (input && window.TEXT_CONSTANTS) {
                    input.placeholder = TEXT_CONSTANTS.ENTER_REQUEST_ID || 'Enter requestId';
                }
            } catch (e) { /* no-op */ }
        }

        function copyRequestId(reqId, event) {
            if (!reqId) return;
            navigator.clipboard.writeText(String(reqId)).then(() => {
                if (event && event.target) {
                    const btn = event.target;
                    const original = btn.textContent;
                    btn.textContent = TEXT_CONSTANTS.COPIED || 'Copied!';
                    btn.style.backgroundColor = '#4CAF50';
                    setTimeout(() => { btn.textContent = TEXT_CONSTANTS.COPY || 'Copy'; btn.style.backgroundColor=''; }, 1000);
                } else {
                    showToast(TEXT_CONSTANTS.COPIED_CLIPBOARD || 'Copied to clipboard!', 'success');
                }
            }).catch((err) => {
                console.error(err);
                showToast(TEXT_CONSTANTS.FAILED_COPY_CLIPBOARD || 'Failed to copy to clipboard', 'error');
            });
            if (event && event.stopPropagation) event.stopPropagation();
        }

        function findRequestById(requestId) {
            if (!requestId) return null;
            const idStr = String(requestId);
            const pools = [window.filteredRequests, window.currentFilteredRequests, window.originalRequests];
            for (const pool of pools) {
                if (Array.isArray(pool)) {
                    const found = pool.find(r => (r && (r.requestId === idStr || r.requestID === idStr)));
                    if (found) return found;
                }
            }
            return null;
        }

        function renderWholeRecord(record) {
            const pre = document.getElementById('whole-record-json');
            if (!pre) return;
            if (!record) {
                pre.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.RECORD_NOT_FOUND) || 'Request ID not found';
                return;
            }
            try {
                const out = Object.assign({}, record);
                if (out.request && typeof out.request === 'object') out.request = Object.assign({}, out.request);
                if (out.plan && typeof out.plan === 'string') { try { out.plan = JSON.parse(out.plan); } catch(_){} }
                if (out.request && out.request.plan && typeof out.request.plan === 'string') { try { out.request.plan = JSON.parse(out.request.plan); } catch(_){} }
                pre.textContent = JSON.stringify(out, null, 2);
            } catch (e) {
                pre.textContent = ((window.TEXT_CONSTANTS && TEXT_CONSTANTS.ERROR_PARSING_JSON) || 'Error parsing JSON:') + ' ' + (e && e.message ? e.message : e);
            }
        }

        function loadWholeRecordById(requestId) {
            const rec = findRequestById(requestId);
            try { const link = document.querySelector('a[href="#whole-record"]'); if (link && link.click) link.click(); } catch (_) {}
            renderWholeRecord(rec);
        }

        function loadWholeRecordFromInput() {
            const input = document.getElementById('whole-record-request-id-input');
            if (!input) return;
            const val = (input.value || '').trim();
            if (!val) return;
            loadWholeRecordById(val);
        }

        function handleWholeRecordHash() {
            try {
                const hash = window.location.hash || '';
                const m = hash.match(/requestId=([^&]+)/i);
                if (m && m[1]) {
                    const id = decodeURIComponent(m[1]);
                    const input = document.getElementById('whole-record-request-id-input');
                    if (input) input.value = id;
                    loadWholeRecordById(id);
                }
            } catch (e) { /* no-op */ }
        }

        (function(){
            function initWholeRecord() {
                setWholeRecordTexts();
                handleWholeRecordHash();
                try { window.addEventListener('hashchange', handleWholeRecordHash); } catch(_) {}
                try {
                  var inp = document.getElementById('whole-record-request-id-input');
                  if (inp) {
                    inp.addEventListener('paste', function(){
                      setTimeout(function(){
                        var v = (inp.value||'').trim();
                        if (v) loadWholeRecordById(v);
                      }, 0);
                    });
                    // Also auto-load when user types/pastes and pauses
                    var t;
                    inp.addEventListener('input', function(){
                      clearTimeout(t);
                      t = setTimeout(function(){
                        var v = (inp.value||'').trim();
                        if (v) loadWholeRecordById(v);
                      }, 300);
                    });
                  }
                } catch(_) {}
            }
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initWholeRecord);
            } else {
                initWholeRecord();
            }
        })();

        // Index/Query Flow functionality
        let indexQueryFlowData = {
            indexes: new Map(),
            queries: new Map(),
            connections: new Map(),
        };

        // Clear all Index/Query Flow content
        function clearIndexQueryFlow() {
            // Clear the flow elements container
            const flowElements = document.getElementById("flow-elements");
            if (flowElements) {
                flowElements.innerHTML = "";
            }

            // Clear the SVG connections
            const svg = document.getElementById("flow-svg");
            if (svg) {
                svg.innerHTML = "";
            }

            // Clear data structures
            if (indexQueryFlowData) {
                indexQueryFlowData.indexes.clear();
                indexQueryFlowData.queries.clear();
                indexQueryFlowData.connections.clear();
            }
        }

        // Process Index/Query data without DOM rendering (for hidden tabs)
        function processIndexQueryData(requests) {


            // Clear and rebuild data structures
            indexQueryFlowData.indexes.clear();
            indexQueryFlowData.queries.clear();
            indexQueryFlowData.connections.clear();

            // Copy exact logic from buildIndexQueryFlow but skip DOM rendering
            const requestIndexMap = new Map();
            const allIndexes = new Map();
            const queryGroups = new Map();

            let requestsWithPlans = 0;
            let requestsWithOperators = 0;

            requests.forEach((request, requestIndex) => {
                requestIndexMap.set(requestIndex, new Set());
                if (request.plan) {
                    requestsWithPlans++;
                    const planObj = typeof request.plan === "string" ? JSON.parse(request.plan) : request.plan;

                    if (planObj && planObj["#operator"]) {
                        requestsWithOperators++;
                        const statement = request.preparedText || request.statement || "";
                        let bucketScopeCollection = "unknown.unknown.unknown";

                        const fromMatch = statement.match(/FROM\s+([^\s\n\r\t]+)/i);
                        if (fromMatch) {
                            const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                            const parts = target.split(".");
                            if (parts.length === 1) {
                                bucketScopeCollection = `${parts[0]}._default._default`;
                            } else if (parts.length === 2) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                            } else if (parts.length >= 3) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                            }
                        }

                        extractIndexUsage(planObj, requestIndex, requestIndexMap, bucketScopeCollection);
                    }
                }

                // Group queries by normalized statement  
                const stmt = request.preparedText || request.statement;
                if (stmt) {
                    const normalized = normalizeStatement(stmt);
                    if (!queryGroups.has(normalized)) {
                        queryGroups.set(normalized, {
                            normalizedStatement: normalized,
                            statement: stmt, // Add original statement for createQueryDiv
                            count: 0,
                            totalDuration: 0, // Add totalDuration calculation
                            requests: [],
                            scanConsistencies: [] // non-unbounded values only
                        });
                    }
                    const group = queryGroups.get(normalized);
                    group.count++;
                    // Use same logic as Analysis tab: serviceTime converted to ms
                    const durationMs = parseTime(request.serviceTime);
                    group.totalDuration += isNaN(durationMs) ? 0 : durationMs;
                    // Track non-unbounded scan consistency for this group
                    try {
                        const sc = ((request.scanConsistency) || (request.request && request.request.scanConsistency) || 'unbounded').toLowerCase();
                        if (sc && sc !== 'unbounded' && !group.scanConsistencies.includes(sc)) {
                            group.scanConsistencies.push(sc);
                        }
                    } catch(_) {}
                    group.requests.push(request);
                }
            });

            // Build allIndexes from requestIndexMap (same as main function)
            requestIndexMap.forEach((indexSet, requestIndex) => {
                indexSet.forEach((indexName) => {
                    if (!allIndexes.has(indexName)) {
                        const isPrimaryCheck = indexName === "#primary" ||
                            indexName.includes("#primary") ||
                            indexName.includes("primary") ||
                            indexName.endsWith("_primary");



                        allIndexes.set(indexName, {
                            name: indexName,
                            requests: [],
                            totalUsage: 0,
                            isPrimary: isPrimaryCheck,
                            scanTimes: [],
                            itemsScanned: [],
                            itemsFetched: []
                        });
                    }
                    const indexObj = allIndexes.get(indexName);
                    indexObj.requests.push(requests[requestIndex]);
                    indexObj.totalUsage++;

                    // Collect statistics from the request
                    const request = requests[requestIndex];
                    if (request) {

                        // Extract actual index scan service time and items data from plan data  
                        const indexData = extractIndexScanDataFromPlan(request.plan, indexName);
                        if (indexData.scanTime > 0) {
                            indexObj.scanTimes.push(indexData.scanTime);
                        }
                        if (indexData.itemsScanned > 0) {
                            indexObj.itemsScanned.push(indexData.itemsScanned);
                        }
                        if (indexData.itemsFetched > 0) {
                            indexObj.itemsFetched.push(indexData.itemsFetched);
                        }
                    }
                });
            });

            // CRITICAL: Populate indexQueryFlowData with processed data for SVG rendering
            // Sort indexes by totalUsage (descending) and filter out indexes with no real usage data
            const sortedIndexes = Array.from(allIndexes.values())
                .filter(index => {
                    // Only show indexes that have actual performance data
                    const hasStats = index.scanTimes.length > 0 || index.itemsScanned.length > 0 || index.itemsFetched.length > 0;
                    if (!hasStats) {

                    }
                    return hasStats;
                })
                .sort((a, b) => b.totalUsage - a.totalUsage);
            const sortedQueries = Array.from(queryGroups.values()).sort((a, b) => b.count - a.count);

            indexQueryFlowData.indexes = new Map(sortedIndexes.map(idx => [idx.name, idx]));
            indexQueryFlowData.queries = new Map(sortedQueries.map(q => [q.normalizedStatement, q]));



            // Rebuild connections data
            requestIndexMap.forEach((indexSet, requestIndex) => {
                const request = requests[requestIndex];
                const stmt = request.preparedText || request.statement;
                if (stmt) {
                    const normalized = normalizeStatement(stmt);
                    indexSet.forEach((indexName) => {
                        const connectionKey = `${normalized}::${indexName}`;
                        if (!indexQueryFlowData.connections.has(connectionKey)) {
                            indexQueryFlowData.connections.set(connectionKey, {
                                queryStatement: normalized,
                                indexName: indexName,
                                count: 0,
                            });
                        }
                        indexQueryFlowData.connections.get(connectionKey).count++;
                    });
                }
            });

            // Update counts with correct data
            const indexCountEl = document.getElementById("index-count");
            const queryCountEl = document.getElementById("query-count");
            if (indexCountEl) indexCountEl.textContent = allIndexes.size;
            if (queryCountEl) queryCountEl.textContent = queryGroups.size;


        }

        // Helper function to resolve #primary to actual primary index name
        function resolvePrimaryIndexName(bucketScopeCollection) {
            // Look through indexData to find the actual primary index for this collection
            for (const index of indexData) {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                    const isPrimary =
                        index.name.includes("primary") ||
                        index.name.includes("#primary") ||
                        index.name.endsWith("_primary");

                    if (isPrimary && targetString === bucketScopeCollection) {
                        return index.name;
                    }
                }
            }
            // If no actual primary index found, keep #primary
            return "#primary";
        }

        function buildIndexQueryFlow(requests = null) {
            // Use provided requests or fall back to original requests
            const requestsToUse = requests || originalRequests;



            if (!requestsToUse || requestsToUse.length === 0) {

                return;
            }

            // Check if Index/Query Flow tab is currently visible using jQuery UI tabs
            const activeTabIndex = $("#tabs").tabs("option", "active");
            const indexQueryFlowTabIndex = 5; // Index/Query Flow is the 6th tab (0-indexed)



            // Always clear first to ensure clean state
            clearIndexQueryFlow();

            // Process data but skip DOM rendering when tab is hidden
            if (activeTabIndex !== indexQueryFlowTabIndex) {

                processIndexQueryData(requestsToUse);
                return;
            }



            // Step 1: Track which indexes each request uses (by request index)
            const requestIndexMap = new Map(); // requestIndex -> Set of index names

            let requestsWithPlans = 0;
            let requestsWithOperators = 0;
            requestsToUse.forEach((request, requestIndex) => {
                requestIndexMap.set(requestIndex, new Set());
                if (request.plan) {
                    requestsWithPlans++;

                    // Debug: Show the actual plan structure
                    if (requestIndex < 3) {
                        if (typeof request.plan === "string") {
                            try {
                                const parsedPlan = JSON.parse(request.plan);
                            } catch (e) { }
                        }
                    }

                    // Parse the plan JSON string if needed (same as Dashboard logic)
                    const planObj =
                        typeof request.plan === "string"
                            ? JSON.parse(request.plan)
                            : request.plan;

                    if (planObj && planObj["#operator"]) {
                        requestsWithOperators++;

                        // Get bucket.scope.collection from the statement for primary index resolution
                        const statement = request.preparedText || request.statement || "";
                        let bucketScopeCollection = "unknown.unknown.unknown";

                        const fromMatch = statement.match(/FROM\s+([^\s\n\r\t]+)/i);
                        if (fromMatch) {
                            const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                            const parts = target.split(".");
                            if (parts.length === 1) {
                                bucketScopeCollection = `${parts[0]}._default._default`;
                            } else if (parts.length === 2) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                            } else if (parts.length >= 3) {
                                bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                            }
                        }

                        extractIndexUsage(
                            planObj,
                            requestIndex,
                            requestIndexMap,
                            bucketScopeCollection
                        );
                    }
                }
            });

            // Step 2: Build query groups and track which request indices belong to each group
            const queryGroups = new Map();
            requestsToUse.forEach((request, requestIndex) => {
                const stmt = request.preparedText || request.statement;
                const normalizedStatement = normalizeStatement(stmt);
                if (!queryGroups.has(normalizedStatement)) {
                    queryGroups.set(normalizedStatement, {
                        statement: stmt,
                        normalizedStatement,
                        count: 0,
                        totalDuration: 0,
                        requestIndices: [],
                        scanConsistencies: [] // non-unbounded values only
                    });
                }
                const group = queryGroups.get(normalizedStatement);
                group.count++;
                // Use same logic as Analysis tab: serviceTime converted to ms
                const durationMs = parseTime(request.serviceTime);

                group.totalDuration += isNaN(durationMs) ? 0 : durationMs;
                // Track non-unbounded scan consistency for this group
                try {
                    const sc = ((request.scanConsistency) || (request.request && request.request.scanConsistency) || 'unbounded').toLowerCase();
                    if (sc && sc !== 'unbounded' && !group.scanConsistencies.includes(sc)) {
                        group.scanConsistencies.push(sc);
                    }
                } catch(_) {}
                group.requestIndices.push(requestIndex);
            });

            // Step 3: Build final index data and connections using request indices
            const allIndexes = new Map();
            let connectionCount = 0;

            queryGroups.forEach((queryGroup, queryKey) => {
                queryGroup.requestIndices.forEach((requestIndex) => {
                    const indexesForRequest = requestIndexMap.get(requestIndex);

                    if (indexesForRequest && indexesForRequest.size > 0) {
                        indexesForRequest.forEach((indexName) => {
                            // Track index usage
                            if (!allIndexes.has(indexName)) {
                                const isPrimaryCheck = indexName === "#primary" ||
                                    indexName.includes("#primary") ||
                                    indexName.includes("primary") ||
                                    indexName.endsWith("_primary");


                                allIndexes.set(indexName, {
                                    name: indexName,
                                    totalUsage: 0,
                                    isPrimary: isPrimaryCheck,
                                    scanTimes: [],
                                    itemsScanned: [],
                                    itemsFetched: [],
                                });
                            }

                            const indexObj = allIndexes.get(indexName);
                            indexObj.totalUsage++;

                            // Collect statistics from the request
                            const request = requestsToUse[requestIndex];
                            if (request) {
                                // Extract actual index scan service time and items data from plan data
                                const indexData = extractIndexScanDataFromPlan(request.plan, indexName);
                                if (indexData.scanTime > 0) {
                                    indexObj.scanTimes.push(indexData.scanTime);
                                }
                                if (indexData.itemsScanned > 0) {
                                    indexObj.itemsScanned.push(indexData.itemsScanned);
                                }
                                if (indexData.itemsFetched > 0) {
                                    indexObj.itemsFetched.push(indexData.itemsFetched);
                                }
                            }

                            // Track connection
                            const connectionKey = `${queryGroup.normalizedStatement}::${indexName}`;
                            if (!indexQueryFlowData.connections.has(connectionKey)) {
                                indexQueryFlowData.connections.set(connectionKey, {
                                    queryStatement: queryGroup.normalizedStatement,
                                    indexName: indexName,
                                    count: 0,
                                });
                            }
                            indexQueryFlowData.connections.get(connectionKey).count++;
                            connectionCount++;
                        });
                    }
                });
            });

            // Convert to sorted arrays and filter out indexes with no real usage data
            const sortedIndexes = Array.from(allIndexes.values())
                .filter(index => {
                    // Only show indexes that have actual performance data
                    const hasStats = index.scanTimes.length > 0 || index.itemsScanned.length > 0 || index.itemsFetched.length > 0;
                    return hasStats;
                })
                .sort((a, b) => b.totalUsage - a.totalUsage);
            const sortedQueries = Array.from(queryGroups.values()).sort(
                (a, b) => b.count - a.count
            );



            indexQueryFlowData.queries = new Map(
                sortedQueries.map((q) => [q.normalizedStatement, q])
            );


            renderIndexQueryFlow(sortedIndexes, sortedQueries);
        }

        // Extract the actual service time and items data for a specific index from the plan JSON
        function extractIndexScanDataFromPlan(planString, indexName) {
            if (!planString || !indexName) return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };

            try {
                // Handle both cases: plan as string (needs parsing) or plan as object (already parsed)
                let plan;
                if (typeof planString === 'string') {
                    plan = JSON.parse(planString);
                } else if (typeof planString === 'object' && planString !== null) {
                    plan = planString; // Already parsed
                } else {
                    return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };
                }

                let result = { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };

                function searchOperatorForIndex(operator) {
                    if (!operator) return;

                    const opType = operator["#operator"];

                    // Check if this operator uses the target index
                    const operatorIndex = operator.index || operator.indexName;

                    if (operatorIndex === indexName ||
                        (indexName.includes("primary") && operatorIndex === "#primary") ||
                        (indexName === "def_primary" && operatorIndex === "#primary")) {

                        // Extract servTime and items data from this operator's stats
                        if (operator["#stats"]) {
                            const stats = operator["#stats"];

                            if (stats["servTime"]) {
                                result.scanTime = parseTime(stats["servTime"]);
                            }
                            if (stats["#itemsOut"]) {
                                result.itemsScanned = stats["#itemsOut"];
                            }
                            if (stats["#itemsIn"]) {
                                result.itemsFetched = stats["#itemsIn"];
                            }
                        }
                    }

                    // Recursively search child operators
                    if (operator["~child"]) {
                        searchOperatorForIndex(operator["~child"]);
                    }

                    if (operator["~children"]) {
                        for (const child of operator["~children"]) {
                            searchOperatorForIndex(child);
                        }
                    }

                    // Also search scan property (used in DistinctScan)
                    if (operator["scan"]) {
                        searchOperatorForIndex(operator["scan"]);
                    }

                    // Search other nested operator properties
                    if (operator["input"]) {
                        searchOperatorForIndex(operator["input"]);
                    }

                    if (operator["inputs"] && Array.isArray(operator["inputs"])) {
                        for (const input of operator["inputs"]) {
                            searchOperatorForIndex(input);
                        }
                    }

                    if (operator["left"]) {
                        searchOperatorForIndex(operator["left"]);
                    }

                    if (operator["right"]) {
                        searchOperatorForIndex(operator["right"]);
                    }

                    if (operator["first"]) {
                        searchOperatorForIndex(operator["first"]);
                    }

                    if (operator["second"]) {
                        searchOperatorForIndex(operator["second"]);
                    }

                    if (operator["scans"] && Array.isArray(operator["scans"])) {
                        for (const scan of operator["scans"]) {
                            searchOperatorForIndex(scan);
                        }
                    }
                }

                searchOperatorForIndex(plan);
                return result;
            } catch (e) {
                console.warn("Failed to process plan data:", e);
                console.warn("Plan type:", typeof planString);
                console.warn("Plan is null:", planString === null);
                return { scanTime: 0, itemsScanned: 0, itemsFetched: 0 };
            }
        }

        function extractIndexUsage(
            operator,
            requestIndex,
            requestIndexMap,
            bucketScopeCollection = "unknown.unknown.unknown"
        ) {
            if (!operator) {
                return;
            }

            // Function to record index usage for this request
            function recordIndexUsage(indexName) {
                // If this is #primary, try to resolve to actual primary index name
                if (indexName === "#primary") {
                    const resolved = resolvePrimaryIndexName(bucketScopeCollection);
                    indexName = resolved;
                }
                requestIndexMap.get(requestIndex).add(indexName);
            }

            const opType = operator["#operator"];

            // Check for IndexScan operators
            if (
                opType === "IndexScan" ||
                opType === "IndexScan2" ||
                opType === "IndexScan3"
            ) {
                if (operator.index) {
                    recordIndexUsage(operator.index);
                }
                if (operator.indexName) {
                    recordIndexUsage(operator.indexName);
                }
            }

            // Check for PrimaryScan operators
            if (
                opType === "PrimaryScan" ||
                opType === "PrimaryScan2" ||
                opType === "PrimaryScan3"
            ) {
                // For primary scans, prefer resolved name over operator.index to avoid duplicates
                let resolvedName = resolvePrimaryIndexName(bucketScopeCollection);
                if (resolvedName && resolvedName !== "#primary") {
                    recordIndexUsage(resolvedName);
                } else if (operator.index) {
                    recordIndexUsage(operator.index);
                } else {
                    recordIndexUsage("#primary");
                }
            }

            // Check for sequential scan
            if (operator.using === "sequentialscan") {
                recordIndexUsage("#sequentialscan");
            }

            // Recursively check child operators (same as Dashboard logic)
            if (operator["~child"]) {
                extractIndexUsage(
                    operator["~child"],
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator["~children"] && Array.isArray(operator["~children"])) {
                operator["~children"].forEach((child) =>
                    extractIndexUsage(
                        child,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            if (operator.input) {
                extractIndexUsage(
                    operator.input,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.inputs && Array.isArray(operator.inputs)) {
                operator.inputs.forEach((input) =>
                    extractIndexUsage(
                        input,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            if (operator.left) {
                extractIndexUsage(
                    operator.left,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.right) {
                extractIndexUsage(
                    operator.right,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for first and second properties (used in set operations like ExceptAll)
            if (operator.first) {
                extractIndexUsage(
                    operator.first,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            if (operator.second) {
                extractIndexUsage(
                    operator.second,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for scans array (used in UnionScan, IntersectScan, etc.)
            if (operator.scans && Array.isArray(operator.scans)) {
                operator.scans.forEach((scan) =>
                    extractIndexUsage(
                        scan,
                        requestIndex,
                        requestIndexMap,
                        bucketScopeCollection
                    )
                );
            }
            // Check for scan property (used in DistinctScan)
            if (operator.scan) {
                extractIndexUsage(
                    operator.scan,
                    requestIndex,
                    requestIndexMap,
                    bucketScopeCollection
                );
            }
            // Check for subqueries array
            if (operator["~subqueries"] && Array.isArray(operator["~subqueries"])) {
                operator["~subqueries"].forEach((subquery) => {
                    if (subquery.executionTimings) {
                        extractIndexUsage(
                            subquery.executionTimings,
                            requestIndex,
                            requestIndexMap,
                            bucketScopeCollection
                        );
                    }
                });
            }
        }

        function renderIndexQueryFlow(indexes, queries) {

            const flowElements = document.getElementById("flow-elements");

            if (!flowElements) {
                console.error("flow-elements container not found");
                return;
            }

            // Update counts in summary
            const indexCountEl = document.getElementById("index-count");
            const queryCountEl = document.getElementById("query-count");
            if (indexCountEl) indexCountEl.textContent = indexes.length;
            if (queryCountEl) queryCountEl.textContent = queries.length;

            // Clear container
            flowElements.innerHTML = "";

            if (indexes.length === 0) {
                flowElements.innerHTML =
                    '<div style="padding: 20px; text-align: center; color: #666; font-style: italic;">No index usage found in the queries.<br><br>This could mean:<br>• Queries use sequential scans<br>• Index information not in execution plans<br>• All queries are prepared statements without index details</div>';
                return;
            }

            // Generate colors for indexes
            const colors = generateColors(indexes.length);

            // Calculate layout - indexes on left, queries on right
            const canvasWidth = flowElements.offsetWidth || 1200;
            const indexItemHeight = 144; // Index spacing
            const queryItemHeight = 173; // Query spacing with additional 20% (144 * 1.2)
            const canvasHeight = Math.max(
                indexes.length * indexItemHeight,
                queries.length * queryItemHeight,
                400
            );

            // Set container height
            flowElements.style.height = canvasHeight + "px";

            // Position indexes on the left
            const indexPositions = [];
            indexes.forEach((index, i) => {
                const x = 50;
                const y = 50 + i * indexItemHeight;
                const indexDiv = createIndexDiv(index, colors[i], x, y);
                flowElements.appendChild(indexDiv);
                indexPositions.push({
                    element: indexDiv,
                    x: x + 150,
                    y: y + 40,
                    index: index,
                }); // right edge + center
            });

            // Position queries on the right
            const queryPositions = [];
            queries.forEach((query, queryIndex) => {
                const x = canvasWidth - 380;
                const y = 50 + queryIndex * queryItemHeight;
                const queryDiv = createQueryDiv(query, queryIndex, x, y);
                flowElements.appendChild(queryDiv);
                queryPositions.push({
                    element: queryDiv,
                    x: x,
                    y: y + 40,
                    query: query,
                }); // left edge + center
            });

            // Draw connections after elements are positioned
            // Use multiple attempts with increasing delays to ensure layout is complete
            setTimeout(() => {
                drawSimpleConnections(indexPositions, queryPositions, colors);
            }, 100);

            // Additional redraw after longer delay to ensure correct positioning
            setTimeout(() => {
                redrawConnectionsAfterDrag();
            }, 300);
        }

        function createIndexDiv(index, color, x, y) {
            const div = document.createElement("div");
            let className = "index-item";
            if (index.isPrimary) className += " primary";
            if (index.name === "#sequentialscan") className += " sequential-scan";

            div.className = className;
            div.style.borderColor = color;
            div.style.position = "absolute";
            div.style.left = x + "px";
            div.style.top = y + "px";
            div.style.width = "280px";
            div.style.margin = "0"; // Override CSS margin for absolute positioning

            // Add orange background for sequential scan
            if (index.name === "#sequentialscan") {
                div.style.backgroundColor = "#fff3cd";
                div.style.borderColor = "#ff9800";
            }

            div.draggable = true;
            div.dataset.indexName = index.name;

            const stats = calculateIndexStats(index);

            // Check avg scan time for styling:
            // 2-10 seconds: USE KEYS color (orange) and bold
            // 10+ seconds: Red and bold
            const scanTimes = index.scanTimes || [];
            const avgScanTimeMs = scanTimes.length
                ? scanTimes.reduce((a, b) => a + b, 0) / scanTimes.length
                : 0;
            const avgScanTimeSeconds = avgScanTimeMs / 1000;
            let avgScanTimeStyle = "";
            if (avgScanTimeSeconds >= 10) {
                avgScanTimeStyle = "font-weight: bold; color: red;";
            } else if (avgScanTimeSeconds >= 2) {
                avgScanTimeStyle = "font-weight: bold; color: #ff9800;";
            }

            div.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="font-weight: bold; font-size: 14px; color: #333;">${index.name
                } | Scanned: ${index.totalUsage}</div>
            <button onclick="copyIndexName('${index.name.replace(
                    /'/g,
                    "\\'"
                )}', event)" class="btn-standard" style="font-size: 11px;">Copy</button>
          </div>
          <div class="index-stats" style="font-size: 13px; margin-top: 8px;">
            Avg Scan Time: <span style="${avgScanTimeStyle}">${stats.avgScanTime
                }</span><br>
            Avg Items Scanned: ${stats.avgItemsScanned}<br>
            Avg Items Fetched: ${stats.avgItemsFetched}<br>
            Min/Max Scan Time: ${stats.minScanTime} / ${stats.maxScanTime}<br>
            Min/Max Items: ${stats.minItems} / ${stats.maxItems}
          </div>
        `;

            makeDraggable(div);
            return div;
        }

        function createQueryDiv(query, queryIndex, x, y) {
            const div = document.createElement("div");
            div.className = "query-item";
            div.style.position = "absolute";
            div.style.left = x + "px";
            div.style.top = y + "px";
            div.style.width = "320px";
            div.style.margin = "0"; // Override CSS margin for absolute positioning
            div.draggable = true;
            div.dataset.queryId = `query-${queryIndex}`;
            div.dataset.queryStatement = query.normalizedStatement;

            const avgDuration = query.totalDuration / query.count;
            const avgDurationSeconds = avgDuration / 1000;

            // Check for USE KEYS in the statement
            const hasUseKeys = query.statement.includes("USE KEYS");
            const useKeysIndicator = hasUseKeys
                ? ' <span style="color: orange; font-weight: bold;">(USE KEYS)</span>'
                : "";

            // Check if avg duration >= 60 seconds for red/bold styling
            const avgDurationStyle =
                avgDurationSeconds >= 60 ? "font-weight: bold; color: red;" : "";

            const badgesHTML = (Array.isArray(query.scanConsistencies) && query.scanConsistencies.length > 0)
                ? query.scanConsistencies.map((c) => {
                    const lc = String(c).toLowerCase();
                    let bg = '#6c757d';
                    if (lc === 'scan_plus') bg = '#28a745';
                    else if (lc === 'request_plus') bg = '#fd7e14';
                    return `<span class="consistency-badge" style="display:inline-block;margin-left:6px;background:${bg};color:#fff;padding:2px 6px;border-radius:8px;font-size:10px;font-weight:700;">${lc}</span>`;
                }).join('')
                : '';

            div.innerHTML = `
          <div style="font-weight: bold; font-size: 14px; color: #333;">Executions: ${query.count
                }${useKeysIndicator}${badgesHTML}</div>
          <div style="font-size: 12px; color: #666; margin: 4px 0;">Avg Duration: <span style="${avgDurationStyle}">${formatTime(
                    avgDuration
                )}</span></div>
          <div class="query-text" id="query-text-${query.normalizedStatement.replace(
                    /[^a-zA-Z0-9]/g,
                    ""
                )}">
            ${query.statement}
          </div>
          <div class="query-controls">
            <button onclick="toggleQueryText('${query.normalizedStatement.replace(
                    /[^a-zA-Z0-9]/g,
                    ""
                )}')" class="btn-standard">Show More</button>
            <button class="btn-standard query-copy-btn" data-query-statement="${encodeURIComponent(
                    query.statement
                )}">Copy</button>
          </div>
        `;

            // Add event listener for copy button
            const copyBtn = div.querySelector(".query-copy-btn");
            if (copyBtn) {
                copyBtn.addEventListener("click", function (e) {
                    e.stopPropagation(); // Prevent drag from starting
                    const statement = decodeURIComponent(this.dataset.queryStatement);
                    copyQueryText(statement, e);
                });
            }

            makeDraggable(div);
            return div;
        }

        function calculateIndexStats(index) {
            const scanTimes = index.scanTimes || [];
            const itemsScanned = index.itemsScanned || [];
            const itemsFetched = index.itemsFetched || [];

            return {
                avgScanTime: scanTimes.length
                    ? formatTime(
                        scanTimes.reduce((a, b) => a + b, 0) / scanTimes.length
                    )
                    : "N/A",
                minScanTime: scanTimes.length
                    ? formatTime(Math.min(...scanTimes))
                    : "N/A",
                maxScanTime: scanTimes.length
                    ? formatTime(Math.max(...scanTimes))
                    : "N/A",
                avgItemsScanned: itemsScanned.length
                    ? Math.round(
                        itemsScanned.reduce((a, b) => a + b, 0) / itemsScanned.length
                    )
                    : "N/A",
                avgItemsFetched: itemsFetched.length
                    ? Math.round(
                        itemsFetched.reduce((a, b) => a + b, 0) / itemsFetched.length
                    )
                    : "N/A",
                minItems: itemsScanned.length ? Math.min(...itemsScanned) : "N/A",
                maxItems: itemsScanned.length ? Math.max(...itemsScanned) : "N/A",
            };
        }

        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = ((i * 360) / count) % 360;
                colors.push(`hsl(${hue}, 70%, 50%)`);
            }
            return colors;
        }

        function drawSimpleConnections(indexPositions, queryPositions, colors) {
            const svg = document.getElementById("flow-svg");
            if (!svg) {
                console.error("SVG element not found");
                return;
            }

            svg.innerHTML = "";

            // Create maps for easy lookup
            const indexMap = new Map();
            indexPositions.forEach((pos, i) => {
                indexMap.set(pos.index.name, { ...pos, color: colors[i] });
            });

            const queryMap = new Map();
            queryPositions.forEach((pos) => {
                queryMap.set(pos.query.normalizedStatement, pos);
            });

            let connectionsDrawn = 0;

            indexQueryFlowData.connections.forEach((connection) => {
                const indexPos = indexMap.get(connection.indexName);
                const queryPos = queryMap.get(connection.queryStatement);

                if (indexPos && queryPos) {
                    drawSimpleConnection(svg, indexPos, queryPos, connection.count);
                    connectionsDrawn++;
                }
            });
        }

        function drawSimpleConnection(svg, indexPos, queryPos, count) {
            const startX = indexPos.x;
            const startY = indexPos.y;
            const endX = queryPos.x;
            const endY = queryPos.y;

            // Calculate line thickness (scale between 2 and 12 pixels)
            const maxCount = Math.max(
                ...Array.from(indexQueryFlowData.connections.values()).map(
                    (c) => c.count
                )
            );
            const thickness = Math.max(
                2,
                Math.min(12, (count / maxCount) * 10 + 2)
            );

            // Create curved path instead of straight line
            const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
            );

            // Calculate control points for the curve
            const curveAmount = Math.abs(endX - startX) * 0.4; // Curve intensity based on distance

            // Create a smooth S-curve
            const d = `M ${startX} ${startY} C ${startX + curveAmount} ${startY}, ${endX - curveAmount
                } ${endY}, ${endX} ${endY}`;

            path.setAttribute("d", d);
            path.setAttribute("stroke", indexPos.color);
            path.setAttribute("stroke-width", thickness);
            path.setAttribute("opacity", "0.7");
            path.setAttribute("fill", "none");

            // Create usage count label
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;

            const rect = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
            );
            const text = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
            );

            text.setAttribute("x", midX);
            text.setAttribute("y", midY + 4);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("font-size", "11");
            text.setAttribute("font-weight", "bold");
            text.setAttribute("fill", "#333");
            text.textContent = count;

            // Estimate text dimensions
            const textWidth = count.toString().length * 7;
            rect.setAttribute("x", midX - textWidth / 2 - 3);
            rect.setAttribute("y", midY - 7);
            rect.setAttribute("width", textWidth + 6);
            rect.setAttribute("height", 14);
            rect.setAttribute("fill", "white");
            rect.setAttribute("stroke", "#333");
            rect.setAttribute("stroke-width", "1");
            rect.setAttribute("rx", "3");

            svg.appendChild(path);
            svg.appendChild(rect);
            svg.appendChild(text);
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            element.addEventListener("mousedown", function (e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // Get current position relative to the container, not viewport
                const container = document.getElementById("flow-elements");
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();

                startLeft = elementRect.left - containerRect.left;
                startTop = elementRect.top - containerRect.top;

                element.style.position = "absolute";
                element.style.zIndex = "1000";
                e.preventDefault();
            });

            document.addEventListener("mousemove", function (e) {
                if (!isDragging) return;
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                element.style.left = startLeft + deltaX + "px";
                element.style.top = startTop + deltaY + "px";

                // Redraw connections during drag for smooth following
                if (
                    document.getElementById("index-query-flow").style.display !== "none"
                ) {
                    redrawConnectionsAfterDrag();
                }
            });

            document.addEventListener("mouseup", function () {
                if (isDragging) {
                    isDragging = false;
                    element.style.zIndex = "";
                    // Redraw connections after drag
                    setTimeout(() => {
                        if (
                            document.getElementById("index-query-flow").style.display !==
                            "none"
                        ) {
                            redrawConnectionsAfterDrag();
                        }
                    }, 50);
                }
            });
        }

        function redrawConnectionsAfterDrag() {
            // Get current positions of all elements
            const indexElements = document.querySelectorAll("[data-index-name]");
            const queryElements = document.querySelectorAll("[data-query-id]");

            const indexPositions = [];
            const queryPositions = [];
            const colors = generateColors(indexElements.length);

            // Build current index positions
            indexElements.forEach((element, i) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document
                    .getElementById("flow-elements")
                    .getBoundingClientRect();
                const indexName = element.dataset.indexName;

                // Create a minimal index object with just the name
                const indexObj = { name: indexName };

                indexPositions.push({
                    element: element,
                    x: rect.right - containerRect.left, // right edge
                    y: rect.top - containerRect.top + rect.height / 2, // center
                    index: indexObj,
                });
            });

            // Build current query positions
            queryElements.forEach((element) => {
                const rect = element.getBoundingClientRect();
                const containerRect = document
                    .getElementById("flow-elements")
                    .getBoundingClientRect();
                const queryStatement = element.dataset.queryStatement;

                // Create a minimal query object with just the normalized statement
                const queryObj = { normalizedStatement: queryStatement };

                queryPositions.push({
                    element: element,
                    x: rect.left - containerRect.left, // left edge
                    y: rect.top - containerRect.top + rect.height / 2, // center
                    query: queryObj,
                });
            });

            // Redraw connections with current positions
            drawSimpleConnections(indexPositions, queryPositions, colors);
        }

        function toggleQueryText(id) {
            const element = document.getElementById(`query-text-${id}`);
            const button = element.nextElementSibling.firstElementChild;

            if (element.classList.contains("expanded")) {
                element.classList.remove("expanded");
                button.textContent = "Show More";
            } else {
                element.classList.add("expanded");
                button.textContent = "Hide";
            }
        }

        function copyQueryText(text, event) {
            navigator.clipboard.writeText(text).then(() => {
                // Brief visual feedback
                const button = event ? event.target : window.event.target;
                const originalText = button.textContent;
                button.textContent = "Copied!";
                button.style.backgroundColor = "#4CAF50";
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = "";
                }, 1000);
            });
        }

        function copyIndexName(indexName, event) {
            navigator.clipboard.writeText(indexName).then(() => {
                // Brief visual feedback
                const button = event.target;
                const originalText = button.textContent;
                const originalBg = button.style.backgroundColor;
                button.textContent = "Copied!";
                button.style.backgroundColor = "#4CAF50";
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = originalBg;
                }, 1000);
            });
        }

        // Copy to clipboard function for indexes and keys
        function copyToClipboard(text, event) {
            navigator.clipboard.writeText(text).then(() => {
                // Brief visual feedback
                const button = event.target;
                const originalText = button.textContent;
                const originalBg = button.style.backgroundColor;
                button.textContent = "Copied!";
                button.style.backgroundColor = "#28a745";
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = originalBg;
                }, 1000);
            });
        }

        // Toggle USE KEYS visibility
        function toggleUseKeys() {
            const hiddenKeys = document.querySelectorAll(".hidden-key");
            const toggleBtn = document.getElementById("toggle-keys-btn");

            if (hiddenKeys.length > 0) {
                const isHidden = hiddenKeys[0].style.display === "none";

                if (isHidden) {
                    // Show hidden keys
                    hiddenKeys.forEach((key) => (key.style.display = "block"));
                    toggleBtn.textContent = "Hide Keys";
                } else {
                    // Hide keys
                    hiddenKeys.forEach((key) => (key.style.display = "none"));
                    toggleBtn.textContent = `Show ${hiddenKeys.length} More Keys`;
                }
            }
        }

        // Hook removed - buildIndexQueryFlow will be called directly after data processing

        // Version management
        const APP_VERSION = "3.16.3";
        const LAST_UPDATED = "2025-09-29";

        function getVersionInfo() {
            return {
                version: APP_VERSION,
                lastUpdated: LAST_UPDATED,
                features: [
                    "Global system query exclusion",
                    "Enhanced accessibility (ARIA)",
                    "Chart performance optimizations",
                    "Time range filtering with buffers",
                    "Index/Query Flow analysis",
                    "Toast notification system",
                ],
            };
        }

        // Initialize the application
        // Index Analysis Variables
        let indexData = [];
        let filteredIndexData = [];
        let usedIndexes = new Set(); // Store indexes found in query data

        // Calculate human-readable time difference
        function getTimeSince(dateString) {
            if (!dateString || dateString === "Never") return "";

            const now = new Date();
            const past = new Date(dateString);
            const diffMs = now - past;

            const minutes = Math.floor(diffMs / 60000);
            const hours = Math.floor(diffMs / 3600000);
            const days = Math.floor(diffMs / 86400000);
            const weeks = Math.floor(days / 7);
            const months = Math.floor(days / 30);
            const years = Math.floor(days / 365);

            if (years > 0) return `(${years} year${years > 1 ? "s" : ""} ago)`;
            if (months > 0) return `(${months} month${months > 1 ? "s" : ""} ago)`;
            if (weeks > 0) return `(${weeks} week${weeks > 1 ? "s" : ""} ago)`;
            if (days > 0) return `(${days} day${days > 1 ? "s" : ""} ago)`;
            if (hours > 0) return `(${hours} hour${hours > 1 ? "s" : ""} ago)`;
            if (minutes > 0)
                return `(${minutes} minute${minutes > 1 ? "s" : ""} ago)`;
            return "(just now)";
        }

        // Create state badge HTML
        function createStateBadge(state) {
            const stateClass =
                state === "online"
                    ? "state-online"
                    : state === "offline"
                        ? "state-offline"
                        : state === "building"
                            ? "state-building"
                            : "state-offline";
            return `<span class="state-badge ${stateClass}">${state || "unknown"
                }</span>`;
        }

        // Extract and store all indexes used in queries
        function extractUsedIndexes(requests) {
            usedIndexes.clear();

            let totalIndexReferences = 0;

            requests.forEach((request, index) => {
                // Handle different JSON structures
                let actualRequest = request;
                if (request.completed_requests) {
                    // User's format: { completed_requests: {...}, plan: "..." }
                    actualRequest = {
                        ...request.completed_requests,
                        plan: request.plan,
                    };
                } else {
                }

                if (actualRequest.plan) {
                }

                // Create a copy of the request with parsed plan
                const processedRequest = { ...actualRequest };

                // Parse the plan if it's a string
                if (typeof processedRequest.plan === "string") {
                    try {
                        processedRequest.plan = JSON.parse(processedRequest.plan);
                    } catch (e) {
                        console.warn(
                            `⚠️ Failed to parse plan JSON for request: ${processedRequest.clientContextID ||
                            processedRequest.requestId ||
                            "unknown"
                            }`,
                            e
                        );
                        return; // Skip this request if plan can't be parsed
                    }
                } else if (processedRequest.plan) {
                } else {
                    console.warn(`⚠️ No plan found in request`);
                    return;
                }

                const indexesAndKeys = extractIndexesAndKeys(processedRequest);

                // Get bucket.scope.collection from the statement
                const statement =
                    actualRequest.preparedText || actualRequest.statement || "";

                let bucketScopeCollection = "unknown.unknown.unknown";

                // Try to extract FROM clause to get bucket.scope.collection
                const fromMatch = statement.match(/FROM\s+([^\s\n\r\t]+)/i);
                if (fromMatch) {
                    const target = fromMatch[1].replace(/`/g, "").replace(/;$/, "");
                    const parts = target.split(".");
                    if (parts.length === 1) {
                        bucketScopeCollection = `${parts[0]}._default._default`;
                    } else if (parts.length === 2) {
                        bucketScopeCollection = `${parts[0]}.${parts[1]}._default`;
                    } else if (parts.length >= 3) {
                        bucketScopeCollection = `${parts[0]}.${parts[1]}.${parts[2]}`;
                    }
                }

                // Add each index with its bucket.scope.collection
                indexesAndKeys.indexes.forEach((indexName) => {
                    const indexKey = `${indexName}|${bucketScopeCollection}`;
                    usedIndexes.add(indexKey);
                    totalIndexReferences++;
                });
            });

            console.log(
                `✅ Index extraction complete: ${usedIndexes.size} unique indexes, ${totalIndexReferences} total references`
            );
        }

        // Calculate and update index statistics
        function updateIndexStats() {
            const buckets = new Set();
            const scopes = new Set();
            const collections = new Set();
            let primaryCount = 0;
            let withReplicasCount = 0;
            let noReplicasCount = 0;
            let neverScannedCount = 0;
            let usedCount = 0;
            let mobileIndexCount = 0;

            filteredIndexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    buckets.add(target.bucket);
                    scopes.add(target.scope);
                    collections.add(target.collection);
                }

                // Check if primary
                if (
                    index.name.includes("primary") ||
                    index.name.includes("#primary")
                ) {
                    primaryCount++;
                }

                // Check replicas (skip FTS indexes)
                const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                if (idxType !== 'fts') {
                    const replica = index.metadata?.num_replica || 0;
                    if (replica > 0) {
                        withReplicasCount++;
                    } else {
                        noReplicasCount++;
                    }
                }

                // Check if never scanned (skip FTS indexes)
                const lastScan = index.metadata?.last_scan_time;
                const idxTypeForNever = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                if (idxTypeForNever !== 'fts') {
                    if (!lastScan || lastScan === "Never") {
                        neverScannedCount++;
                    }
                }

                // Check if used in queries
                const target = parseIndexTarget(index.indexString);
                const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");

                const exactKey = `${index.name}|${targetString}`;
                const primaryKey = `#primary|${targetString}`;

                if (
                    usedIndexes.has(exactKey) ||
                    (isPrimary && usedIndexes.has(primaryKey))
                ) {
                    usedCount++;
                }

                // Check if mobile/sync gateway index
                if (index.name.startsWith("sg_")) {
                    mobileIndexCount++;
                }
            });

            // Update stats display
            document.getElementById("stat-indexes").textContent =
                filteredIndexData.length;
            document.getElementById("stat-buckets").textContent = buckets.size;
            document.getElementById("stat-scopes").textContent = scopes.size;
            document.getElementById("stat-collections").textContent =
                collections.size;

            const primaryElement = document.getElementById("stat-primary");
            primaryElement.textContent = primaryCount;
            primaryElement.className = primaryCount > 0 ? "primary-warning" : "";

            const replicaInfoElement = document.getElementById("stat-replica-info");
            replicaInfoElement.innerHTML = `<span class="${noReplicasCount > 0 ? "replica-zero" : ""
                }">${noReplicasCount}</span>/${withReplicasCount}`;

            document.getElementById("stat-never-scanned").textContent =
                neverScannedCount;
            document.getElementById(
                "stat-used-total"
            ).textContent = `${usedCount}/${filteredIndexData.length}`;
            document.getElementById("stat-mobile-indexes").textContent =
                mobileIndexCount;
        }

        // Parse and process index JSON data
        function parseIndexJSON() {
            // Prefer uploaded file content (in-memory) over textarea to avoid DOM bloat
            const uploadedIndexRaw = (window._uploadedIndexesJsonRaw && typeof window._uploadedIndexesJsonRaw === 'string') ? window._uploadedIndexesJsonRaw.trim() : "";
            const indexTextAreaVal = (document.getElementById("indexJsonInput")?.value || "").trim();
            const sourceJson = uploadedIndexRaw || indexTextAreaVal;

            if (!sourceJson) {
                indexData = [];
                displayIndexResults();
                return;
            }

            try {
                const parsedData = JSON.parse(sourceJson);
                indexData = Array.isArray(parsedData) ? parsedData : [parsedData];

                // Extract unique buckets, scopes, collections
                updateFilterDropdowns();

                // Apply current filters and display
                applyIndexFilters();
            } catch (error) {
                document.getElementById("indexResults").innerHTML = `
                    <div class="text-align-center" style="color: #dc3545; margin-top: 50px;">
                        <strong>Invalid JSON Format</strong><br>
                        Please check your JSON syntax: ${error.message}
                    </div>
                `;
            }
        }

        // Extract bucket, scope, collection from indexString
        function parseIndexTarget(indexString) {
            const match = indexString.match(/\bON\s+([^\s(;]+)/i);
            if (!match)
                return { bucket: "unknown", scope: "unknown", collection: "unknown" };

            // Clean up the target string - remove backticks, leading dots, trailing semicolons
            let target = match[1]
                .replace(/`/g, "")
                .replace(/^\.+/, "")
                .replace(/;+$/, "");
            const parts = target.split(".").filter((part) => part.length > 0);

            if (parts.length === 1) {
                return {
                    bucket: parts[0],
                    scope: "_default",
                    collection: "_default",
                };
            } else if (parts.length === 2) {
                return { bucket: parts[0], scope: parts[1], collection: "_default" };
            } else if (parts.length >= 3) {
                return { bucket: parts[0], scope: parts[1], collection: parts[2] };
            }

            return {
                bucket: parts[0] || "unknown",
                scope: parts[1] || "unknown",
                collection: parts[2] || "unknown",
            };
        }

        // Update filter dropdowns with available options
        function updateFilterDropdowns() {
            const buckets = new Set();

            indexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);
                    buckets.add(target.bucket);
                }
            });

            updateDropdown("bucketFilter", Array.from(buckets).sort());

            // Update scopes and collections based on selected filters
            updateCascadingDropdowns();
        }

        // Update scopes and collections based on selected bucket/scope
        function updateCascadingDropdowns() {
            const selectedBucket = document.getElementById("bucketFilter").value;
            const selectedScope = document.getElementById("scopeFilter").value;

            const scopes = new Set();
            const collections = new Set();

            indexData.forEach((index) => {
                if (index.indexString) {
                    const target = parseIndexTarget(index.indexString);

                    // If bucket is selected, only show scopes for that bucket
                    if (
                        selectedBucket === "(ALL)" ||
                        target.bucket === selectedBucket
                    ) {
                        scopes.add(target.scope);

                        // If scope is also selected, only show collections for that bucket.scope
                        if (selectedScope === "(ALL)" || target.scope === selectedScope) {
                            collections.add(target.collection);
                        }
                    }
                }
            });

            updateDropdown("scopeFilter", Array.from(scopes).sort());
            updateDropdown("collectionFilter", Array.from(collections).sort());
        }

        function updateDropdown(selectId, options) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;

            // Clear existing options except (ALL)
            select.innerHTML = '<option value="(ALL)">(ALL)</option>';

            // Add new options
            options.forEach((option) => {
                const optionElement = document.createElement("option");
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });

            // Restore previous selection if it still exists
            if (options.includes(currentValue)) {
                select.value = currentValue;
            }
        }

        // Apply current filter settings
        function applyIndexFilters() {
            const bucketFilter = document.getElementById("bucketFilter").value;
            const scopeFilter = document.getElementById("scopeFilter").value;
            const collectionFilter =
                document.getElementById("collectionFilter").value;
            const searchTerm =
                document.getElementById("indexSearch")?.value.toLowerCase().trim() ||
                "";
            const typeFilter = document.querySelector('input[name="indexTypeFilter"]:checked')?.value || 'all';

            // Get checkbox filter states
            const filterPrimary =
                document.getElementById("filter-primary")?.checked || false;
            const filterUsed =
                document.getElementById("filter-used")?.checked || false;
            const filterNoReplica =
                document.getElementById("filter-no-replica")?.checked || false;
            const filterNeverScanned =
                document.getElementById("filter-never-scanned")?.checked || false;
            const filterExcludeMobile =
                document.getElementById("filter-exclude-mobile")?.checked || false;

            filteredIndexData = indexData.filter((index) => {
                if (!index.indexString) return false;

                const target = parseIndexTarget(index.indexString);

                // Basic dropdown filters
                const passesDropdownFilters =
                    (bucketFilter === "(ALL)" || target.bucket === bucketFilter) &&
                    (scopeFilter === "(ALL)" || target.scope === scopeFilter) &&
                    (collectionFilter === "(ALL)" ||
                        target.collection === collectionFilter);

                if (!passesDropdownFilters) return false;

                // Search filter
                if (searchTerm) {
                    const indexName = index.name.toLowerCase();
                    const indexString = index.indexString?.toLowerCase() || "";
                    const matchesSearch =
                        indexName.includes(searchTerm) ||
                        indexString.includes(searchTerm);
                    if (!matchesSearch) return false;
                }

                // Type radio filter (All, GSI, FTS)
                if (typeFilter !== 'all') {
                    const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase()) || 'gsi';
                    if (typeFilter === 'gsi' && idxType !== 'gsi') return false;
                    if (typeFilter === 'fts' && idxType !== 'fts') return false;
                }

                // Checkbox filters
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");
                if (filterPrimary && !isPrimary) return false;

                // Check if used in queries
                if (filterUsed) {
                    const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                    const exactKey = `${index.name}|${targetString}`;
                    const primaryKey = `#primary|${targetString}`;
                    const isUsed =
                        usedIndexes.has(exactKey) ||
                        (isPrimary && usedIndexes.has(primaryKey));
                    if (!isUsed) return false;
                }

                // Check replicas (skip FTS indexes when filtering by no replica)
                if (filterNoReplica) {
                    const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                    if (idxType === 'fts') return false;
                    const replica = index.metadata?.num_replica || 0;
                    if (replica !== 0) return false;
                }

                // Check never scanned (skip FTS indexes)
                if (filterNeverScanned) {
                    const idxTypeNs = ((index.indexType || index.metadata?.using || '').toString().toLowerCase());
                    if (idxTypeNs === 'fts') return false;
                    const lastScan = index.metadata?.last_scan_time;
                    if (lastScan && lastScan !== "Never") return false;
                }

                // Exclude Sync Gateway/Mobile indexes (sg_ prefixed)
                if (filterExcludeMobile) {
                    if (index.name.startsWith("sg_")) return false;
                }

                return true;
            });

            updateIndexStats();
            displayIndexResults();

            // Count and log matches
            let matchedCount = 0;
            filteredIndexData.forEach((index) => {
                const target = parseIndexTarget(index.indexString);
                const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
                const isPrimary =
                    index.name.includes("primary") || index.name.includes("#primary");

                const exactKey = `${index.name}|${targetString}`;
                const primaryKey = `#primary|${targetString}`;

                if (
                    usedIndexes.has(exactKey) ||
                    (isPrimary && usedIndexes.has(primaryKey))
                ) {
                    matchedCount++;
                }
            });

            console.log(
                `📊 Matching summary: ${matchedCount}/${filteredIndexData.length} indexes found in query data`
            );
        }

        // Display filtered index results
        function displayIndexResults() {
            const resultsContainer = document.getElementById("indexResults");
            const sortBy = document.getElementById("sortBy").value;

            if (filteredIndexData.length === 0) {
                if (indexData.length === 0) {
                    // No index data loaded - show instructions
                    resultsContainer.innerHTML = `
                        <div class="text-align-center" style="margin-top: 30px;">
                            <h4 style="color: #495057; margin-bottom: 20px;">No Index Data Loaded</h4>
                            <p style="color: #666; margin-bottom: 20px;">
                                To analyze indexes, run this query in your Couchbase Query Workbench and paste the results in the second textarea above:
                            </p>
                            <div class="sql-query-box">
                                <button class="btn-standard sql-copy-btn" onclick="copyIndexQuery(event)">Copy Query</button>
                                <pre>SELECT 
                                s.name,
                                s.id,
                                s.metadata,
                                s.state,
                                s.num_replica,
                                s.\`using\` AS indexType,
                                CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
                                FROM system:indexes AS s
                                LET bid = CONCAT("", s.bucket_id, ""),
                                sid = CONCAT("", s.scope_id, ""),
                                kid = CONCAT("", s.keyspace_id, ""),
                                k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
                                ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
                                w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
                                    p = CASE WHEN s.\`partition\` IS NOT NULL THEN " PARTITION BY " || s.\`partition\` ELSE "" END
 ;</pre>
                            </div>
                            <p style="color: #666; font-size: 13px; margin-top: 15px;">
                                <strong>Steps:</strong><br>
                                1. Copy the query above<br>
                                2. Run it in Couchbase Query Workbench<br>
                                3. Copy the JSON results<br>
                                4. Paste into the second textarea at the top<br>
                                5. Click "Parse JSON" again
                            </p>
                        </div>
                    `;
                } else {
                    // Index data loaded but filtered out
                    resultsContainer.innerHTML = `
                        <p style="color: #666; text-align: center; margin-top: 50px;">
                            No indexes match the current filters.
                        </p>
                    `;
                }
                return;
            }

            console.log(
                `🔄 Displaying ${filteredIndexData.length} indexes and checking for query matches...`
            );

            let html = "";

            if (sortBy === "Bucket") {
                // Group by bucket
                const grouped = {};
                filteredIndexData.forEach((index) => {
                    const target = parseIndexTarget(index.indexString);
                    if (!grouped[target.bucket]) grouped[target.bucket] = [];
                    grouped[target.bucket].push(index);
                });

                Object.keys(grouped)
                    .sort()
                    .forEach((bucket) => {
                        html += `<div class="bucket-group">`;
                        html += `<h3 style="font-size: 24px;">${bucket}</h3>`;
                        grouped[bucket]
                            .sort((a, b) => a.name.localeCompare(b.name))
                            .forEach((index) => {
                                html += createIndexHTML(index);
                            });
                        html += `</div>`;
                    });
            } else if (sortBy === "LastScanned") {
                // Sort by last scanned time (newest first)
                const sorted = [...filteredIndexData].sort((a, b) => {
                    const aLastScan = a.metadata?.last_scan_time || 0;
                    const bLastScan = b.metadata?.last_scan_time || 0;

                    // Handle 'Never' scanned cases (put them at the end)
                    if (aLastScan === 0 && bLastScan === 0)
                        return a.name.localeCompare(b.name);
                    if (aLastScan === 0) return 1;
                    if (bLastScan === 0) return -1;

                    // Sort by timestamp (newest first)
                    return new Date(bLastScan) - new Date(aLastScan);
                });
                sorted.forEach((index) => {
                    html += createIndexHTML(index);
                });
            } else {
                // Sort by name (default)
                const sorted = [...filteredIndexData].sort((a, b) =>
                    a.name.localeCompare(b.name)
                );
                sorted.forEach((index) => {
                    html += createIndexHTML(index);
                });
            }

            resultsContainer.innerHTML = html;
        }

        function createIndexHTML(index) {
            const target = parseIndexTarget(index.indexString);
            const isPrimary =
                index.name.includes("primary") || index.name.includes("#primary");
            const lastScan = index.metadata?.last_scan_time || "Never";
            const rawReplica = index.metadata?.num_replica;
            const state = index.state || "unknown";
            const timeSince = getTimeSince(lastScan);
            const lastScanFormatted =
                lastScan === "Never" ? "Never" : new Date(lastScan).toLocaleString();
            const idxType = ((index.indexType || index.metadata?.using || '').toString().toLowerCase()) || 'gsi';
            const isFtsIndex = idxType === 'fts';
            const idxTypeLabel = isFtsIndex ? 'FTS' : 'GSI';
            const computedReplica = (rawReplica ?? 0);
            const replicaDisplay = isFtsIndex ? TEXT_CONSTANTS.N_A : computedReplica;
            const replicaClass = (!isFtsIndex && computedReplica === 0) ? "replica-zero" : "";
            const lastScanDisplay = isFtsIndex ? TEXT_CONSTANTS.N_A : lastScanFormatted;
            const timeSinceDisplay = isFtsIndex ? "" : timeSince;

            // Check if this index is used in the parsed query data
            const targetString = `${target.bucket}.${target.scope}.${target.collection}`;
            let isUsed = false;

            // First try exact match
            const exactKey = `${index.name}|${targetString}`;
            if (usedIndexes.has(exactKey)) {
                isUsed = true;
                console.log(
                    `✅ Exact match found: "${index.name}" on ${targetString}`
                );
            }

            // If not found and this is a primary index, also check for #primary match
            if (!isUsed && isPrimary) {
                const primaryKey = `#primary|${targetString}`;
                if (usedIndexes.has(primaryKey)) {
                    isUsed = true;
                    console.log(
                        `✅ Primary match found: "${index.name}" matches "#primary" on ${targetString}`
                    );
                }
            }

            const usedBadge = isUsed ? '<span class="used-badge">Used</span>' : "";

            return `
                <div class="index-item ${isPrimary ? "primary" : ""}">
                    <h4>${index.name} ${usedBadge}</h4>
                    <div class="index-details">
                        <strong>Target:</strong> ${target.bucket}.${target.scope
                }.${target.collection}<br>
                        <strong>State:</strong> ${createStateBadge(
                    state
                )} | <strong>Type:</strong> ${idxTypeLabel} | <strong>Replicas:</strong> <span class="${replicaClass}">${replicaDisplay}</span> | <strong>Last Scan:</strong> ${lastScanDisplay} ${timeSinceDisplay}
                    </div>
                    <div class="index-statement">
                        ${index.indexString}
                        <button class="btn-standard copy-btn" onclick="copyIndexDefinition('${index.indexString.replace(
                    /'/g,
                    "\\'"
                )}', event)">Copy</button>
                    </div>
                </div>
            `;
        }

        // Copy index definition to clipboard
        function copyIndexDefinition(indexString, event) {
            navigator.clipboard
                .writeText(indexString)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.style.backgroundColor = "#28a745";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "#007bff";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy: ", err);
                });
        }

        // Copy index query to clipboard
        function copyIndexQuery(event) {
            const query = `SELECT 
            s.name,
            s.id,
            s.metadata,
            s.state,
            s.num_replica,
            s.\`using\` AS indexType,
            CONCAT("CREATE INDEX ", s.name, " ON ", k, ks, p, w, ";") AS indexString
            FROM system:indexes AS s
            LET bid = CONCAT("", s.bucket_id, ""),
            sid = CONCAT("", s.scope_id, ""),
            kid = CONCAT("", s.keyspace_id, ""),
            k = NVL2(bid, CONCAT2(".", bid, sid, kid), kid),
            ks = CASE WHEN s.is_primary THEN "" ELSE "(" || CONCAT2(",", s.index_key) || ")" END,
            w = CASE WHEN s.condition IS NOT NULL THEN " WHERE " || REPLACE(s.condition, '"', "'") ELSE "" END,
                p = CASE WHEN s.\`partition\` IS NOT NULL THEN " PARTITION BY " || s.\`partition\` ELSE "" END
 ;`;

            navigator.clipboard
                .writeText(query)
                .then(() => {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.style.backgroundColor = "#28a745";
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = "#007bff";
                    }, 1000);
                })
                .catch((err) => {
                    console.error("Failed to copy query: ", err);
                });
        }

        // Initialize index analysis functionality
        function initializeIndexAnalysis() {
            const indexJsonInput = document.getElementById("indexJsonInput");
            const bucketFilter = document.getElementById("bucketFilter");
            const scopeFilter = document.getElementById("scopeFilter");
            const collectionFilter = document.getElementById("collectionFilter");
            const sortBy = document.getElementById("sortBy");

            // Add event listeners
            if (indexJsonInput)
                indexJsonInput.addEventListener("input", parseIndexJSON);
            if (bucketFilter) {
                bucketFilter.addEventListener("change", () => {
                    // Reset scope and collection when bucket changes
                    document.getElementById("scopeFilter").value = "(ALL)";
                    document.getElementById("collectionFilter").value = "(ALL)";
                    updateCascadingDropdowns();
                    applyIndexFilters();
                });
            }
            if (scopeFilter) {
                scopeFilter.addEventListener("change", () => {
                    // Reset collection when scope changes
                    document.getElementById("collectionFilter").value = "(ALL)";
                    updateCascadingDropdowns();
                    applyIndexFilters();
                });
            }
            if (collectionFilter)
                collectionFilter.addEventListener("change", applyIndexFilters);
            if (sortBy) sortBy.addEventListener("change", applyIndexFilters);

            // Add search input event listener with debouncing
            const indexSearch = document.getElementById("indexSearch");
            if (indexSearch) {
                let searchTimeout;
                indexSearch.addEventListener("input", () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(applyIndexFilters, 300); // 300ms debounce
                });
            }

            // Add checkbox event listeners
            const filterCheckboxes = [
                "filter-primary",
                "filter-used",
                "filter-no-replica",
                "filter-never-scanned",
                "filter-exclude-mobile",
            ];

            // Radio buttons for type filter
            const typeRadios = [
                "filter-type-all",
                "filter-type-gsi",
                "filter-type-fts",
            ];
            typeRadios.forEach((id) => {
                const radio = document.getElementById(id);
                if (radio) {
                    radio.addEventListener("change", applyIndexFilters);
                }
            });

            filterCheckboxes.forEach((id) => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener("change", applyIndexFilters);
                }
            });

            console.log(TEXT_CONSTANTS.INDEX_ANALYSIS_INITIALIZED);
        }

        document.addEventListener("DOMContentLoaded", function () {
            console.log(TEXT_CONSTANTS.INITIALIZING_ANALYZER);
            console.log(`📦 Version: ${APP_VERSION} (Updated: ${LAST_UPDATED})`);
            console.log(`${TEXT_CONSTANTS.FEATURES}`, getVersionInfo().features.join(", "));

            // Initialize theme from localStorage

            // Enhance keyboard navigation
            enhanceKeyboardNavigation();

            // Initialize tabs with enhanced accessibility
            $("#tabs").tabs({
                activate: function (event, ui) {
                    // Announce tab change to screen readers
                    const tabName = ui.newTab.find("a").text();
                    showToast(`${TEXT_CONSTANTS.SWITCHED_TO} ${tabName}`, "info");
                },
            });

            // Add event listener for system query exclusion checkbox
            const excludeCheckbox = document.getElementById(
                "exclude-system-queries"
            );
            if (excludeCheckbox) {
                excludeCheckbox.addEventListener("change", function () {
                    console.log(`System query exclusion changed to: ${this.checked}`);
                    const jsonInput = document.getElementById("json-input").value;
                    if (jsonInput.trim()) {
                        showFilterReminder();
                    }
                });
            }

            // Add event listeners for date/time filter controls
            const startDateInput = document.getElementById("start-date");
            const endDateInput = document.getElementById("end-date");
            const sqlFilterInput = document.getElementById("sql-statement-filter");
            const elapsedFilterInput = document.getElementById("elapsed-time-filter");

            if (startDateInput) {
                startDateInput.addEventListener("change", function () {
                    console.log(`Start date changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            if (endDateInput) {
                endDateInput.addEventListener("change", function () {
                    console.log(`End date changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            if (sqlFilterInput) {
                sqlFilterInput.addEventListener("input", function () {
                    console.log(`SQL filter changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            if (elapsedFilterInput) {
                elapsedFilterInput.addEventListener("input", function () {
                    console.log(`Elapsed filter changed to: ${this.value}`);
                    showFilterReminder();
                });
            }

            console.log(TEXT_CONSTANTS.ANALYZER_INITIALIZED);

            // Setup JSON file upload handlers
            (function setupUploadInputs() {
                try {
                    const setButtonLabels = () => {
                        const btn1 = document.getElementById('upload-completed-btn');
                        const btn2 = document.getElementById('upload-indexes-btn');
                        if (btn1) btn1.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.UPLOAD_JSON) || 'Upload .json';
                        if (btn2) btn2.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.UPLOAD_JSON) || 'Upload .json';
                        const orTxt = (window.TEXT_CONSTANTS && (TEXT_CONSTANTS.OR_LABEL || 'OR')) || 'OR';
                        const or1 = document.getElementById('or-label-1');
                        const or2 = document.getElementById('or-label-2');
                        if (or1) or1.textContent = orTxt;
                        if (or2) or2.textContent = orTxt;
                        const completedHeader = document.getElementById('completed-section-title');
                        const indexesHeader = document.getElementById('indexes-section-title');
                        if (completedHeader) completedHeader.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.COMPLETED_JSON_HEADER) || 'Completed Requests JSON (system:completed_requests)';
                        if (indexesHeader) indexesHeader.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.INDEXES_JSON_HEADER) || 'Indexes JSON (system:indexes output)';
                    };
                    setButtonLabels();

                    const jsonTextarea = document.getElementById('json-input');
                    const indexTextarea = document.getElementById('indexJsonInput');

                    const completedInput = document.getElementById('completed-requests-file');
                    const completedBtn = document.getElementById('upload-completed-btn');
                    const completedName = document.getElementById('completed-file-name');

                    const indexesInput = document.getElementById('indexes-file');
                    const indexesBtn = document.getElementById('upload-indexes-btn');
                    const indexesName = document.getElementById('indexes-file-name');

                    // In-memory upload buffers to avoid populating textareas
                    window._uploadedCompletedJsonRaw = window._uploadedCompletedJsonRaw || '';
                    window._uploadedIndexesJsonRaw = window._uploadedIndexesJsonRaw || '';

                    const readJsonFile = (file, onLoad, onError) => {
                        if (!file) return;
                        const name = file.name || '';
                        if (!/\.json$/i.test(name)) {
                            showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.INVALID_FILE_TYPE) || 'Please select a .json file', 'warning');
                            return;
                        }
                        const reader = new FileReader();
                        reader.onload = () => { try { onLoad(reader.result); } catch (e) { /* no-op */ } };
                        reader.onerror = () => {
                            showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.FILE_READ_ERROR) || 'Error reading file', 'error');
                            if (typeof onError === 'function') onError();
                        };
                        reader.readAsText(file);
                    };

                    if (completedBtn && completedInput) {
                        completedBtn.addEventListener('click', () => completedInput.click());
                        completedInput.addEventListener('change', function () {
                            const file = this.files && this.files[0];
                            if (!file) return;
                            readJsonFile(
                                file,
                                (text) => {
                                    // Store uploaded JSON in memory; do NOT populate textarea to keep DOM light
                                    window._uploadedCompletedJsonRaw = text || '';
                                    if (completedName) completedName.textContent = file.name || '';
                                    // Auto-run parse on successful upload
                                    if (typeof parseJSON === 'function') {
                                        try { setTimeout(() => parseJSON(), 0); } catch (e) { /* no-op */ }
                                    }
                                },
                                () => {
                                    this.value = '';
                                    if (completedName) completedName.textContent = '';
                                }
                            );
                        });
                    }

                    if (indexesBtn && indexesInput) {
                        indexesBtn.addEventListener('click', () => indexesInput.click());
                        indexesInput.addEventListener('change', function () {
                            const file = this.files && this.files[0];
                            if (!file) return;
                            readJsonFile(
                                file,
                                (text) => {
                                    // Store uploaded JSON in memory; do NOT populate textarea to keep DOM light
                                    window._uploadedIndexesJsonRaw = text || '';
                                    // Parse immediately using in-memory data
                                    if (typeof parseIndexJSON === 'function') {
                                        try { parseIndexJSON(); } catch (e) { /* no-op */ }
                                    }
                                    if (indexesName) indexesName.textContent = file.name || '';
                                },
                                () => {
                                    this.value = '';
                                    if (indexesName) indexesName.textContent = '';
                                }
                            );
                        });
                    }

                    if (jsonTextarea) {
                        jsonTextarea.addEventListener('paste', () => {
                            const fi = completedInput;
                            if (fi && fi.value) {
                                fi.value = '';
                                if (completedName) completedName.textContent = '';
                            }
                            // Clear in-memory upload to give paste precedence
                            if (window._uploadedCompletedJsonRaw) {
                                window._uploadedCompletedJsonRaw = '';
                                showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.PASTE_OVERRIDES_UPLOAD) || 'Pasted JSON overrides uploaded file; cleared file selection', 'info');
                            }
                            // Auto-run parse after paste completes
                            if (typeof parseJSON === 'function') {
                                try { setTimeout(() => parseJSON(), 0); } catch (e) { /* no-op */ }
                            }
                        });
                    }
                    if (indexTextarea) {
                        indexTextarea.addEventListener('paste', () => {
                            const fi = indexesInput;
                            if (fi && fi.value) {
                                fi.value = '';
                                if (indexesName) indexesName.textContent = '';
                            }
                            // Clear in-memory upload to give paste precedence
                            if (window._uploadedIndexesJsonRaw) {
                                window._uploadedIndexesJsonRaw = '';
                                showToast((window.TEXT_CONSTANTS && TEXT_CONSTANTS.PASTE_OVERRIDES_UPLOAD) || 'Pasted JSON overrides uploaded file; cleared file selection', 'info');
                            }
                            // Auto-run index parse after paste completes
                            if (typeof parseIndexJSON === 'function') {
                                try { setTimeout(() => parseIndexJSON(), 0); } catch (e) { /* no-op */ }
                            }
                        });
                    }
                } catch (e) { /* no-op */ }
            })();

            // Initialize index analysis
            initializeIndexAnalysis();

            // Make version info globally accessible
            window.QueryAnalyzer = {
                version: getVersionInfo,
                about: () => {
                    const info = getVersionInfo();
                    console.log(`
🔍 Couchbase Query Analyzer v${info.version}
📅 Last Updated: ${info.lastUpdated}
🎯 Purpose: Analyze Couchbase N1QL query performance from system:completed_requests
                    
🚀 Features:
${info.features.map((f) => `   • ${f}`).join("\n")}

💡 Usage: Type QueryAnalyzer.version() for version info
                    `);
                },
            };

            console.log(TEXT_CONSTANTS.TIP_ABOUT);
        });

        // =====================
        // Report Maker (Phase 1)
        // =====================
        let reportModeActive = false;
        let savedTimelineDisplay = null; // Map<Element, string> original inline display values
        function getReportSelections() {
            const sectionChecks = document.querySelectorAll('#report-sections input[type="checkbox"]');
            const sections = {};
            sectionChecks.forEach(chk => { sections[chk.getAttribute('data-section')] = chk.checked; });

            // Timeline charts from dynamic list
            const chartChecks = document.querySelectorAll('#report-timeline-charts input[type="checkbox"]');
            const timelineChartsSel = {};
            chartChecks.forEach(chk => { timelineChartsSel[chk.getAttribute('data-chart-id')] = chk.checked; });

            return {
                sections,
                options: {
                    includeHeader: !!document.getElementById('opt-include-header')?.checked,
                    includeFilters: !!document.getElementById('opt-include-filters')?.checked,
                    flattenTables: !!document.getElementById('opt-flatten-tables')?.checked,
                    chartsAsImages: !!document.getElementById('opt-charts-as-images')?.checked,
                },
                timelineCharts: timelineChartsSel,
            };
        }

        function populateReportMakerTimelineCharts() {
            const container = document.getElementById('report-timeline-charts');
            if (!container) return;
            container.innerHTML = '';
            const mapNames = {
                'duration-buckets': 'Duration Buckets',
                'query-types': 'Query Types',
                'operations': 'Operations',
                'filter': 'Filter Efficiency',
                'result-count': 'Result Count',
                'result-size': 'Result Size',
                'timeline': 'Timeline',
                'memory': 'Memory',
                'exec-vs-kernel': 'Exec vs Kernel',
                'exec-vs-serv': 'Exec vs Service',
                'exec-vs-elapsed': 'Exec vs Elapsed',
                'enhanced-operations': 'Enhanced Operations',
                'cpu-time': 'CPU Time'
            };
            // Default OFF list
            const defaultOff = new Set(['timeline','memory','exec-vs-kernel','exec-vs-serv','exec-vs-elapsed','cpu-time','enhanced-operations']);
            const cards = document.querySelectorAll('#timeline .chart-container');
            cards.forEach(card => {
                const id = card.getAttribute('data-chart-id') || card.querySelector('canvas')?.id || '';
                if (!id) return;
                const lbl = mapNames[id] || id;
                const checkedAttr = defaultOff.has(id) ? '' : 'checked';
                const label = document.createElement('label');
                label.innerHTML = `<input type=\"checkbox\" data-chart-id=\"${id}\" ${checkedAttr}> ${lbl}`;
                container.appendChild(label);
            });
        }

        function addReportHeader(summaryText) {
            let header = document.getElementById('report-header');
            if (!header) {
                header = document.createElement('div');
                header.id = 'report-header';
                document.body.insertBefore(header, document.body.firstChild);
            }
            // preserve existing exit button
            const existingBtn = header.querySelector('#report-exit-btn');
            const ver = (typeof getVersionInfo === 'function' ? getVersionInfo().version : '');
            const now = new Date().toLocaleString();
            header.innerHTML = `
              <h1>Couchbase Query Analyzer ${ver ? 'v' + ver : ''}</h1>
              <div class=\"meta\">${TEXT_CONSTANTS.REPORT_GENERATED_AT || 'Generated at'}: ${now}${summaryText ? ' • ' + summaryText : ''}</div>
            `;
            // ensure header is printable when summary is included
            header.classList.add('print-visible');
            if (existingBtn) header.appendChild(existingBtn);
        }

        function buildTabHighlights(selections) {
            const bullets = [];
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;

            // Dashboard
            if (selections.sections && selections.sections.dashboard) {
                try {
                    const list = Array.isArray(window.everyQueryData) ? window.everyQueryData : [];
                    const total = list.length;
                    const prim = list.filter(r => r["Primary Scan Used"] === 'Yes').length;
                    const fatal = list.filter(r => (r.state || '').toLowerCase() === 'fatal').length;
                    const stCounts = {};
                    list.forEach(r => { const k = (r.statementType || '').toString(); stCounts[k] = (stCounts[k]||0)+1; });
                    const topTypes = Object.entries(stCounts).sort((a,b)=>b[1]-a[1]).slice(0,3).map(([k,v])=>`${k} (${v})`).join(', ');
                    bullets.push(`<h4>Dashboard</h4><ul>
                        <li>Primary index usage: ${total?Math.round((prim/total)*100):0}% (${prim}/${total})</li>
                        <li>Fatal rate: ${total?Math.round((fatal/total)*100):0}% (${fatal}/${total})</li>
                        <li>Top statement types: ${topTypes || '-'}</li>
                    </ul>`);
                } catch(e){}
            }

            // Timeline
            if (selections.sections && selections.sections.timeline) {
                try {
                    const reqs = Array.isArray(window.originalRequests) ? window.originalRequests : [];
                    let minT, maxT; 
                    reqs.forEach(r => { const d = new Date(r.requestTime); if (!isNaN(d)) { if (!minT||d<minT) minT=d; if (!maxT||d>maxT) maxT=d; }});
                    const spanHrs = (minT&&maxT)? Math.round((maxT-minT)/(1000*60*60)) : 0;
                    const unit = reqs.length ? getOptimalTimeUnit(reqs) : 'minute';
                    bullets.push(`<h4>Timeline</h4><ul>
                        <li>Span: ${spanHrs} hours${spanHrs>=24?` (~${Math.round(spanHrs/24)} days)`:''}</li>
                        <li>Grouping: ${unit}</li>
                    </ul>`);
                } catch(e){}
            }

            // Query Groups
            if (selections.sections && selections.sections.analysis) {
                try {
                    const groups = Array.isArray(window.analysisData) ? window.analysisData : [];
                    const count = groups.length;
                    let slow = null;
                    groups.forEach(g => { const ref = g.groupRef; if (ref && !isNaN(ref.avg_duration_in_seconds)) { if (!slow || ref.avg_duration_in_seconds > slow.avg) slow = { avg: ref.avg_duration_in_seconds, stmt: ref.normalized_statement }; }});
                    bullets.push(`<h4>Query Groups</h4><ul>
                        <li>Total groups: ${count}</li>
                        <li>Slowest avg duration: ${slow ? formatTime(slow.avg*1000) : 'N/A'}</li>
                    </ul>`);
                } catch(e){}
            }

            // Every Query
            if (selections.sections && selections.sections["every-query"]) {
                try {
                    const list = Array.isArray(window.everyQueryData) ? window.everyQueryData : [];
                    let longest = null;
                    list.forEach(r => { const ms = parseTime(r.request?.elapsedTime || r.elapsedTime); if (!isNaN(ms)) { if (!longest || ms > longest.ms) longest = { ms, stmt: r.request?.statement || r.statement }; }});
                    bullets.push(`<h4>Every Query</h4><ul>
                        <li>Longest elapsed: ${longest ? formatTime(longest.ms) : 'N/A'}</li>
                    </ul>`);
                } catch(e){}
            }

            // Index/Query Flow
            if (selections.sections && selections.sections["index-query-flow"]) {
                bullets.push(`<h4>Index/Query Flow</h4><ul>
                    <li>Visual map of queries and indexes. Use this to spot overused primary scans and heavy fetch paths.</li>
                </ul>`);
            }

            // Indexes
            if (selections.sections && selections.sections.indexes) {
                try {
                    const ix = (document.getElementById('stat-indexes')||{}).textContent || '0';
                    const prim = (document.getElementById('stat-primary')||{}).textContent || '0';
                    const never = (document.getElementById('stat-never-scanned')||{}).textContent || '0';
                    bullets.push(`<h4>Indexes</h4><ul>
                        <li>Total indexes: ${ix}</li>
                        <li>Primary indexes: ${prim}</li>
                        <li>Never scanned: ${never}</li>
                    </ul>`);
                } catch(e){}
            }

            return bullets.join('');
        }

        function buildCoverDetailedSections(selections) {
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;
            let html = '';
            try {
                if (selections.sections && selections.sections.dashboard) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">📊 <span>Dashboard</span></h3>
                      <p class="muted">High-level overview with draggable charts showing query duration distribution, index type usage, scan consistency patterns, result size analysis, and system health metrics. Perfect for at-a-glance performance monitoring.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections.insights) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">💡 <span>Insights Tab</span></h3>
                      <p class="muted">The Insights tab provides automated analysis organized into three main categories, each with expandable insights and live metrics based on your parsed query data:</p>
                      <div class="cover-grid">
                        <div>
                          <h4>📊 Analysis Categories</h4>
                          <h5>🔍 Index Performance Issues</h5>
                          <ul class="list-tight">
                            <li>Inefficient Index Scans - Identifies queries with poor selectivity ratios</li>
                            <li>Slow Index Scan Times - Flags indexes taking 2+ seconds to scan</li>
                            <li>Primary Index Over-Usage - Detects reliance on expensive primary indexes</li>
                            <li>ORDER BY / LIMIT / OFFSET Index Over-Scan - Highlights over-scanning due to pagination patterns <span class="badge beta">BETA</span></li>
                          </ul>
                          <h5>⚡ Resource Utilization Issues</h5>
                          <ul class="list-tight">
                            <li>High Kernel Time in Queries - CPU scheduling overhead analysis</li>
                            <li>High Memory Usage Detected - Memory-intensive query identification</li>
                            <li>Slow USE KEY Queries - KV service bottleneck detection</li>
                          </ul>
                        </div>
                        <div>
                          <h5>🔄 Query Pattern Analysis</h5>
                          <ul class="list-tight">
                            <li>Missing WHERE Clauses - Identifies full collection scans</li>
                            <li>Inefficient LIKE Operations - Detects leading wildcard usage</li>
                            <li>SELECT * Usage - Finds queries returning entire documents <span class="badge live">LIVE</span></li>
                          </ul>
                          <h5>🚀 Performance Optimization Opportunities</h5>
                          <ul class="list-tight">
                            <li>Large Payload Streaming - Identifies queries with heavy network usage</li>
                            <li>Large Result Set Queries - Flags memory and bandwidth intensive operations</li>
                            <li>Timeout-Prone Queries - Detects queries approaching timeout limits</li>
                          </ul>
                        </div>
                      </div>
                      <div class="callout" style="margin-top:10px;">
                        <strong>Live Data:</strong> Insights marked with <span class="badge live">LIVE</span> analyze your actual parsed data, while <span class="badge beta">BETA</span> insights are experimental and may show false positives.
                      </div>
                    </div>`;
                }
                if (selections.sections && selections.sections.timeline) {
                    // Build selected timeline charts list
                    const selectedCharts = Object.entries(selections.timelineCharts || {})
                        .filter(([, v]) => v)
                        .map(([k]) => k);
                    let chartsHtml = '<li>-</li>';
                    try {
                        if (selectedCharts.length) {
                            const container = document.getElementById('report-timeline-charts');
                            const items = [];
                            selectedCharts.forEach(id => {
                                let labelText = id;
                                const input = container ? container.querySelector(`input[data-chart-id="${id}"]`) : null;
                                const label = input ? input.closest('label') : null;
                                if (label) labelText = label.textContent.trim();
                                items.push(`<li>${labelText}</li>`);
                            });
                            chartsHtml = items.join('');
                        }
                    } catch (e) {}
                    html += `
                        <div class="section cover-card">
                          <h3 class="emoji-title">⏰ <span>Timeline</span></h3>
                          <p class="muted">Chronological analysis with zoomable time-series charts. Track query patterns by time grouping (seconds to days), analyze duration buckets, operation types, result counts, and memory usage trends over time with dual Y-axis support.</p>
                          <h4 style="margin-top:10px;">Timeline charts</h4>
                          <ul>${chartsHtml}</ul>
                        </div>
                    `;
                }
                if (selections.sections && selections.sections.analysis) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">🔍 <span>Query Groups</span></h3>
                      <p class="muted">Analyze similar queries grouped by normalized patterns. Compare aggregated statistics, identify frequently executed query types, and optimize query families that share similar execution characteristics and performance profiles.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections['every-query']) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">📋 <span>Every Query</span></h3>
                      <p class="muted">Detailed tabular view of individual query executions with sorting, filtering, and search capabilities. Drill down into specific query metrics, execution plans, and performance details for granular analysis and debugging.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections['index-query-flow']) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">🌊 <span>Index/Query Flow</span></h3>
                      <p class="muted">Interactive visual flow diagram showing the relationship between indexes and queries. See which indexes are used by which queries, identify index usage patterns, and optimize index coverage with drag-and-pan visualization.</p>
                    </div>`;
                }
                if (selections.sections && selections.sections.indexes) {
                    html += `
                    <div class="section cover-card">
                      <h3 class="emoji-title">🗂️ <span>Indexes</span></h3>
                      <p class="muted">Comprehensive index management with filtering by bucket/scope/collection. Analyze index performance metrics, memory residency, scan times, and usage patterns. Includes search and sorting capabilities for large index inventories.</p>
                    </div>`;
                }
            } catch (e) { /* ignore */ }
            return html;
        }

        function buildReportCoverHTML(selections) {
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;
            const now = new Date().toLocaleString();
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            const sqlFilter = document.getElementById('sql-statement-filter');
            const timeRange = (startDateInput?.value && endDateInput?.value) ? `${startDateInput.value} → ${endDateInput.value}` : '-';

            // Counts
            let total = 0, after = 0;
            try { total = Array.isArray(originalRequests) ? originalRequests.length : 0; } catch(e){}
            try { after = Array.isArray(filteredEveryQueryData) ? filteredEveryQueryData.length : (Array.isArray(everyQueryData) ? everyQueryData.length : 0); } catch(e){}

            return `
              <h1>${t('COVER_TITLE','Couchbase Query Analysis Report')}</h1>
              <div class="line">${t('REPORT_GENERATED_AT','Generated at')}: ${now}</div>
              <div class="line">${t('COVER_TIME_RANGE','Time range')}: ${timeRange}</div>
              <div class="line">${t('COVER_FILTERS_APPLIED','Filters applied')}: ${sqlFilter?.value || '-'}</div>
              <div class="line">${t('COVER_DATA_COUNTS','Data counts')}: ${after}${total ? ` ${t('OF_TOTAL','of')} ${total}` : ''}</div>
              ${buildCoverDetailedSections(selections)}
            `;
        }

        function toggleSectionsVisibility(selections) {
            const panels = document.querySelectorAll('[data-report-section]');
            panels.forEach(p => p.classList.remove('report-visible'));
            Object.keys(selections.sections).forEach(key => {
                if (selections.sections[key]) {
                    const el = document.querySelector(`[data-report-section=\"${key}\"]`);
                    if (el) el.classList.add('report-visible');
                }
            });

            // Within timeline, hide unselected chart containers
            const tlSel = selections.timelineCharts || {};
            document.querySelectorAll('#timeline .chart-container').forEach(c => {
                const id = c.getAttribute('data-chart-id');
                if (!id) return;
                c.style.display = (tlSel[id] === false) ? 'none' : '';
            });
        }

        function flattenScrollableAreas(enable) {
            const selectors = [
                '#table-section', '#analysis-table-section', '#table-container', '#analysis-table-container', '.table-scroll', '.overflow-auto'
            ];
            selectors.forEach(sel => {
                document.querySelectorAll(sel).forEach(el => {
                    if (enable) el.classList.add('print-unclamp'); else el.classList.remove('print-unclamp');
                });
            });
        }

        function replaceChartsWithImages(enable) {
            const selectedPanels = document.querySelectorAll('.report-visible');
            const canvases = [];
            selectedPanels.forEach(panel => {
                panel.querySelectorAll('canvas').forEach(cv => canvases.push(cv));
            });

            if (enable) {
                canvases.forEach(canvas => {
                    // Skip if already replaced
                    if (canvas.dataset.replaced === '1') return;
                    try {
                        const ratio = window.devicePixelRatio || 1;
                        const url = canvas.toDataURL('image/png');
                        const img = document.createElement('img');
                        img.className = 'chart-print-img';
                        img.src = url;
                        img.dataset.replaceId = canvas.id || '';
                        canvas.style.display = 'none';
                        canvas.dataset.replaced = '1';
                        canvas.parentElement.insertBefore(img, canvas.nextSibling);
                    } catch (e) { /* ignore */ }
                });
            } else {
                document.querySelectorAll('.chart-print-img').forEach(img => {
                    const canvasId = img.dataset.replaceId;
                    const canvas = canvasId ? document.getElementById(canvasId) : null;
                    if (canvas) {
                        canvas.style.display = '';
                        delete canvas.dataset.replaced;
                    }
                    img.remove();
                });
            }
        }

        function buildReportSummary() {
            const info = [];
            // Data counts if available
            try {
                if (Array.isArray(everyQueryData) && everyQueryData.length) {
                    info.push(`${TEXT_CONSTANTS.SHOWING_TOP || 'Showing top'} ${everyQueryData.length}`);
                }
            } catch (e) {}
            // Date range
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            if (startDateInput?.value && endDateInput?.value) {
                info.push(`${TEXT_CONSTANTS.REPORT_TIME_RANGE || 'Range'}: ${startDateInput.value} → ${endDateInput.value}`);
            }
            // SQL++ statement filter
            const sqlFilter = document.getElementById('sql-statement-filter');
            if (sqlFilter?.value) {
                info.push(`${TEXT_CONSTANTS.REPORT_FILTERS_APPLIED || 'Filter'}: ${sqlFilter.value}`);
            }
            // Elapsed time filter
            const elapsedFilter = document.getElementById('elapsed-time-filter');
            if (elapsedFilter?.value) {
                info.push(`${TEXT_CONSTANTS.REPORT_FILTERS_APPLIED || 'Filter'}: elapsed ${elapsedFilter.value}`);
            }
            return info.join(' • ');
        }

        function enterReportMode() {
            populateReportMakerTimelineCharts();
            const selections = getReportSelections();
            document.body.classList.add('report-mode');
            reportModeActive = true;
            // Save original timeline chart container visibility
            savedTimelineDisplay = new Map();
            document.querySelectorAll('#timeline .chart-container').forEach(c => {
                savedTimelineDisplay.set(c, c.style.display);
            });
            // reset printable header state; will be enabled only if option selected
            const hdr = document.getElementById('report-header');
            if (hdr) hdr.classList.remove('print-visible');

            // Floating exit button
            let exitBtn = document.getElementById('report-exit-btn');
            if (!exitBtn) {
                exitBtn = document.createElement('button');
                exitBtn.id = 'report-exit-btn';
                exitBtn.className = 'report-exit-btn';
                exitBtn.textContent = (TEXT_CONSTANTS && TEXT_CONSTANTS.EXIT_REPORT_PREVIEW) || 'EXIT REPORT PREVIEW';
                exitBtn.addEventListener('click', exitReportMode);
                // append into report header (sticky)
                let header = document.getElementById('report-header');
                if (!header) {
                    header = document.createElement('div');
                    header.id = 'report-header';
                    document.body.insertBefore(header, document.body.firstChild);
                }
                header.appendChild(exitBtn);
            } else {
                exitBtn.style.display = 'inline-block';
            }

            // Cover page
            let cover = document.getElementById('report-cover');
            if (!cover) {
                cover = document.createElement('div');
                cover.id = 'report-cover';
                document.body.insertBefore(cover, document.body.firstChild);
            }
            cover.innerHTML = buildReportCoverHTML(selections);
            cover.style.display = 'block';

            // Cover already forces a page break in print via CSS (#report-cover { page-break-after: always })
            // Remove any legacy cover-break element to avoid blank page 2
            const legacyBrk = document.getElementById('report-cover-break');
            if (legacyBrk) legacyBrk.remove();

            toggleSectionsVisibility(selections);
            if (selections.options.includeHeader) addReportHeader(buildReportSummary());
            flattenScrollableAreas(selections.options.flattenTables);
            replaceChartsWithImages(selections.options.chartsAsImages);
        }

        function resetReportMakerDefaults() {
        // Sections default states
        const defaultSections = {
        'dashboard': true,
        'insights': true,
        'timeline': true,
        'analysis': true,
        'every-query': false,
        'index-query-flow': false,
        'indexes': false
        };
        document.querySelectorAll('#report-sections input[type="checkbox"]').forEach(chk => {
            const k = chk.getAttribute('data-section');
            if (k in defaultSections) chk.checked = !!defaultSections[k];
            });
            // Options default states
            const opt = {
                'opt-include-header': true,
                'opt-include-filters': true,
                'opt-flatten-tables': true,
                'opt-charts-as-images': true
            };
            Object.keys(opt).forEach(id => {
                const el = document.getElementById(id);
                if (el) el.checked = !!opt[id];
            });
            // Timeline charts list regenerated with default ON/OFF
            populateReportMakerTimelineCharts();
        }

        function exitReportMode() {
            reportModeActive = false;
            document.body.classList.remove('report-mode');
            // Restore
            replaceChartsWithImages(false);
            flattenScrollableAreas(false);
            const header = document.getElementById('report-header');
            if (header) { header.style.display = 'none'; header.classList.remove('print-visible'); }
            const cover = document.getElementById('report-cover');
            if (cover) cover.style.display = 'none';
            const legacyBrk = document.getElementById('report-cover-break');
            if (legacyBrk) legacyBrk.remove();
            const exitBtn = document.getElementById('report-exit-btn');
            if (exitBtn) exitBtn.style.display = 'none';
            // Re-show timeline charts to original visibility state
            if (savedTimelineDisplay instanceof Map) {
                document.querySelectorAll('#timeline .chart-container').forEach(c => {
                    const val = savedTimelineDisplay.get(c);
                    c.style.display = (typeof val === 'string') ? val : '';
                });
                savedTimelineDisplay = null;
            }
            // Trigger resize so charts recompute layout
            setTimeout(() => window.dispatchEvent(new Event('resize')), 0);
            // Reset checkboxes back to defaults
            resetReportMakerDefaults();
        }

        function setSearchControlsVisibility(hide) {
            ['analysis-search-controls', 'search-controls'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = hide ? 'none' : '';
            });
        }

        function addPageBreaksForSelectedPanels() {
            // Remove existing auto breaks (keep cover break)
            document.querySelectorAll('.page-break.auto').forEach(el => el.remove());
            const panels = Array.from(document.querySelectorAll('[data-report-section].report-visible'));
            panels.forEach((panel, idx) => {
                if (idx === 0) return;
                const br = document.createElement('div');
                br.className = 'page-break auto';
                panel.insertAdjacentElement('beforebegin', br);
            });
        }


        function printReport() {
            const selections = getReportSelections();
            if (!reportModeActive) {
                // Enter preview with current selections
                enterReportMode();
            } else {
                // Re-apply current selections to preview before printing
                toggleSectionsVisibility(selections);
                if (selections.options.includeHeader) {
                    addReportHeader(buildReportSummary());
                } else {
                    const header = document.getElementById('report-header');
                    if (header) { header.style.display = 'none'; header.classList.remove('print-visible'); }
                }
                flattenScrollableAreas(selections.options.flattenTables);
                replaceChartsWithImages(selections.options.chartsAsImages);
                const cover = document.getElementById('report-cover');
                if (cover) cover.innerHTML = buildReportCoverHTML(selections);
            }
            // Insert page breaks so each selected tab starts on a new page (after cover)
            addPageBreaksForSelectedPanels();
            // Hide non-printable UI just in case the browser ignores CSS
            setSearchControlsVisibility(true);
            // Restore after printing
            const restore = () => setSearchControlsVisibility(false);
            window.addEventListener('afterprint', restore, { once: true });
            // Allow layout to settle before printing
            setTimeout(() => window.print(), 100);
        }

        async function loadTestSample() {
            try {
                const res = await fetch('sample/test_system_completed_requests.json');
                const json = await res.text();
                const textarea = document.getElementById('json-input');
                textarea.value = json;
                parseJSON();
                showToast(TEXT_CONSTANTS.COPIED_CLIPBOARD || 'Loaded');
            } catch (e) {
                console.error('Failed to load sample JSON', e);
                showToast('Failed to load sample JSON', 'error');
            }
        }

        // Wire up Report Maker buttons on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            const t = (k, d) => (window.TEXT_CONSTANTS && TEXT_CONSTANTS[k]) ? TEXT_CONSTANTS[k] : d;

            const btnPreview = document.getElementById('btn-preview-report');
            const btnPrint = document.getElementById('btn-print-report');
            const btnExit = document.getElementById('btn-exit-report');
            if (btnPreview) btnPreview.addEventListener('click', enterReportMode);
            if (btnPrint) btnPrint.addEventListener('click', printReport);
            if (btnExit) btnExit.addEventListener('click', exitReportMode);

            // Set localized labels
            if (btnPreview) btnPreview.textContent = t('PREVIEW_REPORT', 'Preview Report');
            if (btnPrint) btnPrint.textContent = t('PRINT_SAVE_PDF', 'Print / Save PDF');
            if (btnExit) btnExit.textContent = t('EXIT_REPORT_MODE', 'Exit Report Mode');

            const hSections = document.getElementById('rm-select-sections-title');
            const hTimeline = document.getElementById('rm-select-timeline-title');
            const hOptions = document.getElementById('rm-options-title');
            if (hSections) hSections.textContent = t('SELECT_SECTIONS', 'Select sections');
            if (hTimeline) hTimeline.textContent = t('SELECT_TIMELINE_CHARTS', 'Select Timeline charts');
            if (hOptions) hOptions.textContent = t('REPORT_OPTIONS', 'Options');

            const lIncHead = document.getElementById('rm-opt-include-header');
            const lIncFilt = document.getElementById('rm-opt-include-filters');
            const lFlatTbl = document.getElementById('rm-opt-flatten-tables');
            const lChartsImg = document.getElementById('rm-opt-charts-as-images');
            if (lIncHead) lIncHead.textContent = t('INCLUDE_HEADER_SUMMARY', 'Include header summary');
            if (lIncFilt) lIncFilt.textContent = t('INCLUDE_FILTERS', 'Include filters applied');
            if (lFlatTbl) lFlatTbl.textContent = t('FLATTEN_TABLES_FOR_PRINT', 'Flatten scrollable tables for print');
            if (lChartsImg) lChartsImg.textContent = t('CONVERT_CHARTS_TO_IMAGES', 'Convert charts to images for printing');

            populateReportMakerTimelineCharts();

            // Setup input toggle tab and styles (Issue #88)
            try {
                // Inject minimal CSS for the toggle tab
                const css = `
                .toggle-input-tab { position: fixed; left: 2px; top: 2px; z-index: 10001; color: #fff; border: 1px solid rgba(255,255,255,0.9); border-radius: 4px; width: 28px; height: 28px; padding: 0; display: inline-flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 900; line-height: 1; letter-spacing: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer; }
                .toggle-input-tab.showing { background: #007bff; }
                .toggle-input-tab.showing:hover { background: #0056b3; }
                .toggle-input-tab.hidden { background: #28a745; }
                .toggle-input-tab.hidden:hover { background: #1e7e34; }
                .help-fixed-badge { position: fixed; right: 6px; top: 6px; z-index: 9998; background: #f1f3f5; color: #343a40; border: 1px solid #dee2e6; border-radius: 14px; padding: 4px 10px; font-size: 11px; font-weight: 700; box-shadow: 0 1px 6px rgba(0,0,0,0.12); }
                .help-fixed-badge a { color: #007bff; text-decoration: none; }
                .help-fixed-badge a:hover { text-decoration: underline; }
                .queries-fixed-badge { position: fixed; top: 6px; left: 50%; transform: translateX(-50%); z-index: 9997; background: #f8f9fa; color: #343a40; border: 1px solid #dee2e6; border-radius: 14px; padding: 4px 12px; font-size: 11px; font-weight: 600; box-shadow: 0 1px 6px rgba(0,0,0,0.08); pointer-events: none; }
                @media print { .toggle-input-tab { display: none !important; } .help-fixed-badge, .queries-fixed-badge { display: none !important; } }
                /* Fade-up animation helpers for input panel */
                #input-section.input-anim { transition: opacity 320ms cubic-bezier(0.22, 1, 0.36, 1), transform 320ms cubic-bezier(0.22, 1, 0.36, 1); will-change: opacity, transform; }
                #input-section.fade-up-hidden { opacity: 0; transform: translateY(-12px); }
                `;
                const styleEl = document.createElement('style');
                styleEl.textContent = css;
                document.head.appendChild(styleEl);

                // Create the toggle tab if not present
                let tab = document.getElementById('toggle-input-tab');
                if (!tab) {
                    tab = document.createElement('button');
                    tab.id = 'toggle-input-tab';
                    tab.type = 'button';
                    tab.className = 'toggle-input-tab';
                    tab.setAttribute('aria-controls', 'input-section');
                    tab.setAttribute('aria-expanded', 'false');
                    tab.title = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.SHOW_INPUT_PANEL) || 'Show';
                    tab.textContent = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.SHOW_INPUT_PANEL) || 'Show';
                    tab.addEventListener('click', toggleInputSection);
                    document.body.appendChild(tab);
                }
                // Ensure initial label matches current state (input is visible at load)
                const hideLabel = (window.TEXT_CONSTANTS && TEXT_CONSTANTS.HIDE_INPUT_PANEL) || 'Hide';
                tab.textContent = '↑';
                tab.title = hideLabel;
                tab.setAttribute('aria-expanded', 'true');
                tab.classList.remove('hidden');
                tab.classList.add('showing');

                // Create fixed help badge (always visible top-right)
                let help = document.getElementById('help-fixed-badge');
                if (!help) {
                help = document.createElement('div');
                help.id = 'help-fixed-badge';
                help.className = 'help-fixed-badge';
                const helpText = t('HELP_DEBUG_TIPS', 'NEED HELP? Debugging + Tool Tips — Click Here');
                help.innerHTML = `<a href="https://cb.fuj.io/analysis_hub#introduction" target="_blank" rel="noopener">${helpText}</a>`;
                document.body.appendChild(help);
                }

                // Create fixed queries count badge (center top)
                let qbadge = document.getElementById('queries-fixed-badge');
                if (!qbadge) {
                    qbadge = document.createElement('div');
                    qbadge.id = 'queries-fixed-badge';
                    qbadge.className = 'queries-fixed-badge';
                    qbadge.innerHTML = 'Showing all <strong>0</strong> queries';
                    document.body.appendChild(qbadge);
                }
            } catch (e) {
                console.warn('Failed to initialize input toggle tab', e);
            }
        });
    </script>
</body>

</html>